Index: Makefile.am
===================================================================
--- Makefile.am	(revision 740)
+++ Makefile.am	(working copy)
@@ -51,10 +51,20 @@
 scripts/custom/custom_example.cpp \
 scripts/custom/custom_gossip_codebox.cpp \
 scripts/custom/test.cpp \
+scripts/custom/teleguy.cpp \
 scripts/go/go_scripts.cpp \
+scripts/guard/ancient_of_war.cpp \
+scripts/guard/g_marcus_jonathan.cpp \
 scripts/guard/guard_ai.cpp \
 scripts/guard/guard_ai.h \
 scripts/guard/guards.cpp \
+scripts/guard/officers.cpp \
+scripts/guard/overlord_saurfang.cpp \
+scripts/guard/archbishop_benedictus.cpp \
+scripts/guard/high_fire_mage.cpp \
+scripts/guard/high_sorcerer_andromath.cpp \
+scripts/guard/highlord_bolvar_fordragon.cpp \
+scripts/guard/thrall.cpp \
 scripts/item/item_scripts.cpp \
 scripts/item/item_test.cpp \
 scripts/npc/npc_escortAI.cpp \
@@ -167,6 +177,7 @@
 scripts/zone/coilfang_resevoir/underbog/boss_hungarfen.cpp \
 scripts/zone/darkshore/darkshore.cpp \
 scripts/zone/deadmines/deadmines.cpp \
+scripts/zone/deadmines/def_deadmines.h \
 scripts/zone/dun_morogh/dun_morogh.cpp \
 scripts/zone/dustwallow_marsh/dustwallow_marsh.cpp \
 scripts/zone/eastern_plaguelands/eastern_plaguelands.cpp \
@@ -189,6 +200,7 @@
 scripts/zone/hellfire_citadel/magtheridons_lair/instance_magtheridons_lair.cpp \
 scripts/zone/hellfire_citadel/shattered_halls/boss_nethekurse.cpp \
 scripts/zone/hellfire_citadel/shattered_halls/boss_warbringer_omrogg.cpp \
+scripts/zone/hellfire_citadel/shattered_halls/boss_warchief_kargath_bladefist.cpp \
 scripts/zone/hellfire_citadel/shattered_halls/def_shattered_halls.h \
 scripts/zone/hellfire_citadel/shattered_halls/instance_shattered_halls.cpp \
 scripts/zone/hellfire_peninsula/boss_doomlord_kazzak.cpp \
Index: ScriptMgr.cpp
===================================================================
--- ScriptMgr.cpp	(revision 740)
+++ ScriptMgr.cpp	(working copy)
@@ -78,12 +78,22 @@
 extern void AddSC_custom_example();
 extern void AddSC_custom_gossip_codebox();
 extern void AddSC_test();
+extern void AddSC_teleguy();
 
 // -- GO --
 extern void AddSC_go_scripts();
 
 // -- Guard --
 extern void AddSC_guards();
+extern void AddSC_city_officer();
+extern void AddSC_ancient_of_war();
+extern void AddSC_overlord_saurfang();
+extern void AddSC_g_marcus_jonathan();
+extern void AddSC_archbishop_benedictus();
+extern void AddSC_high_fire_mage();
+extern void AddSC_high_sorcerer_andromath();
+extern void AddSC_highlord_bolvar_fordragon();
+extern void AddSC_thrall();
 
 // -- Honor --
 
@@ -249,6 +259,8 @@
 //Darkshore
 //Darnassus
 //Deadmines
+extern void AddSC_instance_deadmines();
+
 //Deadwind pass
 //Desolace
 //Dire Maul
@@ -298,6 +310,7 @@
 //--Shattered Halls
 extern void AddSC_boss_grand_warlock_nethekurse();
 extern void AddSC_boss_warbringer_omrogg();
+extern void AddSC_boss_warchief_kargath_bladefist();
 extern void AddSC_instance_shattered_halls();
 
 //--Ramparts
@@ -323,6 +336,7 @@
 extern void AddSC_boss_shade_of_aran();
 extern void AddSC_boss_malchezaar();
 extern void AddSC_boss_terestian_illhoof();
+extern void AddSC_boss_nightbane();
 extern void AddSC_netherspite_infernal();
 extern void AddSC_boss_moroes();
 extern void AddSC_bosses_opera();
@@ -1262,12 +1276,22 @@
     AddSC_custom_example();
     AddSC_custom_gossip_codebox();
     AddSC_test();
+	AddSC_teleguy();
 
     // -- GO --
     AddSC_go_scripts();
 
     // -- Guard --
     AddSC_guards();
+    AddSC_city_officer();
+    AddSC_ancient_of_war();
+    AddSC_overlord_saurfang();
+    AddSC_g_marcus_jonathan();
+    AddSC_archbishop_benedictus();
+    AddSC_high_fire_mage();
+    AddSC_high_sorcerer_andromath();
+    AddSC_highlord_bolvar_fordragon();
+    AddSC_thrall();
 
     // -- Honor --
 
@@ -1433,6 +1457,8 @@
     //Darkshore
     //Darnassus
     //Deadmines
+    AddSC_instance_deadmines();
+
     //Deadwind pass
     //Desolace
     //Dire Maul
@@ -1482,6 +1508,7 @@
     //--Shattered Halls
     AddSC_boss_grand_warlock_nethekurse();
     AddSC_boss_warbringer_omrogg();
+    AddSC_boss_warchief_kargath_bladefist();
     AddSC_instance_shattered_halls();
 
     //--Ramparts
@@ -1507,6 +1534,7 @@
     AddSC_boss_shade_of_aran();
     AddSC_boss_malchezaar();
     AddSC_boss_terestian_illhoof();
+    AddSC_boss_nightbane();
     AddSC_netherspite_infernal();
     AddSC_boss_moroes();
     AddSC_bosses_opera();
Index: scripts/custom/teleguy.cpp
===================================================================
--- scripts/custom/teleguy.cpp	(revision 0)
+++ scripts/custom/teleguy.cpp	(revision 0)
@@ -0,0 +1,702 @@
+#include "precompiled.h"
+long long int money;
+int costo;
+
+bool GossipHello_teleguy(Player *player, Creature *_Creature)
+{
+
+    if ( player->GetTeam() == ALLIANCE ) {
+player->ADD_GOSSIP_ITEM( 5, "Darnassus. 5 Silver"		, GOSSIP_SENDER_MAIN, 1203);
+player->ADD_GOSSIP_ITEM( 5, "Exodar. 5 Silver"			, GOSSIP_SENDER_MAIN, 1216);
+player->ADD_GOSSIP_ITEM( 5, "Stormwind. 5 Silver"		, GOSSIP_SENDER_MAIN, 1206);
+player->ADD_GOSSIP_ITEM( 5, "Ironforge. 5 Silver"		, GOSSIP_SENDER_MAIN, 1224);
+player->ADD_GOSSIP_ITEM( 5, "Gnomeregan. 5 Silver"		, GOSSIP_SENDER_MAIN, 1222);
+player->ADD_GOSSIP_ITEM( 5, "Shattrath City. 5 Silver"            , GOSSIP_SENDER_MAIN, 1287);
+player->ADD_GOSSIP_ITEM( 5, "Isle Of Quel'Danas. 5 Silver"        , GOSSIP_SENDER_MAIN, 1288);
+player->ADD_GOSSIP_ITEM( 7, "[Instances] ->"			, GOSSIP_SENDER_MAIN, 5550);
+
+	}  else {
+
+
+player->ADD_GOSSIP_ITEM( 5, "Orgrimmar. 5 Silver"		, GOSSIP_SENDER_MAIN, 1215);
+player->ADD_GOSSIP_ITEM( 5, "Silvermoon. 5 Silver"		, GOSSIP_SENDER_MAIN, 1217);
+player->ADD_GOSSIP_ITEM( 5, "Undercity. 5 Silver"		, GOSSIP_SENDER_MAIN, 1213);
+player->ADD_GOSSIP_ITEM( 5, "Thunder Bluff. 5 Silver"	, GOSSIP_SENDER_MAIN, 1225);
+player->ADD_GOSSIP_ITEM( 5, "Gnomeregan. 5 Silver"		, GOSSIP_SENDER_MAIN, 1222);
+player->ADD_GOSSIP_ITEM( 5, "Shattrath City. 5 Silver"            , GOSSIP_SENDER_MAIN, 1287);
+player->ADD_GOSSIP_ITEM( 5, "Isle Of Quel'Danas. 5 Silver"        , GOSSIP_SENDER_MAIN, 1288);
+player->ADD_GOSSIP_ITEM( 7, "[Instances] ->"			, GOSSIP_SENDER_MAIN, 5550);
+	}
+	
+	player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+
+return true;
+
+}
+
+
+void SendDefaultMenu_teleguy(Player *player, Creature *_Creature, uint32 action )
+{
+
+if(!player->getAttackers().empty())
+
+	{
+	player->CLOSE_GOSSIP_MENU();
+    _Creature->Say("You are in combat!", LANG_UNIVERSAL, NULL);
+return;
+    }
+
+if( player->getLevel() < 8  ) 
+
+    {
+	player->CLOSE_GOSSIP_MENU();
+    _Creature->Say("You must be lvl 8+", LANG_UNIVERSAL, NULL);
+return;
+    }
+
+money = player-> GetMoney();
+costo = 500;
+
+if (money < costo ) 
+	{
+	player->CLOSE_GOSSIP_MENU();
+	_Creature->Say("You haven't enough money", LANG_UNIVERSAL, NULL);
+return;
+	}
+
+switch(action)
+
+{
+
+case 5550: //Instances
+player->ADD_GOSSIP_ITEM( 5, "Ragefire Chasm. 10 Silver"			 , GOSSIP_SENDER_MAIN, 1248);
+player->ADD_GOSSIP_ITEM( 5, "The Wailing Caverns. 10 Silver"     , GOSSIP_SENDER_MAIN, 1249);
+player->ADD_GOSSIP_ITEM( 5, "The Stockade. 10 Silver"			 , GOSSIP_SENDER_MAIN, 1253);
+player->ADD_GOSSIP_ITEM( 5, "Deadmines. 10 Silver"               , GOSSIP_SENDER_MAIN, 1250);
+player->ADD_GOSSIP_ITEM( 5, "Shadowfang Keep. 10 Silver"         , GOSSIP_SENDER_MAIN, 1251);
+player->ADD_GOSSIP_ITEM( 5, "Blackfathom Deeps. 10 Silver"       , GOSSIP_SENDER_MAIN, 1252);
+player->ADD_GOSSIP_ITEM( 5, "Razorfen Kraul. 20 Silver"          , GOSSIP_SENDER_MAIN, 1254);
+player->ADD_GOSSIP_ITEM( 5, "Razorfen Downs. 20 Silver"          , GOSSIP_SENDER_MAIN, 1256);
+player->ADD_GOSSIP_ITEM( 5, "Scarlet Monastery. 20 Silver"       , GOSSIP_SENDER_MAIN, 1257);
+player->ADD_GOSSIP_ITEM( 7, "[More] ->"							 , GOSSIP_SENDER_MAIN, 5551);
+player->ADD_GOSSIP_ITEM( 7, "<- [Main Menu]"					 , GOSSIP_SENDER_MAIN, 5552);
+
+	
+player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+
+break;
+
+case 5551: //More Instances
+player->ADD_GOSSIP_ITEM( 5, "Uldaman. 30 Silver"                   , GOSSIP_SENDER_MAIN, 1258);
+player->ADD_GOSSIP_ITEM( 5, "Zul'Farrak. 30 Silver"                , GOSSIP_SENDER_MAIN, 1259);
+player->ADD_GOSSIP_ITEM( 5, "Maraudon. 40 Silver"                  , GOSSIP_SENDER_MAIN, 1260);
+player->ADD_GOSSIP_ITEM( 5, "Maraudon. 40 Silver"                  , GOSSIP_SENDER_MAIN, 1260);
+player->ADD_GOSSIP_ITEM( 5, "The Sunken Temple. 40 Silver"		   , GOSSIP_SENDER_MAIN, 1261);
+player->ADD_GOSSIP_ITEM( 5, "Blackrock Depths. 40 Silver"          , GOSSIP_SENDER_MAIN, 1262);
+player->ADD_GOSSIP_ITEM( 5, "Dire Maul. 50 Silver"                 , GOSSIP_SENDER_MAIN, 1263);
+player->ADD_GOSSIP_ITEM( 5, "Blackrock Spire. 50 Silver"           , GOSSIP_SENDER_MAIN, 1264);
+player->ADD_GOSSIP_ITEM( 5, "Stratholme. 50 Silver"                , GOSSIP_SENDER_MAIN, 1265);
+player->ADD_GOSSIP_ITEM( 5, "Scholomance. 50 Silver"               , GOSSIP_SENDER_MAIN, 1266);
+player->ADD_GOSSIP_ITEM( 7, "[More] ->"							   , GOSSIP_SENDER_MAIN, 5553);
+player->ADD_GOSSIP_ITEM( 7, "<- [Back]"							   , GOSSIP_SENDER_MAIN, 5550);
+player->ADD_GOSSIP_ITEM( 7, "<- [Main Menu]"					   , GOSSIP_SENDER_MAIN, 5552);
+	
+player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+
+break;
+
+case 5553: //Instances 60-70
+player->ADD_GOSSIP_ITEM( 5, "Karazhan. 1 Gold"                              , GOSSIP_SENDER_MAIN, 4007);
+player->ADD_GOSSIP_ITEM( 5, "Gruul's Lair. 1 Gold"                          , GOSSIP_SENDER_MAIN, 4008);
+player->ADD_GOSSIP_ITEM( 5, "Hellfire Citadel. 1 Gold"                      , GOSSIP_SENDER_MAIN, 4009);
+player->ADD_GOSSIP_ITEM( 5, "Coilfang Reservoir. 1 Gold"                    , GOSSIP_SENDER_MAIN, 4010);
+player->ADD_GOSSIP_ITEM( 5, "Tempest Keep. 1 Gold"                          , GOSSIP_SENDER_MAIN, 4011);
+player->ADD_GOSSIP_ITEM( 5, "Caverns of Time. 1 Gold"                       , GOSSIP_SENDER_MAIN, 4012);
+player->ADD_GOSSIP_ITEM( 5, "Zul'Aman. 1 Gold"                              , GOSSIP_SENDER_MAIN, 4016);
+player->ADD_GOSSIP_ITEM( 5, "Black Temple. 1 Gold"                          , GOSSIP_SENDER_MAIN, 4013);
+player->ADD_GOSSIP_ITEM( 5, "Magister's Terrace. 2 Gold"                    , GOSSIP_SENDER_MAIN, 4017);
+player->ADD_GOSSIP_ITEM( 5, "Sunwell Plateau. 2 Gold"                       , GOSSIP_SENDER_MAIN, 4018);
+player->ADD_GOSSIP_ITEM( 7, "<- [Back]"							   , GOSSIP_SENDER_MAIN, 5550);
+player->ADD_GOSSIP_ITEM( 7, "<- [Main Menu]"					   , GOSSIP_SENDER_MAIN, 5552);
+
+
+player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+
+break;
+
+
+case 5552: //Back To Main Menu
+    if ( player->GetTeam() == ALLIANCE ) {
+player->ADD_GOSSIP_ITEM( 5, "Darnassus. 5 Silver"			, GOSSIP_SENDER_MAIN, 1203);
+player->ADD_GOSSIP_ITEM( 5, "Exodar. 5 Silver"				, GOSSIP_SENDER_MAIN, 1216);
+player->ADD_GOSSIP_ITEM( 5, "Stormwind. 5 Silver"			, GOSSIP_SENDER_MAIN, 1206);
+player->ADD_GOSSIP_ITEM( 5, "Ironforge. 5 Silver"			, GOSSIP_SENDER_MAIN, 1224);
+player->ADD_GOSSIP_ITEM( 5, "Gnomeregan. 5 Silver"			, GOSSIP_SENDER_MAIN, 1222);
+player->ADD_GOSSIP_ITEM( 5, "Shattrath City. 5 Silver"            , GOSSIP_SENDER_MAIN, 1287);
+player->ADD_GOSSIP_ITEM( 5, "Isle Of Quel'Danas. 5 Silver"        , GOSSIP_SENDER_MAIN, 1288);
+player->ADD_GOSSIP_ITEM( 7, "[Instances] ->"				, GOSSIP_SENDER_MAIN, 5550);
+
+	}  else {
+
+
+player->ADD_GOSSIP_ITEM( 5, "Orgrimmar. 5 Silver"			, GOSSIP_SENDER_MAIN, 1215);
+player->ADD_GOSSIP_ITEM( 5, "Silvermoon. 5 Silver"			, GOSSIP_SENDER_MAIN, 1217);
+player->ADD_GOSSIP_ITEM( 5, "Undercity. 5 Silver"			, GOSSIP_SENDER_MAIN, 1213);
+player->ADD_GOSSIP_ITEM( 5, "Thunder Bluff. 5 Silver"		, GOSSIP_SENDER_MAIN, 1225);
+player->ADD_GOSSIP_ITEM( 5, "Gnomeregan. 5 Silver"			, GOSSIP_SENDER_MAIN, 1222);
+player->ADD_GOSSIP_ITEM( 5, "Shattrath City. 5 Silver"            , GOSSIP_SENDER_MAIN, 1287);
+player->ADD_GOSSIP_ITEM( 5, "Isle Of Quel'Danas. 5 Silver"        , GOSSIP_SENDER_MAIN, 1288);
+player->ADD_GOSSIP_ITEM( 7, "[Instances] ->"				, GOSSIP_SENDER_MAIN, 5550);
+	}
+
+player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+
+break;
+
+case 1203: // Teleport to Darnassus
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(1, 9947.52f, 2482.73f, 1316.21f, 0.0f);
+player->ModifyMoney(-1*costo);
+break;
+
+// Teleport to Stormwind
+case 1206:
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(0, -8960.14f, 516.266f, 96.3568f, 0.0f);
+player->ModifyMoney(-1*costo);
+break;
+
+// Teleport to Undercity
+case 1213:
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(0, 1819.71f, 238.79f, 60.5321f, 0.0f);
+player->ModifyMoney(-1*costo);
+
+break;
+
+// Teleport to Orgrimmar
+case 1215:
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(1, 1552.5f, -4420.66f, 8.94802f, 0.0f);
+player->ModifyMoney(-1*costo);
+break;
+
+// Teleport to Exodar
+case 1216:
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(530, -4073.03f, -12020.4f, -1.47f, 0.0f);
+player->ModifyMoney(-1*costo);
+break;
+
+// Teleport to Silvermoon
+case 1217:
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(530, 9338.74f, -7277.27f, 13.7895f, 0.0f);
+player->ModifyMoney(-1*costo);
+
+break;
+
+case 1222://teleport player to Gnomeregan
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(0, -5163.43f,660.40f,348.28f,4.65f);
+player->ModifyMoney(-1*costo);
+
+break;
+
+// Teleport to Ironforge
+case 1224:
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(0, -4924.07f, -951.95f, 501.55f, 5.40f);
+player->ModifyMoney(-1*costo);
+
+break;
+
+// Teleport to Thunder Bluff
+case 1225:
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(1, -1280.19f,127.21f,131.35f,5.16f); 
+player->ModifyMoney(-1*costo);
+
+break;
+
+case 1248://teleport player to Ragefire Chasm
+		
+if( player->getLevel() >= 8)
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(1, 1800.53f,-4394.68f,-17.93f,5.49f);
+		player->ModifyMoney(-2*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 8!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1249://teleport player to the Wailing Caverns
+		
+if (player->getLevel() >= 10)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(1, -722.53f,-2226.30f,16.94f,2.71f);
+		player->ModifyMoney(-2*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 10!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1250://teleport player to the Deadmines
+		
+if (player->getLevel() >= 10)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, -11212.04f,1658.58f,25.67f,1.45f);
+		player->ModifyMoney(-2*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 10!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1251://teleport player to Shadowfang Keep
+		
+	if (player->getLevel() >= 15)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, -254.47f,1524.68f,76.89f,1.56f);
+		player->ModifyMoney(-2*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 15!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1252://teleport player to Blackfathom Deeps
+		
+	if (player->getLevel() >= 15)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(1, 4254.58f,664.74f,-29.04f,1.97f);
+		player->ModifyMoney(-2*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 15!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1253://teleport player to the Stockade
+		
+	if (player->getLevel() >= 20)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, -8769.76f,813.08f,97.63f,2.26f);
+		player->ModifyMoney(-2*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 20!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1254://teleport player to Razorfen Kraul
+		
+	if (player->getLevel() >= 24)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(1, -4484.04f,-1739.40f,86.47f,1.23f);
+		player->ModifyMoney(-4*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 24!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1255://teleport player to Gnomeregan
+		
+	if (player->getLevel() >= 20)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, -5162.62f,667.81f,248.05f,1.48f);
+		player->ModifyMoney(-4*costo);
+		
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 20!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1256://teleport player to Razorfen Downs
+		
+	if (player->getLevel() >= 25)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(1, -4645.08f,-2470.85f,85.53f,4.39f);
+		player->ModifyMoney(-4*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 25!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1257://teleport player to the Scarlet Monastery
+		
+	if (player->getLevel() >= 25)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, 2843.89f,-693.74f,139.32f,5.11f);
+		player->ModifyMoney(-4*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 25!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1258://teleport player to Uldaman
+		
+	if (player->getLevel() >= 35)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, -6119.70f,-2957.30f,204.11f,0.03f);
+		player->ModifyMoney(-6*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 35!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1259://teleport player to Zul'Farrak
+		
+	if (player->getLevel() >= 35)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(1, -6839.39f,-2911.03f,8.87f,0.41f);
+		player->ModifyMoney(-6*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 35!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+
+case 1260://teleport player to Maraudon
+		
+	if (player->getLevel() >= 40)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(1, -1433.33f,2955.34f,96.21f,4.82f);
+		player->ModifyMoney(-8*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 40!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1261://teleport player to the Sunken Temple
+		
+	if (player->getLevel() >= 45)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, -10346.92f,-3851.90f,-43.41f,6.09f);
+		player->ModifyMoney(-8*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 45!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1262://teleport player to Blackrock Depths
+		
+	if (player->getLevel() >= 45)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, -7301.03f,-913.19f,165.37f,0.08f);
+		player->ModifyMoney(-8*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 45!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+	
+case 1263://teleport player to Dire Maul
+		
+	if (player->getLevel() >= 50)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(1, -3982.47f,1127.79f,161.02f,0.05f);
+		player->ModifyMoney(-10*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 50!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1264://teleport player to Blackrock Spire
+		
+	if (player->getLevel() >= 50)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, -7535.43f,-1212.04f,285.45f,5.29f);
+		player->ModifyMoney(-10*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 50!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1265://teleport player to Stratholme
+		
+	if (player->getLevel() >= 50)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, 3263.54f,-3379.46f,143.59f,0.00f);
+		player->ModifyMoney(-10*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 50!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1266://teleport player to Scholomance
+		
+	if (player->getLevel() >= 50)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, 1219.01f,-2604.66f,85.61f,0.50f);
+		player->ModifyMoney(-10*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 50!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1287:// Shattrath City
+
+if( player->getLevel() >= 58)
+    {
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -1850.209961f, 5435.821777f, -10.961435f, 3.403913f);
+        player->ModifyMoney(-1*costo);
+ } else {
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Say("You must be at least level 58!", LANG_UNIVERSAL, NULL);
+    }
+    
+break;
+
+case 1288://teleport player to Isle Of Quel'Danas
+
+    if (player->getLevel() >= 65)
+        
+    {
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 12947.4f,-6893.31f,5.68398f,3.09154f);
+        player->ModifyMoney(-1*costo);
+	} else {
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Say("You must be at least level 65!", LANG_UNIVERSAL, NULL);
+    }
+    
+break;
+
+case 4007:// Karazhan
+
+    if (player->getLevel() >= 70)
+        
+    {
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -11118.8f, -2010.84f, 47.0807f, 0.0f);
+        player->ModifyMoney(-20*costo);
+	} else {
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Say("You must be at least level 70!", LANG_UNIVERSAL, NULL);
+    }
+    
+break;
+
+case 4008:// Gruul's Lair
+
+    if (player->getLevel() >= 65)
+        
+    {
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 3539.007568f, 5082.357910f, 1.691071f, 0.0f);
+        player->ModifyMoney(-20*costo);
+	} else {
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Say("You must be at least level 65!", LANG_UNIVERSAL, NULL);
+    }
+    
+break;
+
+case 4009:// Hellfire Citadel
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(530, -305.816223f, 3056.401611f, -2.473183f, 2.01f);
+player->ModifyMoney(-20*costo);
+break;
+
+case 4010:// Coilfang Reservoir
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(530, 517.288025f, 6976.279785f, 32.007198f, 0.0f);
+player->ModifyMoney(-20*costo);
+break;
+
+case 4011:// Tempest Keep
+
+    if (player->getLevel() >= 70)
+        
+    {
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 3089.579346f, 1399.046509f, 187.653458f, 4.794070f);
+        player->ModifyMoney(-20*costo);
+	} else {
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Say("You must be at least level 70!", LANG_UNIVERSAL, NULL);
+    }
+    
+break;
+
+case 4012:// Caverns of Time
+
+    if (player->getLevel() >= 66)
+        
+    {
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -8173.66f, -4746.36f, 33.8423f, 4.93989f);
+        player->ModifyMoney(-20*costo);
+	} else {
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Say("You must be at least level 66!", LANG_UNIVERSAL, NULL);
+    }
+    
+break;
+
+case 4016:// Zul'Aman
+
+    if (player->getLevel() >= 70)
+        
+    {
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 6846.95f, -7954.5f, 170.028f, 4.61501f);
+        player->ModifyMoney(-20*costo);
+	} else {
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Say("You must be at least level 70!", LANG_UNIVERSAL, NULL);
+    }
+    
+break;
+
+case 4013:// Black Temple
+
+    if (player->getLevel() >= 70)
+        
+    {
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -3610.719482f, 324.987579f, 37.400028f, 3.282981f);
+        player->ModifyMoney(-20*costo);
+	} else {
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Say("You must be at least level 70!", LANG_UNIVERSAL, NULL);
+    }
+    
+break;
+
+case 4017:// magistrate
+
+    if (player->getLevel() >= 70)
+        
+    {
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 12884.6f, -7317.69f, 65.5023f, 4.799f);
+        player->ModifyMoney(-40*costo);
+	} else {
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Say("You must be at least level 70!", LANG_UNIVERSAL, NULL);
+    }
+    
+break;
+
+case 4018:// sunwell
+
+    if (player->getLevel() >= 70)
+        
+    {
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 12574.1f, -6774.81f, 15.0904f, 3.13788f);
+        player->ModifyMoney(-40*costo);
+	} else {
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Say("You must be at least level 70!", LANG_UNIVERSAL, NULL);
+    }
+    
+break;
+
+}
+
+
+}
+
+bool GossipSelect_teleguy(Player *player, Creature *_Creature, uint32
+
+sender, uint32 action )
+
+{
+// Main menu
+if (sender == GOSSIP_SENDER_MAIN)
+SendDefaultMenu_teleguy(player, _Creature, action   );
+
+return true;
+
+}
+void AddSC_teleguy()
+{
+    Script *newscript;
+ 
+newscript = new Script;
+newscript->Name = "teleguy";
+newscript->pGossipHello = &GossipHello_teleguy;
+newscript->pGossipSelect = &GossipSelect_teleguy;
+newscript->pItemHello = NULL;
+newscript->pGOHello = NULL;
+newscript->pAreaTrigger = NULL;
+newscript->pItemQuestAccept = NULL;
+newscript->pGOQuestAccept = NULL;
+newscript->pGOChooseReward = NULL;
+
+newscript->RegisterSelf();
+}
Index: scripts/guard/ancient_of_war.cpp
===================================================================
--- scripts/guard/ancient_of_war.cpp	(revision 0)
+++ scripts/guard/ancient_of_war.cpp	(revision 0)
@@ -0,0 +1,234 @@
+/* 
+###############################
+ Ancient of War, of Lore v 2.0
+ (Darnassus protectors)
+###############################
+
+by Myav 
+*/
+
+#include "precompiled.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL ancient_of_warAI : public ScriptedAI
+{
+    ancient_of_warAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+
+    if(m_creature->GetEntry() == 3469)
+       m_creature->SetMaxHealth(167000);
+     else m_creature->SetMaxHealth(250000);
+    if(m_creature->GetEntry() == 3469)
+       m_creature->SetHealth(167000);
+     else m_creature->SetMaxHealth(250000);
+    m_creature->SetArmor(19200);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,1620);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,270);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DAZE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_KNOCKOUT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+3500,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+}
+
+void wood()
+{
+       float x;
+       float y;
+       float z;
+       float X;
+       float Y;
+       float Z;
+       m_creature->GetPosition(x,y,z);
+       m_creature->getVictim()->GetPosition(X,Y,Z);
+       if(x > X)
+           X = x + 20 + 10 - rand()%20;
+       else
+           X = x - 20 + 10 - rand()%20;
+       if(y > Y)
+           Y = y + 20 + 10 - rand()%20;
+       else
+           Y = y - 20 + 10 - rand()%20;
+       m_creature->GetRespawnCoord(x,y,z);        
+       Helper = DoSpawnCreature(4423, (float) (X - x), (float) (Y - y), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+       if(Helper && enemy)
+          ((CreatureAI*)Helper->AI())->AttackStart(enemy); 
+}
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    if(!Help && m_creature->GetEntry() == 3469)
+    {
+       for(int i = 0; i < 5;i++)
+       {
+            wood();
+       }
+       Help = 60000 + rand()%45000;
+    }
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+           int Change = 0;
+           int info = NULL;
+
+            if(!m_creature->HasAura(25640,0))
+            {
+                info = 25640;
+                Change = 1;
+            }
+            else
+            {
+                 if(enemy)
+                  {
+                   switch(rand()%5)
+                   {
+               case 0:
+                  info = 22924;
+                  break;
+               case 1:
+                    info = 35244;
+                    break;
+               case 2:
+                    info = 24648;
+                    break;
+               case 3:
+                    info = 40434;
+                    break;
+               case 4:
+                    info = 37592;
+                    break;
+               }//switch
+            }//if rage
+            }
+            if(m_creature->GetEntry() == 3468)
+                info = NULL;
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+        }//end attack ready
+    }// end attack distance
+/*    else 
+    { 
+     if(!m_creature->IsNonMeleeSpellCasted(false))
+     {
+         if ((*m_creature).GetMotionMaster()->top()->GetMovementGeneratorType()!=TARGETED_MOTION_TYPE)
+         {
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+         }
+     }
+    }//end else */
+}
+};
+CreatureAI* GetAI_ancient_of_war(Creature *_Creature)
+{
+    return new ancient_of_warAI (_Creature);
+}
+
+void AddSC_ancient_of_war()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "ancient_of_war";
+    newscript->GetAI = &GetAI_ancient_of_war;
+    newscript->RegisterSelf();
+}
Index: scripts/guard/archbishop_benedictus.cpp
===================================================================
--- scripts/guard/archbishop_benedictus.cpp	(revision 0)
+++ scripts/guard/archbishop_benedictus.cpp	(revision 0)
@@ -0,0 +1,344 @@
+/* 
+##############################
+ Archbishop Benedictus v 2.0
+##############################
+
+by Myav 
+*/
+
+#include "precompiled.h"
+#include "../creature/simple_ai.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL archbishop_benedictusAI : public ScriptedAI
+{
+    archbishop_benedictusAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    uint32 InnerTimer;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+
+    m_creature->SetMaxHealth(255000);
+    m_creature->SetHealth(255000);
+    m_creature->SetMaxPower(POWER_MANA,180000);
+    m_creature->SetPower(POWER_MANA,180000);
+    m_creature->SetArmor(5720);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DISARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_INTERRUPT_CAST, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CONFUSED, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM , true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR , true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DAZE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_BANISH, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+3000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+
+}
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if (InnerTimer > diff)
+        InnerTimer -= diff;
+    else InnerTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    if(!m_creature->HasAura(25431,0) && InnerTimer < diff && !m_creature->HasAura(27173,0) && !m_creature->HasAura(20924,0))
+    {
+     InnerTimer = 5000;
+     DoCast(m_creature, 25431);
+     return;
+    }
+    if(!m_creature->HasAura(25312,0))
+    {
+     DoCast(m_creature, 25312);
+     return;
+    }
+    if(!m_creature->HasAura(25431,0))
+    {
+     DoCast(m_creature, 25431);
+     return;
+    }
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+           int Change = 0;
+           int info = NULL;
+
+                 if(enemy)
+                  {
+                   switch(rand()%9)
+                   {
+               case 0:
+                  info = 32375;
+                  break;
+               case 1:
+                    info = 33206;
+                    Change = 1;
+                    break;
+               case 2:
+                    info = 10060;
+                    Change = 1;
+                    break;
+               case 3:
+                    info = 41373;
+                    Change = 1;
+                    break;
+               case 4:
+                    info = 34866;
+                    Change = 1;
+                    break;
+               case 5:
+                    info = 41380;
+                    break;
+               case 6:
+                    info = 37260;
+                    Change = 1;
+                    break;
+               case 7:
+                    info = 41471;
+                    break;
+               case 8:
+                    info = 39013;
+                    Change = 1;
+                    break;
+               }//switch
+            }
+
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+        }//end attack ready
+    }// end attack distance
+/*    else 
+    { 
+     if(!m_creature->IsNonMeleeSpellCasted(false))
+     {
+         if ((*m_creature).GetMotionMaster()->top()->GetMovementGeneratorType()!=TARGETED_MOTION_TYPE)
+         {
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+         }
+     }
+    }//end else */
+}
+};
+CreatureAI* GetAI_cathedral_of_light(Creature *_Creature)
+{
+    SimpleAI* ai = new SimpleAI (_Creature);
+
+    uint32 CreatureID = _Creature->GetEntry();
+
+    ai->m_creature->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_INTERRUPT_CAST, true);
+    ai->m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM, true);
+
+    switch (CreatureID) 
+    {
+        //Duthorian Rall
+    case 6171: 
+        ai->Spell[0].Enabled = true;               
+        ai->Spell[0].Spell_Id = 27155;      //Seal     
+        ai->Spell[0].Cooldown = 30000;                 
+        ai->Spell[0].First_Cast = 500;             
+        ai->Spell[0].Cast_Target_Type = CAST_SELF;  
+
+        ai->Spell[1].Enabled = true;               
+        ai->Spell[1].Spell_Id = 10308;      //Hammer     
+        ai->Spell[1].Cooldown = 45000;                 
+        ai->Spell[1].First_Cast = 10000;             
+        ai->Spell[1].Cast_Target_Type = CAST_HOSTILE_TARGET;  
+
+        ai->Spell[2].Enabled = true;               
+        ai->Spell[2].Spell_Id = 27141;      //Bless     
+        ai->Spell[2].Cooldown = 120000;                 
+        ai->Spell[2].First_Cast = 5000;             
+        ai->Spell[2].Cast_Target_Type = CAST_SELF;  
+
+        ai->Spell[3].Enabled = true;               
+        ai->Spell[3].Spell_Id = 33072;      //Shock     
+        ai->Spell[3].Cooldown = 20000;                 
+        ai->Spell[3].First_Cast = 15000;             
+        ai->Spell[3].Cast_Target_Type = CAST_HOSTILE_TARGET;  
+
+        ai->Spell[4].Enabled = true;               
+        ai->Spell[4].Spell_Id = 27136;      //Heal     
+        ai->Spell[4].Cooldown = 15000;                 
+        ai->Spell[4].First_Cast = 20000;             
+        ai->Spell[4].Cast_Target_Type = CAST_SELF;
+
+        ai->Spell[5].Enabled = true;               
+        ai->Spell[5].Spell_Id = 35396;      //Strike     
+        ai->Spell[5].Cooldown = 15000;                 
+        ai->Spell[5].First_Cast = 30000;             
+        ai->Spell[5].Cast_Target_Type = CAST_HOSTILE_TARGET;
+        break;
+
+        //High Priestess Laurena
+    case 376: 
+        ai->Spell[0].Enabled = true;               
+        ai->Spell[0].Spell_Id = 25431;      //Inner     
+        ai->Spell[0].Cooldown = 120000;                 
+        ai->Spell[0].First_Cast = 500;             
+        ai->Spell[0].Cast_Target_Type = CAST_SELF;  
+
+        ai->Spell[1].Enabled = true;               
+        ai->Spell[1].Spell_Id = 27801;      //Holy Nova     
+        ai->Spell[1].Cooldown = 30000;                 
+        ai->Spell[1].First_Cast = 10000;             
+        ai->Spell[1].Cast_Target_Type = CAST_HOSTILE_TARGET;  
+
+        ai->Spell[2].Enabled = true;               
+        ai->Spell[2].Spell_Id = 25218;      //Shield     
+        ai->Spell[2].Cooldown = 15000;                 
+        ai->Spell[2].First_Cast = 5000;             
+        ai->Spell[2].Cast_Target_Type = CAST_SELF;  
+
+        ai->Spell[3].Enabled = true;               
+        ai->Spell[3].Spell_Id = 25364;      //Smite     
+        ai->Spell[3].Cooldown = 20000;                 
+        ai->Spell[3].First_Cast = 15000;             
+        ai->Spell[3].Cast_Target_Type = CAST_HOSTILE_TARGET;  
+
+        ai->Spell[4].Enabled = true;               
+        ai->Spell[4].Spell_Id = 34866;      //Circle Heal     
+        ai->Spell[4].Cooldown = 15000;                 
+        ai->Spell[4].First_Cast = 20000;             
+        ai->Spell[4].Cast_Target_Type = CAST_SELF;
+
+        ai->Spell[5].Enabled = true;               
+        ai->Spell[5].Spell_Id = 25222;      //Renew     
+        ai->Spell[5].Cooldown = 25000;                 
+        ai->Spell[5].First_Cast = 25000;             
+        ai->Spell[5].Cast_Target_Type = CAST_SELF;
+
+        ai->Spell[6].Enabled = true;               
+        ai->Spell[6].Spell_Id = 25314;      //Heal     
+        ai->Spell[6].Cooldown = 15000;                 
+        ai->Spell[6].First_Cast = 30000;             
+        ai->Spell[6].Cast_Target_Type = CAST_SELF;
+
+        ai->Spell[7].Enabled = true;               
+        ai->Spell[7].Spell_Id = 25308;      //Prayer of Healing     
+        ai->Spell[7].Cooldown = 25000;                 
+        ai->Spell[7].First_Cast = 35000;             
+        ai->Spell[7].Cast_Target_Type = CAST_SELF;
+        break;
+    }
+
+    ai->Reset();
+
+    return ai;
+}
+CreatureAI* GetAI_archbishop_benedictus(Creature *_Creature)
+{
+    return new archbishop_benedictusAI (_Creature);
+}
+
+void AddSC_archbishop_benedictus()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "archbishop_benedictus";
+    newscript->GetAI = &GetAI_archbishop_benedictus;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "cathedral_of_light";
+    newscript->GetAI = &GetAI_cathedral_of_light;
+    newscript->RegisterSelf();
+}
Index: scripts/guard/g_marcus_jonathan.cpp
===================================================================
--- scripts/guard/g_marcus_jonathan.cpp	(revision 0)
+++ scripts/guard/g_marcus_jonathan.cpp	(revision 0)
@@ -0,0 +1,200 @@
+/* 
+###############################
+ General Marcus Jonathan v 1.0
+ (Stormwind protector)
+###############################
+
+by Myav 
+*/
+
+#include "precompiled.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL g_marcus_jonathanAI : public ScriptedAI
+{
+    g_marcus_jonathanAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    Unit* enemy;
+    Creature* Helper;
+    
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+
+    m_creature->SetMaxHealth(98000);
+    m_creature->SetHealth(98000);
+    m_creature->SetArmor(11520);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_KNOCKOUT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+3000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+}
+
+void grunts()
+{
+       float x;
+       float y;
+       float z;
+       float X;
+       float Y;
+       float Z;
+       m_creature->GetPosition(x,y,z);
+       m_creature->getVictim()->GetPosition(X,Y,Z);
+       if(x > X)
+           X = x + 20 + 10 - rand()%20;
+       else
+           X = x - 20 + 10 - rand()%20;
+       if(y > Y)
+           Y = y + 20 + 10 - rand()%20;
+       else
+           Y = y - 20 + 10 - rand()%20;
+       m_creature->GetRespawnCoord(x,y,z);        
+       Helper = DoSpawnCreature(68, (float) (X - x), (float) (Y - y), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+       if(Helper && enemy)
+          ((CreatureAI*)Helper->AI())->AttackStart(enemy); 
+}
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    if(!Help)
+    {
+
+       for(int i = 0; i < 4;i++)
+       {
+            grunts();
+       }
+       Help = 60000 + rand()%45000;
+    }
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+           int Change = 0;
+           int info = NULL;
+
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+        }//end attack ready
+    }// end attack distance
+/*    else 
+    { 
+     if(!m_creature->IsNonMeleeSpellCasted(false))
+     {
+         if ((*m_creature).GetMotionMaster()->top()->GetMovementGeneratorType()!=TARGETED_MOTION_TYPE)
+         {
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+         }
+     }
+    }//end else */
+}
+};
+CreatureAI* GetAI_g_marcus_jonathan(Creature *_Creature)
+{
+    return new g_marcus_jonathanAI (_Creature);
+}
+
+void AddSC_g_marcus_jonathan()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "g_marcus_jonathan";
+    newscript->GetAI = &GetAI_g_marcus_jonathan;
+    newscript->RegisterSelf();
+}
Index: scripts/guard/guard_ai.cpp
===================================================================
--- scripts/guard/guard_ai.cpp	(revision 740)
+++ scripts/guard/guard_ai.cpp	(working copy)
@@ -1,26 +1,12 @@
-/* Copyright (C) 2006 - 2008 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+/* 
+###################
+ City Guards v 4
+###################
 
-/* ScriptData
-SDName: Guard_AI
-SD%Complete: 90
-SDComment:
-SDCategory: Guards
-EndScriptData */
+by Myav
+*/
 
+
 #include "precompiled.h"
 #include "guard_ai.h"
 
@@ -30,26 +16,188 @@
 
 void guardAI::Reset()
 {
+    if(_Aggro == 2)
+     _Aggro = 1;
     GlobalCooldown = 0;
-    BuffTimer = 0;                                          //Rebuff as soon as we can
+    Bandage = 0;
+    Potion = 0;
+    OffHand = 0;
+    Help = 30000 + rand()%20000;
+    yell = false;
+    //m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+750,true);
+    if(!(m_creature->GetEntry() == 2041 || m_creature->GetEntry() == 4423))
+    {
+       m_creature->setPowerType(POWER_RAGE); 
+       m_creature->SetMaxPower(POWER_RAGE,500);
+       m_creature->SetPower(POWER_RAGE,0); 
+       bool elite = false;
+       int temp3 = 0;
+       int temp4 = 0;
+       int temp5 = 0; 
+       int temp6 = 0;
+       temp3 = m_creature->getLevel();
+       elite = m_creature->isElite();
+       if(elite)
+       {
+          temp4 = temp3 * 200;
+          temp5 = temp3 * 120;          
+          temp6 = temp3 * 8;
+       }
+        else
+        {
+           if(temp3 < 71)
+           {
+               temp4 = temp3 * 125;
+               temp5 = temp3 * 75;
+               temp6 = temp3 * 5;
+           }
+           else
+           {
+              temp4 = temp3 * 175;
+              temp5 = temp3 * 105;          
+              temp6 = temp3 * 7;
+           }       
+        }
+       if(m_creature->GetEntry() == 12481)
+        temp4 = temp4 * 4;
+       if(m_creature->GetEntry() == 12480)
+        temp4 = temp4 * 6;
+       if(m_creature->GetEntry() == 5624)
+        temp4 = temp4 * 3;
+       m_creature->SetMaxHealth(temp4);
+       m_creature->SetHealth(temp4);
+       m_creature->SetArmor(temp5);
+       m_creature->SetResistance(SPELL_SCHOOL_NORMAL,temp6);
+       m_creature->SetResistance(SPELL_SCHOOL_HOLY,temp6);
+       m_creature->SetResistance(SPELL_SCHOOL_FIRE,temp6);
+       m_creature->SetResistance(SPELL_SCHOOL_NATURE,temp6);
+       m_creature->SetResistance(SPELL_SCHOOL_FROST,temp6);
+       m_creature->SetResistance(SPELL_SCHOOL_SHADOW,temp6);
+       m_creature->SetResistance(SPELL_SCHOOL_ARCANE,temp6);
+    } 
+    //if(m_creature->getLevel() > 70 || m_creature->isElite())
+       //m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+900,false);
+    //else m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+500,false);
+    //if(m_creature->GetEntry() == 12481)
+        //m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+1600,false);
+    //if(m_creature->GetEntry() == 12480)
+        //m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+1900,false);
 }
 
 void guardAI::Aggro(Unit *who)
 {
-}
-
-void guardAI::JustDied(Unit *Killer)
-{
     //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
-    if( Killer->GetTypeId() == TYPEID_PLAYER )
-        m_creature->SendZoneUnderAttackMessage((Player*)Killer);
-    else if( Unit *owner = Killer->GetOwner() )
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
     {
-        if( owner->GetTypeId() == TYPEID_PLAYER )
-            m_creature->SendZoneUnderAttackMessage((Player*)owner);
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
     }
+    if(m_creature->getFaction() == 85 && !yell)
+    {
+       yell = true;
+       switch(rand()%4)
+       {
+           case 0:
+              DoYell("We are under Attack !!",LANG_ORCISH,NULL);
+              DoPlaySoundToSet(m_creature,6198);
+              break;
+           case 1:
+              DoSay("Time to Killing!",LANG_ORCISH,NULL);
+              DoPlaySoundToSet(m_creature,6205);
+              break;
+           case 2:
+              DoSay("Yargh!",LANG_ORCISH,NULL);
+              DoPlaySoundToSet(m_creature,6206);
+              break;
+           case 3:
+              DoSay("Time to Die!",LANG_ORCISH,NULL);
+              DoPlaySoundToSet(m_creature,6207);
+              break;
+       }
+    }
+    if(m_creature->getFaction() == 11 && !yell)
+    {
+       yell = true;
+       switch(rand()%4)
+       {
+       case 0:
+          DoYell("We are under Attack !!",LANG_COMMON,NULL);
+          break;
+       case 1:
+          DoSay("Time to Killing!",LANG_COMMON,NULL);
+          break;
+       case 2:
+          DoSay("Yahn!",LANG_COMMON,NULL);
+          break;
+       case 3:
+          DoSay("Time to Die!",LANG_COMMON,NULL);
+          break;
+       }
+    }
+    if(m_creature->getFaction() == 79 && !yell)
+    {
+       yell = true;
+       switch(rand()%4)
+       {
+           case 0:
+              DoYell("We are under Attack !!",LANG_DARNASSIAN,NULL);
+              break;
+           case 1:
+              DoSay("Time to Killing!",LANG_DARNASSIAN,NULL);
+              break;
+           case 2:
+              DoSay("Yahn!",LANG_DARNASSIAN,NULL);
+              break;
+           case 3:
+              DoSay("Time to Die!",LANG_DARNASSIAN,NULL);
+              break;
+       }
+    }
 }
+void guardAI::DamageDeal(Unit *done_to, uint32 &damage)
+{
+   if(m_creature->GetEntry() == 4423)
+       return;
+   temp1 = m_creature->GetPower(POWER_RAGE);
+   temp2 = 0;
+   temp2 = temp1;
+   switch(rand()%4)
+   {
+      case 0:temp1 = temp2 + 40;break;
+      case 1:temp1 = temp2 + 50;break;
+      case 2:temp1 = temp2 + 60;break;
+      case 3:temp1 = temp2 + 70;break;
+   }
+   if(temp1 > 500)
+      m_creature->SetPower(POWER_RAGE,500);   
+   else
+      m_creature->SetPower(POWER_RAGE,temp1);
+}
 
+void guardAI::DamageTaken(Unit *done_by, uint32 &damage)
+{
+    if(damage > m_creature->GetHealth())
+        return;
+
+   if(m_creature->GetEntry() == 4423)
+       return;
+
+   temp1 = m_creature->GetPower(POWER_RAGE);
+   temp2 = 0;
+   temp2 = temp1;
+   switch(rand()%4)
+   {
+      case 0:temp1 = temp2 + 20;break;
+      case 1:temp1 = temp2 + 30;break;
+      case 2:temp1 = temp2 + 40;break;
+      case 3:temp1 = temp2 + 50;break;
+   }
+   if(temp1 > 500)
+      m_creature->SetPower(POWER_RAGE,500);   
+   else
+      m_creature->SetPower(POWER_RAGE,temp1); 
+}
+
 void guardAI::UpdateAI(const uint32 diff)
 {
     //Always decrease our global cooldown first
@@ -57,61 +205,278 @@
         GlobalCooldown -= diff;
     else GlobalCooldown = 0;
 
-    //Buff timer (only buff when we are alive and not in combat
-    if (m_creature->isAlive() && !InCombat)
-        if (BuffTimer < diff )
-    {
-        //Find a spell that targets friendly and applies an aura (these are generally buffs)
-        SpellEntry const *info = SelectSpell(m_creature, -1, -1, SELECT_TARGET_ANY_FRIEND, 0, 0, 0, 0, SELECT_EFFECT_AURA);
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
 
-        if (info && !GlobalCooldown)
-        {
-            //Cast the buff spell
-            DoCastSpell(m_creature, info);
+    //Always decrease Bandage
+    if (Bandage > diff)
+        Bandage -= diff;
+    else Bandage = 0;
 
-            //Set our global cooldown
-            GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+    //Always decrease OffHand
+    if (OffHand > diff)
+        OffHand -= diff;
+    else OffHand = 0;
 
-            //Set our timer to 10 minutes before rebuff
-            BuffTimer = 600000;
-        }                                                   //Try agian in 30 seconds
-        else BuffTimer = 30000;
-    }else BuffTimer -= diff;
+    //Always decrease Potion
+    if (Potion > diff)
+        Potion -= diff;
+    else Potion = 0;
 
+    if(!m_creature->isAlive())
+        return;
+
+    if (!InCombat && !(m_creature->GetEntry() == 2041 || m_creature->GetEntry() == 4423))
+    {
+       temp1 = m_creature->GetPower(POWER_RAGE);
+       temp2 = temp1;
+       temp1 = temp2 - 3;
+       if(temp1 > 0)
+          m_creature->SetPower(POWER_RAGE,temp1);
+       else
+          m_creature->SetPower(POWER_RAGE,0);
+    }
+
     //Return since we have no target
     if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
         return;
 
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    if(!Help && !(m_creature->GetEntry() == 2041 || m_creature->GetEntry() == 4423))
+    {
+       int entry = m_creature->GetEntry();
+       float x;
+       float y;
+       float z;
+       float X;
+       float Y;
+       float Z;
+       m_creature->GetPosition(x,y,z);
+       m_creature->getVictim()->GetPosition(X,Y,Z);
+       if(x > X)
+           X = x + 20;
+       else
+           X = x - 20;
+       if(y > Y)
+           Y = y + 20;
+       else
+           Y = y - 20;
+       m_creature->GetRespawnCoord(x,y,z); 
+
+          if(entry != 12480 && entry != 12481)
+           {
+       Helper = DoSpawnCreature(entry, (float) (X - x), (float) (Y - y), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+    /*   Helper = DoSpawnCreature(entry, 0, 0, 0, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000); */
+       if(Helper && enemy)
+          ((CreatureAI*)Helper->AI())->AttackStart(enemy); 
+           }else
+             {
+       Helper = DoSpawnCreature(68, (float) (X - x + 3), (float) (Y - y - 3), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+           if(Helper && enemy)
+           ((CreatureAI*)Helper->AI())->AttackStart(enemy); 
+           Creature* Helper2 = NULL;
+       Helper2 = DoSpawnCreature(68, (float) (X - x - 3), (float) (Y - y + 3), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+           if(Helper2 && enemy)
+           ((CreatureAI*)Helper2->AI())->AttackStart(enemy); 
+            Creature* Helper3 = NULL;
+       Helper3 = DoSpawnCreature(68, (float) (X - x + 3), (float) (Y - y + 3), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+           if(Helper3 && enemy)
+           ((CreatureAI*)Helper3->AI())->AttackStart(enemy); 
+             }
+
+       Help = 45000 + rand()%30000;
+    }
+
     // Make sure our attack is ready and we arn't currently casting
     if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
     {
+            if(m_creature->getVictim() && m_creature->SelectHostilTarget() && m_creature->GetEntry() == 3084 && OffHand > 0 && OffHand < 500)
+            {
+                m_creature->HandleEmoteCommand(EMOTE_ONESHOT_ATTACKOFF);
+                m_creature->AttackerStateUpdate(m_creature->getVictim());
+                m_creature->resetAttackTimer();
+                OffHand = 0;
+            }
         //If we are within range melee the target
         if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
         {
+
+           if(_Aggro != 2 && m_creature->GetEntry() != 2041 && m_creature->GetEntry() != 5624)
+           {
+              _Aggro = 2;
+              DoCast(m_creature,2457);
+              return;
+           }
+
+           if(m_creature->GetHealth()*100 / m_creature->GetMaxHealth() > 39 && m_creature->HasAura(2458,0) && m_creature->GetEntry() != 2041 && m_creature->GetEntry() != 5624)
+           {
+              DoCast(m_creature,2457);
+              return; 
+           }
+
             bool Healing = false;
-            SpellEntry const *info = NULL;
+            int Change = 0;
+            int info = NULL;
 
             //Select a healing spell if less than 30% hp
-            if (m_creature->GetHealth()*100 / m_creature->GetMaxHealth() < 30)
-                info = SelectSpell(m_creature, -1, -1, SELECT_TARGET_ANY_FRIEND, 0, 0, 0, 0, SELECT_EFFECT_HEALING);
+            if (m_creature->GetHealth()*100 / m_creature->GetMaxHealth() < 40)
+            {
+               if(Potion == 0 && !Healing)
+               {
+                  Potion = 60000;
+                  info = 17534;
+                  Healing = true;
+               }
+               else
+               {
+                  if(Bandage == 0 && !Healing)
+                  {
+                     Bandage = 60000;
+                     info = 38919;
+                     Healing = true;
+                  }
+                  else
+                      if(m_creature->HasAura(2457,0))
+                      {
+                         info = 2458;
+                         Change = 3;
+                      }  
+               }//if bandage
+            }//if health <40%
+            else
+            {
+                         if(!m_creature->HasAura(2048,0) && m_creature->GetPower(POWER_RAGE) > 100)
+                         {
+                            info = 2048;
+                            Change = 3;    
+                         }
+                         else
+                         {
+                            if(enemy && !enemy->HasAura(25203,0) && m_creature->GetPower(POWER_RAGE) > 100)
+                            {
+                               info = 25203;
+                               Change = 4;    
+                            }
+                            //select a hostile spell
+                            else
+                            {
+                               if(enemy && m_creature->GetPower(POWER_RAGE) > 100)
+                               {
+                                  switch(rand()%8)
+                                  {
+                                     case 0:
+                                        info = 29707;
+                                        break;
+                                     case 1:
+                                        info = 11574;
+                                        break;
+                                     case 2:
+                                        info = 30022;
+                                        break;
+                                     case 3:
+                                        info = 11597;
+                                        break;
+                                     case 4:
+                                        if(m_creature->HasAura(2457,0))
+                                           info = 25248;
+                                        else info = 20569;
+                                        break;
+                                     case 5:
+                                        if(m_creature->HasAura(2457,0))
+                                           info = 20560;
+                                        else info = 6554;
+                                        break;
+                                     case 6:
+                                        if(m_creature->HasAura(2457,0))
+                                           info = 11581;
+                                        else info = 1680;
+                                        break;
+                                     case 7:
+                                        info = 11597;
+                                        break;
+                                  }//switch
+                               }//if rage
+                            }//else hostile spell
+                         }//if no demoralizing
+                     }//if no battle shout
 
-            //No healing spell available, select a hostile spell
-            if (info) Healing = true;
-            else info = SelectSpell(m_creature->getVictim(), -1, -1, SELECT_TARGET_ANY_ENEMY, 0, 0, 0, 0, SELECT_EFFECT_DONTCARE);
+            if(m_creature->GetEntry() == 4423)
+               info = NULL;
 
-            //20% chance to replace our white hit with a spell
-            if (info && rand() % 5 == 0 && !GlobalCooldown)
+            if(m_creature->GetEntry() == 5624)
             {
-                //Cast the spell
-                if (Healing)DoCastSpell(m_creature, info);
-                else DoCastSpell(m_creature->getVictim(), info);
+                info = NULL;
+                if(!m_creature->HasAura(41924,0))
+                    DoCast(m_creature, 41924);
+            }
 
+            //50% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Healing)DoCast(m_creature, info);
+                else
+                {
+                         if(Change == 3)
+                         {
+                            DoCast(m_creature, info);                            
+                            if(m_creature->getFaction() == 85)
+                            {
+                               DoYell("Warcry",LANG_ORCISH,NULL); 
+                               DoPlaySoundToSet(m_creature,6204);
+                            }
+                         }
+                         else
+                         {
+                            if(Change == 4)
+                               DoCast(enemy, info);
+                            else
+                                DoCast(enemy, info);
+                         }              
+                }
                 //Set our global cooldown
                 GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
-            }
+            }//end 50% change
             else m_creature->AttackerStateUpdate(m_creature->getVictim());
 
             m_creature->resetAttackTimer();
+            if(m_creature->GetEntry() == 3084)
+                OffHand = 1000;
         }
     }
     else
Index: scripts/guard/guard_ai.h
===================================================================
--- scripts/guard/guard_ai.h	(revision 740)
+++ scripts/guard/guard_ai.h	(working copy)
@@ -1,4 +1,4 @@
-/* Copyright (C) 2006 - 2008 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+/* Copyright (C) 2006,2007 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
  * This program is free software licensed under GPL version 2
  * Please see the included DOCS/LICENSE.TXT for more information */
 
@@ -9,17 +9,29 @@
 
 struct MANGOS_DLL_DECL guardAI : public ScriptedAI
 {
-    guardAI(Creature *c) : ScriptedAI(c) {Reset();}
+    guardAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0; _Aggro = 0;}
 
-    uint32 GlobalCooldown;                                  //This variable acts like the global cooldown that players have (1.5 seconds)
-    uint32 BuffTimer;                                       //This variable keeps track of buffs
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Bandage;
+    uint32 Potion;
+    uint32 Help;
+    uint32 OffHand;
+    uint32 ZoneAttackMsgTimer;
+    bool yell;
+    int _Aggro;
+    float temp1;
+    float temp2;
+    Unit* enemy;
+    Creature* Helper;
 
     void Reset();
 
     void Aggro(Unit *who);
 
-    void JustDied(Unit *Killer);
+    void DamageDeal(Unit *done_to, uint32 &damage);
 
+    void DamageTaken(Unit *done_by, uint32 &damage);
+
     void UpdateAI(const uint32 diff);
 };
 #endif
Index: scripts/guard/high_fire_mage.cpp
===================================================================
--- scripts/guard/high_fire_mage.cpp	(revision 0)
+++ scripts/guard/high_fire_mage.cpp	(revision 0)
@@ -0,0 +1,207 @@
+/* 
+##############################
+ Lady Catrana Prestor v 1.0
+##############################
+
+by Myav 
+*/
+
+#include "precompiled.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL high_fire_mageAI : public ScriptedAI
+{
+    high_fire_mageAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+
+    m_creature->SetMaxHealth(120000);
+    m_creature->SetHealth(120000);
+    m_creature->SetMaxPower(POWER_MANA,90000);
+    m_creature->SetPower(POWER_MANA,90000);
+    m_creature->SetArmor(5720);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_KNOCKOUT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+1000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+}
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    if(!m_creature->HasAura(30482,0))
+    {
+     DoCast(m_creature, 30482);
+     return;
+    }
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+           int Change = 0;
+           int info = NULL;
+
+                 if(enemy)
+                  {
+                   switch(rand()%9)
+                   {
+               case 0:
+                  info = 38151;
+                  Change = 1;
+                  break;
+               case 1:
+                    info = 38536;
+                    break;
+               case 2:
+                    info = 33043;
+                    break;
+               case 3:
+                    info = 27079;
+                    break;
+               case 4:
+                    info = 41383;
+                    break;
+               case 5:
+                    info = 38535;
+                    break;
+               case 6:
+                    info = 12598;
+                    break;
+               case 7:
+                    info = 12042;
+                    Change = 1;
+                    break;
+               case 8:
+                    info = 38636;
+                    break;
+               }//switch
+            }
+
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+        }//end attack ready
+    }// end attack distance
+/*    else 
+    { 
+     if(!m_creature->IsNonMeleeSpellCasted(false))
+     {
+         if ((*m_creature).GetMotionMaster()->top()->GetMovementGeneratorType()!=TARGETED_MOTION_TYPE)
+         {
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+         }
+     }
+    }//end else */
+}
+};
+CreatureAI* GetAI_high_fire_mage(Creature *_Creature)
+{
+    return new high_fire_mageAI (_Creature);
+}
+
+void AddSC_high_fire_mage()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "high_fire_mage";
+    newscript->GetAI = &GetAI_high_fire_mage;
+    newscript->RegisterSelf();
+}
Index: scripts/guard/high_sorcerer_andromath.cpp
===================================================================
--- scripts/guard/high_sorcerer_andromath.cpp	(revision 0)
+++ scripts/guard/high_sorcerer_andromath.cpp	(revision 0)
@@ -0,0 +1,205 @@
+/* 
+##############################
+ High Sorcerer Andromath v 1.0
+##############################
+
+by Myav 
+*/
+
+#include "precompiled.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL high_sorcerer_andromathAI : public ScriptedAI
+{
+    high_sorcerer_andromathAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+
+    m_creature->SetMaxHealth(120000);
+    m_creature->SetHealth(120000);
+    m_creature->SetMaxPower(POWER_MANA,90000);
+    m_creature->SetPower(POWER_MANA,90000);
+    m_creature->SetArmor(5720);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_KNOCKOUT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+1000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+}
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    if(!m_creature->HasAura(27124,0))
+    {
+     DoCast(m_creature, 27124);
+    }
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+           int Change = 0;
+           int info = NULL;
+
+                 if(enemy)
+                  {
+                   switch(rand()%9)
+                   {
+               case 0:
+                  info = 33405;
+                  Change = 1;
+                  break;
+               case 1:
+                    info = 41382;
+                    break;
+               case 2:
+                    info = 5164;
+                    break;
+               case 3:
+                    info = 39348;
+                    break;
+               case 4:
+                    info = 29717;
+                    break;
+               case 5:
+                    info = 31250;
+                    break;
+               case 6:
+                    info = 24857;
+                    break;
+               case 7:
+                    info = 41486;
+                    break;
+               case 8:
+                    info = 39414;
+                    break;
+               }//switch
+            }
+
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+        }//end attack ready
+    }// end attack distance
+/*    else 
+    { 
+     if(!m_creature->IsNonMeleeSpellCasted(false))
+     {
+         if ((*m_creature).GetMotionMaster()->top()->GetMovementGeneratorType()!=TARGETED_MOTION_TYPE)
+         {
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+         }
+     }
+    }//end else */
+}
+};
+CreatureAI* GetAI_high_sorcerer_andromath(Creature *_Creature)
+{
+    return new high_sorcerer_andromathAI (_Creature);
+}
+
+void AddSC_high_sorcerer_andromath()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "high_sorcerer_andromath";
+    newscript->GetAI = &GetAI_high_sorcerer_andromath;
+    newscript->RegisterSelf();
+}
Index: scripts/guard/highlord_bolvar_fordragon.cpp
===================================================================
--- scripts/guard/highlord_bolvar_fordragon.cpp	(revision 0)
+++ scripts/guard/highlord_bolvar_fordragon.cpp	(revision 0)
@@ -0,0 +1,226 @@
+/* 
+#################################
+ highlord Bolvar Fordragon v 1.0
+#################################
+
+by Myav 
+*/
+
+#include "precompiled.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL highlord_bolvar_fordragonAI : public ScriptedAI
+{
+    highlord_bolvar_fordragonAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+
+    m_creature->SetMaxHealth(380000);
+    m_creature->SetHealth(380000);
+    m_creature->SetMaxPower(POWER_MANA,150000);
+    m_creature->SetPower(POWER_MANA,150000);
+    m_creature->SetArmor(11520);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DISARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_INTERRUPT_CAST, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CONFUSED, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM , true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR , true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DAZE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_BANISH, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+3000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+}
+
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    if(!m_creature->HasAura(27150,0))
+    {
+     DoCast(m_creature, 27150);
+     return;
+    }
+
+    if(!m_creature->HasAura(27158,0))
+    {
+     DoCast(m_creature, 27158);
+     return;
+    }
+
+    if(!m_creature->HasAura(20217,0))
+    {
+     DoCast(m_creature, 20217);
+     return;
+    }
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+           int Change = 0;
+           int info = NULL;
+
+              if(enemy)
+                  {
+                   switch(rand()%9)
+                   {
+               case 0:
+                  info = 36946;
+                  break;
+               case 1:
+                    info = 38921;
+                    break;
+               case 2:
+                    info = 32700;
+                    break;
+               case 3:
+                    info = 41367;
+                    Change = 1;
+                    break;
+               case 4:
+                    info = 10308;
+                    break;
+               case 5:
+                    info = 31904;
+                    Change = 1;
+                    break;
+               case 6:
+                    info = 41450;
+                    Change = 1;
+                    break;
+               case 7:
+                    info = 31884;
+                    Change = 1;
+                    break;
+               case 8:
+                    info = 35395;
+                    break;
+               }//switch
+            }
+
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+        }//end attack ready
+    }// end attack distance
+/*    else 
+    { 
+     if(!m_creature->IsNonMeleeSpellCasted(false))
+     {
+         if ((*m_creature).GetMotionMaster()->top()->GetMovementGeneratorType()!=TARGETED_MOTION_TYPE)
+         {
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+         }
+     }
+    }//end else */
+}
+};
+CreatureAI* GetAI_highlord_bolvar_fordragon(Creature *_Creature)
+{
+    return new highlord_bolvar_fordragonAI (_Creature);
+}
+
+void AddSC_highlord_bolvar_fordragon()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "highlord_bolvar_fordragon";
+    newscript->GetAI = &GetAI_highlord_bolvar_fordragon;
+    newscript->RegisterSelf();
+}
Index: scripts/guard/officers.cpp
===================================================================
--- scripts/guard/officers.cpp	(revision 0)
+++ scripts/guard/officers.cpp	(revision 0)
@@ -0,0 +1,379 @@
+/* 
+#####################
+ City Officers v 4
+#####################
+
+by Myav
+*/
+
+#include "precompiled.h"
+#include "guard_ai.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL city_officerAI : public ScriptedAI
+{
+    city_officerAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0; _Aggro = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 OffHand;
+    uint32 ZoneAttackMsgTimer;
+    bool yell;
+    int _Aggro;
+    float temp1;
+    float temp2;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 5000;
+    OffHand = 0;
+    yell = false;
+
+    m_creature->setPowerType(POWER_RAGE); 
+    m_creature->SetMaxPower(POWER_RAGE,500);
+    m_creature->SetPower(POWER_RAGE,0); 
+    if(m_creature->GetEntry() != 2041 && m_creature->GetEntry() != 18103)   
+        m_creature->SetMaxHealth(33600);
+    else 
+    {
+    if(m_creature->GetEntry() == 18103)
+         m_creature->SetMaxHealth(47400);
+     else m_creature->SetMaxHealth(67000);
+    }
+    if(m_creature->GetEntry() != 2041 && m_creature->GetEntry() != 18103)
+        m_creature->SetHealth(33600);
+    else
+    {
+    if(m_creature->GetEntry() == 18103)
+         m_creature->SetHealth(47400);
+     else m_creature->SetHealth(67000);
+    }
+    if(m_creature->GetEntry() == 21970 || m_creature->GetEntry() == 21971)
+        m_creature->SetMaxHealth(45725);
+    if(m_creature->GetEntry() == 21970 || m_creature->GetEntry() == 21971)
+        m_creature->SetHealth(45725);
+    m_creature->SetArmor(9600);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,540);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,540);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,540);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,540);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,540);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,540);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,540);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+1000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+
+}
+
+void DamageDeal(Unit *done_to, uint32 &damage)
+{
+   if(m_creature->GetEntry() == 2041 || m_creature->GetEntry() == 18103)
+       return;
+   temp1 = m_creature->GetPower(POWER_RAGE);
+   temp2 = 0;
+   temp2 = temp1;
+   switch(rand()%4)
+   {
+      case 0:temp1 = temp2 + 40;break;
+      case 1:temp1 = temp2 + 50;break;
+      case 2:temp1 = temp2 + 60;break;
+      case 3:temp1 = temp2 + 70;break;
+   }
+   if(temp1 > 500)
+      m_creature->SetPower(POWER_RAGE,500);   
+   else
+      m_creature->SetPower(POWER_RAGE,temp1);
+}
+
+void DamageTaken(Unit *done_by, uint32 &damage)
+{
+    if(damage > m_creature->GetHealth())
+        return;
+
+   if(m_creature->GetEntry() == 2041 || m_creature->GetEntry() == 18103)
+       return;
+
+   temp1 = m_creature->GetPower(POWER_RAGE);
+   temp2 = 0;
+   temp2 = temp1;
+   switch(rand()%4)
+   {
+      case 0:temp1 = temp2 + 20;break;
+      case 1:temp1 = temp2 + 30;break;
+      case 2:temp1 = temp2 + 40;break;
+      case 3:temp1 = temp2 + 50;break;
+   }
+   if(temp1 > 500)
+      m_creature->SetPower(POWER_RAGE,500);   
+   else
+      m_creature->SetPower(POWER_RAGE,temp1); 
+}
+
+
+void guards()
+{
+       int entry = NULL;
+       float x;
+       float y;
+       float z;
+       float X;
+       float Y;
+       float Z;
+       m_creature->GetPosition(x,y,z);
+       m_creature->getVictim()->GetPosition(X,Y,Z);
+       if(x > X)
+           X = x + 20 + 10 - rand()%20;
+       else
+           X = x - 20 + 10 - rand()%20;
+       if(y > Y)
+           Y = y + 20 + 10 - rand()%20;
+       else
+           Y = y - 20 + 10 - rand()%20;
+       m_creature->GetRespawnCoord(x,y,z); 
+       if(m_creature->getFaction() == 85)
+           entry = 3296;
+       if(m_creature->getFaction() == 79)
+           entry = 4262;
+       if(m_creature->getFaction() == 11)
+           entry = 68;
+       if(m_creature->getFaction() == 71)
+           entry = 5624;
+       if(m_creature->getFaction() == 57)
+           entry = 5595;
+       if(m_creature->getFaction() == 105)
+           entry = 3084;    
+       if(m_creature->getFaction() == 1638)
+           entry = 16733;
+       if(m_creature->getFaction() == 1604)
+           entry = 16222;
+       Helper = DoSpawnCreature(entry, (float) (X - x), (float) (Y - y), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+    /*   Helper = DoSpawnCreature(entry, 0, 0, 0, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000); */
+       if(Helper && enemy)
+          ((CreatureAI*)Helper->AI())->AttackStart(enemy); 
+}
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease our OffHand cooldown first
+    if (OffHand > diff)
+        OffHand -= diff;
+    else OffHand = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    //Buff timer (only buff when we are alive and not in combat
+    if (!InCombat)
+    {
+       temp1 = m_creature->GetPower(POWER_RAGE);
+       temp2 = temp1;
+       temp1 = temp2 - 3;
+       if(temp1 > 0)
+          m_creature->SetPower(POWER_RAGE,temp1);
+       else
+          m_creature->SetPower(POWER_RAGE,0);
+    }
+
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    if(!Help && m_creature->GetEntry() != 2041 && m_creature->GetEntry() != 18103)
+    {
+       if(m_creature->getFaction() == 85)
+        DoYell("Orgrimmar is under Invasion! Guards!! Help me!",LANG_ORCISH,NULL);
+       if(m_creature->getFaction() == 79)
+        DoYell("Darnassus is under Invasion! Guards!! Help me!",LANG_DARNASSIAN,NULL);
+       if(m_creature->getFaction() == 11)
+        DoYell("Stormwind is under Invasion! Guards!! Help me!",LANG_COMMON,NULL);
+       if(m_creature->getFaction() == 71)
+        DoYell("Undercity is under Invasion! Guards!! Help me!",LANG_GUTTERSPEAK,NULL);
+       if(m_creature->getFaction() == 57)
+        DoYell("Ironforge is under Invasion! Guards!! Help me!",LANG_DWARVISH,NULL);
+       if(m_creature->getFaction() == 105)
+        DoYell("Thunder Bluff is under Invasion! Guards!! Help me!",LANG_TAURAHE,NULL);
+       if(m_creature->getFaction() == 1638)
+        DoYell("The Exodar is under Invasion! Guards!! Help me!",LANG_DRAENEI,NULL);
+       if(m_creature->getFaction() == 1604)
+        DoYell("Silvermoon is under Invasion! Guards!! Help me!",LANG_THALASSIAN,NULL);
+       m_creature->HandleEmoteCommand(EMOTE_ONESHOT_BATTLEROAR);
+       for(int i = 0; i < 3;i++)
+       {
+            guards();
+       }
+       Help = 60000 + rand()%45000;
+    }
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+            if(m_creature->getVictim() && m_creature->SelectHostilTarget() && OffHand > 0 && OffHand < 500)
+            {
+                m_creature->HandleEmoteCommand(EMOTE_ONESHOT_ATTACKOFF);
+                m_creature->AttackerStateUpdate(m_creature->getVictim());
+                m_creature->resetAttackTimer();
+                OffHand = 0;
+            }
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+
+           if(_Aggro != 2 && m_creature->GetEntry() != 2041 && m_creature->GetEntry() != 18103)
+           {
+              _Aggro = 2;
+              DoCast(m_creature,2457);
+              return;
+           }
+
+           int Change = 0;
+           int info = NULL;
+
+       /*     if(!m_creature->HasAura(469,0) && m_creature->GetPower(POWER_RAGE) > 50)
+            {
+                info = 469;
+                Change = 1;
+            }
+            else
+            { */
+                if(!m_creature->HasAura(2048,0) && m_creature->GetPower(POWER_RAGE) > 50)
+                {
+                    info = 2048;
+                    Change = 1;
+                }
+                else
+                 if(enemy && m_creature->GetPower(POWER_RAGE) > 100)
+                  {
+                   switch(rand()%9)
+                   {
+               case 0:
+                  info = 30324;
+                  break;
+               case 1:
+                    info = 30335;
+                    break;
+               case 2:
+                    info = 12323;
+                    break;
+               case 3:
+                    info = 5246;
+                    break;
+               case 4:
+                    info = 12809;
+                    break;
+               case 5:
+
+                    info = 38474;
+                    break;
+               case 6:
+                    info = 31955;
+                    break;
+               case 7:
+                    info = 30989;
+                    break;
+               case 8:
+                    info = 13736;
+                    break;
+               }//switch
+            }//if rage
+        /*    } */
+
+            if(m_creature->GetEntry() == 2041 || m_creature->GetEntry() == 18103)
+                info = NULL;
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 3 < 2 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+            OffHand = 1000;
+        }//end attack ready
+    }// end attack distance
+}
+};
+CreatureAI* GetAI_city_officer(Creature *_Creature)
+{
+    return new city_officerAI (_Creature);
+}
+CreatureAI* GetAI_city_guard(Creature *_Creature)
+{
+    return new guardAI (_Creature);
+}
+void AddSC_city_officer()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "city_officer";
+    newscript->GetAI = &GetAI_city_officer;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "city_guard";
+    newscript->GetAI = &GetAI_city_guard;
+    newscript->RegisterSelf();
+}
Index: scripts/guard/overlord_saurfang.cpp
===================================================================
--- scripts/guard/overlord_saurfang.cpp	(revision 0)
+++ scripts/guard/overlord_saurfang.cpp	(revision 0)
@@ -0,0 +1,235 @@
+/* 
+##############################
+ High Overlord Saurfang v 1.0
+ (Orgrimmar protector)
+##############################
+
+by Myav 
+*/
+
+#include "precompiled.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL overlord_saurfangAI : public ScriptedAI
+{
+    overlord_saurfangAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+    m_creature->SetMaxHealth(98000);
+    m_creature->SetHealth(98000);
+    m_creature->SetArmor(11520);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_KNOCKOUT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+2000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+}
+
+void grunts()
+{
+       float x;
+       float y;
+       float z;
+       float X;
+       float Y;
+       float Z;
+       m_creature->GetPosition(x,y,z);
+       m_creature->getVictim()->GetPosition(X,Y,Z);
+       if(x > X)
+           X = x + 20 + 10 - rand()%20;
+       else
+           X = x - 20 + 10 - rand()%20;
+       if(y > Y)
+           Y = y + 20 + 10 - rand()%20;
+       else
+           Y = y - 20 + 10 - rand()%20;
+       m_creature->GetRespawnCoord(x,y,z);        
+       Helper = DoSpawnCreature(3296, (float) (X - x), (float) (Y - y), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+       if(Helper && enemy)
+          ((CreatureAI*)Helper->AI())->AttackStart(enemy); 
+}
+
+void JustDied(Unit*)
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+    m_creature->RemoveAllAttackers();
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+2000,false);
+}
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    if(!Help)
+    {
+
+       for(int i = 0; i < 4;i++)
+       {
+            grunts();
+       }
+       Help = 60000 + rand()%45000;
+    }
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+           int Change = 0;
+           int info = NULL;
+
+            if(!m_creature->HasAura(8269,0))
+            {
+                info = 8269;
+                Change = 1;
+            }
+            else
+            {
+                 if(enemy)
+                  {
+                   switch(rand()%5)
+                   {
+               case 0:
+                  info = 11430;
+                  break;
+               case 1:
+                    info = 31955;
+                    break;
+               case 2:
+                    info = 5164;
+                    break;
+               case 3:
+                    info = 41400;
+                    break;
+               case 4:
+                    info = 41197;
+                    break;
+               }//switch
+            }//if rage
+            }
+
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+        }//end attack ready
+    }// end attack distance
+/*    else 
+    { 
+     if(!m_creature->IsNonMeleeSpellCasted(false))
+     {
+         if ((*m_creature).GetMotionMaster()->top()->GetMovementGeneratorType()!=TARGETED_MOTION_TYPE)
+         {
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+         }
+     }
+    }//end else */
+}
+};
+CreatureAI* GetAI_overlord_saurfang(Creature *_Creature)
+{
+    return new overlord_saurfangAI (_Creature);
+}
+
+void AddSC_overlord_saurfang()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "overlord_saurfang";
+    newscript->GetAI = &GetAI_overlord_saurfang;
+    newscript->RegisterSelf();
+}
Index: scripts/guard/thrall.cpp
===================================================================
--- scripts/guard/thrall.cpp	(revision 0)
+++ scripts/guard/thrall.cpp	(revision 0)
@@ -0,0 +1,278 @@
+/* 
+############
+ Thrall v 1
+############
+
+by Myav
+*/
+
+#include "precompiled.h"
+#include "guard_ai.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL thrallAI : public ScriptedAI
+{
+    thrallAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    bool yell;
+    int _Aggro;
+    float temp1;
+    float temp2;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 5000;
+    yell = false;
+    m_creature->setPowerType(POWER_RAGE); 
+    m_creature->SetMaxPower(POWER_RAGE,500);
+    m_creature->SetPower(POWER_RAGE,0);    
+    m_creature->SetMaxHealth(360000);
+    m_creature->SetHealth(360000);
+    m_creature->SetArmor(11520);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DISARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_INTERRUPT_CAST, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CONFUSED, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM , true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR , true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DAZE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_BANISH, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+3000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+}
+
+void DamageDeal(Unit *done_to, uint32 &damage)
+{
+   temp1 = m_creature->GetPower(POWER_RAGE);
+   temp2 = 0;
+   temp2 = temp1;
+   switch(rand()%4)
+   {
+      case 0:temp1 = temp2 + 40;break;
+      case 1:temp1 = temp2 + 50;break;
+      case 2:temp1 = temp2 + 60;break;
+      case 3:temp1 = temp2 + 70;break;
+   }
+   if(temp1 > 500)
+      m_creature->SetPower(POWER_RAGE,500);   
+   else
+      m_creature->SetPower(POWER_RAGE,temp1);
+}
+
+void DamageTaken(Unit *done_by, uint32 &damage)
+{
+    if(damage > m_creature->GetHealth())
+        return;
+
+   temp1 = m_creature->GetPower(POWER_RAGE);
+   temp2 = 0;
+   temp2 = temp1;
+   switch(rand()%4)
+   {
+      case 0:temp1 = temp2 + 20;break;
+      case 1:temp1 = temp2 + 30;break;
+      case 2:temp1 = temp2 + 40;break;
+      case 3:temp1 = temp2 + 50;break;
+   }
+   if(temp1 > 500)
+      m_creature->SetPower(POWER_RAGE,500);   
+   else
+      m_creature->SetPower(POWER_RAGE,temp1); 
+}
+
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    //Buff timer (only buff when we are alive and not in combat
+    if (!InCombat)
+    {
+       temp1 = m_creature->GetPower(POWER_RAGE);
+       temp2 = temp1;
+       temp1 = temp2 - 3;
+       if(temp1 > 0)
+          m_creature->SetPower(POWER_RAGE,temp1);
+       else
+          m_creature->SetPower(POWER_RAGE,0);
+    }
+
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+           if(!m_creature->HasAura(41447,0))
+           {
+              DoCast(m_creature,41447);
+              return;
+           }
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+
+           if(_Aggro != 2 && m_creature->GetEntry() != 2041)
+           {
+              _Aggro = 2;
+              DoCast(m_creature,2457);
+              return;
+           }
+
+           int Change = 0;
+           int info = NULL;
+
+       /*     if(!m_creature->HasAura(469,0) && m_creature->GetPower(POWER_RAGE) > 50)
+            {
+                info = 469;
+                Change = 1;
+            }
+            else
+            { */
+                if(!m_creature->getVictim()->HasAura(29584,0) && m_creature->GetPower(POWER_RAGE) > 50)
+                {
+                    info = 29584;
+                }
+                else
+                 if(enemy && m_creature->GetPower(POWER_RAGE) > 100)
+                  {
+                   switch(rand()%8)
+                   {
+               case 0:
+                  info = 37476;
+                  break;
+               case 1:
+                    info = 36706;
+                    break;
+               case 2:
+                    info = 38618;
+                    break;
+               case 3:
+                    info = 12975;
+                    Change = 1;
+                    break;
+               case 4:
+                    info = 12809;
+                    break;
+               case 5:
+                    info = 36138;
+                    break;
+               case 6:
+                    info = 5246;
+                    break;
+               case 7:
+                    info = 34620;
+                    break;
+               }//switch
+            }//if rage
+        /*    } */
+
+            if(m_creature->GetEntry() == 2041)
+                info = NULL;
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 3 < 2 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+
+        }//end attack ready
+    }// end attack distance
+}
+};
+CreatureAI* GetAI_thrall(Creature *_Creature)
+{
+    return new thrallAI (_Creature);
+}
+void AddSC_thrall()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "thrall";
+    newscript->GetAI = &GetAI_thrall;
+    newscript->RegisterSelf();
+}
Index: scripts/item/item_scripts.cpp
===================================================================
--- scripts/item/item_scripts.cpp	(revision 740)
+++ scripts/item/item_scripts.cpp	(working copy)
@@ -393,6 +393,25 @@
 }
 
 /*#####
+# item_wolpertinger_net
+#####*/
+
+bool ItemUse_item_wolpertinger_net(Player *player, Item* _Item, SpellCastTargets const& targets)
+{
+    if( targets.getUnitTarget() && targets.getUnitTarget()->GetTypeId()==TYPEID_UNIT &&
+        targets.getUnitTarget()->GetEntry() == 23487 )
+        return false;
+
+    WorldPacket data(SMSG_CAST_FAILED, (4+2));              // prepare packet error message
+    data << uint32(_Item->GetEntry());                      // itemId
+    data << uint8(SPELL_FAILED_BAD_TARGETS);                // reason
+    player->GetSession()->SendPacket(&data);                // send message: Invalid target
+
+    player->SendEquipError(EQUIP_ERR_YOU_CAN_NEVER_USE_THAT_ITEM,_Item,NULL);
+    return true;
+}
+
+/*#####
 # item_yehkinyas_bramble
 #####*/
 
@@ -518,6 +537,11 @@
     newscript->RegisterSelf();
 
     newscript = new Script;
+    newscript->Name = "item_wolpertinger_net";
+    newscript->pItemUse = &ItemUse_item_wolpertinger_net;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
     newscript->Name = "item_yehkinyas_bramble";
     newscript->pItemUse = &ItemUse_item_yehkinyas_bramble;
     newscript->RegisterSelf();
Index: scripts/zone/black_temple/boss_supremus.cpp
===================================================================
--- scripts/zone/black_temple/boss_supremus.cpp	(revision 740)
+++ scripts/zone/black_temple/boss_supremus.cpp	(working copy)
@@ -122,7 +122,7 @@
         CheckTimer = 1000;
         SupremusGUID = 0;
         FireballTimer = 500;
-        GeyserTimer = 0;
+        GeyserTimer = 2000;
     }
 
     void Aggro(Unit *who) {}
@@ -357,15 +357,7 @@
 
                 if (target)
                 {
-                    Creature* Volcano = NULL;
-                    Volcano = SummonCreature(CREATURE_VOLCANO, target);
-
-                    if (Volcano)
-                    {
-                        DoCast(target, SPELL_VOLCANIC_ERUPTION);
-                        ((npc_volcanoAI*)Volcano->AI())->SetSupremusGUID(m_creature->GetGUID());
-                    }
-
+                    DoCast(target, SPELL_VOLCANIC_ERUPTION);
                     DoScriptText(EMOTE_GROUND_CRACK, m_creature);
                     SummonVolcanoTimer = 10000;
                 }
Index: scripts/zone/coilfang_resevoir/serpent_shrine/boss_lady_vashj.cpp
===================================================================
--- scripts/zone/coilfang_resevoir/serpent_shrine/boss_lady_vashj.cpp	(revision 740)
+++ scripts/zone/coilfang_resevoir/serpent_shrine/boss_lady_vashj.cpp	(working copy)
@@ -66,7 +66,7 @@
 #define TAINTED_ELEMENTAL           22009
 #define COILFANG_STRIDER            22056
 #define COILFANG_ELITE              22055
-#define FATHOM_SPOREBAT             22140
+#define TOXIC_SPORE_BAT             22140
 
 float ElementPos[8][4] =
 {
@@ -329,7 +329,7 @@
                 if (SummonSporebat_Timer < diff)
                 {
                     Creature *Sporebat = NULL;
-                    Sporebat = m_creature->SummonCreature(FATHOM_SPOREBAT, SPOREBAT_X, SPOREBAT_Y, SPOREBAT_Z, SPOREBAT_O, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+                    Sporebat = m_creature->SummonCreature(TOXIC_SPORE_BAT, SPOREBAT_X, SPOREBAT_Y, SPOREBAT_Z, SPOREBAT_O, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
 
                     if (Sporebat)
                     {
@@ -594,11 +594,11 @@
     }
 };
 
-//Fathom Sporebat
+//Toxic Spore Bat
 //Toxic Spores: Used in Phase 3 by the Spore Bats, it creates a contaminated green patch of ground, dealing about 2775-3225 nature damage every second to anyone who stands in it.
-struct MANGOS_DLL_DECL mob_fathom_sporebatAI : public ScriptedAI
+struct MANGOS_DLL_DECL mob_toxic_spore_batAI : public ScriptedAI
 {
-    mob_fathom_sporebatAI(Creature *c) : ScriptedAI(c)
+    mob_toxic_spore_batAI(Creature *c) : ScriptedAI(c)
     {
         pInstance = ((ScriptedInstance*)c->GetInstanceData());
         Reset();
@@ -807,10 +807,19 @@
 
             //remove this item
             player->DestroyItemCount(31088, 1, true);
+            return true;
         }
-    }
+        else if( targets.getUnitTarget()->GetTypeId()==TYPEID_UNIT )
+            return false;
+        else if(targets.getUnitTarget()->GetTypeId()==TYPEID_PLAYER)
+        {
+            player->DestroyItemCount(31088, 1, true);
+            player->CastSpell(targets.getUnitTarget(), 38134, true);
+            return true;
+        }
+      }
     return true;
-}
+};
 
 CreatureAI* GetAI_boss_lady_vashj(Creature *_Creature)
 {
@@ -827,9 +836,9 @@
     return new mob_tainted_elementalAI (_Creature);
 }
 
-CreatureAI* GetAI_mob_fathom_sporebat(Creature *_Creature)
+CreatureAI* GetAI_mob_toxic_spore_bat(Creature *_Creature)
 {
-    return new mob_fathom_sporebatAI (_Creature);
+    return new mob_toxic_spore_batAI (_Creature);
 }
 
 CreatureAI* GetAI_mob_shield_generator_channel(Creature *_Creature)
@@ -856,8 +865,8 @@
     newscript->RegisterSelf();
 
     newscript = new Script;
-    newscript->Name = "mob_fathom_sporebat";
-    newscript->GetAI = &GetAI_mob_fathom_sporebat;
+    newscript->Name = "mob_toxic_spore_bat";
+    newscript->GetAI = &GetAI_mob_toxic_spore_bat;
     newscript->RegisterSelf();
 
     newscript = new Script;
Index: scripts/zone/deadmines/deadmines.cpp
===================================================================
--- scripts/zone/deadmines/deadmines.cpp	(revision 740)
+++ scripts/zone/deadmines/deadmines.cpp	(working copy)
@@ -22,3 +22,223 @@
 EndScriptData */
 
 #include "precompiled.h"
+#include "def_deadmines.h"
+#include "GameObject.h"
+#include "Player.h"
+#include "Spell.h"
+#include "WorldPacket.h"
+
+#define SOUND_CANNONFIRE	1400
+#define SOUND_DESTROYDOOR	3079
+#define SAY_MR_SMITE_ALARM1 "You there, check out that noise!"
+#define SOUND_MR_SMITE_ALARM1  5775
+#define SAY_MR_SMITE_ALARM2 "We're under attack! A vast, ye swabs! Repel the invaders!"
+#define SOUND_MR_SMITE_ALARM2  5777
+
+#define GO_IRONCLAD_DOOR	16397
+#define GO_DEFIAS_CANNON	16398
+#define GO_DOOR_LEVER		101833
+
+#define DEFIAS_PIRATE		657
+#define DEFIAS_COMPANION	3450
+
+#define CANNON_BLAST_TIMER 3000
+#define PIRATES_DELAY_TIMER 1000
+
+struct MANGOS_DLL_DECL instance_deadmines : public ScriptedInstance
+{
+	GameObject* IronCladDoor;
+	GameObject* DefiasCannon;
+	GameObject* DoorLever;
+	Creature* DefiasPirate1;
+	Creature* DefiasPirate2;
+	Creature* DefiasCompanion;
+	uint32 State;
+	uint32 CannonBlast_Timer;
+	uint32 PiratesDelay_Timer;
+
+	instance_deadmines(Map *Map) : ScriptedInstance(Map) {Initialize();};
+
+	void Initialize()
+	{
+		IronCladDoor = NULL;
+		DefiasCannon = NULL;
+		DoorLever =	NULL;
+		State = CANNON_NOT_USED;
+	}
+
+	virtual void Update(uint32 diff)
+	{
+		switch(State)
+		{
+			case CANNON_GUNPOWDER_USED:
+				CannonBlast_Timer = CANNON_BLAST_TIMER;
+				if(IronCladDoor)
+				{
+					// it's a hack - Mr. Smite should do that but his too far away
+					IronCladDoor->SetName("Mr. Smite");
+					IronCladDoor->Yell(SAY_MR_SMITE_ALARM1, LANG_UNIVERSAL, 0);
+					DoPlaySound(IronCladDoor, SOUND_MR_SMITE_ALARM1);
+				}
+				State = CANNON_BLAST_INITIATED;
+				break;
+			case CANNON_BLAST_INITIATED:	
+				PiratesDelay_Timer = PIRATES_DELAY_TIMER;
+				if(CannonBlast_Timer<diff)
+				{
+					SummonCreatures();
+					ShootCannon();
+					BlastOutDoor();
+					LeverStucked();
+					if(IronCladDoor)
+					{
+						IronCladDoor->Yell(SAY_MR_SMITE_ALARM2, LANG_UNIVERSAL, 0);
+						DoPlaySound(IronCladDoor, SOUND_MR_SMITE_ALARM2);
+					}
+					State = CANNON_PIRATES_ATTACK;						
+				}else
+					CannonBlast_Timer-=diff;								
+				break;
+			case CANNON_PIRATES_ATTACK:
+				if(PiratesDelay_Timer<diff)
+				{
+					MoveCreaturesInside();
+					State = CANNON_EVENT_DONE;
+				}else
+					PiratesDelay_Timer-=diff;
+				break;
+		}
+	}
+
+	void SummonCreatures()
+	{
+		if (IronCladDoor)
+		{
+			DefiasPirate1 = IronCladDoor->SummonCreature(DEFIAS_PIRATE, -100.97, -677, 7.42, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 360000);
+			DefiasPirate2 = IronCladDoor->SummonCreature(DEFIAS_PIRATE, -98.5, -675.77, 7.42, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 360000);
+			DefiasCompanion = IronCladDoor->SummonCreature(DEFIAS_COMPANION, -98.19, -675.08, 7.42, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 360000);
+		}
+	}
+	
+	void MoveCreaturesInside()
+	{
+		MoveCreatureInside(DefiasPirate1);
+		MoveCreatureInside(DefiasPirate2);
+		MoveCreatureInside(DefiasCompanion);
+	}
+
+	void MoveCreatureInside(Creature *creature)
+	{
+		if (creature)
+		{
+			creature->RemoveUnitMovementFlag(MOVEMENTFLAG_WALK_MODE);
+			creature->GetMotionMaster()->MovePoint(0, -102.7,-655.9, 7.43);
+		}
+	}
+
+	void ShootCannon()
+	{
+		if (DefiasCannon)
+		{
+			DefiasCannon->SetUInt32Value(GAMEOBJECT_STATE, 0);
+			DoPlaySound(DefiasCannon, SOUND_CANNONFIRE);
+		}
+	}
+
+	void BlastOutDoor()
+	{
+		if(IronCladDoor)
+		{
+			IronCladDoor->SetUInt32Value(GAMEOBJECT_STATE, 2);
+			DoPlaySound(IronCladDoor, SOUND_DESTROYDOOR);
+		}
+	}
+
+	void LeverStucked()
+	{
+		if (DoorLever)
+			DoorLever->SetUInt32Value(GAMEOBJECT_FLAGS, 4);
+	}
+
+	void OnObjectCreate(GameObject *go)
+	{
+		switch(go->GetEntry())
+		{
+			case GO_IRONCLAD_DOOR:
+				IronCladDoor = go;
+				break;
+			case GO_DEFIAS_CANNON:
+				DefiasCannon = go;
+				break;
+			case GO_DOOR_LEVER:
+				DoorLever = go;
+				break;
+		}
+	}
+
+	void SetData(uint32 type, uint32 data)
+	{
+		if (type == EVENT_STATE)
+		{
+			if (DefiasCannon && IronCladDoor)			
+				State=data;			
+		}
+	}
+
+	uint32 GetData(uint32 type)
+	{
+		if (type == EVENT_STATE)		
+			return State;
+		return 0;
+	}
+
+	void DoPlaySound(GameObject* unit, uint32 sound)
+	{
+		WorldPacket data(4);
+		data.SetOpcode(SMSG_PLAY_SOUND);
+		data << uint32(sound);
+		unit->SendMessageToSet(&data,false);
+	}
+};
+
+/*#####
+# item_Defias_Gunpowder
+#####*/
+
+bool ItemUse_item_Defias_Gunpowder(Player *player, Item* _Item, SpellCastTargets const& targets)
+{
+	ScriptedInstance *pInstance = (player->GetInstanceData()) ? ((ScriptedInstance*)player->GetInstanceData()) : NULL;
+
+	if(!pInstance)
+	{
+		player->GetSession()->SendNotification("Instance script not initialized");
+		return true;
+	}
+	if (pInstance->GetData(EVENT_STATE)!=CANNON_NOT_USED)
+		return false;
+	if(targets.getGOTarget() && targets.getGOTarget()->GetTypeId()==TYPEID_GAMEOBJECT && targets.getGOTarget()->GetEntry() == GO_DEFIAS_CANNON)
+		pInstance->SetData(EVENT_STATE, CANNON_GUNPOWDER_USED);
+
+	player->DestroyItemCount(_Item->GetEntry(), 1, true);
+	return true;
+}
+
+InstanceData* GetInstanceData_instance_deadmines(Map* map)
+{
+	return new instance_deadmines(map);
+}
+
+void AddSC_instance_deadmines()
+{
+	Script *newscript;
+	newscript = new Script;
+	newscript->Name = "instance_deadmines";
+	newscript->GetInstanceData = &GetInstanceData_instance_deadmines;
+	newscript->RegisterSelf();
+	
+	newscript = new Script;
+	newscript->Name = "item_Defias_Gunpowder";
+	newscript->pItemUse = &ItemUse_item_Defias_Gunpowder;
+	newscript->RegisterSelf();
+
+}
Index: scripts/zone/deadmines/def_deadmines.h
===================================================================
--- scripts/zone/deadmines/def_deadmines.h	(revision 0)
+++ scripts/zone/deadmines/def_deadmines.h	(revision 0)
@@ -0,0 +1,14 @@
+#ifndef DEF_DEADMINES_H
+#define DEF_DEADMINES_H
+
+#include "sc_creature.h"
+#include "sc_instance.h"
+
+#define CANNON_NOT_USED 0
+#define CANNON_GUNPOWDER_USED 1
+#define CANNON_BLAST_INITIATED 2
+#define CANNON_PIRATES_ATTACK 3
+#define CANNON_EVENT_DONE 4
+
+#define EVENT_STATE 0
+#endif
Index: scripts/zone/hellfire_citadel/magtheridons_lair/boss_magtheridon.cpp
===================================================================
--- scripts/zone/hellfire_citadel/magtheridons_lair/boss_magtheridon.cpp	(revision 740)
+++ scripts/zone/hellfire_citadel/magtheridons_lair/boss_magtheridon.cpp	(working copy)
@@ -179,6 +179,8 @@
                 m_creature->setFaction(14);
                 m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
                 m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_UNKNOWN9);
+                m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_UNKNOWN2);
 
                 DoScriptText(SAY_FREED, m_creature);
 
Index: scripts/zone/hellfire_citadel/shattered_halls/boss_warchief_kargath_bladefist.cpp
===================================================================
--- scripts/zone/hellfire_citadel/shattered_halls/boss_warchief_kargath_bladefist.cpp	(revision 0)
+++ scripts/zone/hellfire_citadel/shattered_halls/boss_warchief_kargath_bladefist.cpp	(revision 0)
@@ -0,0 +1,114 @@
+#include "precompiled.h"
+
+#define SAY_AGGRO_1        "" 
+#define SAY_AGGRO_2        "I will carve the meat from your bones!" 
+#define SAY_AGGRO_3        "I am called Bladefist for a reason, as you will see..." 
+#define SAY_SLAY_1           "For the real horde!"
+#define SAY_SLAY_2           "I am an only warchief!"
+#define SAY_DEATH             "The true horde... will prevail..."
+
+#define SOUND_AGGRO_1         10323
+#define SOUND_AGGRO_2         10324
+#define SOUND_AGGRO_3         10325
+#define SOUND_SLAY_1             10326
+#define SOUND_SLAY_2             10327
+#define SOUND_DEATH              10328
+
+
+#define AB_BLADEDANCE      30739 
+
+struct MANGOS_DLL_DECL boss_warchief_kargath_bladefistAI : public ScriptedAI 
+{ 
+    boss_warchief_kargath_bladefistAI(Creature *c) : ScriptedAI(c) {Reset();} 
+
+    uint32 BladeDance_Timer; 
+    bool InCombat;    
+
+    void Reset() 
+    { 
+        BladeDance_Timer = 30000;  //GC      
+        InCombat=false;
+    } 
+
+    void KilledUnit(Unit* victim) 
+    { 
+        if (!victim) 
+            return; 
+        switch(rand()%2)
+        {
+        case 0:
+            DoYell(SAY_SLAY_1, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, SOUND_SLAY_1);
+            break;
+        case 1:
+            DoYell(SAY_SLAY_2, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, SOUND_SLAY_2);
+            break;
+        }
+        
+    } 
+
+    void JustDied(Unit *victim)
+    {
+        DoYell(SAY_DEATH, LANG_UNIVERSAL, NULL);
+        DoPlaySoundToSet(m_creature, SOUND_DEATH);
+    }
+
+    
+   void Aggro(Unit *who) 
+    {
+        switch(rand()%3)
+        {
+            case 0:
+                DoYell(SAY_AGGRO_1, LANG_UNIVERSAL, NULL);
+                DoPlaySoundToSet(m_creature, SOUND_AGGRO_1);
+            break;
+            case 1:
+                DoYell(SAY_AGGRO_2, LANG_UNIVERSAL, NULL);
+                DoPlaySoundToSet(m_creature, SOUND_AGGRO_2);
+            break;
+            case 2:
+                DoYell(SAY_AGGRO_3, LANG_UNIVERSAL, NULL);
+                DoPlaySoundToSet(m_creature, SOUND_AGGRO_3);
+            break;
+        }
+    } 
+    
+    void UpdateAI(const uint32 diff) 
+   { 
+        
+        if (!m_creature->SelectHostilTarget()) 
+         return; 
+
+        
+        if( m_creature->getVictim() && m_creature->isAlive()) 
+      { 
+
+      if(BladeDance_Timer<diff) 
+      { 
+         DoCast(m_creature->getVictim(),AB_BLADEDANCE); 
+         BladeDance_Timer=30000; 
+      }else BladeDance_Timer-=diff; 
+
+          
+      DoMeleeAttackIfReady(); 
+      } 
+   } 
+    
+}; 
+
+CreatureAI* GetAI_boss_warchief_kargath_bladefist(Creature *_Creature) 
+{ 
+    return new boss_warchief_kargath_bladefistAI (_Creature); 
+} 
+
+
+void AddSC_boss_warchief_kargath_bladefist() 
+{ 
+    Script *newscript; 
+    newscript = new Script; 
+    newscript->Name = "boss_warchief_kargath_bladefist"; 
+    newscript->GetAI = &GetAI_boss_warchief_kargath_bladefist; 
+    newscript->RegisterSelf(); 
+   return; 
+}
Index: scripts/zone/karazhan/boss_nightbane.cpp
===================================================================
--- scripts/zone/karazhan/boss_nightbane.cpp	(revision 740)
+++ scripts/zone/karazhan/boss_nightbane.cpp	(working copy)
@@ -22,12 +22,370 @@
 EndScriptData */
 
 #include "precompiled.h"
+#include "sc_creature.h"
+#include "WorldPacket.h"
+#include "def_karazhan.h"
 
-#define SPELL_BELLOWING_ROAR        39427
-#define SPELL_CHARRED_EARTH         30129                   //Also 30209 (Target Charred Earth) triggers this
-#define SPELL_DISTRACTING_ASH       30130
-#define SPELL_SMOLDERING_BREATH     30210
-#define SPELL_TAIL_SWEEP            25653
-#define SPELL_RAIN_OF_BONES         37098
-#define SPELL_SMOKING_BLAST         37057
-#define SPELL_FIREBALL_BARRAGE      30282
+// Ground Abilities
+#define SPELL_BELLOWING_ROAR        36922 // Typical dragon fear with a 2.5-second cast time, short duration, and 30-second cooldown. He casts this once every 45 seconds to 1 minute.
+#define SPELL_CLEAVE                30131 // Typical dragon cleave, frontal arc. Hits for approximately 6,000 on plate, 11,000 on cloth.
+#define SPELL_CHARRED_EARTH         30129 // Chars the ground, setting it flame, 2188 to 2812 Fire damage every 3 sec
+#define SPELL_DISTRACTING_ASH       30130 // Reduces the chance to hit with spells and abilities by 30%.
+#define SPELL_SMOLDERING_BREATH     30210 // Inflicts 3700 to 4300 Fire damage to enemies in a cone in front of the caster and ~1700 tvery 3 sec (5 ticks)
+#define SPELL_TAIL_SWEEP            25653 // Inflicts 450 damage on enemies in a cone behind the caster, knocking them back.
+
+// Fly Abilities
+#define SPELL_RAIN_OF_BONES         37098 // Bombards the target and nearby allies with bone fragments, summoning 5 skeletons in the process.
+#define SPELL_SMOKING_BLAST         37057 // Deals 1850 to 2150 physical damage to the target and additional fire damage over time.
+#define SPELL_FIREBALL_BARRAGE      30282 // Throws fireballs at any enemies farther than 40 yards away.
+
+#define SOUND_DEATH                 9454
+#define SOUND_PRE_AGGRO             9455
+#define SOUND_AGGRO                 9456
+#define SOUND_ATTACK                9451
+#define SOUND_WOUND                 9452
+#define SOUND_WOUND_CRIT            9453
+#define SOUND_LOOP                  9457
+
+// summon (Fly Phase)
+#define SUMMON                      17261
+
+// Move boss - new
+struct Locations
+{
+    float x, y, z;
+};
+
+static Locations Flight[]=
+{
+	{-11181, -1893, 104},
+    {-11163, -1903, 92}
+};
+
+struct MANGOS_DLL_DECL boss_nightbaneAI : public ScriptedAI
+{
+    boss_nightbaneAI(Creature *c) : ScriptedAI(c) {pInstance = ((ScriptedInstance*)c->GetInstanceData());Reset();}
+
+    ScriptedInstance* pInstance;
+
+    // Ground State
+    uint32 Bellowing_Timer;
+    uint32 Charred_Timer;
+    uint32 Distracting_Timer;
+    uint32 Smoldering_Timer;
+    uint32 Cleave_Timer;
+    uint32 Tail_Timer;
+
+    // Air State
+    uint32 Fly_Timer;
+    uint32 Rain_Timer;
+    uint32 Summon_Timer;
+    uint32 Smoking_Timer;
+    uint32 Fireball_Timer;
+
+    uint32 Phase;
+    uint32 Wait_Timer;
+    uint32 Summons;
+    Locations Summon_Loc;
+    Creature* Summoned;
+    bool Flying;
+    bool Wait;
+    bool InCombat;
+
+    void Reset()
+    {
+        // Ground State
+        Bellowing_Timer = 60000;
+        Charred_Timer = (20+rand()%20)*1000;
+        Distracting_Timer = (30+rand()%60)*1000;;
+        Smoldering_Timer = 35000;
+        Cleave_Timer = 5000;
+        Tail_Timer = 25000;
+        Summon_Loc.x = Flight[1].x;
+        Summon_Loc.y = Flight[1].y;
+        Summon_Loc.z = Flight[1].z;
+        Phase = 1;
+
+        Flying = false;
+        Wait = false;
+        InCombat = false;
+
+        if(pInstance)
+            pInstance->SetData(DATA_NETHERBANE_EVENT, 0);
+
+        m_creature->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_INTERRUPT_CAST, true);
+        m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, SPELL_AURA_MOD_TAUNT, true);
+    }
+
+    void JustDied(Unit* Killer)
+    {
+        DoPlaySoundToSet(m_creature, SOUND_DEATH);
+        if(pInstance)
+            pInstance->SetData(DATA_NETHERBANE_EVENT, 3); // Completed
+    }
+
+    void Aggro(Unit *who)
+    {
+        DoPlaySoundToSet(m_creature, SOUND_AGGRO);
+        if(pInstance)
+            pInstance->SetData(DATA_NETHERBANE_EVENT, 1);
+        InCombat = true;
+    }
+
+    void ResetThreat()
+    {
+        std::list<HostilReference*>& m_threatlist = m_creature->getThreatManager().getThreatList();
+        if(m_threatlist.empty()) return;
+        std::list<HostilReference*>::iterator i = m_threatlist.begin();
+        for(i = m_threatlist.begin(); i != m_threatlist.end(); ++i)
+        {
+            Unit* pUnit = NULL;
+            pUnit = Unit::GetUnit((*m_creature), (*i)->getUnitGuid());
+            if(pUnit)
+                m_creature->getThreatManager().modifyThreatPercent(pUnit, -100);
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostilTarget() || !m_creature->getVictim()) 
+            return;
+
+        if((m_creature->GetHealth()*100 / m_creature->GetMaxHealth() < 75) && Phase == 1)
+        {
+            m_creature->InterruptSpell(CURRENT_GENERIC_SPELL);
+            m_creature->HandleEmoteCommand(EMOTE_ONESHOT_LIFTOFF);
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveIdle();
+            m_creature->SetHover(true);
+            Wait = true;
+            Wait_Timer = CreatureMove(Flight[0].x, Flight[0].y, Flight[0].z) + 2;
+            Phase++;
+        }
+        if((m_creature->GetHealth()*100 / m_creature->GetMaxHealth() < 50) && Phase == 2)
+        {
+            m_creature->InterruptSpell(CURRENT_GENERIC_SPELL);
+            m_creature->HandleEmoteCommand(EMOTE_ONESHOT_LIFTOFF);
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveIdle();
+            m_creature->SetHover(true);
+            Wait = true;
+            Wait_Timer = CreatureMove(Flight[0].x, Flight[0].y, Flight[0].z) + 2;
+            Phase++;
+        }
+
+        if((m_creature->GetHealth()*100 / m_creature->GetMaxHealth() < 25) && Phase == 3)
+        {
+            m_creature->InterruptSpell(CURRENT_GENERIC_SPELL);
+            m_creature->HandleEmoteCommand(EMOTE_ONESHOT_LIFTOFF);
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveIdle();
+            m_creature->SetHover(true);
+            Wait = true;
+            Wait_Timer = CreatureMove(Flight[0].x, Flight[0].y, Flight[0].z) + 2;
+            Phase++;
+        }
+
+        if(Wait)
+        {
+            if (Wait_Timer < diff)
+            {
+                if (Flying)
+                {
+                    Bellowing_Timer = 60000;
+                    Distracting_Timer = (30+rand()%60)*1000;;
+                    Charred_Timer = (20+rand()%20)*1000;
+                    Cleave_Timer = 5000;
+                    Smoldering_Timer = 35000;
+                    Tail_Timer = 25000;
+                    Flying = false;
+                    m_creature->HandleEmoteCommand(EMOTE_ONESHOT_LAND);
+                    m_creature->SetHover(false);
+                    (*m_creature).GetMotionMaster()->Clear(false);
+                    (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+                    ResetThreat();
+                }
+                else
+                {
+                    Rain_Timer = 2000;
+                    Fireball_Timer = 5000;
+                    Smoking_Timer = 999999;
+                    Summon_Timer = 999999;
+                    Fly_Timer = 999999;
+                    Summons = 1;
+                    Flying = true;
+                }
+                Wait = false;
+            }
+            else Wait_Timer -= diff;
+        }
+        else
+        {
+            if (!Flying)
+            {
+                if (Bellowing_Timer < diff)
+                {
+                    DoCast(m_creature,SPELL_BELLOWING_ROAR);
+                    Bellowing_Timer = (45+rand()%15)*1000;
+                }else Bellowing_Timer -= diff;
+
+                if (Distracting_Timer < diff)
+                {
+                    Unit* target = NULL;
+                    target = SelectUnit(SELECT_TARGET_RANDOM,0);
+                    if (target)
+                        DoCast(target,SPELL_DISTRACTING_ASH);
+                    else
+                        DoCast(m_creature->getVictim(),SPELL_DISTRACTING_ASH);
+                    Distracting_Timer = (30+rand()%60)*1000;
+                }else Distracting_Timer -= diff;
+
+                if (Charred_Timer < diff)
+                {
+                    std::list<HostilReference*>& m_threatlist = m_creature->getThreatManager().getThreatList();
+                    std::list<Unit*> targets;
+                    std::list<HostilReference*>::iterator i = m_threatlist.begin();
+                    for(i = m_threatlist.begin(); i != m_threatlist.end(); ++i)
+                    {
+                        Unit* pUnit = NULL;
+                        pUnit = Unit::GetUnit((*m_creature), (*i)->getUnitGuid());
+                        if (pUnit && pUnit->isAlive() && !m_creature->IsWithinDistInMap(pUnit, 10) && (pUnit->GetTypeId() == TYPEID_PLAYER))
+                            targets.push_back(pUnit);
+                    }
+                    if(!targets.empty())
+                    {
+                        std::list<Unit*>::iterator itr = targets.begin();
+                        advance(itr,(rand()%(targets.size())));
+                        Creature* Target_Helper;
+                        Unit* target = *itr;
+                        Target_Helper = m_creature->SummonCreature(17260,target->GetPositionX(), target->GetPositionY(), target->GetPositionZ(),0,TEMPSUMMON_TIMED_DESPAWN,30000);
+                        Target_Helper->SetUInt32Value(UNIT_NPC_FLAGS,0);
+                        Target_Helper->setFaction(45);
+                        Target_Helper->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                        DoCast(Target_Helper,SPELL_CHARRED_EARTH);
+                        Charred_Timer = (20+rand()%20)*1000;
+                    }
+                }else Charred_Timer -= diff;
+
+                if (Cleave_Timer < diff)
+                {
+                    DoCast(m_creature->getVictim(),SPELL_CLEAVE);
+                    Cleave_Timer = 10000;
+                }else Cleave_Timer -= diff;
+
+                if(Smoldering_Timer <diff)
+                {
+                    DoCast(m_creature->getVictim(),SPELL_SMOLDERING_BREATH);
+                    Smoldering_Timer = 30000;
+                }else Smoldering_Timer -= diff;
+
+                if(Tail_Timer <diff)
+                {
+                    DoCast(m_creature,SPELL_TAIL_SWEEP);
+                    Tail_Timer = 30000;
+                }else Tail_Timer -= diff;
+
+                DoMeleeAttackIfReady();
+            }
+            else
+            {
+                if (Rain_Timer < diff)
+                {
+                    Unit* target = NULL;
+                    target = SelectUnit(SELECT_TARGET_RANDOM,0);
+                    if (!target) 
+                        target = m_creature->getVictim();
+                    DoCast(target,SPELL_RAIN_OF_BONES);
+                    Summon_Loc.x = target->GetPositionX();
+                    Summon_Loc.y = target->GetPositionY();
+                    Summon_Loc.z = target->GetPositionZ();
+                    Summon_Timer = 3000;
+                    Smoking_Timer = 12000;
+                    Rain_Timer = 999999;
+                }else Rain_Timer -= diff;
+
+                if ((Summon_Timer < diff) && (Summons <= 5))
+                {
+                    Unit* target = NULL;
+                    target = SelectUnit(SELECT_TARGET_RANDOM,0);
+                    Summoned = m_creature->SummonCreature(SUMMON,Summon_Loc.x - (rand()%10) + 5, Summon_Loc.y - (rand()%10) + 5, Summon_Loc.z,0,TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN,900000);
+                    if (target)
+                        ((CreatureAI*)Summoned->AI())->AttackStart(target);
+                    else
+                        ((CreatureAI*)Summoned->AI())->AttackStart(m_creature->getVictim());
+                    Summon_Timer = 5000;
+                    Summons++;
+                }else Summon_Timer -= diff;
+
+                if (Smoking_Timer < diff)
+                {
+                    Unit* target = NULL;
+                    target = SelectUnit(SELECT_TARGET_RANDOM,0);
+                    if (target)
+                        DoCast(target,SPELL_SMOKING_BLAST);
+                    else
+                        DoCast(m_creature->getVictim(),SPELL_SMOKING_BLAST);
+                    Fly_Timer = 16000;
+                    Smoking_Timer = 999999;
+                }else Smoking_Timer -= diff;
+
+                if (Fireball_Timer < diff)
+                {
+                    std::list<HostilReference*>& m_threatlist = m_creature->getThreatManager().getThreatList();
+                    std::list<HostilReference*>::iterator i = m_threatlist.begin();
+                    for(i = m_threatlist.begin(); i != m_threatlist.end(); ++i)
+                    {
+                        Unit* pUnit = NULL;
+                        pUnit = Unit::GetUnit((*m_creature), (*i)->getUnitGuid());
+                        if(pUnit && pUnit->isAlive() && !m_creature->IsWithinDistInMap(pUnit, 40))
+                            DoCast(pUnit,SPELL_FIREBALL_BARRAGE);
+                    }
+                    Fireball_Timer = 1000;
+                }else Fireball_Timer -= diff;
+
+                if (Fly_Timer < diff)
+                {
+                    m_creature->InterruptSpell(CURRENT_GENERIC_SPELL);
+                    Wait = true;
+                    Wait_Timer = CreatureMove(Flight[1].x, Flight[1].y, Flight[1].z) + 2;
+                }else Fly_Timer -= diff;
+            }
+        }
+    }
+
+    uint32 CreatureMove(float DestX, float DestY, float DestZ)
+    {
+        float FromX = m_creature->GetPositionX();
+        float FromY = m_creature->GetPositionY();
+        float FromZ = m_creature->GetPositionZ();
+
+        float dx = DestX - FromX;
+        float dy = DestY - FromY;
+        float dz = DestZ - FromZ;
+        double dist = ::sqrt((dx*dx) + (dy*dy) + (dz*dz));
+        double speed = m_creature->GetSpeed(MOVE_RUN);
+
+        if(speed<=0)
+            speed = 2.5f;
+        speed *= 0.001f;
+
+        uint32 TotalTime = static_cast<uint32>( dist/speed + 0.5 );
+        m_creature->SendMonsterMove(DestX,DestY,DestZ,0,true,TotalTime);
+        m_creature->Relocate(DestX,DestY,DestZ);
+        return TotalTime;
+    }
+};
+
+CreatureAI* GetAI_boss_nightbane(Creature *_Creature)
+{
+    return new boss_nightbaneAI (_Creature);
+}
+
+void AddSC_boss_nightbane()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_nightbane";
+    newscript->GetAI = &GetAI_boss_nightbane;
+    newscript->RegisterSelf();
+}
Index: scripts/zone/tempest_keep/the_eye/boss_void_reaver.cpp
===================================================================
--- scripts/zone/tempest_keep/the_eye/boss_void_reaver.cpp	(revision 740)
+++ scripts/zone/tempest_keep/the_eye/boss_void_reaver.cpp	(working copy)
@@ -121,7 +121,7 @@
                 target = Unit::GetUnit(*m_creature, (*itr)->getUnitGuid());
 
                 //15 yard radius minimum
-                if (target && target->GetDistance2d(m_creature) > 15)
+                if (target && target->GetDistance2d(m_creature) > 18)
                     target_list.push_back(target);
 
                 target = NULL;
@@ -131,12 +131,7 @@
                 target = *(target_list.begin()+rand()%target_list.size());
 
             if (target)
-            {
-                Unit* Spawn = NULL;
-                Spawn = m_creature->SummonCreature(CREATURE_ORB_TARGET, target->GetPositionX(), target->GetPositionY(), target->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 10000);
-                if (Spawn)
-                    m_creature->CastSpell(Spawn, SPELL_ARCANE_ORB_TRIGGER, true);
-            }
+                m_creature->CastSpell(target, SPELL_ARCANE_ORB_TRIGGER, true);
 
             ArcaneOrb_Timer = 3000;
         }else ArcaneOrb_Timer -= diff;
Index: VC80/80ScriptDev2.vcproj
===================================================================
--- VC80/80ScriptDev2.vcproj	(revision 740)
+++ VC80/80ScriptDev2.vcproj	(working copy)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8.00"
+	Version="8,00"
 	Name="ScriptDev2"
 	ProjectGUID="{4295C8A9-79B7-4354-8064-F05FB9CA0C96}"
 	RootNamespace="ScriptDev2"
@@ -409,6 +409,18 @@
 				Name="guard"
 				>
 				<File
+					RelativePath="..\scripts\guard\ancient_of_war.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\archbishop_benedictus.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\g_marcus_jonathan.cpp"
+					>
+				</File>
+				<File
 					RelativePath="..\scripts\guard\guard_ai.cpp"
 					>
 				</File>
@@ -420,6 +432,30 @@
 					RelativePath="..\scripts\guard\guards.cpp"
 					>
 				</File>
+				<File
+					RelativePath="..\scripts\guard\high_fire_mage.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\high_sorcerer_andromath.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\highlord_bolvar_fordragon.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\officers.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\overlord_saurfang.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\thrall.cpp"
+					>
+				</File>
 			</Filter>
 			<Filter
 				Name="honor"
@@ -465,6 +501,10 @@
 					>
 				</File>
 				<File
+					RelativePath="..\scripts\custom\teleguy.cpp"
+					>
+				</File>
+				<File
 					RelativePath="..\scripts\custom\test.cpp"
 					>
 				</File>
@@ -555,6 +595,10 @@
 						RelativePath="..\scripts\zone\deadmines\deadmines.cpp"
 						>
 					</File>
+					<File
+						RelativePath="..\scripts\zone\deadmines\def_deadmines.h"
+						>
+					</File>
 				</Filter>
 				<Filter
 					Name="Deadwind Pass"
@@ -1623,6 +1667,10 @@
 							>
 						</File>
 						<File
+							RelativePath="..\scripts\zone\hellfire_citadel\shattered_halls\boss_warchief_kargath_bladefist.cpp"
+							>
+						</File>
+						<File
 							RelativePath="..\scripts\zone\hellfire_citadel\shattered_halls\def_shattered_halls.h"
 							>
 						</File>
Index: VC90/90ScriptDev2.vcproj
===================================================================
--- VC90/90ScriptDev2.vcproj	(revision 740)
+++ VC90/90ScriptDev2.vcproj	(working copy)
@@ -408,6 +408,18 @@
 				Name="guard"
 				>
 				<File
+					RelativePath="..\scripts\guard\ancient_of_war.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\archbishop_benedictus.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\g_marcus_jonathan.cpp"
+					>
+				</File>
+				<File
 					RelativePath="..\scripts\guard\guard_ai.cpp"
 					>
 				</File>
@@ -419,6 +431,30 @@
 					RelativePath="..\scripts\guard\guards.cpp"
 					>
 				</File>
+				<File
+					RelativePath="..\scripts\guard\high_fire_mage.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\high_sorcerer_andromath.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\highlord_bolvar_fordragon.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\officers.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\overlord_saurfang.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\thrall.cpp"
+					>
+				</File>
 			</Filter>
 			<Filter
 				Name="honor"
@@ -464,6 +500,10 @@
 					>
 				</File>
 				<File
+					RelativePath="..\scripts\custom\teleguy.cpp"
+					>
+				</File>
+				<File
 					RelativePath="..\scripts\custom\test.cpp"
 					>
 				</File>
@@ -554,6 +594,10 @@
 						RelativePath="..\scripts\zone\deadmines\deadmines.cpp"
 						>
 					</File>
+					<File
+						RelativePath="..\scripts\zone\deadmines\def_deadmines.h"
+						>
+					</File>
 				</Filter>
 				<Filter
 					Name="Deadwind Pass"
@@ -1622,6 +1666,10 @@
 							>
 						</File>
 						<File
+							RelativePath="..\scripts\zone\hellfire_citadel\shattered_halls\boss_warchief_kargath_bladefist.cpp"
+							>
+						</File>
+						<File
 							RelativePath="..\scripts\zone\hellfire_citadel\shattered_halls\def_shattered_halls.h"
 							>
 						</File>
