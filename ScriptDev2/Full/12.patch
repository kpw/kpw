Index: Makefile.am
===================================================================
--- Makefile.am	(revision 715)
+++ Makefile.am	(working copy)
@@ -51,10 +51,20 @@
 scripts/custom/custom_example.cpp \
 scripts/custom/custom_gossip_codebox.cpp \
 scripts/custom/test.cpp \
+scripts/custom/teleguy.cpp \
 scripts/go/go_scripts.cpp \
+scripts/guard/ancient_of_war.cpp \
+scripts/guard/g_marcus_jonathan.cpp \
 scripts/guard/guard_ai.cpp \
 scripts/guard/guard_ai.h \
 scripts/guard/guards.cpp \
+scripts/guard/officers.cpp \
+scripts/guard/overlord_saurfang.cpp \
+scripts/guard/archbishop_benedictus.cpp \
+scripts/guard/high_fire_mage.cpp \
+scripts/guard/high_sorcerer_andromath.cpp \
+scripts/guard/highlord_bolvar_fordragon.cpp \
+scripts/guard/thrall.cpp \
 scripts/item/item_scripts.cpp \
 scripts/item/item_test.cpp \
 scripts/npc/npc_escortAI.cpp \
@@ -166,6 +176,7 @@
 scripts/zone/coilfang_resevoir/underbog/boss_hungarfen.cpp \
 scripts/zone/darkshore/darkshore.cpp \
 scripts/zone/deadmines/deadmines.cpp \
+scripts/zone/deadmines/def_deadmines.h \
 scripts/zone/dun_morogh/dun_morogh.cpp \
 scripts/zone/dustwallow_marsh/dustwallow_marsh.cpp \
 scripts/zone/eastern_plaguelands/eastern_plaguelands.cpp \
@@ -188,6 +199,7 @@
 scripts/zone/hellfire_citadel/magtheridons_lair/instance_magtheridons_lair.cpp \
 scripts/zone/hellfire_citadel/shattered_halls/boss_nethekurse.cpp \
 scripts/zone/hellfire_citadel/shattered_halls/boss_warbringer_omrogg.cpp \
+scripts/zone/hellfire_citadel/shattered_halls/boss_warchief_kargath_bladefist.cpp \
 scripts/zone/hellfire_citadel/shattered_halls/def_shattered_halls.h \
 scripts/zone/hellfire_citadel/shattered_halls/instance_shattered_halls.cpp \
 scripts/zone/hellfire_peninsula/boss_doomlord_kazzak.cpp \
@@ -363,8 +375,12 @@
 scripts/zone/western_plaguelands/western_plaguelands.cpp \
 scripts/zone/winterspring/winterspring.cpp \
 scripts/zone/zangarmarsh/zangarmarsh.cpp \
+scripts/zone/zulaman/boss_akilzon.cpp \
 scripts/zone/zulaman/boss_janalai.cpp \
+scripts/zone/zulaman/boss_hexlord.cpp \
+scripts/zone/zulaman/boss_halazzi.cpp \
 scripts/zone/zulaman/boss_nalorakk.cpp \
+scripts/zone/zulaman/boss_zuljin.cpp \
 scripts/zone/zulaman/def_zulaman.h \
 scripts/zone/zulaman/instance_zulaman.cpp \
 scripts/zone/zulaman/zulaman.cpp \
Index: ScriptMgr.cpp
===================================================================
--- ScriptMgr.cpp	(revision 715)
+++ ScriptMgr.cpp	(working copy)
@@ -77,12 +77,22 @@
 extern void AddSC_custom_example();
 extern void AddSC_custom_gossip_codebox();
 extern void AddSC_test();
+extern void AddSC_teleguy();
 
 // -- GO --
 extern void AddSC_go_scripts();
 
 // -- Guard --
 extern void AddSC_guards();
+extern void AddSC_city_officer();
+extern void AddSC_ancient_of_war();
+extern void AddSC_overlord_saurfang();
+extern void AddSC_g_marcus_jonathan();
+extern void AddSC_archbishop_benedictus();
+extern void AddSC_high_fire_mage();
+extern void AddSC_high_sorcerer_andromath();
+extern void AddSC_highlord_bolvar_fordragon();
+extern void AddSC_thrall();
 
 // -- Honor --
 
@@ -246,6 +256,8 @@
 //Darkshore
 //Darnassus
 //Deadmines
+extern void AddSC_instance_deadmines();
+
 //Deadwind pass
 //Desolace
 //Dire Maul
@@ -295,6 +307,7 @@
 //--Shattered Halls
 extern void AddSC_boss_grand_warlock_nethekurse();
 extern void AddSC_boss_warbringer_omrogg();
+extern void AddSC_boss_warchief_kargath_bladefist();
 extern void AddSC_instance_shattered_halls();
 
 //--Ramparts
@@ -320,6 +333,7 @@
 extern void AddSC_boss_shade_of_aran();
 extern void AddSC_boss_malchezaar();
 extern void AddSC_boss_terestian_illhoof();
+extern void AddSC_boss_nightbane();
 extern void AddSC_netherspite_infernal();
 extern void AddSC_boss_moroes();
 extern void AddSC_bosses_opera();
@@ -561,9 +575,14 @@
 extern void AddSC_boss_renataki();
 extern void AddSC_boss_wushoolay();
 extern void AddSC_instance_zulgurub();
+
 //Zul'Aman
+extern void AddSC_boss_akilzon();
 extern void AddSC_boss_janalai();
+extern void AddSC_boss_halazzi();
+extern void AddSC_boss_hex_lord_malacrass();
 extern void AddSC_boss_nalorakk();
+extern void AddSC_boss_zuljin();
 extern void AddSC_instance_zulaman();
 extern void AddSC_zulaman();
 
@@ -1255,12 +1274,22 @@
     AddSC_custom_example();
     AddSC_custom_gossip_codebox();
     AddSC_test();
+	AddSC_teleguy();
 
     // -- GO --
     AddSC_go_scripts();
 
     // -- Guard --
     AddSC_guards();
+    AddSC_city_officer();
+    AddSC_ancient_of_war();
+    AddSC_overlord_saurfang();
+    AddSC_g_marcus_jonathan();
+    AddSC_archbishop_benedictus();
+    AddSC_high_fire_mage();
+    AddSC_high_sorcerer_andromath();
+    AddSC_highlord_bolvar_fordragon();
+    AddSC_thrall();
 
     // -- Honor --
 
@@ -1424,6 +1453,8 @@
     //Darkshore
     //Darnassus
     //Deadmines
+    AddSC_instance_deadmines();
+
     //Deadwind pass
     //Desolace
     //Dire Maul
@@ -1473,6 +1504,7 @@
     //--Shattered Halls
     AddSC_boss_grand_warlock_nethekurse();
     AddSC_boss_warbringer_omrogg();
+    AddSC_boss_warchief_kargath_bladefist();
     AddSC_instance_shattered_halls();
 
     //--Ramparts
@@ -1498,6 +1530,7 @@
     AddSC_boss_shade_of_aran();
     AddSC_boss_malchezaar();
     AddSC_boss_terestian_illhoof();
+    AddSC_boss_nightbane();
     AddSC_netherspite_infernal();
     AddSC_boss_moroes();
     AddSC_bosses_opera();
@@ -1741,8 +1774,12 @@
     AddSC_instance_zulgurub();
 
     //Zul'Aman
+    AddSC_boss_akilzon();
     AddSC_boss_janalai();
+    AddSC_boss_halazzi();
+    AddSC_boss_hex_lord_malacrass();
     AddSC_boss_nalorakk();
+    AddSC_boss_zuljin();
     AddSC_instance_zulaman();
     AddSC_zulaman();
 
Index: scripts/custom/teleguy.cpp
===================================================================
--- scripts/custom/teleguy.cpp	(revision 0)
+++ scripts/custom/teleguy.cpp	(revision 0)
@@ -0,0 +1,702 @@
+#include "precompiled.h"
+long long int money;
+int costo;
+
+bool GossipHello_teleguy(Player *player, Creature *_Creature)
+{
+
+    if ( player->GetTeam() == ALLIANCE ) {
+player->ADD_GOSSIP_ITEM( 5, "Darnassus. 5 Silver"		, GOSSIP_SENDER_MAIN, 1203);
+player->ADD_GOSSIP_ITEM( 5, "Exodar. 5 Silver"			, GOSSIP_SENDER_MAIN, 1216);
+player->ADD_GOSSIP_ITEM( 5, "Stormwind. 5 Silver"		, GOSSIP_SENDER_MAIN, 1206);
+player->ADD_GOSSIP_ITEM( 5, "Ironforge. 5 Silver"		, GOSSIP_SENDER_MAIN, 1224);
+player->ADD_GOSSIP_ITEM( 5, "Gnomeregan. 5 Silver"		, GOSSIP_SENDER_MAIN, 1222);
+player->ADD_GOSSIP_ITEM( 5, "Shattrath City. 5 Silver"            , GOSSIP_SENDER_MAIN, 1287);
+player->ADD_GOSSIP_ITEM( 5, "Isle Of Quel'Danas. 5 Silver"        , GOSSIP_SENDER_MAIN, 1288);
+player->ADD_GOSSIP_ITEM( 7, "[Instances] ->"			, GOSSIP_SENDER_MAIN, 5550);
+
+	}  else {
+
+
+player->ADD_GOSSIP_ITEM( 5, "Orgrimmar. 5 Silver"		, GOSSIP_SENDER_MAIN, 1215);
+player->ADD_GOSSIP_ITEM( 5, "Silvermoon. 5 Silver"		, GOSSIP_SENDER_MAIN, 1217);
+player->ADD_GOSSIP_ITEM( 5, "Undercity. 5 Silver"		, GOSSIP_SENDER_MAIN, 1213);
+player->ADD_GOSSIP_ITEM( 5, "Thunder Bluff. 5 Silver"	, GOSSIP_SENDER_MAIN, 1225);
+player->ADD_GOSSIP_ITEM( 5, "Gnomeregan. 5 Silver"		, GOSSIP_SENDER_MAIN, 1222);
+player->ADD_GOSSIP_ITEM( 5, "Shattrath City. 5 Silver"            , GOSSIP_SENDER_MAIN, 1287);
+player->ADD_GOSSIP_ITEM( 5, "Isle Of Quel'Danas. 5 Silver"        , GOSSIP_SENDER_MAIN, 1288);
+player->ADD_GOSSIP_ITEM( 7, "[Instances] ->"			, GOSSIP_SENDER_MAIN, 5550);
+	}
+	
+	player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+
+return true;
+
+}
+
+
+void SendDefaultMenu_teleguy(Player *player, Creature *_Creature, uint32 action )
+{
+
+if(!player->getAttackers().empty())
+
+	{
+	player->CLOSE_GOSSIP_MENU();
+    _Creature->Say("You are in combat!", LANG_UNIVERSAL, NULL);
+return;
+    }
+
+if( player->getLevel() < 8  ) 
+
+    {
+	player->CLOSE_GOSSIP_MENU();
+    _Creature->Say("You must be lvl 8+", LANG_UNIVERSAL, NULL);
+return;
+    }
+
+money = player-> GetMoney();
+costo = 500;
+
+if (money < costo ) 
+	{
+	player->CLOSE_GOSSIP_MENU();
+	_Creature->Say("You haven't enough money", LANG_UNIVERSAL, NULL);
+return;
+	}
+
+switch(action)
+
+{
+
+case 5550: //Instances
+player->ADD_GOSSIP_ITEM( 5, "Ragefire Chasm. 10 Silver"			 , GOSSIP_SENDER_MAIN, 1248);
+player->ADD_GOSSIP_ITEM( 5, "The Wailing Caverns. 10 Silver"     , GOSSIP_SENDER_MAIN, 1249);
+player->ADD_GOSSIP_ITEM( 5, "The Stockade. 10 Silver"			 , GOSSIP_SENDER_MAIN, 1253);
+player->ADD_GOSSIP_ITEM( 5, "Deadmines.	10 Silver"               , GOSSIP_SENDER_MAIN, 1250);
+player->ADD_GOSSIP_ITEM( 5, "Shadowfang Keep. 10 Silver"         , GOSSIP_SENDER_MAIN, 1251);
+player->ADD_GOSSIP_ITEM( 5, "Blackfathom Deeps. 10 Silver"       , GOSSIP_SENDER_MAIN, 1252);
+player->ADD_GOSSIP_ITEM( 5, "Razorfen Kraul. 20 Silver"          , GOSSIP_SENDER_MAIN, 1254);
+player->ADD_GOSSIP_ITEM( 5, "Razorfen Downs. 20 Silver"          , GOSSIP_SENDER_MAIN, 1256);
+player->ADD_GOSSIP_ITEM( 5, "Scarlet Monastery. 20 Silver"       , GOSSIP_SENDER_MAIN, 1257);
+player->ADD_GOSSIP_ITEM( 7, "[More] ->"							 , GOSSIP_SENDER_MAIN, 5551);
+player->ADD_GOSSIP_ITEM( 7, "<- [Main Menu]"					 , GOSSIP_SENDER_MAIN, 5552);
+
+	
+player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+
+break;
+
+case 5551: //More Instances
+player->ADD_GOSSIP_ITEM( 5, "Uldaman. 30 Silver"                   , GOSSIP_SENDER_MAIN, 1258);
+player->ADD_GOSSIP_ITEM( 5, "Zul'Farrak. 30 Silver"                , GOSSIP_SENDER_MAIN, 1259);
+player->ADD_GOSSIP_ITEM( 5, "Maraudon. 40 Silver"                  , GOSSIP_SENDER_MAIN, 1260);
+player->ADD_GOSSIP_ITEM( 5, "Maraudon. 40 Silver"                  , GOSSIP_SENDER_MAIN, 1260);
+player->ADD_GOSSIP_ITEM( 5, "The Sunken Temple. 40 Silver"		   , GOSSIP_SENDER_MAIN, 1261);
+player->ADD_GOSSIP_ITEM( 5, "Blackrock Depths. 40 Silver"          , GOSSIP_SENDER_MAIN, 1262);
+player->ADD_GOSSIP_ITEM( 5, "Dire Maul. 50 Silver"                 , GOSSIP_SENDER_MAIN, 1263);
+player->ADD_GOSSIP_ITEM( 5, "Blackrock Spire. 50 Silver"           , GOSSIP_SENDER_MAIN, 1264);
+player->ADD_GOSSIP_ITEM( 5, "Stratholme. 50 Silver"                , GOSSIP_SENDER_MAIN, 1265);
+player->ADD_GOSSIP_ITEM( 5, "Scholomance. 50 Silver"               , GOSSIP_SENDER_MAIN, 1266);
+player->ADD_GOSSIP_ITEM( 7, "[More] ->"							   , GOSSIP_SENDER_MAIN, 5553);
+player->ADD_GOSSIP_ITEM( 7, "<- [Back]"							   , GOSSIP_SENDER_MAIN, 5550);
+player->ADD_GOSSIP_ITEM( 7, "<- [Main Menu]"					   , GOSSIP_SENDER_MAIN, 5552);
+	
+player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+
+break;
+
+case 5553: //Instances 60-70
+player->ADD_GOSSIP_ITEM( 5, "Karazhan. 1 Gold"                              , GOSSIP_SENDER_MAIN, 4007);
+player->ADD_GOSSIP_ITEM( 5, "Gruul's Lair. 1 Gold"                          , GOSSIP_SENDER_MAIN, 4008);
+player->ADD_GOSSIP_ITEM( 5, "Hellfire Citadel. 1 Gold"                      , GOSSIP_SENDER_MAIN, 4009);
+player->ADD_GOSSIP_ITEM( 5, "Coilfang Reservoir. 1 Gold"                    , GOSSIP_SENDER_MAIN, 4010);
+player->ADD_GOSSIP_ITEM( 5, "Tempest Keep. 1 Gold"                          , GOSSIP_SENDER_MAIN, 4011);
+player->ADD_GOSSIP_ITEM( 5, "Caverns of Time. 1 Gold"                       , GOSSIP_SENDER_MAIN, 4012);
+player->ADD_GOSSIP_ITEM( 5, "Zul'Aman. 1 Gold"                              , GOSSIP_SENDER_MAIN, 4016);
+player->ADD_GOSSIP_ITEM( 5, "Black Temple. 1 Gold"                          , GOSSIP_SENDER_MAIN, 4013);
+player->ADD_GOSSIP_ITEM( 5, "Magister's Terrace. 2 Gold"                    , GOSSIP_SENDER_MAIN, 4017);
+player->ADD_GOSSIP_ITEM( 5, "Sunwell Plateau. 2 Gold"                       , GOSSIP_SENDER_MAIN, 4018);
+player->ADD_GOSSIP_ITEM( 7, "<- [Back]"							   , GOSSIP_SENDER_MAIN, 5550);
+player->ADD_GOSSIP_ITEM( 7, "<- [Main Menu]"					   , GOSSIP_SENDER_MAIN, 5552);
+
+
+player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+
+break;
+
+
+case 5552: //Back To Main Menu
+    if ( player->GetTeam() == ALLIANCE ) {
+player->ADD_GOSSIP_ITEM( 5, "Darnassus. 5 Silver"			, GOSSIP_SENDER_MAIN, 1203);
+player->ADD_GOSSIP_ITEM( 5, "Exodar. 5 Silver"				, GOSSIP_SENDER_MAIN, 1216);
+player->ADD_GOSSIP_ITEM( 5, "Stormwind. 5 Silver"			, GOSSIP_SENDER_MAIN, 1206);
+player->ADD_GOSSIP_ITEM( 5, "Ironforge. 5 Silver"			, GOSSIP_SENDER_MAIN, 1224);
+player->ADD_GOSSIP_ITEM( 5, "Gnomeregan. 5 Silver"			, GOSSIP_SENDER_MAIN, 1222);
+player->ADD_GOSSIP_ITEM( 5, "Shattrath City. 5 Silver"            , GOSSIP_SENDER_MAIN, 1287);
+player->ADD_GOSSIP_ITEM( 5, "Isle Of Quel'Danas. 5 Silver"        , GOSSIP_SENDER_MAIN, 1288);
+player->ADD_GOSSIP_ITEM( 7, "[Instances] ->"				, GOSSIP_SENDER_MAIN, 5550);
+
+	}  else {
+
+
+player->ADD_GOSSIP_ITEM( 5, "Orgrimmar. 5 Silver"			, GOSSIP_SENDER_MAIN, 1215);
+player->ADD_GOSSIP_ITEM( 5, "Silvermoon. 5 Silver"			, GOSSIP_SENDER_MAIN, 1217);
+player->ADD_GOSSIP_ITEM( 5, "Undercity. 5 Silver"			, GOSSIP_SENDER_MAIN, 1213);
+player->ADD_GOSSIP_ITEM( 5, "Thunder Bluff. 5 Silver"		, GOSSIP_SENDER_MAIN, 1225);
+player->ADD_GOSSIP_ITEM( 5, "Gnomeregan. 5 Silver"			, GOSSIP_SENDER_MAIN, 1222);
+player->ADD_GOSSIP_ITEM( 5, "Shattrath City. 5 Silver"            , GOSSIP_SENDER_MAIN, 1287);
+player->ADD_GOSSIP_ITEM( 5, "Isle Of Quel'Danas. 5 Silver"        , GOSSIP_SENDER_MAIN, 1288);
+player->ADD_GOSSIP_ITEM( 7, "[Instances] ->"				, GOSSIP_SENDER_MAIN, 5550);
+	}
+
+player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+
+break;
+
+case 1203: // Teleport to Darnassus
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(1, 9947.52f, 2482.73f, 1316.21f, 0.0f);
+player->ModifyMoney(-1*costo);
+break;
+
+// Teleport to Stormwind
+case 1206:
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(0, -8960.14f, 516.266f, 96.3568f, 0.0f);
+player->ModifyMoney(-1*costo);
+break;
+
+// Teleport to Undercity
+case 1213:
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(0, 1819.71f, 238.79f, 60.5321f, 0.0f);
+player->ModifyMoney(-1*costo);
+
+break;
+
+// Teleport to Orgrimmar
+case 1215:
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(1, 1552.5f, -4420.66f, 8.94802f, 0.0f);
+player->ModifyMoney(-1*costo);
+break;
+
+// Teleport to Exodar
+case 1216:
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(530, -4073.03f, -12020.4f, -1.47f, 0.0f);
+player->ModifyMoney(-1*costo);
+break;
+
+// Teleport to Silvermoon
+case 1217:
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(530, 9338.74f, -7277.27f, 13.7895f, 0.0f);
+player->ModifyMoney(-1*costo);
+
+break;
+
+case 1222://teleport player to Gnomeregan
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(0, -5163.43f,660.40f,348.28f,4.65f);
+player->ModifyMoney(-1*costo);
+
+break;
+
+// Teleport to Ironforge
+case 1224:
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(0, -4924.07f, -951.95f, 501.55f, 5.40f);
+player->ModifyMoney(-1*costo);
+
+break;
+
+// Teleport to Thunder Bluff
+case 1225:
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(1, -1280.19f,127.21f,131.35f,5.16f); 
+player->ModifyMoney(-1*costo);
+
+break;
+
+case 1248://teleport player to Ragefire Chasm
+		
+if( player->getLevel() >= 8)
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(1, 1800.53f,-4394.68f,-17.93f,5.49f);
+		player->ModifyMoney(-2*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 8!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1249://teleport player to the Wailing Caverns
+		
+if (player->getLevel() >= 10)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(1, -722.53f,-2226.30f,16.94f,2.71f);
+		player->ModifyMoney(-2*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 10!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1250://teleport player to the Deadmines
+		
+if (player->getLevel() >= 10)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, -11212.04f,1658.58f,25.67f,1.45f);
+		player->ModifyMoney(-2*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 10!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1251://teleport player to Shadowfang Keep
+		
+	if (player->getLevel() >= 15)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, -254.47f,1524.68f,76.89f,1.56f);
+		player->ModifyMoney(-2*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 15!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1252://teleport player to Blackfathom Deeps
+		
+	if (player->getLevel() >= 15)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(1, 4254.58f,664.74f,-29.04f,1.97f);
+		player->ModifyMoney(-2*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 15!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1253://teleport player to the Stockade
+		
+	if (player->getLevel() >= 20)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, -8769.76f,813.08f,97.63f,2.26f);
+		player->ModifyMoney(-2*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 20!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1254://teleport player to Razorfen Kraul
+		
+	if (player->getLevel() >= 24)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(1, -4484.04f,-1739.40f,86.47f,1.23f);
+		player->ModifyMoney(-4*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 24!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1255://teleport player to Gnomeregan
+		
+	if (player->getLevel() >= 20)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, -5162.62f,667.81f,248.05f,1.48f);
+		player->ModifyMoney(-4*costo);
+		
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 20!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1256://teleport player to Razorfen Downs
+		
+	if (player->getLevel() >= 25)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(1, -4645.08f,-2470.85f,85.53f,4.39f);
+		player->ModifyMoney(-4*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 25!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1257://teleport player to the Scarlet Monastery
+		
+	if (player->getLevel() >= 25)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, 2843.89f,-693.74f,139.32f,5.11f);
+		player->ModifyMoney(-4*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 25!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1258://teleport player to Uldaman
+		
+	if (player->getLevel() >= 35)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, -6119.70f,-2957.30f,204.11f,0.03f);
+		player->ModifyMoney(-6*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 35!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1259://teleport player to Zul'Farrak
+		
+	if (player->getLevel() >= 35)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(1, -6839.39f,-2911.03f,8.87f,0.41f);
+		player->ModifyMoney(-6*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 35!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+
+case 1260://teleport player to Maraudon
+		
+	if (player->getLevel() >= 40)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(1, -1433.33f,2955.34f,96.21f,4.82f);
+		player->ModifyMoney(-8*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 40!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1261://teleport player to the Sunken Temple
+		
+	if (player->getLevel() >= 45)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, -10346.92f,-3851.90f,-43.41f,6.09f);
+		player->ModifyMoney(-8*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 45!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1262://teleport player to Blackrock Depths
+		
+	if (player->getLevel() >= 45)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, -7301.03f,-913.19f,165.37f,0.08f);
+		player->ModifyMoney(-8*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 45!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+	
+case 1263://teleport player to Dire Maul
+		
+	if (player->getLevel() >= 50)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(1, -3982.47f,1127.79f,161.02f,0.05f);
+		player->ModifyMoney(-10*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 50!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1264://teleport player to Blackrock Spire
+		
+	if (player->getLevel() >= 50)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, -7535.43f,-1212.04f,285.45f,5.29f);
+		player->ModifyMoney(-10*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 50!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1265://teleport player to Stratholme
+		
+	if (player->getLevel() >= 50)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, 3263.54f,-3379.46f,143.59f,0.00f);
+		player->ModifyMoney(-10*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 50!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1266://teleport player to Scholomance
+		
+	if (player->getLevel() >= 50)
+		
+	{
+		player->CLOSE_GOSSIP_MENU();
+		player->TeleportTo(0, 1219.01f,-2604.66f,85.61f,0.50f);
+		player->ModifyMoney(-10*costo);
+	} else {
+		player->CLOSE_GOSSIP_MENU();
+		_Creature->Say("You must be at least level 50!", LANG_UNIVERSAL, NULL);
+	}
+	
+break;
+
+case 1287:// Shattrath City
+
+if( player->getLevel() >= 58)
+    {
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -1850.209961f, 5435.821777f, -10.961435f, 3.403913f);
+        player->ModifyMoney(-1*costo);
+ } else {
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Say("You must be at least level 58!", LANG_UNIVERSAL, NULL);
+    }
+    
+break;
+
+case 1288://teleport player to Isle Of Quel'Danas
+
+    if (player->getLevel() >= 65)
+        
+    {
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 12947.4f,-6893.31f,5.68398f,3.09154f);
+        player->ModifyMoney(-1*costo);
+	} else {
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Say("You must be at least level 65!", LANG_UNIVERSAL, NULL);
+    }
+    
+break;
+
+case 4007:// Karazhan
+
+    if (player->getLevel() >= 70)
+        
+    {
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -11118.8f, -2010.84f, 47.0807f, 0.0f);
+        player->ModifyMoney(-20*costo);
+	} else {
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Say("You must be at least level 70!", LANG_UNIVERSAL, NULL);
+    }
+    
+break;
+
+case 4008:// Gruul's Lair
+
+    if (player->getLevel() >= 65)
+        
+    {
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 3539.007568f, 5082.357910f, 1.691071f, 0.0f);
+        player->ModifyMoney(-20*costo);
+	} else {
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Say("You must be at least level 65!", LANG_UNIVERSAL, NULL);
+    }
+    
+break;
+
+case 4009:// Hellfire Citadel
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(530, -305.816223f, 3056.401611f, -2.473183f, 2.01f);
+player->ModifyMoney(-20*costo);
+break;
+
+case 4010:// Coilfang Reservoir
+player->CLOSE_GOSSIP_MENU();
+player->TeleportTo(530, 517.288025f, 6976.279785f, 32.007198f, 0.0f);
+player->ModifyMoney(-20*costo);
+break;
+
+case 4011:// Tempest Keep
+
+    if (player->getLevel() >= 70)
+        
+    {
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 3089.579346f, 1399.046509f, 187.653458f, 4.794070f);
+        player->ModifyMoney(-20*costo);
+	} else {
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Say("You must be at least level 70!", LANG_UNIVERSAL, NULL);
+    }
+    
+break;
+
+case 4012:// Caverns of Time
+
+    if (player->getLevel() >= 66)
+        
+    {
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -8173.66f, -4746.36f, 33.8423f, 4.93989f);
+        player->ModifyMoney(-20*costo);
+	} else {
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Say("You must be at least level 66!", LANG_UNIVERSAL, NULL);
+    }
+    
+break;
+
+case 4016:// Zul'Aman
+
+    if (player->getLevel() >= 70)
+        
+    {
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 6846.95f, -7954.5f, 170.028f, 4.61501f);
+        player->ModifyMoney(-20*costo);
+	} else {
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Say("You must be at least level 70!", LANG_UNIVERSAL, NULL);
+    }
+    
+break;
+
+case 4013:// Black Temple
+
+    if (player->getLevel() >= 70)
+        
+    {
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -3610.719482f, 324.987579f, 37.400028f, 3.282981f);
+        player->ModifyMoney(-20*costo);
+	} else {
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Say("You must be at least level 70!", LANG_UNIVERSAL, NULL);
+    }
+    
+break;
+
+case 4017:// magistrate
+
+    if (player->getLevel() >= 70)
+        
+    {
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 12884.6f, -7317.69f, 65.5023f, 4.799f);
+        player->ModifyMoney(-40*costo);
+	} else {
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Say("You must be at least level 70!", LANG_UNIVERSAL, NULL);
+    }
+    
+break;
+
+case 4018:// sunwell
+
+    if (player->getLevel() >= 70)
+        
+    {
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 12574.1f, -6774.81f, 15.0904f, 3.13788f);
+        player->ModifyMoney(-40*costo);
+	} else {
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Say("You must be at least level 70!", LANG_UNIVERSAL, NULL);
+    }
+    
+break;
+
+}
+
+
+}
+
+bool GossipSelect_teleguy(Player *player, Creature *_Creature, uint32
+
+sender, uint32 action )
+
+{
+// Main menu
+if (sender == GOSSIP_SENDER_MAIN)
+SendDefaultMenu_teleguy(player, _Creature, action   );
+
+return true;
+
+}
+void AddSC_teleguy()
+{
+    Script *newscript;
+ 
+newscript = new Script;
+newscript->Name="teleguy";
+newscript->pGossipHello = &GossipHello_teleguy;
+newscript->pGossipSelect = &GossipSelect_teleguy;
+newscript->pItemHello = NULL;
+newscript->pGOHello = NULL;
+newscript->pAreaTrigger = NULL;
+newscript->pItemQuestAccept = NULL;
+newscript->pGOQuestAccept = NULL;
+newscript->pGOChooseReward = NULL;
+
+m_scripts[nrscripts++] = newscript;
+}
Index: scripts/guard/ancient_of_war.cpp
===================================================================
--- scripts/guard/ancient_of_war.cpp	(revision 0)
+++ scripts/guard/ancient_of_war.cpp	(revision 0)
@@ -0,0 +1,234 @@
+/* 
+###############################
+ Ancient of War, of Lore v 2.0
+ (Darnassus protectors)
+###############################
+
+by Myav 
+*/
+
+#include "precompiled.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL ancient_of_warAI : public ScriptedAI
+{
+    ancient_of_warAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+
+    if(m_creature->GetEntry() == 3469)
+       m_creature->SetMaxHealth(167000);
+     else m_creature->SetMaxHealth(250000);
+    if(m_creature->GetEntry() == 3469)
+       m_creature->SetHealth(167000);
+     else m_creature->SetMaxHealth(250000);
+    m_creature->SetArmor(19200);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,1620);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,270);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DAZE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_KNOCKOUT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+3500,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+}
+
+void wood()
+{
+       float x;
+       float y;
+       float z;
+       float X;
+       float Y;
+       float Z;
+       m_creature->GetPosition(x,y,z);
+       m_creature->getVictim()->GetPosition(X,Y,Z);
+       if(x > X)
+           X = x + 20 + 10 - rand()%20;
+       else
+           X = x - 20 + 10 - rand()%20;
+       if(y > Y)
+           Y = y + 20 + 10 - rand()%20;
+       else
+           Y = y - 20 + 10 - rand()%20;
+       m_creature->GetRespawnCoord(x,y,z);        
+       Helper = DoSpawnCreature(4423, (float) (X - x), (float) (Y - y), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+       if(Helper && enemy)
+          ((CreatureAI*)Helper->AI())->AttackStart(enemy); 
+}
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    if(!Help && m_creature->GetEntry() == 3469)
+    {
+       for(int i = 0; i < 5;i++)
+       {
+            wood();
+       }
+       Help = 60000 + rand()%45000;
+    }
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+           int Change = 0;
+           int info = NULL;
+
+            if(!m_creature->HasAura(25640,0))
+            {
+                info = 25640;
+                Change = 1;
+            }
+            else
+            {
+                 if(enemy)
+                  {
+                   switch(rand()%5)
+                   {
+               case 0:
+                  info = 22924;
+                  break;
+               case 1:
+                    info = 35244;
+                    break;
+               case 2:
+                    info = 24648;
+                    break;
+               case 3:
+                    info = 40434;
+                    break;
+               case 4:
+                    info = 37592;
+                    break;
+               }//switch
+            }//if rage
+            }
+            if(m_creature->GetEntry() == 3468)
+                info = NULL;
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+        }//end attack ready
+    }// end attack distance
+/*    else 
+    { 
+     if(!m_creature->IsNonMeleeSpellCasted(false))
+     {
+         if ((*m_creature).GetMotionMaster()->top()->GetMovementGeneratorType()!=TARGETED_MOTION_TYPE)
+         {
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+         }
+     }
+    }//end else */
+}
+};
+CreatureAI* GetAI_ancient_of_war(Creature *_Creature)
+{
+    return new ancient_of_warAI (_Creature);
+}
+
+void AddSC_ancient_of_war()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name="ancient_of_war";
+    newscript->GetAI = GetAI_ancient_of_war;
+    m_scripts[nrscripts++] = newscript;
+}
Index: scripts/guard/archbishop_benedictus.cpp
===================================================================
--- scripts/guard/archbishop_benedictus.cpp	(revision 0)
+++ scripts/guard/archbishop_benedictus.cpp	(revision 0)
@@ -0,0 +1,344 @@
+/* 
+##############################
+ Archbishop Benedictus v 2.0
+##############################
+
+by Myav 
+*/
+
+#include "precompiled.h"
+#include "../creature/simple_ai.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL archbishop_benedictusAI : public ScriptedAI
+{
+    archbishop_benedictusAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    uint32 InnerTimer;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+
+    m_creature->SetMaxHealth(255000);
+    m_creature->SetHealth(255000);
+    m_creature->SetMaxPower(POWER_MANA,180000);
+    m_creature->SetPower(POWER_MANA,180000);
+    m_creature->SetArmor(5720);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DISARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_INTERRUPT_CAST, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CONFUSED, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM , true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR , true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DAZE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_BANISH, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+3000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+
+}
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if (InnerTimer > diff)
+        InnerTimer -= diff;
+    else InnerTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    if(!m_creature->HasAura(25431,0) && InnerTimer < diff && !m_creature->HasAura(27173,0) && !m_creature->HasAura(20924,0))
+    {
+     InnerTimer = 5000;
+     DoCast(m_creature, 25431);
+     return;
+    }
+    if(!m_creature->HasAura(25312,0))
+    {
+     DoCast(m_creature, 25312);
+     return;
+    }
+    if(!m_creature->HasAura(25431,0))
+    {
+     DoCast(m_creature, 25431);
+     return;
+    }
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+           int Change = 0;
+           int info = NULL;
+
+                 if(enemy)
+                  {
+                   switch(rand()%9)
+                   {
+               case 0:
+                  info = 32375;
+                  break;
+               case 1:
+                    info = 33206;
+                    Change = 1;
+                    break;
+               case 2:
+                    info = 10060;
+                    Change = 1;
+                    break;
+               case 3:
+                    info = 41373;
+                    Change = 1;
+                    break;
+               case 4:
+                    info = 34866;
+                    Change = 1;
+                    break;
+               case 5:
+                    info = 41380;
+                    break;
+               case 6:
+                    info = 37260;
+                    Change = 1;
+                    break;
+               case 7:
+                    info = 41471;
+                    break;
+               case 8:
+                    info = 39013;
+                    Change = 1;
+                    break;
+               }//switch
+            }
+
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+        }//end attack ready
+    }// end attack distance
+/*    else 
+    { 
+     if(!m_creature->IsNonMeleeSpellCasted(false))
+     {
+         if ((*m_creature).GetMotionMaster()->top()->GetMovementGeneratorType()!=TARGETED_MOTION_TYPE)
+         {
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+         }
+     }
+    }//end else */
+}
+};
+CreatureAI* GetAI_cathedral_of_light(Creature *_Creature)
+{
+    SimpleAI* ai = new SimpleAI (_Creature);
+
+    uint32 CreatureID = _Creature->GetEntry();
+
+    ai->m_creature->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_INTERRUPT_CAST, true);
+    ai->m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM, true);
+
+    switch (CreatureID) 
+    {
+        //Duthorian Rall
+    case 6171: 
+        ai->Spell[0].Enabled = true;               
+        ai->Spell[0].Spell_Id = 27155;      //Seal     
+        ai->Spell[0].Cooldown = 30000;                 
+        ai->Spell[0].First_Cast = 500;             
+        ai->Spell[0].Cast_Target_Type = CAST_SELF;  
+
+        ai->Spell[1].Enabled = true;               
+        ai->Spell[1].Spell_Id = 10308;      //Hammer     
+        ai->Spell[1].Cooldown = 45000;                 
+        ai->Spell[1].First_Cast = 10000;             
+        ai->Spell[1].Cast_Target_Type = CAST_HOSTILE_TARGET;  
+
+        ai->Spell[2].Enabled = true;               
+        ai->Spell[2].Spell_Id = 27141;      //Bless     
+        ai->Spell[2].Cooldown = 120000;                 
+        ai->Spell[2].First_Cast = 5000;             
+        ai->Spell[2].Cast_Target_Type = CAST_SELF;  
+
+        ai->Spell[3].Enabled = true;               
+        ai->Spell[3].Spell_Id = 33072;      //Shock     
+        ai->Spell[3].Cooldown = 20000;                 
+        ai->Spell[3].First_Cast = 15000;             
+        ai->Spell[3].Cast_Target_Type = CAST_HOSTILE_TARGET;  
+
+        ai->Spell[4].Enabled = true;               
+        ai->Spell[4].Spell_Id = 27136;      //Heal     
+        ai->Spell[4].Cooldown = 15000;                 
+        ai->Spell[4].First_Cast = 20000;             
+        ai->Spell[4].Cast_Target_Type = CAST_SELF;
+
+        ai->Spell[5].Enabled = true;               
+        ai->Spell[5].Spell_Id = 35396;      //Strike     
+        ai->Spell[5].Cooldown = 15000;                 
+        ai->Spell[5].First_Cast = 30000;             
+        ai->Spell[5].Cast_Target_Type = CAST_HOSTILE_TARGET;
+        break;
+
+        //High Priestess Laurena
+    case 376: 
+        ai->Spell[0].Enabled = true;               
+        ai->Spell[0].Spell_Id = 25431;      //Inner     
+        ai->Spell[0].Cooldown = 120000;                 
+        ai->Spell[0].First_Cast = 500;             
+        ai->Spell[0].Cast_Target_Type = CAST_SELF;  
+
+        ai->Spell[1].Enabled = true;               
+        ai->Spell[1].Spell_Id = 27801;      //Holy Nova     
+        ai->Spell[1].Cooldown = 30000;                 
+        ai->Spell[1].First_Cast = 10000;             
+        ai->Spell[1].Cast_Target_Type = CAST_HOSTILE_TARGET;  
+
+        ai->Spell[2].Enabled = true;               
+        ai->Spell[2].Spell_Id = 25218;      //Shield     
+        ai->Spell[2].Cooldown = 15000;                 
+        ai->Spell[2].First_Cast = 5000;             
+        ai->Spell[2].Cast_Target_Type = CAST_SELF;  
+
+        ai->Spell[3].Enabled = true;               
+        ai->Spell[3].Spell_Id = 25364;      //Smite     
+        ai->Spell[3].Cooldown = 20000;                 
+        ai->Spell[3].First_Cast = 15000;             
+        ai->Spell[3].Cast_Target_Type = CAST_HOSTILE_TARGET;  
+
+        ai->Spell[4].Enabled = true;               
+        ai->Spell[4].Spell_Id = 34866;      //Circle Heal     
+        ai->Spell[4].Cooldown = 15000;                 
+        ai->Spell[4].First_Cast = 20000;             
+        ai->Spell[4].Cast_Target_Type = CAST_SELF;
+
+        ai->Spell[5].Enabled = true;               
+        ai->Spell[5].Spell_Id = 25222;      //Renew     
+        ai->Spell[5].Cooldown = 25000;                 
+        ai->Spell[5].First_Cast = 25000;             
+        ai->Spell[5].Cast_Target_Type = CAST_SELF;
+
+        ai->Spell[6].Enabled = true;               
+        ai->Spell[6].Spell_Id = 25314;      //Heal     
+        ai->Spell[6].Cooldown = 15000;                 
+        ai->Spell[6].First_Cast = 30000;             
+        ai->Spell[6].Cast_Target_Type = CAST_SELF;
+
+        ai->Spell[7].Enabled = true;               
+        ai->Spell[7].Spell_Id = 25308;      //Prayer of Healing     
+        ai->Spell[7].Cooldown = 25000;                 
+        ai->Spell[7].First_Cast = 35000;             
+        ai->Spell[7].Cast_Target_Type = CAST_SELF;
+        break;
+    }
+
+    ai->Reset();
+
+    return ai;
+}
+CreatureAI* GetAI_archbishop_benedictus(Creature *_Creature)
+{
+    return new archbishop_benedictusAI (_Creature);
+}
+
+void AddSC_archbishop_benedictus()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name="archbishop_benedictus";
+    newscript->GetAI = GetAI_archbishop_benedictus;
+    m_scripts[nrscripts++] = newscript;
+
+    newscript = new Script;
+    newscript->Name="cathedral_of_light";
+    newscript->GetAI = GetAI_cathedral_of_light;
+    m_scripts[nrscripts++] = newscript;
+}
Index: scripts/guard/g_marcus_jonathan.cpp
===================================================================
--- scripts/guard/g_marcus_jonathan.cpp	(revision 0)
+++ scripts/guard/g_marcus_jonathan.cpp	(revision 0)
@@ -0,0 +1,200 @@
+/* 
+###############################
+ General Marcus Jonathan v 1.0
+ (Stormwind protector)
+###############################
+
+by Myav 
+*/
+
+#include "precompiled.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL g_marcus_jonathanAI : public ScriptedAI
+{
+    g_marcus_jonathanAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    Unit* enemy;
+    Creature* Helper;
+    
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+
+    m_creature->SetMaxHealth(98000);
+    m_creature->SetHealth(98000);
+    m_creature->SetArmor(11520);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_KNOCKOUT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+3000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+}
+
+void grunts()
+{
+       float x;
+       float y;
+       float z;
+       float X;
+       float Y;
+       float Z;
+       m_creature->GetPosition(x,y,z);
+       m_creature->getVictim()->GetPosition(X,Y,Z);
+       if(x > X)
+           X = x + 20 + 10 - rand()%20;
+       else
+           X = x - 20 + 10 - rand()%20;
+       if(y > Y)
+           Y = y + 20 + 10 - rand()%20;
+       else
+           Y = y - 20 + 10 - rand()%20;
+       m_creature->GetRespawnCoord(x,y,z);        
+       Helper = DoSpawnCreature(68, (float) (X - x), (float) (Y - y), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+       if(Helper && enemy)
+          ((CreatureAI*)Helper->AI())->AttackStart(enemy); 
+}
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    if(!Help)
+    {
+
+       for(int i = 0; i < 4;i++)
+       {
+            grunts();
+       }
+       Help = 60000 + rand()%45000;
+    }
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+           int Change = 0;
+           int info = NULL;
+
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+        }//end attack ready
+    }// end attack distance
+/*    else 
+    { 
+     if(!m_creature->IsNonMeleeSpellCasted(false))
+     {
+         if ((*m_creature).GetMotionMaster()->top()->GetMovementGeneratorType()!=TARGETED_MOTION_TYPE)
+         {
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+         }
+     }
+    }//end else */
+}
+};
+CreatureAI* GetAI_g_marcus_jonathan(Creature *_Creature)
+{
+    return new g_marcus_jonathanAI (_Creature);
+}
+
+void AddSC_g_marcus_jonathan()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name="g_marcus_jonathan";
+    newscript->GetAI = GetAI_g_marcus_jonathan;
+    m_scripts[nrscripts++] = newscript;
+}
Index: scripts/guard/guard_ai.cpp
===================================================================
--- scripts/guard/guard_ai.cpp	(revision 715)
+++ scripts/guard/guard_ai.cpp	(working copy)
@@ -1,26 +1,12 @@
-/* Copyright (C) 2006 - 2008 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+/* 
+###################
+ City Guards v 4
+###################
 
-/* ScriptData
-SDName: Guard_AI
-SD%Complete: 90
-SDComment: 
-SDCategory: Guards
-EndScriptData */
+by Myav
+*/
 
+
 #include "precompiled.h"
 #include "guard_ai.h"
 
@@ -30,26 +16,188 @@
 
 void guardAI::Reset()
 {
+    if(_Aggro == 2)
+     _Aggro = 1;
     GlobalCooldown = 0;
-    BuffTimer = 0;                                          //Rebuff as soon as we can
+    Bandage = 0;
+    Potion = 0;
+    OffHand = 0;
+    Help = 30000 + rand()%20000;
+    yell = false;
+    //m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+750,true);
+    if(!(m_creature->GetEntry() == 2041 || m_creature->GetEntry() == 4423))
+    {
+       m_creature->setPowerType(POWER_RAGE); 
+       m_creature->SetMaxPower(POWER_RAGE,500);
+       m_creature->SetPower(POWER_RAGE,0); 
+       bool elite = false;
+       int temp3 = 0;
+       int temp4 = 0;
+       int temp5 = 0; 
+       int temp6 = 0;
+       temp3 = m_creature->getLevel();
+       elite = m_creature->isElite();
+       if(elite)
+       {
+          temp4 = temp3 * 200;
+          temp5 = temp3 * 120;          
+          temp6 = temp3 * 8;
+       }
+        else
+        {
+           if(temp3 < 71)
+           {
+               temp4 = temp3 * 125;
+               temp5 = temp3 * 75;
+               temp6 = temp3 * 5;
+           }
+           else
+           {
+              temp4 = temp3 * 175;
+              temp5 = temp3 * 105;          
+              temp6 = temp3 * 7;
+           }       
+        }
+       if(m_creature->GetEntry() == 12481)
+        temp4 = temp4 * 4;
+       if(m_creature->GetEntry() == 12480)
+        temp4 = temp4 * 6;
+       if(m_creature->GetEntry() == 5624)
+        temp4 = temp4 * 3;
+       m_creature->SetMaxHealth(temp4);
+       m_creature->SetHealth(temp4);
+       m_creature->SetArmor(temp5);
+       m_creature->SetResistance(SPELL_SCHOOL_NORMAL,temp6);
+       m_creature->SetResistance(SPELL_SCHOOL_HOLY,temp6);
+       m_creature->SetResistance(SPELL_SCHOOL_FIRE,temp6);
+       m_creature->SetResistance(SPELL_SCHOOL_NATURE,temp6);
+       m_creature->SetResistance(SPELL_SCHOOL_FROST,temp6);
+       m_creature->SetResistance(SPELL_SCHOOL_SHADOW,temp6);
+       m_creature->SetResistance(SPELL_SCHOOL_ARCANE,temp6);
+    } 
+    //if(m_creature->getLevel() > 70 || m_creature->isElite())
+       //m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+900,false);
+    //else m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+500,false);
+    //if(m_creature->GetEntry() == 12481)
+        //m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+1600,false);
+    //if(m_creature->GetEntry() == 12480)
+        //m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+1900,false);
 }
 
 void guardAI::Aggro(Unit *who)
 {
-}
-
-void guardAI::JustDied(Unit *Killer)
-{
     //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
-    if( Killer->GetTypeId() == TYPEID_PLAYER )
-        m_creature->SendZoneUnderAttackMessage((Player*)Killer);
-    else if( Unit *owner = Killer->GetOwner() )
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
     {
-        if( owner->GetTypeId() == TYPEID_PLAYER )
-            m_creature->SendZoneUnderAttackMessage((Player*)owner);
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
     }
+    if(m_creature->getFaction() == 85 && !yell)
+    {
+       yell = true;
+       switch(rand()%4)
+       {
+           case 0:
+              DoYell("We are under Attack !!",LANG_ORCISH,NULL);
+              DoPlaySoundToSet(m_creature,6198);
+              break;
+           case 1:
+              DoSay("Time to Killing!",LANG_ORCISH,NULL);
+              DoPlaySoundToSet(m_creature,6205);
+              break;
+           case 2:
+              DoSay("Yargh!",LANG_ORCISH,NULL);
+              DoPlaySoundToSet(m_creature,6206);
+              break;
+           case 3:
+              DoSay("Time to Die!",LANG_ORCISH,NULL);
+              DoPlaySoundToSet(m_creature,6207);
+              break;
+       }
+    }
+    if(m_creature->getFaction() == 11 && !yell)
+    {
+       yell = true;
+       switch(rand()%4)
+       {
+       case 0:
+          DoYell("We are under Attack !!",LANG_COMMON,NULL);
+          break;
+       case 1:
+          DoSay("Time to Killing!",LANG_COMMON,NULL);
+          break;
+       case 2:
+          DoSay("Yahn!",LANG_COMMON,NULL);
+          break;
+       case 3:
+          DoSay("Time to Die!",LANG_COMMON,NULL);
+          break;
+       }
+    }
+    if(m_creature->getFaction() == 79 && !yell)
+    {
+       yell = true;
+       switch(rand()%4)
+       {
+           case 0:
+              DoYell("We are under Attack !!",LANG_DARNASSIAN,NULL);
+              break;
+           case 1:
+              DoSay("Time to Killing!",LANG_DARNASSIAN,NULL);
+              break;
+           case 2:
+              DoSay("Yahn!",LANG_DARNASSIAN,NULL);
+              break;
+           case 3:
+              DoSay("Time to Die!",LANG_DARNASSIAN,NULL);
+              break;
+       }
+    }
 }
+void guardAI::DamageDeal(Unit *done_to, uint32 &damage)
+{
+   if(m_creature->GetEntry() == 4423)
+       return;
+   temp1 = m_creature->GetPower(POWER_RAGE);
+   temp2 = 0;
+   temp2 = temp1;
+   switch(rand()%4)
+   {
+      case 0:temp1 = temp2 + 40;break;
+      case 1:temp1 = temp2 + 50;break;
+      case 2:temp1 = temp2 + 60;break;
+      case 3:temp1 = temp2 + 70;break;
+   }
+   if(temp1 > 500)
+      m_creature->SetPower(POWER_RAGE,500);   
+   else
+      m_creature->SetPower(POWER_RAGE,temp1);
+}
 
+void guardAI::DamageTaken(Unit *done_by, uint32 &damage)
+{
+    if(damage > m_creature->GetHealth())
+        return;
+
+   if(m_creature->GetEntry() == 4423)
+       return;
+
+   temp1 = m_creature->GetPower(POWER_RAGE);
+   temp2 = 0;
+   temp2 = temp1;
+   switch(rand()%4)
+   {
+      case 0:temp1 = temp2 + 20;break;
+      case 1:temp1 = temp2 + 30;break;
+      case 2:temp1 = temp2 + 40;break;
+      case 3:temp1 = temp2 + 50;break;
+   }
+   if(temp1 > 500)
+      m_creature->SetPower(POWER_RAGE,500);   
+   else
+      m_creature->SetPower(POWER_RAGE,temp1); 
+}
+
 void guardAI::UpdateAI(const uint32 diff)
 {
     //Always decrease our global cooldown first
@@ -57,61 +205,278 @@
         GlobalCooldown -= diff;
     else GlobalCooldown = 0;
 
-    //Buff timer (only buff when we are alive and not in combat
-    if (m_creature->isAlive() && !InCombat)
-        if (BuffTimer < diff )
-    {
-        //Find a spell that targets friendly and applies an aura (these are generally buffs)
-        SpellEntry const *info = SelectSpell(m_creature, -1, -1, SELECT_TARGET_ANY_FRIEND, 0, 0, 0, 0, SELECT_EFFECT_AURA);
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
 
-        if (info && !GlobalCooldown)
-        {
-            //Cast the buff spell
-            DoCastSpell(m_creature, info);
+    //Always decrease Bandage
+    if (Bandage > diff)
+        Bandage -= diff;
+    else Bandage = 0;
 
-            //Set our global cooldown
-            GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+    //Always decrease OffHand
+    if (OffHand > diff)
+        OffHand -= diff;
+    else OffHand = 0;
 
-            //Set our timer to 10 minutes before rebuff
-            BuffTimer = 600000;
-        }                                                   //Try agian in 30 seconds
-        else BuffTimer = 30000;
-    }else BuffTimer -= diff;
+    //Always decrease Potion
+    if (Potion > diff)
+        Potion -= diff;
+    else Potion = 0;
 
+    if(!m_creature->isAlive())
+        return;
+
+    if (!InCombat && !(m_creature->GetEntry() == 2041 || m_creature->GetEntry() == 4423))
+    {
+       temp1 = m_creature->GetPower(POWER_RAGE);
+       temp2 = temp1;
+       temp1 = temp2 - 3;
+       if(temp1 > 0)
+          m_creature->SetPower(POWER_RAGE,temp1);
+       else
+          m_creature->SetPower(POWER_RAGE,0);
+    }
+
     //Return since we have no target
     if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
         return;
 
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    if(!Help && !(m_creature->GetEntry() == 2041 || m_creature->GetEntry() == 4423))
+    {
+       int entry = m_creature->GetEntry();
+       float x;
+       float y;
+       float z;
+       float X;
+       float Y;
+       float Z;
+       m_creature->GetPosition(x,y,z);
+       m_creature->getVictim()->GetPosition(X,Y,Z);
+       if(x > X)
+           X = x + 20;
+       else
+           X = x - 20;
+       if(y > Y)
+           Y = y + 20;
+       else
+           Y = y - 20;
+       m_creature->GetRespawnCoord(x,y,z); 
+
+          if(entry != 12480 && entry != 12481)
+           {
+       Helper = DoSpawnCreature(entry, (float) (X - x), (float) (Y - y), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+    /*   Helper = DoSpawnCreature(entry, 0, 0, 0, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000); */
+       if(Helper && enemy)
+          ((CreatureAI*)Helper->AI())->AttackStart(enemy); 
+           }else
+             {
+       Helper = DoSpawnCreature(68, (float) (X - x + 3), (float) (Y - y - 3), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+           if(Helper && enemy)
+           ((CreatureAI*)Helper->AI())->AttackStart(enemy); 
+           Creature* Helper2 = NULL;
+       Helper2 = DoSpawnCreature(68, (float) (X - x - 3), (float) (Y - y + 3), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+           if(Helper2 && enemy)
+           ((CreatureAI*)Helper2->AI())->AttackStart(enemy); 
+            Creature* Helper3 = NULL;
+       Helper3 = DoSpawnCreature(68, (float) (X - x + 3), (float) (Y - y + 3), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+           if(Helper3 && enemy)
+           ((CreatureAI*)Helper3->AI())->AttackStart(enemy); 
+             }
+
+       Help = 45000 + rand()%30000;
+    }
+
     // Make sure our attack is ready and we arn't currently casting
     if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
     {
+            if(m_creature->getVictim() && m_creature->SelectHostilTarget() && m_creature->GetEntry() == 3084 && OffHand > 0 && OffHand < 500)
+            {
+                m_creature->HandleEmoteCommand(EMOTE_ONESHOT_ATTACKOFF);
+                m_creature->AttackerStateUpdate(m_creature->getVictim());
+                m_creature->resetAttackTimer();
+                OffHand = 0;
+            }
         //If we are within range melee the target
         if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
         {
+
+           if(_Aggro != 2 && m_creature->GetEntry() != 2041 && m_creature->GetEntry() != 5624)
+           {
+              _Aggro = 2;
+              DoCast(m_creature,2457);
+              return;
+           }
+
+           if(m_creature->GetHealth()*100 / m_creature->GetMaxHealth() > 39 && m_creature->HasAura(2458,0) && m_creature->GetEntry() != 2041 && m_creature->GetEntry() != 5624)
+           {
+              DoCast(m_creature,2457);
+              return; 
+           }
+
             bool Healing = false;
-            SpellEntry const *info = NULL;
+            int Change = 0;
+            int info = NULL;
 
             //Select a healing spell if less than 30% hp
-            if (m_creature->GetHealth()*100 / m_creature->GetMaxHealth() < 30)
-                info = SelectSpell(m_creature, -1, -1, SELECT_TARGET_ANY_FRIEND, 0, 0, 0, 0, SELECT_EFFECT_HEALING);
+            if (m_creature->GetHealth()*100 / m_creature->GetMaxHealth() < 40)
+            {
+               if(Potion == 0 && !Healing)
+               {
+                  Potion = 60000;
+                  info = 17534;
+                  Healing = true;
+               }
+               else
+               {
+                  if(Bandage == 0 && !Healing)
+                  {
+                     Bandage = 60000;
+                     info = 38919;
+                     Healing = true;
+                  }
+                  else
+                      if(m_creature->HasAura(2457,0))
+                      {
+                         info = 2458;
+                         Change = 3;
+                      }  
+               }//if bandage
+            }//if health <40%
+            else
+            {
+                         if(!m_creature->HasAura(2048,0) && m_creature->GetPower(POWER_RAGE) > 100)
+                         {
+                            info = 2048;
+                            Change = 3;    
+                         }
+                         else
+                         {
+                            if(enemy && !enemy->HasAura(25203,0) && m_creature->GetPower(POWER_RAGE) > 100)
+                            {
+                               info = 25203;
+                               Change = 4;    
+                            }
+                            //select a hostile spell
+                            else
+                            {
+                               if(enemy && m_creature->GetPower(POWER_RAGE) > 100)
+                               {
+                                  switch(rand()%8)
+                                  {
+                                     case 0:
+                                        info = 29707;
+                                        break;
+                                     case 1:
+                                        info = 11574;
+                                        break;
+                                     case 2:
+                                        info = 30022;
+                                        break;
+                                     case 3:
+                                        info = 11597;
+                                        break;
+                                     case 4:
+                                        if(m_creature->HasAura(2457,0))
+                                           info = 25248;
+                                        else info = 20569;
+                                        break;
+                                     case 5:
+                                        if(m_creature->HasAura(2457,0))
+                                           info = 20560;
+                                        else info = 6554;
+                                        break;
+                                     case 6:
+                                        if(m_creature->HasAura(2457,0))
+                                           info = 11581;
+                                        else info = 1680;
+                                        break;
+                                     case 7:
+                                        info = 11597;
+                                        break;
+                                  }//switch
+                               }//if rage
+                            }//else hostile spell
+                         }//if no demoralizing
+                     }//if no battle shout
 
-            //No healing spell available, select a hostile spell
-            if (info) Healing = true;
-            else info = SelectSpell(m_creature->getVictim(), -1, -1, SELECT_TARGET_ANY_ENEMY, 0, 0, 0, 0, SELECT_EFFECT_DONTCARE);
+            if(m_creature->GetEntry() == 4423)
+               info = NULL;
 
-            //20% chance to replace our white hit with a spell
-            if (info && rand() % 5 == 0 && !GlobalCooldown)
+            if(m_creature->GetEntry() == 5624)
             {
-                //Cast the spell
-                if (Healing)DoCastSpell(m_creature, info);
-                else DoCastSpell(m_creature->getVictim(), info);
+                info = NULL;
+                if(!m_creature->HasAura(41924,0))
+                    DoCast(m_creature, 41924);
+            }
 
+            //50% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Healing)DoCast(m_creature, info);
+                else
+                {
+                         if(Change == 3)
+                         {
+                            DoCast(m_creature, info);                            
+                            if(m_creature->getFaction() == 85)
+                            {
+                               DoYell("Warcry",LANG_ORCISH,NULL); 
+                               DoPlaySoundToSet(m_creature,6204);
+                            }
+                         }
+                         else
+                         {
+                            if(Change == 4)
+                               DoCast(enemy, info);
+                            else
+                                DoCast(enemy, info);
+                         }              
+                }
                 //Set our global cooldown
                 GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
-            }
+            }//end 50% change
             else m_creature->AttackerStateUpdate(m_creature->getVictim());
 
             m_creature->resetAttackTimer();
+            if(m_creature->GetEntry() == 3084)
+                OffHand = 1000;
         }
     }
     else
Index: scripts/guard/guard_ai.h
===================================================================
--- scripts/guard/guard_ai.h	(revision 715)
+++ scripts/guard/guard_ai.h	(working copy)
@@ -1,4 +1,4 @@
-/* Copyright (C) 2006 - 2008 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+/* Copyright (C) 2006,2007 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
  * This program is free software licensed under GPL version 2
  * Please see the included DOCS/LICENSE.TXT for more information */
 
@@ -9,17 +9,29 @@
 
 struct MANGOS_DLL_DECL guardAI : public ScriptedAI
 {
-    guardAI(Creature *c) : ScriptedAI(c) {Reset();}
+    guardAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0; _Aggro = 0;}
 
-    uint32 GlobalCooldown;                                  //This variable acts like the global cooldown that players have (1.5 seconds)
-    uint32 BuffTimer;                                       //This variable keeps track of buffs
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Bandage;
+    uint32 Potion;
+    uint32 Help;
+    uint32 OffHand;
+    uint32 ZoneAttackMsgTimer;
+    bool yell;
+    int _Aggro;
+    float temp1;
+    float temp2;
+    Unit* enemy;
+    Creature* Helper;
 
     void Reset();
 
     void Aggro(Unit *who);
 
-    void JustDied(Unit *Killer);
+    void DamageDeal(Unit *done_to, uint32 &damage);
 
+    void DamageTaken(Unit *done_by, uint32 &damage);
+
     void UpdateAI(const uint32 diff);
 };
 #endif
Index: scripts/guard/high_fire_mage.cpp
===================================================================
--- scripts/guard/high_fire_mage.cpp	(revision 0)
+++ scripts/guard/high_fire_mage.cpp	(revision 0)
@@ -0,0 +1,207 @@
+/* 
+##############################
+ Lady Catrana Prestor v 1.0
+##############################
+
+by Myav 
+*/
+
+#include "precompiled.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL high_fire_mageAI : public ScriptedAI
+{
+    high_fire_mageAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+
+    m_creature->SetMaxHealth(120000);
+    m_creature->SetHealth(120000);
+    m_creature->SetMaxPower(POWER_MANA,90000);
+    m_creature->SetPower(POWER_MANA,90000);
+    m_creature->SetArmor(5720);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_KNOCKOUT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+1000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+}
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    if(!m_creature->HasAura(30482,0))
+    {
+     DoCast(m_creature, 30482);
+     return;
+    }
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+           int Change = 0;
+           int info = NULL;
+
+                 if(enemy)
+                  {
+                   switch(rand()%9)
+                   {
+               case 0:
+                  info = 38151;
+                  Change = 1;
+                  break;
+               case 1:
+                    info = 38536;
+                    break;
+               case 2:
+                    info = 33043;
+                    break;
+               case 3:
+                    info = 27079;
+                    break;
+               case 4:
+                    info = 41383;
+                    break;
+               case 5:
+                    info = 38535;
+                    break;
+               case 6:
+                    info = 12598;
+                    break;
+               case 7:
+                    info = 12042;
+                    Change = 1;
+                    break;
+               case 8:
+                    info = 38636;
+                    break;
+               }//switch
+            }
+
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+        }//end attack ready
+    }// end attack distance
+/*    else 
+    { 
+     if(!m_creature->IsNonMeleeSpellCasted(false))
+     {
+         if ((*m_creature).GetMotionMaster()->top()->GetMovementGeneratorType()!=TARGETED_MOTION_TYPE)
+         {
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+         }
+     }
+    }//end else */
+}
+};
+CreatureAI* GetAI_high_fire_mage(Creature *_Creature)
+{
+    return new high_fire_mageAI (_Creature);
+}
+
+void AddSC_high_fire_mage()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name="high_fire_mage";
+    newscript->GetAI = GetAI_high_fire_mage;
+    m_scripts[nrscripts++] = newscript;
+}
Index: scripts/guard/high_sorcerer_andromath.cpp
===================================================================
--- scripts/guard/high_sorcerer_andromath.cpp	(revision 0)
+++ scripts/guard/high_sorcerer_andromath.cpp	(revision 0)
@@ -0,0 +1,205 @@
+/* 
+##############################
+ High Sorcerer Andromath v 1.0
+##############################
+
+by Myav 
+*/
+
+#include "precompiled.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL high_sorcerer_andromathAI : public ScriptedAI
+{
+    high_sorcerer_andromathAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+
+    m_creature->SetMaxHealth(120000);
+    m_creature->SetHealth(120000);
+    m_creature->SetMaxPower(POWER_MANA,90000);
+    m_creature->SetPower(POWER_MANA,90000);
+    m_creature->SetArmor(5720);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_KNOCKOUT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+1000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+}
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    if(!m_creature->HasAura(27124,0))
+    {
+     DoCast(m_creature, 27124);
+    }
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+           int Change = 0;
+           int info = NULL;
+
+                 if(enemy)
+                  {
+                   switch(rand()%9)
+                   {
+               case 0:
+                  info = 33405;
+                  Change = 1;
+                  break;
+               case 1:
+                    info = 41382;
+                    break;
+               case 2:
+                    info = 5164;
+                    break;
+               case 3:
+                    info = 39348;
+                    break;
+               case 4:
+                    info = 29717;
+                    break;
+               case 5:
+                    info = 31250;
+                    break;
+               case 6:
+                    info = 24857;
+                    break;
+               case 7:
+                    info = 41486;
+                    break;
+               case 8:
+                    info = 39414;
+                    break;
+               }//switch
+            }
+
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+        }//end attack ready
+    }// end attack distance
+/*    else 
+    { 
+     if(!m_creature->IsNonMeleeSpellCasted(false))
+     {
+         if ((*m_creature).GetMotionMaster()->top()->GetMovementGeneratorType()!=TARGETED_MOTION_TYPE)
+         {
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+         }
+     }
+    }//end else */
+}
+};
+CreatureAI* GetAI_high_sorcerer_andromath(Creature *_Creature)
+{
+    return new high_sorcerer_andromathAI (_Creature);
+}
+
+void AddSC_high_sorcerer_andromath()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name="high_sorcerer_andromath";
+    newscript->GetAI = GetAI_high_sorcerer_andromath;
+    m_scripts[nrscripts++] = newscript;
+}
Index: scripts/guard/highlord_bolvar_fordragon.cpp
===================================================================
--- scripts/guard/highlord_bolvar_fordragon.cpp	(revision 0)
+++ scripts/guard/highlord_bolvar_fordragon.cpp	(revision 0)
@@ -0,0 +1,226 @@
+/* 
+#################################
+ highlord Bolvar Fordragon v 1.0
+#################################
+
+by Myav 
+*/
+
+#include "precompiled.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL highlord_bolvar_fordragonAI : public ScriptedAI
+{
+    highlord_bolvar_fordragonAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+
+    m_creature->SetMaxHealth(380000);
+    m_creature->SetHealth(380000);
+    m_creature->SetMaxPower(POWER_MANA,150000);
+    m_creature->SetPower(POWER_MANA,150000);
+    m_creature->SetArmor(11520);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DISARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_INTERRUPT_CAST, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CONFUSED, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM , true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR , true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DAZE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_BANISH, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+3000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+}
+
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    if(!m_creature->HasAura(27150,0))
+    {
+     DoCast(m_creature, 27150);
+     return;
+    }
+
+    if(!m_creature->HasAura(27158,0))
+    {
+     DoCast(m_creature, 27158);
+     return;
+    }
+
+    if(!m_creature->HasAura(20217,0))
+    {
+     DoCast(m_creature, 20217);
+     return;
+    }
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+           int Change = 0;
+           int info = NULL;
+
+              if(enemy)
+                  {
+                   switch(rand()%9)
+                   {
+               case 0:
+                  info = 36946;
+                  break;
+               case 1:
+                    info = 38921;
+                    break;
+               case 2:
+                    info = 32700;
+                    break;
+               case 3:
+                    info = 41367;
+                    Change = 1;
+                    break;
+               case 4:
+                    info = 10308;
+                    break;
+               case 5:
+                    info = 31904;
+                    Change = 1;
+                    break;
+               case 6:
+                    info = 41450;
+                    Change = 1;
+                    break;
+               case 7:
+                    info = 31884;
+                    Change = 1;
+                    break;
+               case 8:
+                    info = 35395;
+                    break;
+               }//switch
+            }
+
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+        }//end attack ready
+    }// end attack distance
+/*    else 
+    { 
+     if(!m_creature->IsNonMeleeSpellCasted(false))
+     {
+         if ((*m_creature).GetMotionMaster()->top()->GetMovementGeneratorType()!=TARGETED_MOTION_TYPE)
+         {
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+         }
+     }
+    }//end else */
+}
+};
+CreatureAI* GetAI_highlord_bolvar_fordragon(Creature *_Creature)
+{
+    return new highlord_bolvar_fordragonAI (_Creature);
+}
+
+void AddSC_highlord_bolvar_fordragon()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name="highlord_bolvar_fordragon";
+    newscript->GetAI = GetAI_highlord_bolvar_fordragon;
+    m_scripts[nrscripts++] = newscript;
+}
Index: scripts/guard/officers.cpp
===================================================================
--- scripts/guard/officers.cpp	(revision 0)
+++ scripts/guard/officers.cpp	(revision 0)
@@ -0,0 +1,379 @@
+/* 
+#####################
+ City Officers v 4
+#####################
+
+by Myav
+*/
+
+#include "precompiled.h"
+#include "guard_ai.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL city_officerAI : public ScriptedAI
+{
+    city_officerAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0; _Aggro = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 OffHand;
+    uint32 ZoneAttackMsgTimer;
+    bool yell;
+    int _Aggro;
+    float temp1;
+    float temp2;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 5000;
+    OffHand = 0;
+    yell = false;
+
+    m_creature->setPowerType(POWER_RAGE); 
+    m_creature->SetMaxPower(POWER_RAGE,500);
+    m_creature->SetPower(POWER_RAGE,0); 
+    if(m_creature->GetEntry() != 2041 && m_creature->GetEntry() != 18103)   
+        m_creature->SetMaxHealth(33600);
+    else 
+    {
+    if(m_creature->GetEntry() == 18103)
+         m_creature->SetMaxHealth(47400);
+     else m_creature->SetMaxHealth(67000);
+    }
+    if(m_creature->GetEntry() != 2041 && m_creature->GetEntry() != 18103)
+        m_creature->SetHealth(33600);
+    else
+    {
+    if(m_creature->GetEntry() == 18103)
+         m_creature->SetHealth(47400);
+     else m_creature->SetHealth(67000);
+    }
+    if(m_creature->GetEntry() == 21970 || m_creature->GetEntry() == 21971)
+        m_creature->SetMaxHealth(45725);
+    if(m_creature->GetEntry() == 21970 || m_creature->GetEntry() == 21971)
+        m_creature->SetHealth(45725);
+    m_creature->SetArmor(9600);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,540);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,540);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,540);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,540);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,540);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,540);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,540);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+1000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+
+}
+
+void DamageDeal(Unit *done_to, uint32 &damage)
+{
+   if(m_creature->GetEntry() == 2041 || m_creature->GetEntry() == 18103)
+       return;
+   temp1 = m_creature->GetPower(POWER_RAGE);
+   temp2 = 0;
+   temp2 = temp1;
+   switch(rand()%4)
+   {
+      case 0:temp1 = temp2 + 40;break;
+      case 1:temp1 = temp2 + 50;break;
+      case 2:temp1 = temp2 + 60;break;
+      case 3:temp1 = temp2 + 70;break;
+   }
+   if(temp1 > 500)
+      m_creature->SetPower(POWER_RAGE,500);   
+   else
+      m_creature->SetPower(POWER_RAGE,temp1);
+}
+
+void DamageTaken(Unit *done_by, uint32 &damage)
+{
+    if(damage > m_creature->GetHealth())
+        return;
+
+   if(m_creature->GetEntry() == 2041 || m_creature->GetEntry() == 18103)
+       return;
+
+   temp1 = m_creature->GetPower(POWER_RAGE);
+   temp2 = 0;
+   temp2 = temp1;
+   switch(rand()%4)
+   {
+      case 0:temp1 = temp2 + 20;break;
+      case 1:temp1 = temp2 + 30;break;
+      case 2:temp1 = temp2 + 40;break;
+      case 3:temp1 = temp2 + 50;break;
+   }
+   if(temp1 > 500)
+      m_creature->SetPower(POWER_RAGE,500);   
+   else
+      m_creature->SetPower(POWER_RAGE,temp1); 
+}
+
+
+void guards()
+{
+       int entry = NULL;
+       float x;
+       float y;
+       float z;
+       float X;
+       float Y;
+       float Z;
+       m_creature->GetPosition(x,y,z);
+       m_creature->getVictim()->GetPosition(X,Y,Z);
+       if(x > X)
+           X = x + 20 + 10 - rand()%20;
+       else
+           X = x - 20 + 10 - rand()%20;
+       if(y > Y)
+           Y = y + 20 + 10 - rand()%20;
+       else
+           Y = y - 20 + 10 - rand()%20;
+       m_creature->GetRespawnCoord(x,y,z); 
+       if(m_creature->getFaction() == 85)
+           entry = 3296;
+       if(m_creature->getFaction() == 79)
+           entry = 4262;
+       if(m_creature->getFaction() == 11)
+           entry = 68;
+       if(m_creature->getFaction() == 71)
+           entry = 5624;
+       if(m_creature->getFaction() == 57)
+           entry = 5595;
+       if(m_creature->getFaction() == 105)
+           entry = 3084;    
+       if(m_creature->getFaction() == 1638)
+           entry = 16733;
+       if(m_creature->getFaction() == 1604)
+           entry = 16222;
+       Helper = DoSpawnCreature(entry, (float) (X - x), (float) (Y - y), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+    /*   Helper = DoSpawnCreature(entry, 0, 0, 0, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000); */
+       if(Helper && enemy)
+          ((CreatureAI*)Helper->AI())->AttackStart(enemy); 
+}
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease our OffHand cooldown first
+    if (OffHand > diff)
+        OffHand -= diff;
+    else OffHand = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    //Buff timer (only buff when we are alive and not in combat
+    if (!InCombat)
+    {
+       temp1 = m_creature->GetPower(POWER_RAGE);
+       temp2 = temp1;
+       temp1 = temp2 - 3;
+       if(temp1 > 0)
+          m_creature->SetPower(POWER_RAGE,temp1);
+       else
+          m_creature->SetPower(POWER_RAGE,0);
+    }
+
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    if(!Help && m_creature->GetEntry() != 2041 && m_creature->GetEntry() != 18103)
+    {
+       if(m_creature->getFaction() == 85)
+        DoYell("Orgrimmar is under Invasion! Guards!! Help me!",LANG_ORCISH,NULL);
+       if(m_creature->getFaction() == 79)
+        DoYell("Darnassus is under Invasion! Guards!! Help me!",LANG_DARNASSIAN,NULL);
+       if(m_creature->getFaction() == 11)
+        DoYell("Stormwind is under Invasion! Guards!! Help me!",LANG_COMMON,NULL);
+       if(m_creature->getFaction() == 71)
+        DoYell("Undercity is under Invasion! Guards!! Help me!",LANG_GUTTERSPEAK,NULL);
+       if(m_creature->getFaction() == 57)
+        DoYell("Ironforge is under Invasion! Guards!! Help me!",LANG_DWARVISH,NULL);
+       if(m_creature->getFaction() == 105)
+        DoYell("Thunder Bluff is under Invasion! Guards!! Help me!",LANG_TAURAHE,NULL);
+       if(m_creature->getFaction() == 1638)
+        DoYell("The Exodar is under Invasion! Guards!! Help me!",LANG_DRAENEI,NULL);
+       if(m_creature->getFaction() == 1604)
+        DoYell("Silvermoon is under Invasion! Guards!! Help me!",LANG_THALASSIAN,NULL);
+       m_creature->HandleEmoteCommand(EMOTE_ONESHOT_BATTLEROAR);
+       for(int i = 0; i < 3;i++)
+       {
+            guards();
+       }
+       Help = 60000 + rand()%45000;
+    }
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+            if(m_creature->getVictim() && m_creature->SelectHostilTarget() && OffHand > 0 && OffHand < 500)
+            {
+                m_creature->HandleEmoteCommand(EMOTE_ONESHOT_ATTACKOFF);
+                m_creature->AttackerStateUpdate(m_creature->getVictim());
+                m_creature->resetAttackTimer();
+                OffHand = 0;
+            }
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+
+           if(_Aggro != 2 && m_creature->GetEntry() != 2041 && m_creature->GetEntry() != 18103)
+           {
+              _Aggro = 2;
+              DoCast(m_creature,2457);
+              return;
+           }
+
+           int Change = 0;
+           int info = NULL;
+
+       /*     if(!m_creature->HasAura(469,0) && m_creature->GetPower(POWER_RAGE) > 50)
+            {
+                info = 469;
+                Change = 1;
+            }
+            else
+            { */
+                if(!m_creature->HasAura(2048,0) && m_creature->GetPower(POWER_RAGE) > 50)
+                {
+                    info = 2048;
+                    Change = 1;
+                }
+                else
+                 if(enemy && m_creature->GetPower(POWER_RAGE) > 100)
+                  {
+                   switch(rand()%9)
+                   {
+               case 0:
+                  info = 30324;
+                  break;
+               case 1:
+                    info = 30335;
+                    break;
+               case 2:
+                    info = 12323;
+                    break;
+               case 3:
+                    info = 5246;
+                    break;
+               case 4:
+                    info = 12809;
+                    break;
+               case 5:
+
+                    info = 38474;
+                    break;
+               case 6:
+                    info = 31955;
+                    break;
+               case 7:
+                    info = 30989;
+                    break;
+               case 8:
+                    info = 13736;
+                    break;
+               }//switch
+            }//if rage
+        /*    } */
+
+            if(m_creature->GetEntry() == 2041 || m_creature->GetEntry() == 18103)
+                info = NULL;
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 3 < 2 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+            OffHand = 1000;
+        }//end attack ready
+    }// end attack distance
+}
+};
+CreatureAI* GetAI_city_officer(Creature *_Creature)
+{
+    return new city_officerAI (_Creature);
+}
+CreatureAI* GetAI_city_guard(Creature *_Creature)
+{
+    return new guardAI (_Creature);
+}
+void AddSC_city_officer()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name="city_officer";
+    newscript->GetAI = GetAI_city_officer;
+    m_scripts[nrscripts++] = newscript;
+
+    newscript = new Script;
+    newscript->Name="city_guard";
+    newscript->GetAI = GetAI_city_guard;
+    m_scripts[nrscripts++] = newscript;
+}
Index: scripts/guard/overlord_saurfang.cpp
===================================================================
--- scripts/guard/overlord_saurfang.cpp	(revision 0)
+++ scripts/guard/overlord_saurfang.cpp	(revision 0)
@@ -0,0 +1,235 @@
+/* 
+##############################
+ High Overlord Saurfang v 1.0
+ (Orgrimmar protector)
+##############################
+
+by Myav 
+*/
+
+#include "precompiled.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL overlord_saurfangAI : public ScriptedAI
+{
+    overlord_saurfangAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+    m_creature->SetMaxHealth(98000);
+    m_creature->SetHealth(98000);
+    m_creature->SetArmor(11520);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_KNOCKOUT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+2000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+}
+
+void grunts()
+{
+       float x;
+       float y;
+       float z;
+       float X;
+       float Y;
+       float Z;
+       m_creature->GetPosition(x,y,z);
+       m_creature->getVictim()->GetPosition(X,Y,Z);
+       if(x > X)
+           X = x + 20 + 10 - rand()%20;
+       else
+           X = x - 20 + 10 - rand()%20;
+       if(y > Y)
+           Y = y + 20 + 10 - rand()%20;
+       else
+           Y = y - 20 + 10 - rand()%20;
+       m_creature->GetRespawnCoord(x,y,z);        
+       Helper = DoSpawnCreature(3296, (float) (X - x), (float) (Y - y), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+       if(Helper && enemy)
+          ((CreatureAI*)Helper->AI())->AttackStart(enemy); 
+}
+
+void JustDied(Unit*)
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+    m_creature->RemoveAllAttackers();
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+2000,false);
+}
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    if(!Help)
+    {
+
+       for(int i = 0; i < 4;i++)
+       {
+            grunts();
+       }
+       Help = 60000 + rand()%45000;
+    }
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+           int Change = 0;
+           int info = NULL;
+
+            if(!m_creature->HasAura(8269,0))
+            {
+                info = 8269;
+                Change = 1;
+            }
+            else
+            {
+                 if(enemy)
+                  {
+                   switch(rand()%5)
+                   {
+               case 0:
+                  info = 11430;
+                  break;
+               case 1:
+                    info = 31955;
+                    break;
+               case 2:
+                    info = 5164;
+                    break;
+               case 3:
+                    info = 41400;
+                    break;
+               case 4:
+                    info = 41197;
+                    break;
+               }//switch
+            }//if rage
+            }
+
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+        }//end attack ready
+    }// end attack distance
+/*    else 
+    { 
+     if(!m_creature->IsNonMeleeSpellCasted(false))
+     {
+         if ((*m_creature).GetMotionMaster()->top()->GetMovementGeneratorType()!=TARGETED_MOTION_TYPE)
+         {
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+         }
+     }
+    }//end else */
+}
+};
+CreatureAI* GetAI_overlord_saurfang(Creature *_Creature)
+{
+    return new overlord_saurfangAI (_Creature);
+}
+
+void AddSC_overlord_saurfang()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name="overlord_saurfang";
+    newscript->GetAI = GetAI_overlord_saurfang;
+    m_scripts[nrscripts++] = newscript;
+}
Index: scripts/guard/thrall.cpp
===================================================================
--- scripts/guard/thrall.cpp	(revision 0)
+++ scripts/guard/thrall.cpp	(revision 0)
@@ -0,0 +1,278 @@
+/* 
+############
+ Thrall v 1
+############
+
+by Myav
+*/
+
+#include "precompiled.h"
+#include "guard_ai.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL thrallAI : public ScriptedAI
+{
+    thrallAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    bool yell;
+    int _Aggro;
+    float temp1;
+    float temp2;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 5000;
+    yell = false;
+    m_creature->setPowerType(POWER_RAGE); 
+    m_creature->SetMaxPower(POWER_RAGE,500);
+    m_creature->SetPower(POWER_RAGE,0);    
+    m_creature->SetMaxHealth(360000);
+    m_creature->SetHealth(360000);
+    m_creature->SetArmor(11520);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DISARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_INTERRUPT_CAST, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CONFUSED, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM , true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR , true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DAZE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_BANISH, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+3000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+}
+
+void DamageDeal(Unit *done_to, uint32 &damage)
+{
+   temp1 = m_creature->GetPower(POWER_RAGE);
+   temp2 = 0;
+   temp2 = temp1;
+   switch(rand()%4)
+   {
+      case 0:temp1 = temp2 + 40;break;
+      case 1:temp1 = temp2 + 50;break;
+      case 2:temp1 = temp2 + 60;break;
+      case 3:temp1 = temp2 + 70;break;
+   }
+   if(temp1 > 500)
+      m_creature->SetPower(POWER_RAGE,500);   
+   else
+      m_creature->SetPower(POWER_RAGE,temp1);
+}
+
+void DamageTaken(Unit *done_by, uint32 &damage)
+{
+    if(damage > m_creature->GetHealth())
+        return;
+
+   temp1 = m_creature->GetPower(POWER_RAGE);
+   temp2 = 0;
+   temp2 = temp1;
+   switch(rand()%4)
+   {
+      case 0:temp1 = temp2 + 20;break;
+      case 1:temp1 = temp2 + 30;break;
+      case 2:temp1 = temp2 + 40;break;
+      case 3:temp1 = temp2 + 50;break;
+   }
+   if(temp1 > 500)
+      m_creature->SetPower(POWER_RAGE,500);   
+   else
+      m_creature->SetPower(POWER_RAGE,temp1); 
+}
+
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    //Buff timer (only buff when we are alive and not in combat
+    if (!InCombat)
+    {
+       temp1 = m_creature->GetPower(POWER_RAGE);
+       temp2 = temp1;
+       temp1 = temp2 - 3;
+       if(temp1 > 0)
+          m_creature->SetPower(POWER_RAGE,temp1);
+       else
+          m_creature->SetPower(POWER_RAGE,0);
+    }
+
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+           if(!m_creature->HasAura(41447,0))
+           {
+              DoCast(m_creature,41447);
+              return;
+           }
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+
+           if(_Aggro != 2 && m_creature->GetEntry() != 2041)
+           {
+              _Aggro = 2;
+              DoCast(m_creature,2457);
+              return;
+           }
+
+           int Change = 0;
+           int info = NULL;
+
+       /*     if(!m_creature->HasAura(469,0) && m_creature->GetPower(POWER_RAGE) > 50)
+            {
+                info = 469;
+                Change = 1;
+            }
+            else
+            { */
+                if(!m_creature->getVictim()->HasAura(29584,0) && m_creature->GetPower(POWER_RAGE) > 50)
+                {
+                    info = 29584;
+                }
+                else
+                 if(enemy && m_creature->GetPower(POWER_RAGE) > 100)
+                  {
+                   switch(rand()%8)
+                   {
+               case 0:
+                  info = 37476;
+                  break;
+               case 1:
+                    info = 36706;
+                    break;
+               case 2:
+                    info = 38618;
+                    break;
+               case 3:
+                    info = 12975;
+                    Change = 1;
+                    break;
+               case 4:
+                    info = 12809;
+                    break;
+               case 5:
+                    info = 36138;
+                    break;
+               case 6:
+                    info = 5246;
+                    break;
+               case 7:
+                    info = 34620;
+                    break;
+               }//switch
+            }//if rage
+        /*    } */
+
+            if(m_creature->GetEntry() == 2041)
+                info = NULL;
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 3 < 2 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+
+        }//end attack ready
+    }// end attack distance
+}
+};
+CreatureAI* GetAI_thrall(Creature *_Creature)
+{
+    return new thrallAI (_Creature);
+}
+void AddSC_thrall()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name="thrall";
+    newscript->GetAI = GetAI_thrall;
+    m_scripts[nrscripts++] = newscript;
+}
Index: scripts/item/item_scripts.cpp
===================================================================
--- scripts/item/item_scripts.cpp	(revision 715)
+++ scripts/item/item_scripts.cpp	(working copy)
@@ -393,6 +393,25 @@
 }
 
 /*#####
+# item_wolpertinger_net
+#####*/
+
+bool ItemUse_item_wolpertinger_net(Player *player, Item* _Item, SpellCastTargets const& targets)
+{
+    if( targets.getUnitTarget() && targets.getUnitTarget()->GetTypeId()==TYPEID_UNIT &&
+        targets.getUnitTarget()->GetEntry() == 23487 )
+        return false;
+
+    WorldPacket data(SMSG_CAST_FAILED, (4+2));              // prepare packet error message
+    data << uint32(_Item->GetEntry());                      // itemId
+    data << uint8(SPELL_FAILED_BAD_TARGETS);                // reason
+    player->GetSession()->SendPacket(&data);                // send message: Invalid target
+
+    player->SendEquipError(EQUIP_ERR_YOU_CAN_NEVER_USE_THAT_ITEM,_Item,NULL);
+    return true;
+}
+
+/*#####
 # item_yehkinyas_bramble
 #####*/
 
@@ -518,6 +537,11 @@
     m_scripts[nrscripts++] = newscript;
 
     newscript = new Script;
+    newscript->Name="item_wolpertinger_net";
+    newscript->pItemUse = ItemUse_item_wolpertinger_net;
+    m_scripts[nrscripts++] = newscript;
+
+    newscript = new Script;
     newscript->Name="item_yehkinyas_bramble";
     newscript->pItemUse = ItemUse_item_yehkinyas_bramble;
     m_scripts[nrscripts++] = newscript;
Index: scripts/zone/black_temple/boss_supremus.cpp
===================================================================
--- scripts/zone/black_temple/boss_supremus.cpp	(revision 715)
+++ scripts/zone/black_temple/boss_supremus.cpp	(working copy)
@@ -115,7 +115,7 @@
         CheckTimer = 1000;
         SupremusGUID = 0;
         FireballTimer = 500;
-        GeyserTimer = 0;
+        GeyserTimer = 2000;
     }
 
     void Aggro(Unit *who) {}
@@ -332,15 +332,7 @@
 
                 if(target)
                 {
-                    Creature* Volcano = NULL;
-                    Volcano = SummonCreature(CREATURE_VOLCANO, target);
-
-                    if(Volcano)
-                    {
-                        DoCast(target, SPELL_VOLCANIC_ERUPTION);
-                        ((npc_volcanoAI*)Volcano->AI())->SetSupremusGUID(m_creature->GetGUID());
-                    }
-
+                    DoCast(target, SPELL_VOLCANIC_ERUPTION);
                     DoTextEmote("roars and the ground begins to crack open!", NULL);
                     SummonVolcanoTimer = 10000;
                 }
Index: scripts/zone/coilfang_resevoir/serpent_shrine/boss_lady_vashj.cpp
===================================================================
--- scripts/zone/coilfang_resevoir/serpent_shrine/boss_lady_vashj.cpp	(revision 715)
+++ scripts/zone/coilfang_resevoir/serpent_shrine/boss_lady_vashj.cpp	(working copy)
@@ -66,7 +66,7 @@
 #define TAINTED_ELEMENTAL           22009
 #define COILFANG_STRIDER            22056
 #define COILFANG_ELITE              22055
-#define FATHOM_SPOREBAT             22140
+#define TOXIC_SPORE_BAT             22140
 
 float ElementPos[8][4] =
 {
@@ -329,7 +329,7 @@
                 if (SummonSporebat_Timer < diff)
                 {
                     Creature *Sporebat = NULL;
-                    Sporebat = m_creature->SummonCreature(FATHOM_SPOREBAT, SPOREBAT_X, SPOREBAT_Y, SPOREBAT_Z, SPOREBAT_O, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+                    Sporebat = m_creature->SummonCreature(TOXIC_SPORE_BAT, SPOREBAT_X, SPOREBAT_Y, SPOREBAT_Z, SPOREBAT_O, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
 
                     if (Sporebat)
                     {
@@ -594,11 +594,11 @@
     }
 };
 
-//Fathom Sporebat
+//Toxic Spore Bat
 //Toxic Spores: Used in Phase 3 by the Spore Bats, it creates a contaminated green patch of ground, dealing about 2775-3225 nature damage every second to anyone who stands in it.
-struct MANGOS_DLL_DECL mob_fathom_sporebatAI : public ScriptedAI
+struct MANGOS_DLL_DECL mob_toxic_spore_batAI : public ScriptedAI
 {
-    mob_fathom_sporebatAI(Creature *c) : ScriptedAI(c)
+    mob_toxic_spore_batAI(Creature *c) : ScriptedAI(c)
     {
         pInstance = ((ScriptedInstance*)c->GetInstanceData());
         Reset();
@@ -807,10 +807,19 @@
 
             //remove this item
             player->DestroyItemCount(31088, 1, true);
+            return true;
         }
-    }
+        else if( targets.getUnitTarget()->GetTypeId()==TYPEID_UNIT )
+            return false;
+        else if(targets.getUnitTarget()->GetTypeId()==TYPEID_PLAYER)
+        {
+            player->DestroyItemCount(31088, 1, true);
+            player->CastSpell(targets.getUnitTarget(), 38134, true);
+            return true;
+        }
+      }
     return true;
-}
+};
 
 CreatureAI* GetAI_boss_lady_vashj(Creature *_Creature)
 {
@@ -827,9 +836,9 @@
     return new mob_tainted_elementalAI (_Creature);
 }
 
-CreatureAI* GetAI_mob_fathom_sporebat(Creature *_Creature)
+CreatureAI* GetAI_mob_toxic_spore_bat(Creature *_Creature)
 {
-    return new mob_fathom_sporebatAI (_Creature);
+    return new mob_toxic_spore_batAI (_Creature);
 }
 
 CreatureAI* GetAI_mob_shield_generator_channel(Creature *_Creature)
@@ -856,8 +865,8 @@
     m_scripts[nrscripts++] = newscript;
 
     newscript = new Script;
-    newscript->Name="mob_fathom_sporebat";
-    newscript->GetAI = GetAI_mob_fathom_sporebat;
+    newscript->Name="mob_toxic_spore_bat";
+    newscript->GetAI = GetAI_mob_toxic_spore_bat;
     m_scripts[nrscripts++] = newscript;
 
     newscript = new Script;
Index: scripts/zone/deadmines/deadmines.cpp
===================================================================
--- scripts/zone/deadmines/deadmines.cpp	(revision 715)
+++ scripts/zone/deadmines/deadmines.cpp	(working copy)
@@ -22,3 +22,223 @@
 EndScriptData */
 
 #include "precompiled.h"
+#include "def_deadmines.h"
+#include "GameObject.h"
+#include "Player.h"
+#include "Spell.h"
+#include "WorldPacket.h"
+
+#define SOUND_CANNONFIRE	1400
+#define SOUND_DESTROYDOOR	3079
+#define SAY_MR_SMITE_ALARM1 "You there, check out that noise!"
+#define SOUND_MR_SMITE_ALARM1  5775
+#define SAY_MR_SMITE_ALARM2 "We're under attack! A vast, ye swabs! Repel the invaders!"
+#define SOUND_MR_SMITE_ALARM2  5777
+
+#define GO_IRONCLAD_DOOR	16397
+#define GO_DEFIAS_CANNON	16398
+#define GO_DOOR_LEVER		101833
+
+#define DEFIAS_PIRATE		657
+#define DEFIAS_COMPANION	3450
+
+#define CANNON_BLAST_TIMER 3000
+#define PIRATES_DELAY_TIMER 1000
+
+struct MANGOS_DLL_DECL instance_deadmines : public ScriptedInstance
+{
+	GameObject* IronCladDoor;
+	GameObject* DefiasCannon;
+	GameObject* DoorLever;
+	Creature* DefiasPirate1;
+	Creature* DefiasPirate2;
+	Creature* DefiasCompanion;
+	uint32 State;
+	uint32 CannonBlast_Timer;
+	uint32 PiratesDelay_Timer;
+
+	instance_deadmines(Map *Map) : ScriptedInstance(Map) {Initialize();};
+
+	void Initialize()
+	{
+		IronCladDoor = NULL;
+		DefiasCannon = NULL;
+		DoorLever =	NULL;
+		State = CANNON_NOT_USED;
+	}
+
+	virtual void Update(uint32 diff)
+	{
+		switch(State)
+		{
+			case CANNON_GUNPOWDER_USED:
+				CannonBlast_Timer = CANNON_BLAST_TIMER;
+				if(IronCladDoor)
+				{
+					// it's a hack - Mr. Smite should do that but his too far away
+					IronCladDoor->SetName("Mr. Smite");
+					IronCladDoor->Yell(SAY_MR_SMITE_ALARM1, LANG_UNIVERSAL, 0);
+					DoPlaySound(IronCladDoor, SOUND_MR_SMITE_ALARM1);
+				}
+				State = CANNON_BLAST_INITIATED;
+				break;
+			case CANNON_BLAST_INITIATED:	
+				PiratesDelay_Timer = PIRATES_DELAY_TIMER;
+				if(CannonBlast_Timer<diff)
+				{
+					SummonCreatures();
+					ShootCannon();
+					BlastOutDoor();
+					LeverStucked();
+					if(IronCladDoor)
+					{
+						IronCladDoor->Yell(SAY_MR_SMITE_ALARM2, LANG_UNIVERSAL, 0);
+						DoPlaySound(IronCladDoor, SOUND_MR_SMITE_ALARM2);
+					}
+					State = CANNON_PIRATES_ATTACK;						
+				}else
+					CannonBlast_Timer-=diff;								
+				break;
+			case CANNON_PIRATES_ATTACK:
+				if(PiratesDelay_Timer<diff)
+				{
+					MoveCreaturesInside();
+					State = CANNON_EVENT_DONE;
+				}else
+					PiratesDelay_Timer-=diff;
+				break;
+		}
+	}
+
+	void SummonCreatures()
+	{
+		if (IronCladDoor)
+		{
+			DefiasPirate1 = IronCladDoor->SummonCreature(DEFIAS_PIRATE, -100.97, -677, 7.42, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 360000);
+			DefiasPirate2 = IronCladDoor->SummonCreature(DEFIAS_PIRATE, -98.5, -675.77, 7.42, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 360000);
+			DefiasCompanion = IronCladDoor->SummonCreature(DEFIAS_COMPANION, -98.19, -675.08, 7.42, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 360000);
+		}
+	}
+	
+	void MoveCreaturesInside()
+	{
+		MoveCreatureInside(DefiasPirate1);
+		MoveCreatureInside(DefiasPirate2);
+		MoveCreatureInside(DefiasCompanion);
+	}
+
+	void MoveCreatureInside(Creature *creature)
+	{
+		if (creature)
+		{
+			creature->RemoveUnitMovementFlag(MOVEMENTFLAG_WALK_MODE);
+			creature->GetMotionMaster()->MovePoint(0, -102.7,-655.9, 7.43);
+		}
+	}
+
+	void ShootCannon()
+	{
+		if (DefiasCannon)
+		{
+			DefiasCannon->SetUInt32Value(GAMEOBJECT_STATE, 0);
+			DoPlaySound(DefiasCannon, SOUND_CANNONFIRE);
+		}
+	}
+
+	void BlastOutDoor()
+	{
+		if(IronCladDoor)
+		{
+			IronCladDoor->SetUInt32Value(GAMEOBJECT_STATE, 2);
+			DoPlaySound(IronCladDoor, SOUND_DESTROYDOOR);
+		}
+	}
+
+	void LeverStucked()
+	{
+		if (DoorLever)
+			DoorLever->SetUInt32Value(GAMEOBJECT_FLAGS, 4);
+	}
+
+	void OnObjectCreate(GameObject *go)
+	{
+		switch(go->GetEntry())
+		{
+			case GO_IRONCLAD_DOOR:
+				IronCladDoor = go;
+				break;
+			case GO_DEFIAS_CANNON:
+				DefiasCannon = go;
+				break;
+			case GO_DOOR_LEVER:
+				DoorLever = go;
+				break;
+		}
+	}
+
+	void SetData(uint32 type, uint32 data)
+	{
+		if (type == EVENT_STATE)
+		{
+			if (DefiasCannon && IronCladDoor)			
+				State=data;			
+		}
+	}
+
+	uint32 GetData(uint32 type)
+	{
+		if (type == EVENT_STATE)		
+			return State;
+		return 0;
+	}
+
+	void DoPlaySound(GameObject* unit, uint32 sound)
+	{
+		WorldPacket data(4);
+		data.SetOpcode(SMSG_PLAY_SOUND);
+		data << uint32(sound);
+		unit->SendMessageToSet(&data,false);
+	}
+};
+
+/*#####
+# item_Defias_Gunpowder
+#####*/
+
+bool ItemUse_item_Defias_Gunpowder(Player *player, Item* _Item, SpellCastTargets const& targets)
+{
+	ScriptedInstance *pInstance = (player->GetInstanceData()) ? ((ScriptedInstance*)player->GetInstanceData()) : NULL;
+
+	if(!pInstance)
+	{
+		player->GetSession()->SendNotification("Instance script not initialized");
+		return true;
+	}
+	if (pInstance->GetData(EVENT_STATE)!=CANNON_NOT_USED)
+		return false;
+	if(targets.getGOTarget() && targets.getGOTarget()->GetTypeId()==TYPEID_GAMEOBJECT && targets.getGOTarget()->GetEntry() == GO_DEFIAS_CANNON)
+		pInstance->SetData(EVENT_STATE, CANNON_GUNPOWDER_USED);
+
+	player->DestroyItemCount(_Item->GetEntry(), 1, true);
+	return true;
+}
+
+InstanceData* GetInstanceData_instance_deadmines(Map* map)
+{
+	return new instance_deadmines(map);
+}
+
+void AddSC_instance_deadmines()
+{
+	Script *newscript;
+	newscript = new Script;
+	newscript->Name = "instance_deadmines";
+	newscript->GetInstanceData = GetInstanceData_instance_deadmines;
+	m_scripts[nrscripts++] = newscript;
+	
+	newscript = new Script;
+	newscript->Name="item_Defias_Gunpowder";
+	newscript->pItemUse = ItemUse_item_Defias_Gunpowder;
+	m_scripts[nrscripts++] = newscript;
+
+}
Index: scripts/zone/deadmines/def_deadmines.h
===================================================================
--- scripts/zone/deadmines/def_deadmines.h	(revision 0)
+++ scripts/zone/deadmines/def_deadmines.h	(revision 0)
@@ -0,0 +1,14 @@
+#ifndef DEF_DEADMINES_H
+#define DEF_DEADMINES_H
+
+#include "sc_creature.h"
+#include "sc_instance.h"
+
+#define CANNON_NOT_USED 0
+#define CANNON_GUNPOWDER_USED 1
+#define CANNON_BLAST_INITIATED 2
+#define CANNON_PIRATES_ATTACK 3
+#define CANNON_EVENT_DONE 4
+
+#define EVENT_STATE 0
+#endif
Index: scripts/zone/hellfire_citadel/magtheridons_lair/boss_magtheridon.cpp
===================================================================
--- scripts/zone/hellfire_citadel/magtheridons_lair/boss_magtheridon.cpp	(revision 715)
+++ scripts/zone/hellfire_citadel/magtheridons_lair/boss_magtheridon.cpp	(working copy)
@@ -179,6 +179,8 @@
                 m_creature->setFaction(14);
                 m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
                 m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_UNKNOWN9);
+                m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_UNKNOWN2);
 
                 DoScriptText(SAY_FREED, m_creature);
 
Index: scripts/zone/hellfire_citadel/shattered_halls/boss_warchief_kargath_bladefist.cpp
===================================================================
--- scripts/zone/hellfire_citadel/shattered_halls/boss_warchief_kargath_bladefist.cpp	(revision 0)
+++ scripts/zone/hellfire_citadel/shattered_halls/boss_warchief_kargath_bladefist.cpp	(revision 0)
@@ -0,0 +1,114 @@
+#include "precompiled.h"
+
+#define SAY_AGGRO_1        "" 
+#define SAY_AGGRO_2        "I will carve the meat from your bones!" 
+#define SAY_AGGRO_3        "I am called Bladefist for a reason, as you will see..." 
+#define SAY_SLAY_1           "For the real horde!"
+#define SAY_SLAY_2           "I am an only warchief!"
+#define SAY_DEATH             "The true horde... will prevail..."
+
+#define SOUND_AGGRO_1         10323
+#define SOUND_AGGRO_2         10324
+#define SOUND_AGGRO_3         10325
+#define SOUND_SLAY_1             10326
+#define SOUND_SLAY_2             10327
+#define SOUND_DEATH              10328
+
+
+#define AB_BLADEDANCE      30739 
+
+struct MANGOS_DLL_DECL boss_warchief_kargath_bladefistAI : public ScriptedAI 
+{ 
+    boss_warchief_kargath_bladefistAI(Creature *c) : ScriptedAI(c) {Reset();} 
+
+    uint32 BladeDance_Timer; 
+    bool InCombat;    
+
+    void Reset() 
+    { 
+        BladeDance_Timer = 30000;  //GC      
+        InCombat=false;
+    } 
+
+    void KilledUnit(Unit* victim) 
+    { 
+        if (!victim) 
+            return; 
+        switch(rand()%2)
+        {
+        case 0:
+            DoYell(SAY_SLAY_1, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, SOUND_SLAY_1);
+            break;
+        case 1:
+            DoYell(SAY_SLAY_2, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, SOUND_SLAY_2);
+            break;
+        }
+        
+    } 
+
+    void JustDied(Unit *victim)
+    {
+        DoYell(SAY_DEATH, LANG_UNIVERSAL, NULL);
+        DoPlaySoundToSet(m_creature, SOUND_DEATH);
+    }
+
+    
+   void Aggro(Unit *who) 
+    {
+        switch(rand()%3)
+        {
+            case 0:
+                DoYell(SAY_AGGRO_1, LANG_UNIVERSAL, NULL);
+                DoPlaySoundToSet(m_creature, SOUND_AGGRO_1);
+            break;
+            case 1:
+                DoYell(SAY_AGGRO_2, LANG_UNIVERSAL, NULL);
+                DoPlaySoundToSet(m_creature, SOUND_AGGRO_2);
+            break;
+            case 2:
+                DoYell(SAY_AGGRO_3, LANG_UNIVERSAL, NULL);
+                DoPlaySoundToSet(m_creature, SOUND_AGGRO_3);
+            break;
+        }
+    } 
+    
+    void UpdateAI(const uint32 diff) 
+   { 
+        
+        if (!m_creature->SelectHostilTarget()) 
+         return; 
+
+        
+        if( m_creature->getVictim() && m_creature->isAlive()) 
+      { 
+
+      if(BladeDance_Timer<diff) 
+      { 
+         DoCast(m_creature->getVictim(),AB_BLADEDANCE); 
+         BladeDance_Timer=30000; 
+      }else BladeDance_Timer-=diff; 
+
+          
+      DoMeleeAttackIfReady(); 
+      } 
+   } 
+    
+}; 
+
+CreatureAI* GetAI_boss_warchief_kargath_bladefist(Creature *_Creature) 
+{ 
+    return new boss_warchief_kargath_bladefistAI (_Creature); 
+} 
+
+
+void AddSC_boss_warchief_kargath_bladefist() 
+{ 
+    Script *newscript; 
+    newscript = new Script; 
+    newscript->Name="boss_warchief_kargath_bladefist"; 
+    newscript->GetAI = GetAI_boss_warchief_kargath_bladefist; 
+    m_scripts[nrscripts++] = newscript; 
+   return; 
+}
Index: scripts/zone/karazhan/boss_nightbane.cpp
===================================================================
--- scripts/zone/karazhan/boss_nightbane.cpp	(revision 715)
+++ scripts/zone/karazhan/boss_nightbane.cpp	(working copy)
@@ -22,12 +22,370 @@
 EndScriptData */
 
 #include "precompiled.h"
+#include "sc_creature.h"
+#include "WorldPacket.h"
+#include "def_karazhan.h"
 
-#define SPELL_BELLOWING_ROAR        39427
-#define SPELL_CHARRED_EARTH         30129                   //Also 30209 (Target Charred Earth) triggers this
-#define SPELL_DISTRACTING_ASH       30130
-#define SPELL_SMOLDERING_BREATH     30210
-#define SPELL_TAIL_SWEEP            25653
-#define SPELL_RAIN_OF_BONES         37098
-#define SPELL_SMOKING_BLAST         37057
-#define SPELL_FIREBALL_BARRAGE      30282
+// Ground Abilities
+#define SPELL_BELLOWING_ROAR        36922 // Typical dragon fear with a 2.5-second cast time, short duration, and 30-second cooldown. He casts this once every 45 seconds to 1 minute.
+#define SPELL_CLEAVE                30131 // Typical dragon cleave, frontal arc. Hits for approximately 6,000 on plate, 11,000 on cloth.
+#define SPELL_CHARRED_EARTH         30129 // Chars the ground, setting it flame, 2188 to 2812 Fire damage every 3 sec
+#define SPELL_DISTRACTING_ASH       30130 // Reduces the chance to hit with spells and abilities by 30%.
+#define SPELL_SMOLDERING_BREATH     30210 // Inflicts 3700 to 4300 Fire damage to enemies in a cone in front of the caster and ~1700 tvery 3 sec (5 ticks)
+#define SPELL_TAIL_SWEEP            25653 // Inflicts 450 damage on enemies in a cone behind the caster, knocking them back.
+
+// Fly Abilities
+#define SPELL_RAIN_OF_BONES         37098 // Bombards the target and nearby allies with bone fragments, summoning 5 skeletons in the process.
+#define SPELL_SMOKING_BLAST         37057 // Deals 1850 to 2150 physical damage to the target and additional fire damage over time.
+#define SPELL_FIREBALL_BARRAGE      30282 // Throws fireballs at any enemies farther than 40 yards away.
+
+#define SOUND_DEATH                 9454
+#define SOUND_PRE_AGGRO             9455
+#define SOUND_AGGRO                 9456
+#define SOUND_ATTACK                9451
+#define SOUND_WOUND                 9452
+#define SOUND_WOUND_CRIT            9453
+#define SOUND_LOOP                  9457
+
+// summon (Fly Phase)
+#define SUMMON                      17261
+
+// Move boss - new
+struct Locations
+{
+    float x, y, z;
+};
+
+static Locations Flight[]=
+{
+	{-11181, -1893, 104},
+    {-11163, -1903, 92}
+};
+
+struct MANGOS_DLL_DECL boss_nightbaneAI : public ScriptedAI
+{
+    boss_nightbaneAI(Creature *c) : ScriptedAI(c) {pInstance = ((ScriptedInstance*)c->GetInstanceData());Reset();}
+
+    ScriptedInstance* pInstance;
+
+    // Ground State
+    uint32 Bellowing_Timer;
+    uint32 Charred_Timer;
+    uint32 Distracting_Timer;
+    uint32 Smoldering_Timer;
+    uint32 Cleave_Timer;
+    uint32 Tail_Timer;
+
+    // Air State
+    uint32 Fly_Timer;
+    uint32 Rain_Timer;
+    uint32 Summon_Timer;
+    uint32 Smoking_Timer;
+    uint32 Fireball_Timer;
+
+    uint32 Phase;
+    uint32 Wait_Timer;
+    uint32 Summons;
+    Locations Summon_Loc;
+    Creature* Summoned;
+    bool Flying;
+    bool Wait;
+    bool InCombat;
+
+    void Reset()
+    {
+        // Ground State
+        Bellowing_Timer = 60000;
+        Charred_Timer = (20+rand()%20)*1000;
+        Distracting_Timer = (30+rand()%60)*1000;;
+        Smoldering_Timer = 35000;
+        Cleave_Timer = 5000;
+        Tail_Timer = 25000;
+        Summon_Loc.x = Flight[1].x;
+        Summon_Loc.y = Flight[1].y;
+        Summon_Loc.z = Flight[1].z;
+        Phase = 1;
+
+        Flying = false;
+        Wait = false;
+        InCombat = false;
+
+        if(pInstance)
+            pInstance->SetData(DATA_NETHERBANE_EVENT, 0);
+
+        m_creature->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_INTERRUPT_CAST, true);
+        m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, SPELL_AURA_MOD_TAUNT, true);
+    }
+
+    void JustDied(Unit* Killer)
+    {
+        DoPlaySoundToSet(m_creature, SOUND_DEATH);
+        if(pInstance)
+            pInstance->SetData(DATA_NETHERBANE_EVENT, 3); // Completed
+    }
+
+    void Aggro(Unit *who)
+    {
+        DoPlaySoundToSet(m_creature, SOUND_AGGRO);
+        if(pInstance)
+            pInstance->SetData(DATA_NETHERBANE_EVENT, 1);
+        InCombat = true;
+    }
+
+    void ResetThreat()
+    {
+        std::list<HostilReference*>& m_threatlist = m_creature->getThreatManager().getThreatList();
+        if(m_threatlist.empty()) return;
+        std::list<HostilReference*>::iterator i = m_threatlist.begin();
+        for(i = m_threatlist.begin(); i != m_threatlist.end(); ++i)
+        {
+            Unit* pUnit = NULL;
+            pUnit = Unit::GetUnit((*m_creature), (*i)->getUnitGuid());
+            if(pUnit)
+                m_creature->getThreatManager().modifyThreatPercent(pUnit, -100);
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostilTarget() || !m_creature->getVictim()) 
+            return;
+
+        if((m_creature->GetHealth()*100 / m_creature->GetMaxHealth() < 75) && Phase == 1)
+        {
+            m_creature->InterruptSpell(CURRENT_GENERIC_SPELL);
+            m_creature->HandleEmoteCommand(EMOTE_ONESHOT_LIFTOFF);
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveIdle();
+            m_creature->SetHover(true);
+            Wait = true;
+            Wait_Timer = CreatureMove(Flight[0].x, Flight[0].y, Flight[0].z) + 2;
+            Phase++;
+        }
+        if((m_creature->GetHealth()*100 / m_creature->GetMaxHealth() < 50) && Phase == 2)
+        {
+            m_creature->InterruptSpell(CURRENT_GENERIC_SPELL);
+            m_creature->HandleEmoteCommand(EMOTE_ONESHOT_LIFTOFF);
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveIdle();
+            m_creature->SetHover(true);
+            Wait = true;
+            Wait_Timer = CreatureMove(Flight[0].x, Flight[0].y, Flight[0].z) + 2;
+            Phase++;
+        }
+
+        if((m_creature->GetHealth()*100 / m_creature->GetMaxHealth() < 25) && Phase == 3)
+        {
+            m_creature->InterruptSpell(CURRENT_GENERIC_SPELL);
+            m_creature->HandleEmoteCommand(EMOTE_ONESHOT_LIFTOFF);
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveIdle();
+            m_creature->SetHover(true);
+            Wait = true;
+            Wait_Timer = CreatureMove(Flight[0].x, Flight[0].y, Flight[0].z) + 2;
+            Phase++;
+        }
+
+        if(Wait)
+        {
+            if (Wait_Timer < diff)
+            {
+                if (Flying)
+                {
+                    Bellowing_Timer = 60000;
+                    Distracting_Timer = (30+rand()%60)*1000;;
+                    Charred_Timer = (20+rand()%20)*1000;
+                    Cleave_Timer = 5000;
+                    Smoldering_Timer = 35000;
+                    Tail_Timer = 25000;
+                    Flying = false;
+                    m_creature->HandleEmoteCommand(EMOTE_ONESHOT_LAND);
+                    m_creature->SetHover(false);
+                    (*m_creature).GetMotionMaster()->Clear(false);
+                    (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+                    ResetThreat();
+                }
+                else
+                {
+                    Rain_Timer = 2000;
+                    Fireball_Timer = 5000;
+                    Smoking_Timer = 999999;
+                    Summon_Timer = 999999;
+                    Fly_Timer = 999999;
+                    Summons = 1;
+                    Flying = true;
+                }
+                Wait = false;
+            }
+            else Wait_Timer -= diff;
+        }
+        else
+        {
+            if (!Flying)
+            {
+                if (Bellowing_Timer < diff)
+                {
+                    DoCast(m_creature,SPELL_BELLOWING_ROAR);
+                    Bellowing_Timer = (45+rand()%15)*1000;
+                }else Bellowing_Timer -= diff;
+
+                if (Distracting_Timer < diff)
+                {
+                    Unit* target = NULL;
+                    target = SelectUnit(SELECT_TARGET_RANDOM,0);
+                    if (target)
+                        DoCast(target,SPELL_DISTRACTING_ASH);
+                    else
+                        DoCast(m_creature->getVictim(),SPELL_DISTRACTING_ASH);
+                    Distracting_Timer = (30+rand()%60)*1000;
+                }else Distracting_Timer -= diff;
+
+                if (Charred_Timer < diff)
+                {
+                    std::list<HostilReference*>& m_threatlist = m_creature->getThreatManager().getThreatList();
+                    std::list<Unit*> targets;
+                    std::list<HostilReference*>::iterator i = m_threatlist.begin();
+                    for(i = m_threatlist.begin(); i != m_threatlist.end(); ++i)
+                    {
+                        Unit* pUnit = NULL;
+                        pUnit = Unit::GetUnit((*m_creature), (*i)->getUnitGuid());
+                        if (pUnit && pUnit->isAlive() && !m_creature->IsWithinDistInMap(pUnit, 10) && (pUnit->GetTypeId() == TYPEID_PLAYER))
+                            targets.push_back(pUnit);
+                    }
+                    if(!targets.empty())
+                    {
+                        std::list<Unit*>::iterator itr = targets.begin();
+                        advance(itr,(rand()%(targets.size())));
+                        Creature* Target_Helper;
+                        Unit* target = *itr;
+                        Target_Helper = m_creature->SummonCreature(17260,target->GetPositionX(), target->GetPositionY(), target->GetPositionZ(),0,TEMPSUMMON_TIMED_DESPAWN,30000);
+                        Target_Helper->SetUInt32Value(UNIT_NPC_FLAGS,0);
+                        Target_Helper->setFaction(45);
+                        Target_Helper->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                        DoCast(Target_Helper,SPELL_CHARRED_EARTH);
+                        Charred_Timer = (20+rand()%20)*1000;
+                    }
+                }else Charred_Timer -= diff;
+
+                if (Cleave_Timer < diff)
+                {
+                    DoCast(m_creature->getVictim(),SPELL_CLEAVE);
+                    Cleave_Timer = 10000;
+                }else Cleave_Timer -= diff;
+
+                if(Smoldering_Timer <diff)
+                {
+                    DoCast(m_creature->getVictim(),SPELL_SMOLDERING_BREATH);
+                    Smoldering_Timer = 30000;
+                }else Smoldering_Timer -= diff;
+
+                if(Tail_Timer <diff)
+                {
+                    DoCast(m_creature,SPELL_TAIL_SWEEP);
+                    Tail_Timer = 30000;
+                }else Tail_Timer -= diff;
+
+                DoMeleeAttackIfReady();
+            }
+            else
+            {
+                if (Rain_Timer < diff)
+                {
+                    Unit* target = NULL;
+                    target = SelectUnit(SELECT_TARGET_RANDOM,0);
+                    if (!target) 
+                        target = m_creature->getVictim();
+                    DoCast(target,SPELL_RAIN_OF_BONES);
+                    Summon_Loc.x = target->GetPositionX();
+                    Summon_Loc.y = target->GetPositionY();
+                    Summon_Loc.z = target->GetPositionZ();
+                    Summon_Timer = 3000;
+                    Smoking_Timer = 12000;
+                    Rain_Timer = 999999;
+                }else Rain_Timer -= diff;
+
+                if ((Summon_Timer < diff) && (Summons <= 5))
+                {
+                    Unit* target = NULL;
+                    target = SelectUnit(SELECT_TARGET_RANDOM,0);
+                    Summoned = m_creature->SummonCreature(SUMMON,Summon_Loc.x - (rand()%10) + 5, Summon_Loc.y - (rand()%10) + 5, Summon_Loc.z,0,TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN,900000);
+                    if (target)
+                        ((CreatureAI*)Summoned->AI())->AttackStart(target);
+                    else
+                        ((CreatureAI*)Summoned->AI())->AttackStart(m_creature->getVictim());
+                    Summon_Timer = 5000;
+                    Summons++;
+                }else Summon_Timer -= diff;
+
+                if (Smoking_Timer < diff)
+                {
+                    Unit* target = NULL;
+                    target = SelectUnit(SELECT_TARGET_RANDOM,0);
+                    if (target)
+                        DoCast(target,SPELL_SMOKING_BLAST);
+                    else
+                        DoCast(m_creature->getVictim(),SPELL_SMOKING_BLAST);
+                    Fly_Timer = 16000;
+                    Smoking_Timer = 999999;
+                }else Smoking_Timer -= diff;
+
+                if (Fireball_Timer < diff)
+                {
+                    std::list<HostilReference*>& m_threatlist = m_creature->getThreatManager().getThreatList();
+                    std::list<HostilReference*>::iterator i = m_threatlist.begin();
+                    for(i = m_threatlist.begin(); i != m_threatlist.end(); ++i)
+                    {
+                        Unit* pUnit = NULL;
+                        pUnit = Unit::GetUnit((*m_creature), (*i)->getUnitGuid());
+                        if(pUnit && pUnit->isAlive() && !m_creature->IsWithinDistInMap(pUnit, 40))
+                            DoCast(pUnit,SPELL_FIREBALL_BARRAGE);
+                    }
+                    Fireball_Timer = 1000;
+                }else Fireball_Timer -= diff;
+
+                if (Fly_Timer < diff)
+                {
+                    m_creature->InterruptSpell(CURRENT_GENERIC_SPELL);
+                    Wait = true;
+                    Wait_Timer = CreatureMove(Flight[1].x, Flight[1].y, Flight[1].z) + 2;
+                }else Fly_Timer -= diff;
+            }
+        }
+    }
+
+    uint32 CreatureMove(float DestX, float DestY, float DestZ)
+    {
+        float FromX = m_creature->GetPositionX();
+        float FromY = m_creature->GetPositionY();
+        float FromZ = m_creature->GetPositionZ();
+
+        float dx = DestX - FromX;
+        float dy = DestY - FromY;
+        float dz = DestZ - FromZ;
+        double dist = ::sqrt((dx*dx) + (dy*dy) + (dz*dz));
+        double speed = m_creature->GetSpeed(MOVE_RUN);
+
+        if(speed<=0)
+            speed = 2.5f;
+        speed *= 0.001f;
+
+        uint32 TotalTime = static_cast<uint32>( dist/speed + 0.5 );
+        m_creature->SendMonsterMove(DestX,DestY,DestZ,0,true,TotalTime);
+        m_creature->Relocate(DestX,DestY,DestZ);
+        return TotalTime;
+    }
+};
+
+CreatureAI* GetAI_boss_nightbane(Creature *_Creature)
+{
+    return new boss_nightbaneAI (_Creature);
+}
+
+void AddSC_boss_nightbane()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name="boss_nightbane";
+    newscript->GetAI = GetAI_boss_nightbane;
+    m_scripts[nrscripts++] = newscript;
+}
Index: scripts/zone/tempest_keep/the_eye/boss_void_reaver.cpp
===================================================================
--- scripts/zone/tempest_keep/the_eye/boss_void_reaver.cpp	(revision 715)
+++ scripts/zone/tempest_keep/the_eye/boss_void_reaver.cpp	(working copy)
@@ -121,7 +121,7 @@
                 target = Unit::GetUnit(*m_creature, (*itr)->getUnitGuid());
 
                 //15 yard radius minimum
-                if (target && target->GetDistance2d(m_creature) > 15)
+                if (target && target->GetDistance2d(m_creature) > 18)
                     target_list.push_back(target);
 
                 target = NULL;
@@ -131,12 +131,7 @@
                 target = *(target_list.begin()+rand()%target_list.size());
 
             if (target)
-            {
-                Unit* Spawn = NULL;
-                Spawn = m_creature->SummonCreature(CREATURE_ORB_TARGET, target->GetPositionX(), target->GetPositionY(), target->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 10000);
-                if (Spawn)
-                    m_creature->CastSpell(Spawn, SPELL_ARCANE_ORB_TRIGGER, true);
-            }
+                m_creature->CastSpell(target, SPELL_ARCANE_ORB_TRIGGER, true);
 
             ArcaneOrb_Timer = 3000;
         }else ArcaneOrb_Timer -= diff;
Index: scripts/zone/zulaman/boss_akilzon.cpp
===================================================================
--- scripts/zone/zulaman/boss_akilzon.cpp	(revision 0)
+++ scripts/zone/zulaman/boss_akilzon.cpp	(revision 0)
@@ -0,0 +1,524 @@
+/* Copyright ?2006 - 2008 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* ScriptData
+SDName: boss_Akilzon
+SD%Complete: 75%
+SDComment: Missing timer for Call Lightning and Sound ID's
+SQLUpdate: 
+#Temporary fix for Soaring Eagles
+
+EndScriptData */
+
+#include "precompiled.h"
+#include "def_zulaman.h"
+#include "Spell.h"
+#include "Weather.h"
+
+#define SPELL_STATIC_DISRUPTION 43622
+#define SPELL_STATIC_VISUAL     45265
+#define SPELL_CALL_LIGHTNING     43661 //Missing timer
+#define SPELL_GUST_OF_WIND      43621
+#define SPELL_ELECTRICAL_STORM  43648
+#define SPELL_BERSERK           45078
+
+#define SPELL_EAGLE_SWOOP       44732
+
+//"Your death gonna be quick, strangers. You shoulda never have come to this place..."
+#define SAY_ONAGGRO "I be da predator! You da prey..."
+#define SAY_ONDEATH "You can't... kill... me spirit!"
+#define SAY_ONSLAY1 "Ya got nothin'!"
+#define SAY_ONSLAY2 "Stop your cryin'!"
+#define SAY_ONSUMMON "Feed, me bruddahs!"
+#define SAY_ONENRAGE "All you be doing is wasting my time!"
+#define SOUND_ONAGGRO 12013
+#define SOUND_ONDEATH 12019
+#define SOUND_ONSLAY1 12017
+#define SOUND_ONSLAY2 12018
+#define SOUND_ONSUMMON 12014
+#define SOUND_ONENRAGE 12016
+
+#define MOB_SOARING_EAGLE 24858
+#define SE_LOC_X_MAX 400
+#define SE_LOC_X_MIN 335
+#define SE_LOC_Y_MAX 1435
+#define SE_LOC_Y_MIN 1370
+
+#define MOB_TEMP_TRIGGER    23920
+
+struct MANGOS_DLL_DECL boss_akilzonAI : public ScriptedAI
+{
+    boss_akilzonAI(Creature *c) : ScriptedAI(c)
+    {
+        pInstance = ((ScriptedInstance*)c->GetInstanceData());
+        Reset();
+    }
+    ScriptedInstance *pInstance;
+
+    uint64 TargetGUID;
+    uint64 CycloneGUID;
+    uint64 CloudGUID;
+
+    uint32 StaticDisruption_Timer;
+    uint32 GustOfWind_Timer;
+    uint32 CallLighting_Timer;
+    uint32 ElectricalStorm_Timer;
+    uint32 SDisruptAOEVisual_Timer;
+    uint32 SummonEagles_Timer;
+    uint32 Enrage_Timer;
+
+    uint32 StormCount;
+    uint32 StormSequenceTimer;
+
+    bool isRaining;
+
+    void Reset()
+    {
+        if(pInstance)
+            pInstance->SetData(DATA_AKILZONEVENT, NOT_STARTED);
+
+        StaticDisruption_Timer = (10+rand()%10)*1000; //10 to 20 seconds (bosskillers)
+        GustOfWind_Timer = (20+rand()%10)*1000; //20 to 30 seconds(bosskillers)
+        CallLighting_Timer = (10+rand()%10)*1000; //totaly random timer. can't find any info on this
+        ElectricalStorm_Timer = 60*1000; //60 seconds(bosskillers)
+        Enrage_Timer = 10*60*1000; //10 minutes till enrage(bosskillers)
+        SDisruptAOEVisual_Timer = 99999;
+        SummonEagles_Timer = 99999;
+
+        TargetGUID = 0;
+        CloudGUID = 0;
+        CycloneGUID = 0;
+
+        StormCount = 0;
+        StormSequenceTimer = 0;
+
+        isRaining = false;
+
+        DespawnSummons(MOB_SOARING_EAGLE);
+        SetWeather(WEATHER_STATE_FINE, 0.0f);        
+    }
+
+    void Aggro(Unit *who)
+    {
+        DoYell(SAY_ONAGGRO, LANG_UNIVERSAL, NULL);
+        DoPlaySoundToSet(m_creature, SOUND_ONAGGRO);
+        DoZoneInCombat();
+        if(pInstance)
+            pInstance->SetData(DATA_AKILZONEVENT, IN_PROGRESS);
+    }
+
+    void JustDied(Unit* Killer)
+    {
+        DoYell(SAY_ONDEATH,LANG_UNIVERSAL,NULL);
+        DoPlaySoundToSet(m_creature, SOUND_ONDEATH);
+        if(pInstance)
+            pInstance->SetData(DATA_AKILZONEVENT, DONE);
+        DespawnSummons(MOB_SOARING_EAGLE);
+    }
+
+    void KilledUnit(Unit* victim)
+    {
+        switch(rand()%2)
+        {
+        case 0:
+            DoYell(SAY_ONSLAY1, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, SOUND_ONSLAY1);
+            break;
+        case 1:
+            DoYell(SAY_ONSLAY2, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, SOUND_ONSLAY2);
+            break;
+        }
+    }
+
+    void DespawnSummons(uint32 entry)
+    {
+        std::list<Creature*> templist;
+        float x, y, z;
+        m_creature->GetPosition(x, y, z);
+
+        {
+            CellPair pair(MaNGOS::ComputeCellPair(x, y));
+            Cell cell(pair);
+            cell.data.Part.reserved = ALL_DISTRICT;
+            cell.SetNoCreate();
+
+            AllCreaturesOfEntryInRange check(m_creature, entry, 100);
+            MaNGOS::CreatureListSearcher<AllCreaturesOfEntryInRange> searcher(templist, check);
+
+            TypeContainerVisitor<MaNGOS::CreatureListSearcher<AllCreaturesOfEntryInRange>, GridTypeMapContainer> cSearcher(searcher);
+
+            CellLock<GridReadGuard> cell_lock(cell, pair);
+            cell_lock->Visit(cell_lock, cSearcher, *(m_creature->GetMap()));
+        }
+
+        for(std::list<Creature*>::iterator i = templist.begin(); i != templist.end(); ++i)
+        {
+            (*i)->SetVisibility(VISIBILITY_OFF);
+            (*i)->setDeathState(JUST_DIED);
+        }
+    }
+
+    Player* SelectRandomPlayer(float range = 0.0f, bool alive = true)
+    {
+        Map *map = m_creature->GetMap();
+        if (!map->IsDungeon()) return NULL;
+
+        InstanceMap::PlayerList PlayerList = ((InstanceMap*)map)->GetPlayers();
+        InstanceMap::PlayerList::iterator i;
+        while(PlayerList.size())
+        {
+            i = PlayerList.begin();
+            advance(i, rand()%PlayerList.size());
+            if((range == 0.0f || m_creature->IsWithinDistInMap(*i, range))
+                && (!alive || (*i)->isTargetableForAttack()))
+                return *i;
+            else
+                PlayerList.erase(i);
+        }
+        return NULL;
+    }
+
+    void SetWeather(uint32 weather, float grade)
+    {
+        Map *map = m_creature->GetMap();
+        if (!map->IsDungeon()) return;
+
+        WorldPacket data(SMSG_WEATHER, (4+4+4));
+        data << uint32(weather) << (float)grade << uint8(0);
+
+        ((InstanceMap*)map)->SendToPlayers(&data);
+    }
+
+    void HandleStormSequence(Unit *Cloud) // 1: begin, 2-9: tick, 10: end
+    {
+        if(StormCount < 10 && StormCount > 1)
+        {
+            // deal damage
+            int32 bp0 = 800;
+            for(uint8 i = 2; i < StormCount; ++i)
+                bp0 *= 2;
+
+            CellPair p(MaNGOS::ComputeCellPair(m_creature->GetPositionX(), m_creature->GetPositionY()));
+            Cell cell(p);
+            cell.data.Part.reserved = ALL_DISTRICT;
+            cell.SetNoCreate();
+
+            std::list<Unit *> tempUnitMap;
+
+            {
+                MaNGOS::AnyAoETargetUnitInObjectRangeCheck u_check(m_creature, m_creature, 999);
+                MaNGOS::UnitListSearcher<MaNGOS::AnyAoETargetUnitInObjectRangeCheck> searcher(tempUnitMap, u_check);
+
+                TypeContainerVisitor<MaNGOS::UnitListSearcher<MaNGOS::AnyAoETargetUnitInObjectRangeCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+                TypeContainerVisitor<MaNGOS::UnitListSearcher<MaNGOS::AnyAoETargetUnitInObjectRangeCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+                CellLock<GridReadGuard> cell_lock(cell, p);
+                cell_lock->Visit(cell_lock, world_unit_searcher, *(m_creature->GetMap()));
+                cell_lock->Visit(cell_lock, grid_unit_searcher, *(m_creature->GetMap()));
+            }
+
+            for(std::list<Unit*>::iterator i = tempUnitMap.begin(); i != tempUnitMap.end(); ++i)
+            {
+                if(!Cloud->IsWithinDistInMap(*i, 15))
+                {
+                    float x, y, z;
+                    (*i)->GetPosition(x, y, z);
+                    x = rand()%2 ? x + rand()%5 : x - rand()%5;
+                    y = rand()%2 ? y + rand()%5 : y - rand()%5;
+                    z = Cloud->GetPositionZ() + 2 - rand()%4; 
+                    if(Unit *trigger = m_creature->SummonCreature(MOB_TEMP_TRIGGER, x, y, z, 0, TEMPSUMMON_TIMED_DESPAWN, 2000))
+                    {
+                        trigger->SetUnitMovementFlags(MOVEMENTFLAG_LEVITATING);
+                        trigger->StopMoving();
+                        trigger->CastSpell(trigger, 37248, true);
+                        trigger->CastCustomSpell(*i, 43137, &bp0, NULL, NULL, true, 0, 0, m_creature->GetGUID());
+                    }
+                }
+            }
+
+            // visual
+            float x, y, z;
+            for(uint8 i = 0; i < StormCount; ++i)
+            {
+                Cloud->GetPosition(x, y, z);
+                x = rand()%2 ? x + rand()%10 : x - rand()%10;
+                y = rand()%2 ? y + rand()%10 : y - rand()%10;
+                z = z + 2 - rand()%4; 
+                if(Unit *trigger = m_creature->SummonCreature(MOB_TEMP_TRIGGER, x, y, z, 0, TEMPSUMMON_TIMED_DESPAWN, 2000))
+                {
+                    trigger->SetUnitMovementFlags(MOVEMENTFLAG_LEVITATING);
+                    trigger->StopMoving();
+                    trigger->CastSpell(trigger, 37248, true);
+                }
+                Cloud->GetPosition(x, y, z);
+                x = rand()%2 ? x + 10 + rand()%10 : x - 10 - rand()%10;
+                y = rand()%2 ? y + 10 + rand()%10 : y - 10 - rand()%10;
+                if(Unit *trigger = m_creature->SummonCreature(MOB_TEMP_TRIGGER, x, y, m_creature->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 2000))
+                {
+                    trigger->SetMaxHealth(9999999);
+                    trigger->SetHealth(9999999);
+                    trigger->CastSpell(trigger, 43661, true);
+                }
+            }
+        }
+
+        StormCount++;
+        if(StormCount > 10)
+        {
+            StormCount = 0; // finish
+            SummonEagles_Timer = 5000;
+            m_creature->InterruptNonMeleeSpells(false);
+            Cloud->RemoveAurasDueToSpell(45213);
+            CloudGUID = 0;
+            if(Unit* Cyclone = Unit::GetUnit(*m_creature, CycloneGUID))
+                Cyclone->RemoveAurasDueToSpell(25160);
+            SetWeather(WEATHER_STATE_FINE, 0.0f);
+            isRaining = false;
+        }
+
+        StormSequenceTimer = 1000;
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostilTarget() && !m_creature->getVictim())
+            return;
+
+        if(StormCount)
+        {
+            Unit* target = Unit::GetUnit(*m_creature, CloudGUID);
+            if(!target || !target->isAlive())
+            {
+                EnterEvadeMode();
+                return;
+            }
+            else if(Unit* Cyclone = Unit::GetUnit(*m_creature, CycloneGUID))
+                Cyclone->CastSpell(target, 25160, true); // keep casting or...
+
+            if(StormSequenceTimer < diff) {
+                HandleStormSequence(target);
+            }else StormSequenceTimer -= diff;
+            return;
+        }
+
+        if (Enrage_Timer < diff) {
+            DoYell(SAY_ONENRAGE, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, SOUND_ONENRAGE);
+            m_creature->CastSpell(m_creature, SPELL_BERSERK, true);
+            Enrage_Timer = 600000;
+        }else Enrage_Timer -= diff;
+
+        if (StaticDisruption_Timer < diff) {
+            Unit* target = SelectUnit(SELECT_TARGET_RANDOM, 1);
+            if(!target) target = m_creature->getVictim();
+            TargetGUID = target->GetGUID();
+            m_creature->CastSpell(target, SPELL_STATIC_DISRUPTION, false);
+            m_creature->SetInFront(m_creature->getVictim());
+            StaticDisruption_Timer = (10+rand()%8)*1000; // < 20s
+
+            float dist = m_creature->GetDistance(target->GetPositionX(), target->GetPositionY(), target->GetPositionZ());
+            if (dist < 5.0f) dist = 5.0f;
+            SDisruptAOEVisual_Timer = 1000 + floor(dist / 30 * 1000.0f);
+        }else StaticDisruption_Timer -= diff;
+
+        if (SDisruptAOEVisual_Timer < diff) {
+            Unit* SDVictim = Unit::GetUnit((*m_creature), TargetGUID);
+            if(SDVictim && SDVictim->isAlive())
+                SDVictim->CastSpell(SDVictim, SPELL_STATIC_VISUAL, true);
+            SDisruptAOEVisual_Timer = 99999;
+            TargetGUID = 0;
+        }else SDisruptAOEVisual_Timer -= diff;
+
+        if (GustOfWind_Timer < diff) {
+            Unit* target = SelectUnit(SELECT_TARGET_RANDOM, 1);
+            if(!target) target = m_creature->getVictim();
+            DoCast(target, SPELL_GUST_OF_WIND);
+            GustOfWind_Timer = (20+rand()%10)*1000; //20 to 30 seconds(bosskillers)
+        } else GustOfWind_Timer -= diff;
+
+        if (CallLighting_Timer < diff) {
+            DoCast(m_creature->getVictim(), SPELL_CALL_LIGHTNING);
+            CallLighting_Timer = (12 + rand()%5)*1000; //totaly random timer. can't find any info on this
+        } else CallLighting_Timer -= diff;
+
+        if (!isRaining && ElectricalStorm_Timer < 8000 + rand()%5000) {
+            SetWeather(WEATHER_STATE_HEAVY_RAIN, 0.9999f);
+            isRaining = true;
+        }
+
+        if (ElectricalStorm_Timer < diff) {
+            Unit* target = SelectRandomPlayer(50);
+            if(!target) target = m_creature->getVictim();
+            float x, y, z;
+            target->GetPosition(x, y, z);
+            Unit *Cloud = m_creature->SummonCreature(MOB_TEMP_TRIGGER, x, y, m_creature->GetPositionZ() + 10, 0, TEMPSUMMON_TIMED_DESPAWN, 15000);
+            if(Cloud)
+            {
+                CloudGUID = Cloud->GetGUID();
+                Cloud->SetUnitMovementFlags(MOVEMENTFLAG_LEVITATING);
+                Cloud->StopMoving();
+                Cloud->SetFloatValue(OBJECT_FIELD_SCALE_X, 3.0f);
+                Cloud->setFaction(35);
+                Cloud->SetMaxHealth(9999999);
+                Cloud->SetHealth(9999999);
+                Cloud->CastSpell(Cloud, 45213, true); // cloud visual
+                m_creature->StopMoving();
+                Cloud->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                m_creature->CastSpell(Cloud, 43501, false); // siphon soul
+            }
+            Unit *Cyclone = m_creature->SummonCreature(MOB_TEMP_TRIGGER, x, y, z, 0, TEMPSUMMON_TIMED_DESPAWN, 15000);
+            if(Cyclone)
+            {
+                Cyclone->CastSpell(Cyclone, 25160, true); // wind visual
+                CycloneGUID = Cyclone->GetGUID();
+            }
+            ElectricalStorm_Timer = 60000; //60 seconds(bosskillers)
+            StormCount = 1;
+            StormSequenceTimer = 0;
+        } else ElectricalStorm_Timer -= diff;
+
+        if (SummonEagles_Timer < diff) 
+        {
+            DoYell(SAY_ONSUMMON, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, SOUND_ONSUMMON);
+
+            float x, y, z;
+            m_creature->GetPosition(x, y, z);
+            for (uint8 i = 0; i < 6 + rand()%3; i++) 
+            {
+                if(Unit* target = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                {
+                    x = target->GetPositionX() + 10 - rand()%20;
+                    y = target->GetPositionY() + 10 - rand()%20;
+                    z = target->GetPositionZ() + 6 + rand()%5 + 10;
+                    if(z > 95) z = 95 - rand()%5;
+                }
+
+                Creature *pCreature = m_creature->SummonCreature(MOB_SOARING_EAGLE, x, y, z, 0, TEMPSUMMON_CORPSE_DESPAWN, 0);
+                if (pCreature)
+                {
+                    pCreature->AddThreat(m_creature->getVictim(), 1.0f);
+                    pCreature->AI()->AttackStart(m_creature->getVictim());
+                }
+            }
+            SummonEagles_Timer = 999999;
+        } else SummonEagles_Timer -= diff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL mob_soaring_eagleAI : public ScriptedAI
+{
+    mob_soaring_eagleAI(Creature *c) : ScriptedAI(c) {Reset();}
+
+    uint32 EagleSwoop_Timer;
+    bool arrived;
+    uint32 TargetGUID;
+
+    void Reset()
+    {
+        EagleSwoop_Timer = 5000 + rand()%5000;
+        arrived = true;
+        TargetGUID = 0;
+        m_creature->SetUnitMovementFlags(MOVEMENTFLAG_LEVITATING);
+    }
+
+    void Aggro(Unit *who) {DoZoneInCombat();}
+
+    void AttackStart(Unit *who)
+    {
+        if (!InCombat)
+        {
+            Aggro(who);
+            InCombat = true;
+        }
+    }
+
+    void MoveInLineOfSight(Unit *) {}
+
+    void MovementInform(uint32, uint32)
+    {
+        arrived = true;
+        if(TargetGUID)
+        {
+            if(Unit* target = Unit::GetUnit(*m_creature, TargetGUID))
+                m_creature->CastSpell(target, SPELL_EAGLE_SWOOP, true);
+            TargetGUID = 0;
+            m_creature->SetSpeed(MOVE_RUN, 1.2f);
+            EagleSwoop_Timer = 5000 + rand()%5000;
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if(EagleSwoop_Timer < diff) EagleSwoop_Timer = 0;
+        else EagleSwoop_Timer -= diff;
+
+        if(arrived)
+        {
+            if(Unit* target = SelectUnit(SELECT_TARGET_RANDOM, 0))
+            {
+                float x, y, z;
+                if(EagleSwoop_Timer)
+                {
+                    x = target->GetPositionX() + 10 - rand()%20;
+                    y = target->GetPositionY() + 10 - rand()%20;
+                    z = target->GetPositionZ() + 10 + rand()%5;
+                    if(z > 95) z = 95 - rand()%5;
+                }
+                else
+                {
+                    target->GetContactPoint(m_creature, x, y, z);
+                    z += 2;
+                    m_creature->SetSpeed(MOVE_RUN, 5.0f);
+                    TargetGUID = target->GetGUID();
+                }
+                m_creature->AddUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT);
+                m_creature->GetMotionMaster()->MovePoint(0, x, y, z);
+                m_creature->RemoveUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT);
+                arrived = false;
+            }
+        }
+    }
+};
+
+//Soaring Eagle
+CreatureAI* GetAI_mob_soaring_eagle(Creature *_Creature)
+{
+    return new mob_soaring_eagleAI(_Creature);
+}
+
+CreatureAI* GetAI_boss_akilzon(Creature *_Creature)
+{
+    return new boss_akilzonAI(_Creature);
+}
+
+void AddSC_boss_akilzon()
+{
+    Script *newscript = NULL;
+
+    newscript = new Script;
+    newscript->Name="boss_akilzon";
+    newscript->GetAI = GetAI_boss_akilzon;
+    m_scripts[nrscripts++] = newscript;
+
+    newscript = new Script;
+    newscript->Name="mob_akilzon_eagle";
+    newscript->GetAI = GetAI_mob_soaring_eagle;
+    m_scripts[nrscripts++] = newscript;
+}
Index: scripts/zone/zulaman/boss_halazzi.cpp
===================================================================
--- scripts/zone/zulaman/boss_halazzi.cpp	(revision 0)
+++ scripts/zone/zulaman/boss_halazzi.cpp	(revision 0)
@@ -0,0 +1,402 @@
+/* Copyright (C) 2006 - 2008 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* ScriptData
+SDName: boss_Halazzi
+SD%Complete: 80
+SDComment: 
+SDCategory: ZulAman
+EndScriptData */
+
+#include "precompiled.h"
+#include "def_zulaman.h"
+//#include "spell.h"
+
+#define YELL_AGGRO "Get on your knees and bow to da fang and claw!"
+#define SOUND_AGGRO                    12020
+#define YELL_SABER_ONE "You gonna leave in pieces!"
+#define YELL_SABER_TWO "Me gonna carve ya now!"
+#define YELL_SPLIT "Me gonna carve ya now!"
+#define SOUND_SPLIT                    12021
+#define YELL_MERGE "Spirit, come back to me!"
+#define SOUND_MERGE                    12022
+#define YELL_KILL_ONE "You cant fight the power!"
+#define SOUND_KILL_ONE                12026
+#define YELL_KILL_TWO "You gonna fail!"
+#define SOUND_KILL_TWO                12027
+#define YELL_DEATH "Chaga... choka'jinn."
+#define SOUND_DEATH                    12028
+#define YELL_BERSERK "Whatch you be doing? Pissin' yourselves..."
+#define SOUND_BERSERK                12025
+
+#define SPELL_DUAL_WIELD                29651
+#define SPELL_SABER_LASH                43267
+#define SPELL_FRENZY                    43139
+#define SPELL_FLAMESHOCK                43303
+#define SPELL_EARTHSHOCK                43305
+#define SPELL_TRANSFORM_SPLIT           43142
+#define SPELL_TRANSFORM_SPLIT2          43573
+#define SPELL_TRANSFORM_MERGE           43271
+#define SPELL_SUMMON_LYNX               43143
+#define SPELL_SUMMON_TOTEM              43302
+#define SPELL_BERSERK                   45078
+
+#define MOB_SPIRIT_LYNX                 24143
+#define SPELL_LYNX_FRENZY               43290
+#define SPELL_SHRED_ARMOR               43243
+
+#define MOB_TOTEM                       24224
+#define SPELL_LIGHTNING                 43301
+
+enum PhaseHalazzi
+{
+    PHASE_NONE = 0,
+    PHASE_LYNX = 1,
+    PHASE_SPLIT = 2,
+    PHASE_HUMAN = 3,
+    PHASE_MERGE = 4,
+    PHASE_ENRAGE = 5
+};
+
+struct MANGOS_DLL_DECL boss_halazziAI : public ScriptedAI
+{
+    boss_halazziAI(Creature *c) : ScriptedAI(c)
+    { 
+        pInstance = ((ScriptedInstance*)c->GetInstanceData());
+        Reset();
+        // wait for core patch be accepted
+        SpellEntry *TempSpell = (SpellEntry*)GetSpellStore()->LookupEntry(SPELL_SUMMON_TOTEM);
+        if(TempSpell && TempSpell->EffectImplicitTargetA[0] != 1)
+            TempSpell->EffectImplicitTargetA[0] = 1;
+        // need to find out what controls totem's spell cooldown
+        TempSpell = (SpellEntry*)GetSpellStore()->LookupEntry(SPELL_LIGHTNING);
+        if(TempSpell && TempSpell->CastingTimeIndex != 5)
+            TempSpell->CastingTimeIndex = 5; // 2000 ms casting time
+    }
+
+    ScriptedInstance *pInstance;
+
+    uint32 FrenzyTimer;
+    uint32 SaberlashTimer;
+    uint32 ShockTimer;
+    uint32 TotemTimer;
+    uint32 CheckTimer;
+    uint32 BerserkTimer;
+
+    uint32 TransformCount;
+
+    PhaseHalazzi Phase;
+
+    uint64 LynxGUID;
+
+    void Reset()
+    {
+		if(pInstance)
+            pInstance->SetData(DATA_HALAZZIEVENT, NOT_STARTED);
+
+        TransformCount = 0;
+        BerserkTimer = 600000;
+        CheckTimer = 1000;
+
+        DoCast(m_creature, SPELL_DUAL_WIELD, true);
+
+        Phase = PHASE_NONE;
+        EnterPhase(PHASE_LYNX);
+    }
+
+    void Aggro(Unit *who)
+    {
+		if(pInstance)
+            pInstance->SetData(DATA_HALAZZIEVENT, IN_PROGRESS);
+
+        DoYell(YELL_AGGRO, LANG_UNIVERSAL, NULL);
+        DoPlaySoundToSet(m_creature, SOUND_AGGRO);
+
+        EnterPhase(PHASE_LYNX);
+    }
+
+    void JustSummoned(Creature* summon)
+    {
+        summon->AI()->AttackStart(m_creature->getVictim());
+        if(summon->GetEntry() == MOB_SPIRIT_LYNX)
+            LynxGUID = summon->GetGUID();
+    }
+
+    void DamageTaken(Unit *done_by, uint32 &damage)
+    {
+        if(damage >= m_creature->GetHealth() && Phase != PHASE_ENRAGE)
+            damage = 0;
+    }
+
+    void SpellHit(Unit*, const SpellEntry *spell)
+    {
+        if(spell->Id == SPELL_TRANSFORM_SPLIT2)
+            EnterPhase(PHASE_HUMAN);
+    }
+
+    void AttackStart(Unit *who)
+    {
+        if(Phase != PHASE_MERGE) ScriptedAI::AttackStart(who);
+    }
+
+    void EnterPhase(PhaseHalazzi NextPhase)
+    {
+        switch(NextPhase)
+        {
+        case PHASE_LYNX:
+        case PHASE_ENRAGE:
+            if(Phase == PHASE_MERGE)
+            {
+                m_creature->CastSpell(m_creature, SPELL_TRANSFORM_MERGE, true);
+                m_creature->Attack(m_creature->getVictim(), true);
+                m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
+            }
+            if(Unit *Lynx = Unit::GetUnit(*m_creature, LynxGUID))
+            {
+                Lynx->SetVisibility(VISIBILITY_OFF);
+                Lynx->setDeathState(JUST_DIED);
+            }
+            m_creature->SetMaxHealth(600000);
+            m_creature->SetHealth(600000 - 150000 * TransformCount);
+            FrenzyTimer = 16000;
+            SaberlashTimer = 20000;
+            ShockTimer = 10000;
+            TotemTimer = 12000;
+            break;
+        case PHASE_SPLIT:
+            DoYell(YELL_SPLIT, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, SOUND_SPLIT);
+            m_creature->CastSpell(m_creature, SPELL_TRANSFORM_SPLIT, true);
+            break;
+        case PHASE_HUMAN:
+            //DoCast(m_creature, SPELL_SUMMON_LYNX, true);
+            DoSpawnCreature(MOB_SPIRIT_LYNX, 0,0,0,0, TEMPSUMMON_CORPSE_DESPAWN, 0);
+            m_creature->SetMaxHealth(400000);
+            m_creature->SetHealth(400000);
+            ShockTimer = 10000;
+            TotemTimer = 12000;
+            break;
+        case PHASE_MERGE:
+            if(Unit *Lynx = Unit::GetUnit(*m_creature, LynxGUID))
+            {
+                DoYell(YELL_MERGE, LANG_UNIVERSAL, NULL);
+                DoPlaySoundToSet(m_creature, SOUND_MERGE);
+                Lynx->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                Lynx->GetMotionMaster()->Clear();
+                Lynx->GetMotionMaster()->MoveFollow(m_creature, 0, 0);
+                m_creature->GetMotionMaster()->Clear();
+                m_creature->GetMotionMaster()->MoveFollow(Lynx, 0, 0);
+                TransformCount++;
+            }break;
+        default:
+            break;
+        }
+        Phase = NextPhase;
+    }
+
+     void UpdateAI(const uint32 diff)
+    {
+        if(!m_creature->SelectHostilTarget() && !m_creature->getVictim())
+            return;
+
+        if(BerserkTimer < diff)
+        {
+            DoYell(YELL_BERSERK, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, SOUND_BERSERK);
+            DoCast(m_creature, SPELL_BERSERK, true);
+            BerserkTimer = 60000;
+        }else BerserkTimer -= diff;
+
+        if(Phase == PHASE_LYNX || Phase == PHASE_ENRAGE)
+        {
+            if(SaberlashTimer < diff)
+            {
+                // A tank with more than 490 defense skills should receive no critical hit
+                //m_creature->CastSpell(m_creature, 41296, true);
+                m_creature->CastSpell(m_creature->getVictim(), SPELL_SABER_LASH, true);
+                //m_creature->RemoveAurasDueToSpell(41296);
+                SaberlashTimer = 30000;
+            }else SaberlashTimer -= diff;
+
+            if(FrenzyTimer < diff)
+            {
+                DoCast(m_creature, SPELL_FRENZY);
+                FrenzyTimer = (10+rand()%5)*1000;
+            }else FrenzyTimer -= diff;
+
+            if(Phase == PHASE_LYNX)
+                if(CheckTimer < diff)
+                {
+                    if(m_creature->GetHealth() * 4 < m_creature->GetMaxHealth() * (3 - TransformCount))
+                        EnterPhase(PHASE_SPLIT);
+                    CheckTimer = 1000;
+                }else CheckTimer -= diff;
+        }
+
+        if(Phase == PHASE_HUMAN || Phase == PHASE_ENRAGE)
+        {
+            if(TotemTimer < diff)
+            {
+                DoCast(m_creature, SPELL_SUMMON_TOTEM);
+                TotemTimer = 20000;
+            }else TotemTimer -= diff;
+
+            if(ShockTimer < diff)
+            {
+                if(Unit* target = SelectUnit(SELECT_TARGET_RANDOM,0))
+                {
+                    if(target->IsNonMeleeSpellCasted(false))
+                        DoCast(target,SPELL_EARTHSHOCK);
+                    else
+                        DoCast(target,SPELL_FLAMESHOCK);
+                    ShockTimer = 10000 + rand()%5000;
+                }
+            }else ShockTimer -= diff;
+
+            if(Phase == PHASE_HUMAN)
+                if(CheckTimer < diff)
+                {
+                    if(m_creature->GetHealth() * 10 < m_creature->GetMaxHealth())
+                        EnterPhase(PHASE_MERGE);
+                    else
+                    {
+                        Unit *Lynx = Unit::GetUnit(*m_creature, LynxGUID);
+                        if(Lynx && Lynx->GetHealth() * 10 < Lynx->GetMaxHealth())
+                            EnterPhase(PHASE_MERGE);
+                    }
+                    CheckTimer = 1000;
+                }else CheckTimer -= diff;
+        }
+
+        if(Phase == PHASE_MERGE)
+        {
+            if(CheckTimer < diff)
+            {
+                Unit *Lynx = Unit::GetUnit(*m_creature, LynxGUID);
+                if(Lynx && m_creature->IsWithinDistInMap(Lynx, 6.0f))
+                {
+                    if(TransformCount < 3)
+                        EnterPhase(PHASE_LYNX);
+                    else
+                        EnterPhase(PHASE_ENRAGE);
+                }
+                CheckTimer = 1000;
+            }else CheckTimer -= diff;
+        }
+
+        DoMeleeAttackIfReady();
+    }
+
+    void KilledUnit(Unit* victim)
+    {
+        switch(rand()%2)
+        {
+        case 0:
+            DoYell(YELL_KILL_ONE, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, SOUND_KILL_ONE);
+            break;
+
+        case 1:
+            DoYell(YELL_KILL_TWO, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, SOUND_KILL_TWO);
+            break;
+        }
+    }
+
+    void JustDied(Unit* Killer)
+    {
+		if(pInstance)
+            pInstance->SetData(DATA_HALAZZIEVENT, DONE);
+
+        DoYell(YELL_DEATH, LANG_UNIVERSAL, NULL);
+        DoPlaySoundToSet(m_creature, SOUND_DEATH);
+    }
+};
+
+// Spirits Lynx AI
+
+struct MANGOS_DLL_DECL boss_spiritlynxAI : public ScriptedAI
+{
+    boss_spiritlynxAI(Creature *c) : ScriptedAI(c) { Reset(); }
+
+    uint32 FrenzyTimer;
+    uint32 shredder_timer;
+
+    void Reset()
+    {
+        FrenzyTimer = (30+rand()%20)*1000;  //frenzy every 30-50 seconds
+        shredder_timer = 4000;
+    }
+
+    void DamageTaken(Unit *done_by, uint32 &damage)
+    {
+        if(damage >= m_creature->GetHealth())
+            damage = 0;
+    }
+
+    void AttackStart(Unit *who)
+    {
+        if(!m_creature->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
+            ScriptedAI::AttackStart(who);
+    }
+
+    void Aggro(Unit *who) {DoZoneInCombat();}
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+            return;
+
+        if(FrenzyTimer < diff)
+        {
+            DoCast(m_creature, SPELL_LYNX_FRENZY);
+            FrenzyTimer = (30+rand()%20)*1000;
+        }else FrenzyTimer -= diff;
+
+        if(shredder_timer < diff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_SHRED_ARMOR);
+            shredder_timer = 4000;
+        }else shredder_timer -= diff;
+
+        DoMeleeAttackIfReady();
+    }
+
+};
+
+CreatureAI* GetAI_boss_halazziAI(Creature *_Creature)
+{
+    return new boss_halazziAI (_Creature);
+}
+
+CreatureAI* GetAI_boss_spiritlynxAI(Creature *_Creature)
+{
+    return new boss_spiritlynxAI (_Creature);
+}
+
+void AddSC_boss_halazzi()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name="boss_halazzi";
+    newscript->GetAI = GetAI_boss_halazziAI;
+    m_scripts[nrscripts++] = newscript;
+
+    newscript = new Script;
+    newscript->Name="mob_halazzi_lynx";
+    newscript->GetAI = GetAI_boss_spiritlynxAI;
+    m_scripts[nrscripts++] = newscript;
+}
Index: scripts/zone/zulaman/boss_hexlord.cpp
===================================================================
--- scripts/zone/zulaman/boss_hexlord.cpp	(revision 0)
+++ scripts/zone/zulaman/boss_hexlord.cpp	(revision 0)
@@ -0,0 +1,932 @@
+/* Copyright ?2006,2007 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* ScriptData
+SDName: Boss_Hex_Lord_Malacrass
+SD%Complete:
+SDComment: 
+SDCategory: Zul'Aman
+EndScriptData */
+
+#include "precompiled.h"
+#include "def_zulaman.h"
+
+#define YELL_AGGRO              "Da shadow gonna fall on you... "
+#define SOUND_YELL_AGGRO        12041
+#define YELL_SPIRIT_BOLTS       "Your soul gonna bleed!"
+#define SOUND_YELL_SPIRIT_BOLTS 12047
+#define YELL_DRAIN_POWER        "Darkness comin\' for you"
+#define SOUND_YELL_DRAIN_POWER  12046
+#define YELL_KILL_ONE           "Dis a nightmare ya don\' wake up from!"
+#define SOUND_YELL_KILL_ONE     12043
+#define YELL_KILL_TWO           "Azzaga choogo zinn!"
+#define SOUND_YELL_KILL_TWO     12044
+#define YELL_DEATH              "Dis not... da end of me..."
+#define SOUND_YELL_DEATH        12051
+
+#define SPELL_SPIRIT_BOLTS      43383
+#define SPELL_DRAIN_POWER       44131
+#define SPELL_SIPHON_SOUL       43501
+
+#define MOB_TEMP_TRIGGER        23920
+
+//Defines for various powers he uses after using soul drain
+
+//Druid
+#define SPELL_DR_LIFEBLOOM      43421
+#define SPELL_DR_THORNS         43420
+#define SPELL_DR_MOONFIRE       43545
+
+//Hunter
+#define SPELL_HU_EXPLOSIVE_TRAP 43444
+#define SPELL_HU_FREEZING_TRAP  43447
+#define SPELL_HU_SNAKE_TRAP     43449
+
+//Mage
+#define SPELL_MG_FIREBALL       41383
+#define SPELL_MG_FROSTBOLT      43428
+#define SPELL_MG_FROST_NOVA     43426
+#define SPELL_MG_ICE_LANCE      43427
+
+//Paladin
+#define SPELL_PA_CONSECRATION   43429
+#define SPELL_PA_HOLY_LIGHT     43451
+#define SPELL_PA_AVENGING_WRATH 43430
+
+//Priest
+#define SPELL_PR_HEAL           41372
+#define SPELL_PR_MIND_CONTROL   43550
+#define SPELL_PR_MIND_BLAST     41374
+#define SPELL_PR_SW_DEATH       41375
+#define SPELL_PR_PSYCHIC_SCREAM 43432
+#define SPELL_PR_PAIN_SUPP      44416
+
+//Rogue
+#define SPELL_RO_BLIND          43433
+#define SPELL_RO_SLICE_DICE     43457
+#define SPELL_RO_WOUND_POISON   39665
+
+//Shaman
+#define SPELL_SH_FIRE_NOVA      43436
+#define SPELL_SH_HEALING_WAVE   43548
+#define SPELL_SH_CHAIN_LIGHT    43435
+
+//Warlock
+#define SPELL_WL_CURSE_OF_DOOM  43439
+#define SPELL_WL_RAIN_OF_FIRE   43440
+#define SPELL_WL_UNSTABLE_AFFL  35183
+
+//Warrior
+#define SPELL_WR_SPELL_REFLECT  43443
+#define SPELL_WR_WHIRLWIND      43442
+#define SPELL_WR_MORTAL_STRIKE  43441
+
+#define ORIENT                  1.5696
+#define POS_Y                   921.2795
+#define POS_Z                   33.8883
+
+static float Pos_X[4] = {112.8827, 107.8827, 122.8827, 127.8827};
+
+static uint32 AddEntryList[8]=
+{
+    24240, //Alyson Antille
+    24241, //Thurg
+    24242, //Slither
+    24243, //Lord Raadan
+    24244, //Gazakroth
+    24245, //Fenstalker
+    24246, //Darkheart
+    24247  //Koragg
+};
+
+enum AbilityTarget
+{
+    ABILITY_TARGET_SELF = 0,
+    ABILITY_TARGET_VICTIM = 1,
+    ABILITY_TARGET_ENEMY = 2,
+    ABILITY_TARGET_HEAL = 3,
+    ABILITY_TARGET_BUFF = 4,
+    ABILITY_TARGET_SPECIAL = 5
+};
+
+struct PlayerAbilityStruct
+{
+    uint32 spell;
+    AbilityTarget target;
+    uint32 cooldown;
+};
+
+static PlayerAbilityStruct PlayerAbility[][3] =
+{
+    // 1 warrior
+    {{SPELL_WR_SPELL_REFLECT, ABILITY_TARGET_SELF, 10000},
+    {SPELL_WR_WHIRLWIND, ABILITY_TARGET_SELF, 10000},
+    {SPELL_WR_MORTAL_STRIKE, ABILITY_TARGET_VICTIM, 6000}},
+    // 2 paladin
+    {{SPELL_PA_CONSECRATION, ABILITY_TARGET_SELF, 10000},
+    {SPELL_PA_HOLY_LIGHT, ABILITY_TARGET_HEAL, 10000},
+    {SPELL_PA_AVENGING_WRATH, ABILITY_TARGET_SELF, 10000}},
+    // 3 hunter
+    {{SPELL_HU_EXPLOSIVE_TRAP, ABILITY_TARGET_SELF, 10000},
+    {SPELL_HU_FREEZING_TRAP, ABILITY_TARGET_SELF, 10000},
+    {SPELL_HU_SNAKE_TRAP, ABILITY_TARGET_SELF, 10000}},
+    // 4 rogue
+    {{SPELL_RO_WOUND_POISON, ABILITY_TARGET_VICTIM, 3000},
+    {SPELL_RO_SLICE_DICE, ABILITY_TARGET_SELF, 10000},
+    {SPELL_RO_BLIND, ABILITY_TARGET_ENEMY, 10000}},
+    // 5 priest
+    {{SPELL_PR_PAIN_SUPP, ABILITY_TARGET_HEAL, 10000},
+    {SPELL_PR_HEAL, ABILITY_TARGET_HEAL, 10000},
+    {SPELL_PR_PSYCHIC_SCREAM, ABILITY_TARGET_SELF, 10000}},
+    // 5* shadow priest
+    {{SPELL_PR_MIND_CONTROL, ABILITY_TARGET_ENEMY, 15000},
+    {SPELL_PR_MIND_BLAST, ABILITY_TARGET_ENEMY, 5000},
+    {SPELL_PR_SW_DEATH, ABILITY_TARGET_ENEMY, 10000}},
+    // 7 shaman
+    {{SPELL_SH_FIRE_NOVA, ABILITY_TARGET_SELF, 10000},
+    {SPELL_SH_HEALING_WAVE, ABILITY_TARGET_HEAL, 10000},
+    {SPELL_SH_CHAIN_LIGHT, ABILITY_TARGET_ENEMY, 8000}},
+    // 8 mage
+    {{SPELL_MG_FIREBALL, ABILITY_TARGET_ENEMY, 5000},
+    {SPELL_MG_FROSTBOLT, ABILITY_TARGET_ENEMY, 5000},
+    {SPELL_MG_ICE_LANCE, ABILITY_TARGET_SPECIAL, 2000}},
+    // 9 warlock
+    {{SPELL_WL_CURSE_OF_DOOM, ABILITY_TARGET_ENEMY, 10000},
+    {SPELL_WL_RAIN_OF_FIRE, ABILITY_TARGET_ENEMY, 10000},
+    {SPELL_WL_UNSTABLE_AFFL, ABILITY_TARGET_ENEMY, 10000}},
+    // 11 druid
+    {{SPELL_DR_LIFEBLOOM, ABILITY_TARGET_HEAL, 10000},
+    {SPELL_DR_THORNS, ABILITY_TARGET_SELF, 10000},
+    {SPELL_DR_MOONFIRE, ABILITY_TARGET_ENEMY, 8000}}
+};
+
+struct MANGOS_DLL_DECL boss_hexlord_addAI : public ScriptedAI
+{
+    ScriptedInstance* pInstance;
+
+    boss_hexlord_addAI(Creature* c) : ScriptedAI(c)
+    {
+        pInstance = ((ScriptedInstance*)c->GetInstanceData());
+        Reset();
+    }
+
+    void Reset() {}
+
+    void Aggro(Unit* who) {DoZoneInCombat();}
+
+    void UpdateAI(const uint32 diff)
+    {
+        if(pInstance && pInstance->GetData(DATA_HEXLORDEVENT) != IN_PROGRESS)
+            EnterEvadeMode();
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL boss_hex_lord_malacrassAI : public ScriptedAI
+{
+    boss_hex_lord_malacrassAI(Creature *c) : ScriptedAI(c)
+    {
+        pInstance = ((ScriptedInstance*)c->GetInstanceData());
+        SelectAddEntry();
+        for(uint8 i = 0; i < 4; ++i)
+            AddGUID[i] = 0;
+        Reset();
+    }
+
+    ScriptedInstance *pInstance;
+
+    uint64 AddGUID[4];
+    uint32 AddEntry[4];
+
+    uint64 PlayerGUID;
+
+    uint32 SpiritBolts_Timer;
+    uint32 DrainPower_Timer;
+    uint32 SiphonSoul_Timer;
+    uint32 PlayerAbility_Timer;
+    uint32 CheckAddState_Timer;
+
+    uint32 PlayerClass;
+
+    Unit* SoulDrainTarget;
+
+    void Reset()
+    {
+        if(pInstance)
+            pInstance->SetData(DATA_HEXLORDEVENT, NOT_STARTED);
+
+        SpiritBolts_Timer = 20000;
+        DrainPower_Timer = 60000;
+        SiphonSoul_Timer = 100000;
+        PlayerAbility_Timer = 99999;
+        CheckAddState_Timer = 5000;
+
+        SpawnAdds();
+
+        m_creature->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_DISPLAY, 46916);
+        m_creature->SetUInt32Value(UNIT_VIRTUAL_ITEM_INFO, 50268674);
+        m_creature->SetByteValue(UNIT_FIELD_BYTES_2, 0, SHEATH_STATE_MELEE );
+    }
+
+    void Aggro(Unit* who)
+    {
+        if(pInstance)
+            pInstance->SetData(DATA_HEXLORDEVENT, IN_PROGRESS);
+
+        DoZoneInCombat();
+        DoYell(YELL_AGGRO, LANG_UNIVERSAL, NULL);
+        DoPlaySoundToSet(m_creature, SOUND_YELL_AGGRO);
+
+        for(uint8 i = 0; i < 4; ++i)
+        {
+            Unit* Temp = Unit::GetUnit((*m_creature),AddGUID[i]);
+            if(Temp && Temp->isAlive())
+                ((Creature*)Temp)->AI()->AttackStart(m_creature->getVictim());
+            else
+            {
+                EnterEvadeMode();
+                break;
+            }
+        }
+    }
+
+    void KilledUnit(Unit* victim)
+    {
+        switch(rand()%2)
+        {
+        case 0:
+            DoYell(YELL_KILL_ONE, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, SOUND_YELL_KILL_ONE);
+            break;
+        case 1:
+            DoYell(YELL_KILL_TWO, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, SOUND_YELL_KILL_TWO);
+            break;
+        }
+    }
+
+    void JustDied(Unit* victim)
+    {
+        if(pInstance)
+            pInstance->SetData(DATA_HEXLORDEVENT, DONE);
+
+        DoYell(YELL_DEATH, LANG_UNIVERSAL, NULL);
+        DoPlaySoundToSet(m_creature, SOUND_YELL_DEATH);
+
+        for(uint8 i = 0; i < 4 ; ++i)
+        {
+            Unit* Temp = Unit::GetUnit((*m_creature),AddGUID[i]);
+            if(Temp && Temp->isAlive())
+                Temp->DealDamage(Temp, Temp->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }
+    }
+
+    void SelectAddEntry()
+    {
+        std::vector<uint32> AddList;
+
+        for(uint8 i = 0; i < 8; ++i)
+            AddList.push_back(AddEntryList[i]);
+
+        while(AddList.size() > 4)
+            AddList.erase(AddList.begin()+rand()%AddList.size());
+
+        uint8 i = 0;
+        for(std::vector<uint32>::iterator itr = AddList.begin(); itr != AddList.end(); ++itr, ++i)
+            AddEntry[i] = *itr;
+    }
+
+    void SpawnAdds()
+    {
+        for(uint8 i = 0; i < 4; ++i)
+        {
+            Creature *pCreature = ((Creature*)Unit::GetUnit((*m_creature), AddGUID[i]));
+            if(!pCreature || !pCreature->isAlive())
+            {
+                if(pCreature) pCreature->setDeathState(DEAD);
+                pCreature = m_creature->SummonCreature(AddEntry[i], Pos_X[i], POS_Y, POS_Z, ORIENT, TEMPSUMMON_DEAD_DESPAWN, 0);
+                if(pCreature) AddGUID[i] = pCreature->GetGUID();
+            }
+            else
+            {
+                pCreature->AI()->EnterEvadeMode();
+                pCreature->Relocate(Pos_X[i], POS_Y, POS_Z, ORIENT);
+                pCreature->StopMoving();
+            }
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if(!m_creature->SelectHostilTarget() && !m_creature->getVictim() )
+            return;
+
+        if(CheckAddState_Timer < diff)
+        {
+            for(uint8 i = 0; i < 4; ++i)
+            {
+                Unit* Temp = Unit::GetUnit((*m_creature),AddGUID[i]);
+                if(Temp && Temp->isAlive() && !Temp->getVictim())
+                    ((Creature*)Temp)->AI()->AttackStart(m_creature->getVictim());
+            }
+            CheckAddState_Timer = 5000;
+        }else CheckAddState_Timer -= diff;
+
+        if(DrainPower_Timer < diff)
+        {
+            m_creature->CastSpell(m_creature, SPELL_DRAIN_POWER, true);
+            DoYell(YELL_DRAIN_POWER, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, SOUND_YELL_DRAIN_POWER);
+            DrainPower_Timer = 40000 + rand()%15000;    // must cast in 60 sec, or buff/debuff will disappear
+        }else DrainPower_Timer -= diff;
+
+        if(SpiritBolts_Timer < diff)
+        {
+            if(DrainPower_Timer < 12000)    // channel 10 sec
+                SpiritBolts_Timer = 13000;  // cast drain power first
+            else
+            {
+                m_creature->CastSpell(m_creature, SPELL_SPIRIT_BOLTS, false);
+                DoYell(YELL_SPIRIT_BOLTS, LANG_UNIVERSAL, NULL);
+                DoPlaySoundToSet(m_creature, SOUND_YELL_SPIRIT_BOLTS);
+                SpiritBolts_Timer = 40000;
+                SiphonSoul_Timer = 10000;  // ready to drain
+                PlayerAbility_Timer = 99999;
+            }
+        }else SpiritBolts_Timer -= diff;
+
+        if(SiphonSoul_Timer < diff)
+        {
+            Player* target = SelectRandomPlayer(50);
+            Unit *trigger = DoSpawnCreature(MOB_TEMP_TRIGGER, 0, 0, 0, 0, TEMPSUMMON_TIMED_DESPAWN, 30000);
+            if(!target || !trigger) EnterEvadeMode();
+            else
+            {
+                trigger->SetUInt32Value(UNIT_FIELD_DISPLAYID, 11686);
+                trigger->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                trigger->CastSpell(target, SPELL_SIPHON_SOUL, true);
+                trigger->GetMotionMaster()->MoveChase(m_creature);
+
+                //m_creature->CastSpell(target, SPELL_SIPHON_SOUL, true);
+                //m_creature->SetUInt64Value(UNIT_FIELD_CHANNEL_OBJECT, target->GetGUID());
+                //m_creature->SetUInt32Value(UNIT_CHANNEL_SPELL, SPELL_SIPHON_SOUL);
+
+                PlayerGUID = target->GetGUID();
+                PlayerAbility_Timer = 8000 + rand()%2000;
+                PlayerClass = target->getClass() - 1;
+                if(PlayerClass == 10) PlayerClass = 9; // druid
+                if(PlayerClass == 4 && target->HasSpell(15473)) PlayerClass = 5; // shadow priest
+                SiphonSoul_Timer = 99999;   // buff lasts 30 sec
+            }
+        }else SiphonSoul_Timer -= diff;
+
+        if(PlayerAbility_Timer < diff)
+        {
+            //Unit* target = Unit::GetUnit(*m_creature, PlayerGUID);
+            //if(target && target->isAlive())
+            {
+                UseAbility();
+                PlayerAbility_Timer = 8000 + rand()%2000;
+            }
+        }else PlayerAbility_Timer -= diff;
+
+        DoMeleeAttackIfReady();
+    }
+
+    void UseAbility()
+    {
+        uint32 random = rand()%3;
+        Unit *target = NULL;
+        switch(PlayerAbility[PlayerClass][random].target)
+        {
+        case ABILITY_TARGET_SELF:
+            target = m_creature;
+            break;
+        case ABILITY_TARGET_VICTIM:
+            target = m_creature->getVictim();
+            break;
+        case ABILITY_TARGET_ENEMY:
+        default:
+            target = SelectUnit(SELECT_TARGET_RANDOM, 0);
+            break;
+        case ABILITY_TARGET_HEAL:
+            target = DoSelectLowestHpFriendly(50, 0);
+            break;
+        case ABILITY_TARGET_BUFF:
+            {
+                std::list<Creature*> templist = DoFindFriendlyMissingBuff(50, PlayerAbility[PlayerClass][random].spell);
+                if(!templist.empty()) target = *(templist.begin());
+            }
+            break;
+        }
+        m_creature->CastSpell(target, PlayerAbility[PlayerClass][random].spell, false);
+    }
+
+    Player* SelectRandomPlayer(float range = 0.0f, bool alive = true)
+    {
+        Map *map = m_creature->GetMap();
+        if (!map->IsDungeon()) return NULL;
+
+        InstanceMap::PlayerList PlayerList = ((InstanceMap*)map)->GetPlayers();
+        InstanceMap::PlayerList::iterator i;
+        while(PlayerList.size())
+        {
+            i = PlayerList.begin();
+            advance(i, rand()%PlayerList.size());
+            if((range == 0.0f || m_creature->IsWithinDistInMap(*i, range))
+                && (!alive || (*i)->isAlive()))
+                return *i;
+            else
+                PlayerList.erase(i);
+        }
+        return NULL;
+    }
+};
+
+#define SPELL_BLOODLUST       43578
+#define SPELL_CLEAVE          15496
+
+struct MANGOS_DLL_DECL boss_thurgAI : public boss_hexlord_addAI
+{
+
+    boss_thurgAI(Creature *c) : boss_hexlord_addAI(c) {}
+
+    uint32 bloodlust_timer;
+    uint32 cleave_timer;
+
+    void Reset()
+    {
+        bloodlust_timer = 15000;
+        cleave_timer = 10000;
+
+        boss_hexlord_addAI::Reset();
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if(!m_creature->SelectHostilTarget() || !m_creature->getVictim() )
+            return;
+
+        boss_hexlord_addAI::UpdateAI(diff);
+
+        if(bloodlust_timer < diff)
+        {
+            std::list<Creature*> templist = DoFindFriendlyMissingBuff(50, SPELL_BLOODLUST);
+            if(!templist.empty()) 
+            {
+                Unit* target = *(templist.begin());
+                m_creature->CastSpell(target, SPELL_BLOODLUST, false);
+            }
+            bloodlust_timer = 12000;
+        }else bloodlust_timer -= diff;
+
+        if(cleave_timer < diff)
+        {
+            m_creature->CastSpell(m_creature->getVictim(),SPELL_CLEAVE, false);
+            cleave_timer = 12000; //3 sec cast
+        }else cleave_timer -= diff;
+    }
+};
+
+#define SPELL_FLASH_HEAL     43575
+#define SPELL_DISPEL_MAGIC   43577
+
+struct MANGOS_DLL_DECL boss_alyson_antilleAI : public boss_hexlord_addAI
+{
+    //Holy Priest
+    boss_alyson_antilleAI(Creature *c) : boss_hexlord_addAI(c) {}
+
+    uint32 flashheal_timer;
+    uint32 dispelmagic_timer;
+
+    void Reset()
+    {
+        flashheal_timer = 2500;
+        dispelmagic_timer = 10000;
+
+        //AcquireGUID();
+
+        boss_hexlord_addAI::Reset();
+    }
+
+    void AttackStart(Unit* who)
+    {
+        if (!who)
+            return;
+
+        if (who->isTargetableForAttack())
+        {
+            if(m_creature->Attack(who, false))
+            {
+                m_creature->GetMotionMaster()->MoveChase(who, 20);
+                m_creature->AddThreat(who, 0.0f);
+            }
+
+            if (!InCombat)
+            {
+                Aggro(who);
+                InCombat = true;
+            }
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if(!m_creature->SelectHostilTarget() || !m_creature->getVictim() )
+            return;
+
+        boss_hexlord_addAI::UpdateAI(diff);
+
+
+        if(flashheal_timer < diff)
+        {
+            Unit* target = DoSelectLowestHpFriendly(99, 30000);
+            if(target)
+            {
+                if(target->IsWithinDistInMap(m_creature, 50))
+                    m_creature->CastSpell(target,SPELL_FLASH_HEAL, false);
+                else
+                {
+                    // bugged
+                    //m_creature->GetMotionMaster()->Clear();
+                    //m_creature->GetMotionMaster()->MoveChase(target, 20);
+                }
+            }
+            else
+            {
+                if(rand()%2)
+                {
+                    Unit* target = DoSelectLowestHpFriendly(50, 0);
+                    m_creature->CastSpell(target, SPELL_DISPEL_MAGIC, false);
+                }
+                else
+                    m_creature->CastSpell(SelectUnit(SELECT_TARGET_RANDOM, 0), SPELL_DISPEL_MAGIC, false);
+            }
+            flashheal_timer = 2500;
+        }else flashheal_timer -= diff;
+
+        /*if(dispelmagic_timer < diff)
+        {
+        if(rand()%2)
+        {
+        Unit* target = SelectTarget();
+
+        m_creature->CastSpell(target, SPELL_DISPEL_MAGIC, false);
+        }
+        else
+        m_creature->CastSpell(SelectUnit(SELECT_TARGET_RANDOM, 0), SPELL_DISPEL_MAGIC, false);
+
+        dispelmagic_timer = 12000;
+        }else dispelmagic_timer -= diff;*/
+    }
+};
+
+#define SPELL_FIREBOLT        43584
+
+struct MANGOS_DLL_DECL boss_gazakrothAI : public boss_hexlord_addAI
+{
+    boss_gazakrothAI(Creature *c) : boss_hexlord_addAI(c)  {}
+
+    uint32 firebolt_timer;
+
+    void Reset()
+    {
+        firebolt_timer = 2000;
+        boss_hexlord_addAI::Reset();
+    }
+
+    void AttackStart(Unit* who)
+    {
+        if (!who)
+            return;
+
+        if (who->isTargetableForAttack())
+        {
+            if(m_creature->Attack(who, false))
+            {
+                m_creature->GetMotionMaster()->MoveChase(who, 20);
+                m_creature->AddThreat(who, 0.0f);
+            }
+
+            if (!InCombat)
+            {
+                Aggro(who);
+                InCombat = true;
+            }
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if(!m_creature->SelectHostilTarget() || !m_creature->getVictim() )
+            return;
+
+        boss_hexlord_addAI::UpdateAI(diff);
+
+        if(firebolt_timer < diff)
+        {
+            m_creature->CastSpell(m_creature->getVictim(),SPELL_FIREBOLT, false);
+            firebolt_timer = 700;
+        }else firebolt_timer -= diff;
+    }
+};
+
+#define SPELL_FLAME_BREATH    43582
+#define SPELL_THUNDERCLAP     43583
+
+struct MANGOS_DLL_DECL boss_lord_raadanAI : public boss_hexlord_addAI
+{
+    boss_lord_raadanAI(Creature *c) : boss_hexlord_addAI(c)  {}
+
+    uint32 flamebreath_timer;
+    uint32 thunderclap_timer;
+
+    void Reset()
+    {
+        flamebreath_timer = 8000;
+        thunderclap_timer = 13000;
+
+        boss_hexlord_addAI::Reset();
+
+    }
+    void UpdateAI(const uint32 diff)
+    {
+        if(!m_creature->SelectHostilTarget() || !m_creature->getVictim() )
+            return;
+
+        boss_hexlord_addAI::UpdateAI(diff);
+
+        if (thunderclap_timer < diff)
+        { 
+            m_creature->CastSpell(m_creature->getVictim(),SPELL_THUNDERCLAP, false);
+            thunderclap_timer = 12000;
+        }else thunderclap_timer -= diff;
+
+        if (flamebreath_timer < diff)
+        {
+            m_creature->CastSpell(m_creature->getVictim(),SPELL_FLAME_BREATH, false);
+            flamebreath_timer = 12000;
+        }else flamebreath_timer -= diff;
+    }
+};
+
+#define SPELL_PSYCHIC_WAIL   43590
+
+struct MANGOS_DLL_DECL boss_darkheartAI : public boss_hexlord_addAI
+{
+    boss_darkheartAI(Creature *c) : boss_hexlord_addAI(c)  {}
+
+    uint32 psychicwail_timer;
+
+    void Reset()
+    {
+        psychicwail_timer = 8000;
+
+        boss_hexlord_addAI::Reset();
+
+    }
+    void UpdateAI(const uint32 diff)
+    {
+        if(!m_creature->SelectHostilTarget() || !m_creature->getVictim() )
+            return;
+
+        boss_hexlord_addAI::UpdateAI(diff);
+
+        if (psychicwail_timer < diff)
+        { 
+            m_creature->CastSpell(m_creature->getVictim(),SPELL_PSYCHIC_WAIL, false);
+            psychicwail_timer = 12000;
+        }else psychicwail_timer -= diff;
+    }
+};
+
+#define SPELL_VENOM_SPIT    43579
+
+struct MANGOS_DLL_DECL boss_slitherAI : public boss_hexlord_addAI
+{
+    boss_slitherAI(Creature *c) : boss_hexlord_addAI(c) {}
+
+    uint32 venomspit_timer;
+
+
+    void Reset()
+    {
+        venomspit_timer = 5000;
+        boss_hexlord_addAI::Reset();
+    }
+
+    void AttackStart(Unit* who)
+    {
+        if (!who)
+            return;
+
+        if (who->isTargetableForAttack())
+        {
+            if(m_creature->Attack(who, false))
+            {
+                m_creature->GetMotionMaster()->MoveChase(who, 20);
+                m_creature->AddThreat(who, 0.0f);
+            }
+
+            if (!InCombat)
+            {
+                Aggro(who);
+                InCombat = true;
+            }
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if(!m_creature->SelectHostilTarget() || !m_creature->getVictim() )
+            return;
+        boss_hexlord_addAI::UpdateAI(diff);
+
+        if (venomspit_timer < diff)
+        { 
+            Unit* victim = SelectUnit(SELECT_TARGET_RANDOM, 0);
+            m_creature->CastSpell(victim,SPELL_VENOM_SPIT, false);
+            venomspit_timer = 2500;
+        }else venomspit_timer -= diff;
+    }
+};
+
+//Fenstalker
+#define SPELL_VOLATILE_INFECTION 43586
+
+struct MANGOS_DLL_DECL boss_fenstalkerAI : public boss_hexlord_addAI
+{
+    boss_fenstalkerAI(Creature *c) : boss_hexlord_addAI(c) {}
+
+    uint32 volatileinf_timer;
+
+
+    void Reset()
+    {
+        volatileinf_timer = 15000;
+        boss_hexlord_addAI::Reset();
+
+    }
+    void UpdateAI(const uint32 diff)
+    {
+        if(!m_creature->SelectHostilTarget() || !m_creature->getVictim() )
+            return;
+
+        boss_hexlord_addAI::UpdateAI(diff);
+
+        if (volatileinf_timer < diff)
+        { 
+            // core bug
+            m_creature->getVictim()->CastSpell(m_creature->getVictim(),SPELL_VOLATILE_INFECTION, false);
+            volatileinf_timer = 12000;
+        }else volatileinf_timer -= diff;
+    }
+};
+
+//Koragg
+#define SPELL_COLD_STARE      43593
+#define SPELL_MIGHTY_BLOW     43592
+
+
+struct MANGOS_DLL_DECL boss_koraggAI : public boss_hexlord_addAI
+{
+    boss_koraggAI(Creature *c) : boss_hexlord_addAI(c) {}
+
+    uint32 coldstare_timer;
+    uint32 mightyblow_timer;
+
+
+    void Reset()
+    {
+        coldstare_timer = 15000;
+        mightyblow_timer = 10000;
+        boss_hexlord_addAI::Reset();
+
+    }
+    void UpdateAI(const uint32 diff)
+    {
+        if(!m_creature->SelectHostilTarget() || !m_creature->getVictim() )
+            return;
+
+        boss_hexlord_addAI::UpdateAI(diff);
+
+        if (mightyblow_timer < diff)
+        { 
+            m_creature->CastSpell(m_creature->getVictim(),SPELL_MIGHTY_BLOW, false);
+            mightyblow_timer = 12000;
+        }
+        if (coldstare_timer < diff)
+        {
+            Unit* victim = SelectUnit(SELECT_TARGET_RANDOM, 0);
+            m_creature->CastSpell(victim,SPELL_COLD_STARE, false);
+            coldstare_timer = 12000;
+        }
+    }
+};
+
+CreatureAI* GetAI_boss_hex_lord_malacrass(Creature *_Creature)
+{
+    return new boss_hex_lord_malacrassAI (_Creature);
+}
+
+CreatureAI* GetAI_boss_thurg(Creature *_Creature)
+{
+    return new boss_thurgAI (_Creature);
+}
+
+CreatureAI* GetAI_boss_alyson_antille(Creature *_Creature)
+{
+    return new boss_alyson_antilleAI (_Creature);
+}
+
+CreatureAI* GetAI_boss_gazakroth(Creature *_Creature)
+{
+    return new boss_gazakrothAI (_Creature);
+}
+
+CreatureAI* GetAI_boss_lord_raadan(Creature *_Creature)
+{
+    return new boss_lord_raadanAI (_Creature);
+}
+
+CreatureAI* GetAI_boss_darkheart(Creature *_Creature)
+{
+    return new boss_darkheartAI (_Creature);
+}
+
+CreatureAI* GetAI_boss_slither(Creature *_Creature)
+{
+    return new boss_slitherAI (_Creature);
+}
+
+CreatureAI* GetAI_boss_fenstalker(Creature *_Creature)
+{
+    return new boss_fenstalkerAI (_Creature);
+}
+
+CreatureAI* GetAI_boss_koragg(Creature *_Creature)
+{
+    return new boss_koraggAI (_Creature);
+}
+void AddSC_boss_hex_lord_malacrass()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name="boss_hexlord_malacrass";
+    newscript->GetAI = GetAI_boss_hex_lord_malacrass;
+    m_scripts[nrscripts++] = newscript;
+
+    newscript = new Script;
+    newscript->Name="boss_thurg";
+    newscript->GetAI = GetAI_boss_thurg;
+    m_scripts[nrscripts++] = newscript;
+
+    newscript = new Script;
+    newscript->Name="boss_gazakroth";
+    newscript->GetAI = GetAI_boss_gazakroth;
+    m_scripts[nrscripts++] = newscript;
+
+    newscript = new Script;
+    newscript->Name="boss_lord_raadan";
+    newscript->GetAI = GetAI_boss_lord_raadan;
+    m_scripts[nrscripts++] = newscript;
+
+    newscript = new Script;
+    newscript->Name="boss_darkheart";
+    newscript->GetAI = GetAI_boss_darkheart;
+    m_scripts[nrscripts++] = newscript;
+
+    newscript = new Script;
+    newscript->Name="boss_slither";
+    newscript->GetAI = GetAI_boss_slither;
+    m_scripts[nrscripts++] = newscript;
+
+    newscript = new Script;
+    newscript->Name="boss_fenstalker";
+    newscript->GetAI = GetAI_boss_fenstalker;
+    m_scripts[nrscripts++] = newscript;
+
+    newscript = new Script;
+    newscript->Name="boss_koragg";
+    newscript->GetAI = GetAI_boss_koragg;
+    m_scripts[nrscripts++] = newscript;
+
+    newscript = new Script;
+    newscript->Name="boss_alyson_antille";
+    newscript->GetAI = GetAI_boss_alyson_antille;
+    m_scripts[nrscripts++] = newscript;
+}
Index: scripts/zone/zulaman/boss_janalai.cpp
===================================================================
--- scripts/zone/zulaman/boss_janalai.cpp	(revision 715)
+++ scripts/zone/zulaman/boss_janalai.cpp	(working copy)
@@ -29,14 +29,14 @@
 #define SPELL_FLAME_BREATH          43140
 #define SPELL_FIRE_WALL             43113
 #define SPELL_ENRAGE                44779
-#define SPELL_TELETOCENTER          43098
-#define SPELL_SUMMONALL             43097
-#define SPELL_BERSERK               47008
+#define SPELL_SUMMON_PLAYERS        43097
+#define SPELL_TELE_TO_CENTER        43098 // coord
+#define SPELL_HATCH_ALL             43144
+#define SPELL_BERSERK               45078
 // -- Fire Bob Spells
-#define MOB_FIRE_BOMB               23920
-#define SPELL_FIRE_BOMB_CHANNEL     42621
-#define SPELL_FIRE_BOMB_THROW       42628
-#define SPELL_FIRE_BOMB_DUMMY       42629
+#define SPELL_FIRE_BOMB_CHANNEL     42621 // last forever    
+#define SPELL_FIRE_BOMB_THROW       42628 // throw visual
+#define SPELL_FIRE_BOMB_DUMMY       42629 // bomb visual
 #define SPELL_FIRE_BOMB_DAMAGE      42630
 
 // -- SAYs
@@ -45,7 +45,7 @@
 #define SOUND_FIRE_BOMBS            12032
 #define SAY_FIRE_BOMBS              "I burn ya now!"
 #define SOUND_SUMMON_HATCHER        12033
-#define SAY_SUMMON_HATCHER          "Where ma hatcha? Get to work on dem eggs!"
+#define SAY_SUMMON_HATCHER          "Where ma hatcha? Get to work on dem templist!"
 #define SOUND_ALL_EGGS              12034
 #define SAY_ALL_EGGS                "I show you strength... in numbers."
 #define SOUND_BERSERK               12035
@@ -59,22 +59,22 @@
 #define SOUND_DEATH                 12038
 #define SAY_DEATH                   "Zul'jin... got a surprise for you..."
 
-#define SOUND_AGGRO_1               12039                   //NOT USED need more information
-                                                            //NOT USED need more information (random say before aggro?)
-#define SAY_AGGRO_1                 "Come, strangers. The spirit of the dragonhawk hot be hungry for worthy souls."
-#define SOUND_AGGRO_2               12040                   //NOT USED need more information
-                                                            //NOT USED need more information (random say before aggro?)
-#define SAY_AGGRO_2                 "Come, friends. Your bodies gonna feed ma hatchlings, and your souls are going to feed me with power!"
+#define SOUND_AGGRO_1               12039 //NOT USED need more information
+#define SAY_AGGRO_1                 "Come, strangers. The spirit of the dragonhawk hot be hungry for worthy souls." //NOT USED need more information(random say before aggro?)
+#define SOUND_AGGRO_2               12040 //NOT USED need more information
+#define SAY_AGGRO_2                 "Come, friends. Your bodies gonna feed ma HatchNum, and your souls are going to feed me with power!" //NOT USED need more information(random say before aggro?)
 
 // --Summons
 #define MOB_AMANI_HATCHER           23818
-#define MOB_HATCHLING               23598
+#define MOB_HATCHLING               23598   // 42493
+#define MOB_EGG                     23817
+#define MOB_FIRE_BOMB               23920
 
 // -- Hatcher Spells
-#define SPELL_HATCH_EGG             43734
+#define SPELL_HATCH_EGG             43734   // 42471
 
 // -- Hatchling Spells
-#define SPELL_FLAMEBUFFED           43299
+#define SPELL_FLAMEBUFFET           43299
 
 const int area_dx = 44;
 const int area_dy = 51;
@@ -92,76 +92,74 @@
     {-33.93, 1175.68, 19, 1.5*3.1415}
 };
 
-float hatcherway_l[5][3] =
+float hatcherway[2][5][3] =
 {
-    {-87.46,1170.09,6},
-    {-74.41,1154.75,6},
-    {-52.74,1153.32,19},
-    {-33.37,1172.46,19},
-    {-33.09,1203.87,19}
+    {
+        {-87.46,1170.09,6},
+        {-74.41,1154.75,6},
+        {-52.74,1153.32,19},
+        {-33.37,1172.46,19},
+        {-33.09,1203.87,19}
+    },
+    {
+        {-86.57,1132.85,6},
+        {-73.94,1146.00,6},
+        {-52.29,1146.51,19},
+        {-33.57,1125.72,19},
+        {-34.29,1095.22,19}
+    }
 };
 
-float hatcherway_r[5][3] =
-{
-    {-86.57,1132.85,6},
-    {-73.94,1146.00,6},
-    {-52.29,1146.51,19},
-    {-33.57,1125.72,19},
-    {-34.29,1095.22,19}
-};
-
 struct MANGOS_DLL_DECL boss_janalaiAI : public ScriptedAI
 {
     boss_janalaiAI(Creature *c) : ScriptedAI(c)
     {
-        pInstance = ((ScriptedInstance*)c->GetInstanceData());
+        pInstance =((ScriptedInstance*)c->GetInstanceData());
         Reset();
     }
 
     ScriptedInstance *pInstance;
 
-    uint32 fire_breath_timer;
-    uint32 bomb_timer;
-    uint32 throw_timer;
-    uint32 enrage_timer;
-    uint32 finishedbomb_timer;
-    uint32 bombcounter;
-    uint32 hatchertime;
-    uint32 eggs;
-    uint32 wipetimer;
-    uint32 reset_timer;
+    uint32 FireBreathTimer;
+    uint32 BombTimer;
+    uint32 BombSequenceTimer;
+    uint32 BombCount;
+    uint32 HatcherTimer;
+    uint32 EnrageTimer;
+    uint32 ResetTimer;
+
     bool noeggs;
     bool enraged;
-    bool enragetime;
+    bool isBombing;
 
-    uint64 FireBombGUIDs[40];
-    uint64 ThrowControllerGUID;
+    bool isFlameBreathing;
 
-    bool bombing;
+    uint64 FireBombGUIDs[40];    
 
     void Reset()
     {
         if(pInstance)
             pInstance->SetData(DATA_JANALAIEVENT, NOT_STARTED);
 
-        fire_breath_timer = 8000;
-        bomb_timer = 30000;
-        enrage_timer = 300000;                              // 5 minutes
-        finishedbomb_timer = 6000;
-        throw_timer = 1000;
-        bombcounter = 0;
+        FireBreathTimer = 8000;
+        BombTimer = 30000;
+        BombSequenceTimer = 1000;
+        BombCount = 0;
+        HatcherTimer = 10000;
+        EnrageTimer = 300000;
+        ResetTimer = 5000;
+
         noeggs = false;
-        hatchertime = 10000;
-        wipetimer = 600000;                                 // 10 mins
-        bombing =false;
-        reset_timer = 5000;
+        isBombing =false;
         enraged = false;
-        enragetime = false;
 
-        ThrowControllerGUID = 0;
+        isFlameBreathing = false;
 
+
         for(uint8 i = 0; i < 40; i++)
             FireBombGUIDs[i] = 0;
+
+        HatchAllEggs(1);
     }
 
     void JustDied(Unit* Killer)
@@ -176,15 +174,15 @@
     void KilledUnit(Unit* victim)
     {
         switch(rand()%2)
-        {
-            case 0:
-                DoYell(SAY_SLAY_1, LANG_UNIVERSAL, NULL);
-                DoPlaySoundToSet(m_creature,SOUND_SLAY_1);
-                break;
-            case 1:
-                DoYell(SAY_SLAY_2, LANG_UNIVERSAL, NULL);
-                DoPlaySoundToSet(m_creature,SOUND_SLAY_1);
-                break;
+        {        
+        case 0:
+            DoYell(SAY_SLAY_1, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature,SOUND_SLAY_1);
+            break;
+        case 1:
+            DoYell(SAY_SLAY_2, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature,SOUND_SLAY_1);
+            break;        
         }
     }
 
@@ -195,280 +193,289 @@
 
         DoYell(SAY_AGGRO, LANG_UNIVERSAL, NULL);
         DoPlaySoundToSet(m_creature,SOUND_AGGRO);
+        DoZoneInCombat();
     }
 
-    void FireWall()                                         // Create Firewall
+    void DamageDeal(Unit* target, uint32 &damage)
     {
+        if(isFlameBreathing)
+        {
+            if(!m_creature->HasInArc(M_PI/6, target))
+                damage = 0;
+        }
+    }
+
+    void FireWall()
+    {
+        uint8 WallNum;
         Creature* wall = NULL;
-        wall = m_creature->SummonCreature(MOB_FIRE_BOMB,FireWallCoords[0][0],FireWallCoords[0][1],FireWallCoords[0][2],FireWallCoords[0][3],TEMPSUMMON_TIMED_DESPAWN,11500);
-        if(wall)
-            wall->CastSpell(wall,SPELL_FIRE_WALL,false);
+        for(uint8 i = 0; i < 4; i++)
+        {
+            if(i == 0 || i == 2)
+                WallNum = 3;
+            else
+                WallNum = 2;
 
-        wall = m_creature->SummonCreature(MOB_FIRE_BOMB,FireWallCoords[0][0],FireWallCoords[0][1]+5,FireWallCoords[0][2],FireWallCoords[0][3],TEMPSUMMON_TIMED_DESPAWN,11500);
-        if(wall)
-            wall->CastSpell(wall,SPELL_FIRE_WALL,false);
+            for(uint8 j = 0; j < WallNum; j++)
+            {
+                if(WallNum == 3)
+                    wall = m_creature->SummonCreature(MOB_FIRE_BOMB, FireWallCoords[i][0],FireWallCoords[i][1]+5*(j-1),FireWallCoords[i][2],FireWallCoords[i][3],TEMPSUMMON_TIMED_DESPAWN,15000);
+                else
+                    wall = m_creature->SummonCreature(MOB_FIRE_BOMB, FireWallCoords[i][0]-2+4*j,FireWallCoords[i][1],FireWallCoords[i][2],FireWallCoords[i][3],TEMPSUMMON_TIMED_DESPAWN,15000);
+                if(wall) wall->CastSpell(wall, SPELL_FIRE_WALL, true);
+            }
+        }
+    }
 
-        wall = m_creature->SummonCreature(MOB_FIRE_BOMB,FireWallCoords[0][0],FireWallCoords[0][1]-5,FireWallCoords[0][2],FireWallCoords[0][3],TEMPSUMMON_TIMED_DESPAWN,11500);
-        if(wall)
-            wall->CastSpell(wall,SPELL_FIRE_WALL,false);
+    void SpawnBombs()
+    {
+        float dx, dy;
+        for( int i(0); i < 40; i++)
+        {
+            dx =(rand()%(area_dx))-(area_dx/2);
+            dy =(rand()%(area_dy))-(area_dy/2);
 
-        wall = m_creature->SummonCreature(MOB_FIRE_BOMB,FireWallCoords[1][0]-2,FireWallCoords[1][1]-2,FireWallCoords[1][2],FireWallCoords[1][3],TEMPSUMMON_TIMED_DESPAWN,11500);
-        if(wall)
-            wall->CastSpell(wall,SPELL_FIRE_WALL,false);
+            Creature* bomb = DoSpawnCreature(MOB_FIRE_BOMB, dx, dy, 0, 0, TEMPSUMMON_TIMED_DESPAWN, 15000);
+            if(bomb) FireBombGUIDs[i] = bomb->GetGUID();
+        }
+        BombCount = 0;
+    }
 
-        wall = m_creature->SummonCreature(MOB_FIRE_BOMB,FireWallCoords[1][0]+2,FireWallCoords[1][1]+2,FireWallCoords[1][2],FireWallCoords[1][3],TEMPSUMMON_TIMED_DESPAWN,11500);
-        if(wall)
-            wall->CastSpell(wall,SPELL_FIRE_WALL,false);
+    bool HatchAllEggs(uint32 action) //1: reset, 2: isHatching all
+    {
+        std::list<Creature*> templist;
+        float x, y, z;
+        m_creature->GetPosition(x, y, z);
 
-        wall = m_creature->SummonCreature(MOB_FIRE_BOMB,FireWallCoords[2][0],FireWallCoords[2][1],FireWallCoords[2][2],FireWallCoords[2][3],TEMPSUMMON_TIMED_DESPAWN,11500);
-        if(wall)
-            wall->CastSpell(wall,SPELL_FIRE_WALL,false);
+        {
+            CellPair pair(MaNGOS::ComputeCellPair(x, y));
+            Cell cell(pair);
+            cell.data.Part.reserved = ALL_DISTRICT;
+            cell.SetNoCreate();
 
-        wall = m_creature->SummonCreature(MOB_FIRE_BOMB,FireWallCoords[2][0],FireWallCoords[2][1]-5,FireWallCoords[2][2],FireWallCoords[2][3],TEMPSUMMON_TIMED_DESPAWN,11500);
-        if(wall)
-            wall->CastSpell(wall,SPELL_FIRE_WALL,false);
+            AllCreaturesOfEntryInRange check(m_creature, MOB_EGG, 100);
+            MaNGOS::CreatureListSearcher<AllCreaturesOfEntryInRange> searcher(templist, check);
 
-        wall = m_creature->SummonCreature(MOB_FIRE_BOMB,FireWallCoords[2][0],FireWallCoords[2][1]+5,FireWallCoords[2][2],FireWallCoords[2][3],TEMPSUMMON_TIMED_DESPAWN,11500);
-        if(wall)
-            wall->CastSpell(wall,SPELL_FIRE_WALL,false);
+            TypeContainerVisitor<MaNGOS::CreatureListSearcher<AllCreaturesOfEntryInRange>, GridTypeMapContainer> cSearcher(searcher);
 
-        wall = m_creature->SummonCreature(MOB_FIRE_BOMB,FireWallCoords[3][0]-2,FireWallCoords[3][1],FireWallCoords[3][2],FireWallCoords[3][3],TEMPSUMMON_TIMED_DESPAWN,11500);
-        if(wall)
-            wall->CastSpell(wall,SPELL_FIRE_WALL,false);
+            CellLock<GridReadGuard> cell_lock(cell, pair);
+            cell_lock->Visit(cell_lock, cSearcher, *(m_creature->GetMap()));
+        }
 
-        wall = m_creature->SummonCreature(MOB_FIRE_BOMB,FireWallCoords[3][0]+2,FireWallCoords[3][1],FireWallCoords[3][2],FireWallCoords[3][3],TEMPSUMMON_TIMED_DESPAWN,11500);
-        if(wall)
-            wall->CastSpell(wall,SPELL_FIRE_WALL,false);
+        //error_log("Eggs %d at middle", templist.size());
+        if(!templist.size())
+            return false;
+
+        for(std::list<Creature*>::iterator i = templist.begin(); i != templist.end(); ++i)
+        {
+            if(action == 1)
+               (*i)->SetDisplayId(10056);
+            else if(action == 2 &&(*i)->GetDisplayId() != 11686)
+               (*i)->CastSpell(*i, SPELL_HATCH_EGG, false);
+        }
+        return true;
     }
 
-    void throwBombs()                                       // create Bombs
+    void Boom()
     {
-        float dx;
-        float dy;
-        for ( int i(0); i < 40; i++)
+        std::list<Creature*> templist;
+        float x, y, z;
+        m_creature->GetPosition(x, y, z);
+
         {
-            dx = (rand()%(area_dx))-(area_dx/2);
-            dy = (rand()%(area_dy))-(area_dy/2);
+            CellPair pair(MaNGOS::ComputeCellPair(x, y));
+            Cell cell(pair);
+            cell.data.Part.reserved = ALL_DISTRICT;
+            cell.SetNoCreate();
 
-            Creature* bomb = DoSpawnCreature(MOB_FIRE_BOMB, dx, dy, 0, 0, TEMPSUMMON_TIMED_DESPAWN, 13000);
-            if(bomb)
-                FireBombGUIDs[i] = bomb->GetGUID();
-        }
+            AllCreaturesOfEntryInRange check(m_creature, MOB_FIRE_BOMB, 100);
+            MaNGOS::CreatureListSearcher<AllCreaturesOfEntryInRange> searcher(templist, check);
 
-        Creature* ThrowController = DoSpawnCreature(MOB_FIRE_BOMB,0,0,1,0,TEMPSUMMON_TIMED_DESPAWN,10000);
-        if(ThrowController)
-            ThrowControllerGUID = ThrowController->GetGUID();
+            TypeContainerVisitor<MaNGOS::CreatureListSearcher<AllCreaturesOfEntryInRange>, GridTypeMapContainer> cSearcher(searcher);
 
-        bombcounter = 0;
+            CellLock<GridReadGuard> cell_lock(cell, pair);
+            cell_lock->Visit(cell_lock, cSearcher, *(m_creature->GetMap()));
+        }
+        for(std::list<Creature*>::iterator i = templist.begin(); i != templist.end(); ++i)
+        {
+           (*i)->CastSpell(*i, SPELL_FIRE_BOMB_DAMAGE, true);
+           (*i)->RemoveAllAuras();
+        }
     }
 
-    void throw5Bombs()                                      //throwanimation
+    void HandleBombSequence()
     {
-        for ( int i(0); i < 5; i++)
+        if(BombCount < 40)
         {
-            Unit* ThrowController = NULL;
-            Unit* FireBomb = NULL;
-            if(ThrowControllerGUID)
-                ThrowController = Unit::GetUnit((*m_creature), ThrowControllerGUID);
-
-            if(FireBombGUIDs[bombcounter])
-                FireBomb = Unit::GetUnit((*m_creature), FireBombGUIDs[bombcounter]);
-
-            if(ThrowController && FireBomb)
+            if(Unit *FireBomb = Unit::GetUnit((*m_creature), FireBombGUIDs[BombCount]))
             {
-                ThrowController->CastSpell(FireBomb,SPELL_FIRE_BOMB_THROW,true);
-                FireBomb->CastSpell(FireBomb,SPELL_FIRE_BOMB_DUMMY,false);
-                bombcounter ++;
+                FireBomb->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                DoCast(FireBomb, SPELL_FIRE_BOMB_THROW, true);
+                FireBomb->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
             }
+            BombCount++;
+            if(BombCount == 40)
+            {
+                BombSequenceTimer = 5000;
+            }else BombSequenceTimer = 100;
         }
+        else
+        {
+            Boom();
+            isBombing = false;
+            BombTimer = 20000+rand()%20000;
+            m_creature->RemoveAurasDueToSpell(SPELL_FIRE_BOMB_CHANNEL);
+            if(EnrageTimer <= 10000)
+                EnrageTimer = 0;
+            else
+                EnrageTimer -= 10000;
+        }
     }
 
     void UpdateAI(const uint32 diff)
     {
-        if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
-            return;
-
-        if(!bombing)                                        // every Spell if NOT Bombing
+        if(isFlameBreathing)
         {
-            //FIRE BREATH  several videos says every 8Secounds
-            if(fire_breath_timer < diff)
+            if(!m_creature->IsNonMeleeSpellCasted(false))
             {
-                Unit* target = NULL;
-                target = SelectUnit(SELECT_TARGET_RANDOM,0);
-                if(target)
-                    DoCast(target,SPELL_FLAME_BREATH);
-                fire_breath_timer = 8000;
-            }else fire_breath_timer -=diff;
+                isFlameBreathing = false;
+            }else return;
+        }
 
-            if(bomb_timer < diff)
+        if(isBombing)
+        {
+            if(BombSequenceTimer < diff)
             {
-                FireWall();
-                bomb_timer = 20000+rand()%20000;
-                m_creature->Relocate(JanalainPos[0][0],JanalainPos[0][1],JanalainPos[0][2],0);
-                m_creature->SendMonsterMove(JanalainPos[0][0], JanalainPos[0][1],JanalainPos[0][2],0,0,100);
-                DoYell(SAY_FIRE_BOMBS, LANG_UNIVERSAL, NULL);
-                DoPlaySoundToSet(m_creature,SOUND_FIRE_BOMBS);
-                throwBombs();
-                bombing = true;
+                HandleBombSequence();
+            }else BombSequenceTimer -= diff;
+            return;
+        }
 
-                //Teleport every Player into the middle
-                Unit* Temp = NULL;
-                std::list<HostilReference*>::iterator i = m_creature->getThreatManager().getThreatList().begin();
-                for (; i != m_creature->getThreatManager().getThreatList().end(); ++i)
-                {
-                    Temp = Unit::GetUnit((*m_creature),(*i)->getUnitGuid());
-                    if (Temp && m_creature->GetDistance(Temp) > 30.0)
-                        DoTeleportPlayer(Temp, m_creature->GetPositionX(), m_creature->GetPositionY(), m_creature->GetPositionZ(), 0);
-                }
-                DoCast(m_creature,SPELL_TELETOCENTER,true); // only Effect Spell
-                DoCast(m_creature,SPELL_FIRE_BOMB_CHANNEL,false);
-                finishedbomb_timer = 11000;
-            }else bomb_timer -=diff;
+        if(!m_creature->SelectHostilTarget() && !m_creature->getVictim())
+            return;   
 
-            //enrage if under 25% hp before 5 min.
-            if (((m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 25) && !enraged)
+        //enrage if under 25% hp before 5 min.
+        if(!enraged && m_creature->GetHealth() * 4 < m_creature->GetMaxHealth())
+            EnrageTimer = 0;
+
+        if(EnrageTimer < diff)
+        {
+            if(!enraged)
             {
-                enragetime = true;
-                enrage_timer = 600000;
+                m_creature->CastSpell(m_creature, SPELL_ENRAGE, true);
+                enraged = true;
+                EnrageTimer = 300000;
             }
-
-            //Enrage but only if not bombing
-            if(enragetime && !enraged)
+            else
             {
                 DoYell(SAY_BERSERK, LANG_UNIVERSAL, NULL);
-                DoPlaySoundToSet(m_creature,SOUND_BERSERK);
-                m_creature->InterruptNonMeleeSpells(false);
-                DoCast(m_creature,SPELL_ENRAGE);
-                enraged = true;
+                DoPlaySoundToSet(m_creature,SOUND_BERSERK);  
+                m_creature->CastSpell(m_creature, SPELL_BERSERK, true);
+                EnrageTimer = 300000;            
             }
-        }
+        }else EnrageTimer -= diff;
 
-        //Enrage after 5 minutes
-        if(enrage_timer < diff)
+        if(BombTimer < diff)
         {
-            enragetime = true;
-            enrage_timer = 600000;
-        }else enrage_timer -=diff;
+            DoYell(SAY_FIRE_BOMBS, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, SOUND_FIRE_BOMBS);
 
-        if(bombing)                                         // every Spell if Bombing
-        {
-            if(bombcounter < 40)
+            m_creature->AttackStop();
+            m_creature->GetMotionMaster()->Clear();
+            m_creature->Relocate(JanalainPos[0][0],JanalainPos[0][1],JanalainPos[0][2],0);
+            m_creature->SendMonsterMove(JanalainPos[0][0], JanalainPos[0][1],JanalainPos[0][2],0,0,0);
+            m_creature->StopMoving();
+            m_creature->CastSpell(m_creature, SPELL_FIRE_BOMB_CHANNEL, false);
+            //DoTeleportPlayer(m_creature, JanalainPos[0][0], JanalainPos[0][1],JanalainPos[0][2], 0);
+            //m_creature->CastSpell(m_creature, SPELL_TELE_TO_CENTER, true);
+
+            FireWall();
+            SpawnBombs();
+            isBombing = true;
+            BombSequenceTimer = 100;
+
+            //Teleport every Player into the middle
+            Map *map = m_creature->GetMap();
+            if(!map->IsDungeon()) return;
+            InstanceMap::PlayerList const &PlayerList =((InstanceMap*)map)->GetPlayers();
+            for(InstanceMap::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
             {
-                if(throw_timer < diff)
-                {
-                    throw5Bombs();
-                    throw_timer = 1000;
-                }else throw_timer -=diff;
+                if((*i)->isAlive())
+                    DoTeleportPlayer(*i, JanalainPos[0][0]-5+rand()%10, JanalainPos[0][1]-5+rand()%10, JanalainPos[0][2], 0);
             }
+            //m_creature->CastSpell(Temp, SPELL_SUMMON_PLAYERS, true); // core bug, spell does not work if too far
+            return;
+        }else BombTimer -= diff;
 
-            if(finishedbomb_timer < diff)
-            {
-                bombing = false;
-                finishedbomb_timer = 6000;
-                m_creature->RemoveAura(SPELL_FIRE_BOMB_CHANNEL,0);
-                m_creature->RemoveAura(SPELL_FIRE_BOMB_CHANNEL,1);
-            }else finishedbomb_timer -=diff;
-        }
-
-        //Call Hatcher
         if(!noeggs)
         {
-            if(hatchertime < diff)
+            if(100 * m_creature->GetHealth() < 35 * m_creature->GetMaxHealth()) 
             {
-                if(pInstance->GetData(DATA_J_EGGSLEFT)>0 || pInstance->GetData(DATA_J_EGGSRIGHT) > 0)
+                m_creature->AttackStop();
+                m_creature->GetMotionMaster()->Clear();
+                m_creature->Relocate(JanalainPos[0][0],JanalainPos[0][1],JanalainPos[0][2],0);
+                m_creature->SendMonsterMove(JanalainPos[0][0], JanalainPos[0][1],JanalainPos[0][2],0,0,0);
+                m_creature->StopMoving();
+                m_creature->CastSpell(m_creature, SPELL_HATCH_ALL, false);
+                HatchAllEggs(2);
+                noeggs = true;
+            }
+            else if(HatcherTimer < diff)
+            {
+                if(HatchAllEggs(0))
                 {
-                    Unit* hatcher = NULL;
                     DoYell(SAY_SUMMON_HATCHER, LANG_UNIVERSAL, NULL);
                     DoPlaySoundToSet(m_creature,SOUND_SUMMON_HATCHER);
-                    hatcher = m_creature->SummonCreature(MOB_AMANI_HATCHER,hatcherway_l[0][0],hatcherway_l[0][1],hatcherway_l[0][2],0,TEMPSUMMON_CORPSE_TIMED_DESPAWN,10000);
-                    if(hatcher)
-                        hatcher->GetMotionMaster()->MovePoint(0, hatcherway_l[0][0], hatcherway_l[0][1], hatcherway_l[0][2]);
-
-                    hatcher = m_creature->SummonCreature(MOB_AMANI_HATCHER,hatcherway_r[0][0],hatcherway_r[0][1],hatcherway_r[0][2],0,TEMPSUMMON_CORPSE_TIMED_DESPAWN,10000);
-                    if(hatcher)
-                        hatcher->GetMotionMaster()->MovePoint(0, hatcherway_r[0][0],hatcherway_r[0][1],hatcherway_r[0][2]);
-                    hatchertime = 45000;
+                    m_creature->SummonCreature(MOB_AMANI_HATCHER,hatcherway[0][0][0],hatcherway[0][0][1],hatcherway[0][0][2],0,TEMPSUMMON_CORPSE_TIMED_DESPAWN,10000);
+                    m_creature->SummonCreature(MOB_AMANI_HATCHER,hatcherway[1][0][0],hatcherway[1][0][1],hatcherway[1][0][2],0,TEMPSUMMON_CORPSE_TIMED_DESPAWN,10000);
+                    HatcherTimer = 90000;
                 }
                 else
-                {
                     noeggs = true;
-                }
-            }else hatchertime -=diff;
+            }else HatcherTimer -= diff;
         }
 
-        //WIPE after 10 minutes
-        if(wipetimer < diff)
+        if(ResetTimer < diff)
         {
-            DoYell(SAY_BERSERK, LANG_UNIVERSAL, NULL);
-            DoPlaySoundToSet(m_creature,SOUND_BERSERK);
-            DoCast(m_creature,SPELL_ENRAGE);
+            float x, y, z;
+            m_creature->GetPosition(x, y, z);
+            if(x < -70 || x > 0 || y > 1176 || y < 1121 || z < 18)
+                EnterEvadeMode();
+            ResetTimer = 5000;
+        }else ResetTimer -= diff;
 
-            wipetimer = 30000;
-        }else wipetimer -=diff;
+        DoMeleeAttackIfReady();    
 
-        //Hatch All
-        if(!noeggs && (m_creature->GetHealth()*100) / m_creature->GetMaxHealth() < 35)
-        {
-            DoYell(SAY_ALL_EGGS , LANG_UNIVERSAL, NULL);
-            DoPlaySoundToSet(m_creature,SOUND_BERSERK);
-
-            if(pInstance)
-                eggs = pInstance->GetData(DATA_J_EGGSLEFT);
-
-            int i;
-            for(i=1;i<=eggs;i=i+1)
+        if(FireBreathTimer < diff)
+        {  
+            if(Unit* target = SelectUnit(SELECT_TARGET_RANDOM,0))
             {
-                int r = (rand()%20 - 10);
-                int s = (rand()%20 - 10);
-                m_creature->SummonCreature(MOB_HATCHLING,JanalainPos[0][0]+s,JanalainPos[0][1]+r,JanalainPos[0][2],0,TEMPSUMMON_CORPSE_TIMED_DESPAWN,15000);
-
-                if(pInstance)
-                    pInstance->SetData(DATA_J_HATCHLEFT,1);
+                m_creature->AttackStop();
+                m_creature->GetMotionMaster()->Clear();
+                m_creature->CastSpell(target, SPELL_FLAME_BREATH, false);
+                m_creature->StopMoving();
+                isFlameBreathing = true;
             }
-
-            if(pInstance)
-                eggs = pInstance->GetData(DATA_J_EGGSRIGHT);
-
-            for(i=1;i<=eggs;i=i+1)
-            {
-                int r = (rand()%20 - 10);
-                int s = (rand()%20 - 10);
-                m_creature->SummonCreature(MOB_HATCHLING,JanalainPos[0][0]+s,JanalainPos[0][1]+r,JanalainPos[0][2],0,TEMPSUMMON_CORPSE_TIMED_DESPAWN,15000);
-                if(pInstance)
-                    pInstance->SetData(DATA_J_HATCHRIGHT,1);
-            }
-
-            noeggs = true;
-        }
-
-        //check for reset ... exploit preventing ... pulled from his podest
-        if(reset_timer < diff)
-        {
-            if(m_creature->GetPositionX() < -70 || m_creature->GetPositionX() > 0)
-            {
-                EnterEvadeMode();
-                reset_timer = 5000;                         //every 5 Seca
-            }
-        }else reset_timer -=diff;
-
-        DoMeleeAttackIfReady();
-    }
+            FireBreathTimer = 8000;            
+        }else FireBreathTimer -= diff;
+    }    
 };
 
 CreatureAI* GetAI_boss_janalaiAI(Creature *_Creature)
 {
-    return new boss_janalaiAI (_Creature);
+    return new boss_janalaiAI(_Creature);
 }
 
 struct MANGOS_DLL_DECL mob_jandalai_firebombAI : public ScriptedAI
 {
     mob_jandalai_firebombAI(Creature *c) : ScriptedAI(c){Reset();}
 
-    uint32 bomb_timer;
+    void Reset() {}
 
-    void Reset()
+    void SpellHit(Unit *caster, const SpellEntry *spell)
     {
-        bomb_timer = 12000;
+        if(spell->Id == SPELL_FIRE_BOMB_THROW)
+            m_creature->CastSpell(m_creature, SPELL_FIRE_BOMB_DUMMY, true);
     }
 
     void Aggro(Unit* who) {}
@@ -477,263 +484,221 @@
 
     void MoveInLineOfSight(Unit* who) {}
 
-    void UpdateAI(const uint32 diff)
-    {
-        if(bomb_timer < diff)                               //Boom
-        {
-            m_creature->CastSpell(m_creature,SPELL_FIRE_BOMB_DAMAGE,false);
-            bomb_timer = 1800000;
-        }else bomb_timer -=diff;
-    }
+    void UpdateAI(const uint32 diff) {}
 };
 
 CreatureAI* GetAI_mob_jandalai_firebombAI(Creature *_Creature)
 {
-    return new mob_jandalai_firebombAI (_Creature);
+    return new mob_jandalai_firebombAI(_Creature);
 }
 
 struct MANGOS_DLL_DECL mob_amanishi_hatcherAI : public ScriptedAI
 {
     mob_amanishi_hatcherAI(Creature *c) : ScriptedAI(c)
     {
-        pInstance = ((ScriptedInstance*)c->GetInstanceData());
+        pInstance =((ScriptedInstance*)c->GetInstanceData());
         Reset();
     }
 
     ScriptedInstance *pInstance;
 
     uint32 waypoint;
-    bool waytype;
-    bool start;
-    bool hatch;
-    bool wait;
-    uint32 hatchlings;
-    uint32 waittimer;
-    uint32 eggs;
-    uint32 delete_timer;
+    uint32 HatchNum;
+    uint32 WaitTimer;
 
+    bool side;
+    bool hasChangedSide;
+    bool isHatching;
+
     void Reset()
     {
+        side =(m_creature->GetPositionY() < 1150);
         waypoint = 0;
-        waytype = 0;
-        hatch = false;
-        start = false;
-        wait = false;
-        waittimer = 4000;
-        hatchlings = 0;
-        eggs = 0;
-        delete_timer = 10000;
-
-        //m_creature->RemoveAllAuras();
-        //m_creature->DeleteThreatList();
-        //m_creature->CombatStop();
-        //DoGoHome();
+        isHatching = false;
+        hasChangedSide = false;
+        WaitTimer = 1;
+        HatchNum = 0;
     }
 
-    void Aggro(Unit* who)
+    bool HatchEggs(uint32 num)
     {
-    }
+        std::list<Creature*> templist;
+        float x, y, z;
+        m_creature->GetPosition(x, y, z);
 
-    void UpdateAI(const uint32 diff)
-    {
-        if(pInstance && (pInstance->GetData(DATA_JANALAIEVENT) == 1))
         {
-            if(!start && !hatch)
-            {
-                waytype = ( m_creature->GetPositionY() > 1150);
-                waypoint = 1;
-                start = true;
-            }
+            CellPair pair(MaNGOS::ComputeCellPair(x, y));
+            Cell cell(pair);
+            cell.data.Part.reserved = ALL_DISTRICT;
+            cell.SetNoCreate();
 
-            if(start && !hatch)
-            {
-                if(wait)
-                {
-                    if(waittimer < diff)
-                    {
-                        wait = false;
-                        waittimer = 4000;
-                        waypoint++;
+            AllCreaturesOfEntryInRange check(m_creature, 23817, 50);
+            MaNGOS::CreatureListSearcher<AllCreaturesOfEntryInRange> searcher(templist, check);
 
-                        if (waypoint == 5)
-                        {
-                            hatch = true;
-                            waittimer = 0;
-                            hatchlings = 1;
-                        }
-                    }
-                    else
-                    {
-                        waittimer -=diff;
-                    }
-                }
-                else
-                {
-                    m_creature->GetMotionMaster()->Clear();
-                    if(waytype)
-                        m_creature->GetMotionMaster()->MovePoint(0,hatcherway_l[waypoint][0],hatcherway_l[waypoint][1],hatcherway_l[waypoint][2]);
-                    else
-                        m_creature->GetMotionMaster()->MovePoint(0,hatcherway_r[waypoint][0],hatcherway_r[waypoint][1],hatcherway_r[waypoint][2]);
-                    wait= true;
-                }
-            }
+            TypeContainerVisitor<MaNGOS::CreatureListSearcher<AllCreaturesOfEntryInRange>, GridTypeMapContainer> cSearcher(searcher);
 
-            if(start && hatch)
-            {
-                if(waittimer < diff)
-                {
-                    if(!pInstance)
-                        return;
+            CellLock<GridReadGuard> cell_lock(cell, pair);
+            cell_lock->Visit(cell_lock, cSearcher, *(m_creature->GetMap()));
+        }
 
-                    waittimer = 4000;
-                    Unit* hatchling;
+        //error_log("Eggs %d at %d", templist.size(), side);
 
-                    if(waytype)
-                    {
-                        eggs = pInstance->GetData(DATA_J_EGGSLEFT);
+        for(std::list<Creature*>::iterator i = templist.begin(); i != templist.end() && num > 0; ++i)
+        {
+            if((*i)->GetDisplayId() != 11686)
+            {
+               (*i)->CastSpell(*i, SPELL_HATCH_EGG, false);
+                num--;
+            }
+        }
 
-                        if(eggs > 0)
-                            DoCast(m_creature,SPELL_HATCH_EGG);
+        if(num)
+            return false;   // no more templist
+        else
+            return true;
+    }
 
-                        int i;
-                        for(i=1;i<=hatchlings;i=i+1)
-                        {
-                            eggs = pInstance->GetData(DATA_J_EGGSLEFT);
-                            if(eggs <= 0)
-                            {
-                                if (waytype) waytype = false; else waytype = true;
-                                waittimer = 15000;
-                                hatch = false;
-                                waypoint = 4;
-                                wait = true;
-                                i = hatchlings;
-                            }
-                            else
-                            {
-                                hatchling = DoSpawnCreature(MOB_HATCHLING,rand()%4-2,rand()%4-2,0,0,TEMPSUMMON_CORPSE_TIMED_DESPAWN,15000);
-                                pInstance->SetData(DATA_J_HATCHLEFT,1);
-                            }
-                        }
+    void Aggro(Unit* who) {}
+    void AttackStart(Unit*) {}
+    void MoveInLineOfSight(Unit*) {}
+    void MovementInform(uint32, uint32)
+    {
+        if(waypoint == 5)
+        {
+            isHatching = true;
+            HatchNum = 1;
+            WaitTimer = 5000;
+        }
+        else 
+            WaitTimer = 1;
+    }
 
-                        DoCast(m_creature,SPELL_HATCH_EGG);
+    void UpdateAI(const uint32 diff)
+    {
+        if(!pInstance || !(pInstance->GetData(DATA_JANALAIEVENT) == IN_PROGRESS))
+        {
+            m_creature->SetVisibility(VISIBILITY_OFF);
+            m_creature->setDeathState(JUST_DIED);
+            return;
+        }
 
-                        if(hatchlings < 5)
-                            hatchlings++;
-                    }
-                    else
-                    {
-                        eggs = pInstance->GetData(DATA_J_EGGSRIGHT);
-
-                        if(eggs > 0)
-                            DoCast(m_creature,SPELL_HATCH_EGG);
-
-                        int i;
-                        for(i=1;i<=hatchlings;i=i+1)
-                        {
-                            eggs = pInstance->GetData(DATA_J_EGGSRIGHT);
-                            if(eggs <= 0)
-                            {
-                                if (waytype) waytype = false; else waytype = true;
-                                waittimer = 15000;
-                                hatch = false;
-                                waypoint = 4;
-                                wait = true;
-                                i = hatchlings;
-                            }
-                            else
-                            {
-                                hatchling = DoSpawnCreature(MOB_HATCHLING,rand()%4-2,rand()%4-2,0,0,TEMPSUMMON_CORPSE_TIMED_DESPAWN,15000);
-                                pInstance->SetData(DATA_J_HATCHRIGHT,1);
-                            }
-                        }
-
-                        DoCast(m_creature,SPELL_HATCH_EGG);
-                        hatchlings++;
-                    }
-                }else waittimer -=diff;
+        if(!isHatching)
+        {
+            if(WaitTimer)
+            {
+                m_creature->GetMotionMaster()->Clear();
+                m_creature->GetMotionMaster()->MovePoint(0,hatcherway[side][waypoint][0],hatcherway[side][waypoint][1],hatcherway[side][waypoint][2]);
+                waypoint++;
+                WaitTimer = 0;
             }
         }
         else
-        {
-            if(delete_timer < diff)
+        {   
+            if(WaitTimer < diff)
             {
-                m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
-                delete_timer = 10000;
-            }else delete_timer -=diff;
+                if(HatchEggs(HatchNum))
+                {
+                    HatchNum++;
+                    WaitTimer = 10000;
+                }
+                else if(!hasChangedSide)
+                {
+                    side = side ? 0 : 1;
+                    isHatching = false;
+                    waypoint = 3;
+                    WaitTimer = 1;
+                    hasChangedSide = true;
+                }
+                else
+                {
+                    m_creature->SetVisibility(VISIBILITY_OFF);
+                    m_creature->setDeathState(JUST_DIED);
+                }
+            }else WaitTimer -= diff;
         }
     }
 };
 
 CreatureAI* GetAI_mob_amanishi_hatcherAI(Creature *_Creature)
 {
-    return new mob_amanishi_hatcherAI (_Creature);
+    return new mob_amanishi_hatcherAI(_Creature);
 }
 
 struct MANGOS_DLL_DECL mob_hatchlingAI : public ScriptedAI
 {
     mob_hatchlingAI(Creature *c) : ScriptedAI(c)
     {
-        pInstance = ((ScriptedInstance*)c->GetInstanceData());
+        pInstance =((ScriptedInstance*)c->GetInstanceData());
         Reset();
     }
 
     ScriptedInstance *pInstance;
+    uint32 BuffetTimer;
 
-    uint32 buffer_timer;
-    uint32 delete_timer;
-    bool start;
-
     void Reset()
     {
-        buffer_timer = 7000;
-        delete_timer = 10000;
-        start = false;
-    }
+        BuffetTimer = 7000;
+        if(m_creature->GetPositionY() > 1150)
+            m_creature->GetMotionMaster()->MovePoint(0, hatcherway[0][3][0]+rand()%4-2,1150+rand()%4-2,hatcherway[0][3][2]);
+        else
+            m_creature->GetMotionMaster()->MovePoint(0,hatcherway[1][3][0]+rand()%4-2,1150+rand()%4-2,hatcherway[1][3][2]);
 
-    void Aggro(Unit *who)
-    {
+        m_creature->SetUnitMovementFlags(MOVEMENTFLAG_LEVITATING);
     }
 
+    void Aggro(Unit *who) {DoZoneInCombat();}
+
     void UpdateAI(const uint32 diff)
     {
-        if(!start)
+        if(!pInstance || !(pInstance->GetData(DATA_JANALAIEVENT) == IN_PROGRESS))
         {
-            if(m_creature->GetPositionY() > 1150)
-                m_creature->GetMotionMaster()->MovePoint(0, hatcherway_l[3][0]+rand()%4-2,hatcherway_l[3][1]+rand()%4-2,hatcherway_l[3][2]);
-            else
-                m_creature->GetMotionMaster()->MovePoint(0,hatcherway_r[3][0]+rand()%4-2,hatcherway_r[3][1]+rand()%4-2,hatcherway_r[3][2]);
-            start = true;
+            m_creature->SetVisibility(VISIBILITY_OFF);
+            m_creature->setDeathState(JUST_DIED);
+            return;
         }
 
-        if(delete_timer < diff && (pInstance && !(pInstance->GetData(DATA_JANALAIEVENT) == 1)))
-        {
-            if(!(m_creature->getVictim()))
-                m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
-            delete_timer = 10000;
-        }else delete_timer -=diff;
-
-        if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        if(!m_creature->SelectHostilTarget() || !m_creature->getVictim())
             return;
 
-        if (buffer_timer < diff)
+        if(BuffetTimer < diff)
         {
-            Unit* target = NULL;
-            target = SelectUnit(SELECT_TARGET_RANDOM,0);
-            if(target)
-                DoCast(target,SPELL_FLAMEBUFFED);
+            m_creature->CastSpell(m_creature->getVictim(), SPELL_FLAMEBUFFET, false);
+            BuffetTimer = 5000;
+        }else BuffetTimer -= diff;
 
-            buffer_timer = 7000;
-        }else buffer_timer -=diff;
-
         DoMeleeAttackIfReady();
     }
 };
 
 CreatureAI* GetAI_mob_hatchlingAI(Creature *_Creature)
 {
-    return new mob_hatchlingAI (_Creature);
+    return new mob_hatchlingAI(_Creature);
 }
 
+struct MANGOS_DLL_DECL mob_eggAI : public ScriptedAI
+{
+    mob_eggAI(Creature *c) : ScriptedAI(c){}
+    void Reset() {}
+    void Aggro(Unit* who) {}
+    void AttackStart(Unit* who) {}
+    void MoveInLineOfSight(Unit* who) {}
+    void UpdateAI(const uint32 diff) {}
+
+    void SpellHit(Unit *caster, const SpellEntry *spell)
+    {
+        if(spell->Id == SPELL_HATCH_EGG)
+        {
+            DoSpawnCreature(MOB_HATCHLING, 0, 0, 0, 0, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 60000);
+            m_creature->SetDisplayId(11686);
+        }            
+    }
+};
+
+CreatureAI* GetAI_mob_eggAI(Creature *_Creature)
+{
+    return new mob_eggAI(_Creature);
+}
+
 void AddSC_boss_janalai()
 {
     Script *newscript;
@@ -744,17 +709,22 @@
     m_scripts[nrscripts++] = newscript;
 
     newscript = new Script;
-    newscript->Name="mob_jandalai_firebomb";
+    newscript->Name="mob_janalai_firebomb";
     newscript->GetAI = GetAI_mob_jandalai_firebombAI;
     m_scripts[nrscripts++] = newscript;
 
     newscript = new Script;
-    newscript->Name="mob_amanishi_hatcher";
+    newscript->Name="mob_janalai_hatcher";
     newscript->GetAI = GetAI_mob_amanishi_hatcherAI;
     m_scripts[nrscripts++] = newscript;
 
     newscript = new Script;
-    newscript->Name="mob_hatchling";
+    newscript->Name="mob_janalai_hatchling";
     newscript->GetAI = GetAI_mob_hatchlingAI;
     m_scripts[nrscripts++] = newscript;
+
+    newscript = new Script;
+    newscript->Name="mob_janalai_egg";
+    newscript->GetAI = GetAI_mob_eggAI;
+    m_scripts[nrscripts++] = newscript; 
 }
Index: scripts/zone/zulaman/boss_nalorakk.cpp
===================================================================
--- scripts/zone/zulaman/boss_nalorakk.cpp	(revision 715)
+++ scripts/zone/zulaman/boss_nalorakk.cpp	(working copy)
@@ -22,6 +22,7 @@
 EndScriptData */
 
 #include "precompiled.h"
+#include "def_zulaman.h"
 
 //TODO: Trash Waves
 
@@ -49,11 +50,11 @@
 #define YELL_BERSERK            "You had your chance, now it be too late!"
 #define SOUND_YELL_BERSERK      12074
 
-#define SPELL_BERSERK           45078                       //unsure, this increases damage, size and speed
+#define SPELL_BERSERK           45078
 
 //Defines for Troll form
 #define SPELL_BRUTALSWIPE       42384
-//#define SPELL_MANGLE            42389 This doesn't seem to apply the mangle debuff after all
+#define SPELL_MANGLE            42389
 #define SPELL_MANGLEEFFECT      44955
 #define SPELL_SURGE             42402
 #define SPELL_BEARFORM          42377
@@ -74,182 +75,217 @@
 
 struct MANGOS_DLL_DECL boss_nalorakkAI : public ScriptedAI
 {
-    boss_nalorakkAI(Creature *c) : ScriptedAI(c) {Reset();}
+    boss_nalorakkAI(Creature *c) : ScriptedAI(c)
+    {
+        pInstance = ((ScriptedInstance*)c->GetInstanceData());
+        Reset();
+    }
 
-    uint32 ChangeForm_Timer;
+    ScriptedInstance *pInstance;
+
     uint32 BrutalSwipe_Timer;
     uint32 Mangle_Timer;
     uint32 Surge_Timer;
+
     uint32 LaceratingSlash_Timer;
     uint32 RendFlesh_Timer;
     uint32 DeafeningRoar_Timer;
-    uint32 ShapeShiftCheck_Timer;
+
+    uint32 ShapeShift_Timer;
     uint32 Berserk_Timer;
+
+    uint64 ChargeTargetGUID;
+    bool isCharging;
+
     bool inBearForm;
-    bool Berserking;
-    bool ChangedToBear;
-    bool ChangedToTroll;
 
     void Reset()
     {
-        ChangeForm_Timer = 45000;
-        BrutalSwipe_Timer = 12000;
-        Mangle_Timer = 15000;
-        Surge_Timer = 20000;
-        LaceratingSlash_Timer = 6000;
-        RendFlesh_Timer = 6000;
-        DeafeningRoar_Timer = 20000;
-        ShapeShiftCheck_Timer = 40000;
+        if(pInstance)
+            pInstance->SetData(DATA_NALORAKKEVENT, NOT_STARTED);
+
+        Surge_Timer = 15000 + rand()%5000;
+        BrutalSwipe_Timer = 7000 + rand()%5000;
+        Mangle_Timer = 10000 + rand()%5000;
+        ShapeShift_Timer = 45000 + rand()%5000;
         Berserk_Timer = 600000;
+
+        ChargeTargetGUID = 0;
+        isCharging = false;
+
         inBearForm = false;
-        Berserking = false;
-        ChangedToBear = false;
-        ChangedToTroll = true;
+        m_creature->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_DISPLAY + 1, 5122);
     }
 
     void Aggro(Unit *who)
     {
+        if(pInstance)
+            pInstance->SetData(DATA_NALORAKKEVENT, IN_PROGRESS);
+
         DoYell(YELL_AGGRO, LANG_UNIVERSAL, NULL);
         DoPlaySoundToSet(m_creature, SOUND_YELL_AGGRO);
+        DoZoneInCombat();
     }
 
-    void KilledUnit(Unit* victim)
+    void JustDied(Unit* Killer)    
+    {	
+        if(pInstance)
+            pInstance->SetData(DATA_NALORAKKEVENT, DONE);
+
+        DoYell(YELL_DEATH,LANG_UNIVERSAL,NULL);		
+        DoPlaySoundToSet(m_creature, SOUND_YELL_DEATH);  
+    }
+
+    void KilledUnit(Unit* victim)    
     {
         switch(rand()%2)
         {
-            case 0:
-                DoYell(YELL_KILL_ONE, LANG_UNIVERSAL, NULL);
-                DoPlaySoundToSet(m_creature, SOUND_YELL_KILL_ONE);
-                break;
-            case 1:
-                DoYell(YELL_KILL_TWO, LANG_UNIVERSAL, NULL);
-                DoPlaySoundToSet(m_creature, SOUND_YELL_KILL_TWO);
-                break;
+        case 0:
+            DoYell(YELL_KILL_ONE, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, SOUND_YELL_KILL_ONE);
+            break;
+        case 1:
+            DoYell(YELL_KILL_TWO, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, SOUND_YELL_KILL_TWO);
+            break;        
         }
     }
 
-    void JustDied(Unit* Killer)
+    void MovementInform(uint32, uint32)
     {
-        DoYell(YELL_DEATH,LANG_UNIVERSAL,NULL);
-        DoPlaySoundToSet(m_creature, SOUND_YELL_DEATH);
+        if(ChargeTargetGUID)
+        {
+            if(Unit* target = Unit::GetUnit(*m_creature, ChargeTargetGUID))
+                m_creature->CastSpell(target, SPELL_SURGE, true);
+            ChargeTargetGUID = 0;
+        }
     }
 
     void UpdateAI(const uint32 diff)
     {
-        //Return since we have no target
-        if (!m_creature->SelectHostilTarget() || !m_creature->getVictim() )
+        if(isCharging)
+        {
+            if(!ChargeTargetGUID)
+            {
+                m_creature->SetSpeed(MOVE_RUN, 1.2f);
+                m_creature->GetMotionMaster()->Clear();
+                if(m_creature->getVictim())
+                {
+                    m_creature->Attack(m_creature->getVictim(), true);
+                    m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
+                }
+                isCharging = false;
+            }
             return;
+        }
 
-        //Berserking
-        if ((Berserk_Timer < diff) && (!Berserking))
+        if(!m_creature->SelectHostilTarget() && !m_creature->getVictim())
+            return;
+
+        if(Berserk_Timer < diff)
         {
-            DoCast(m_creature, SPELL_BERSERK);
+            DoCast(m_creature, SPELL_BERSERK, true);
             DoYell(YELL_BERSERK, LANG_UNIVERSAL, NULL);
             DoPlaySoundToSet(m_creature, SOUND_YELL_BERSERK);
-            Berserking = true;
+            Berserk_Timer = 600000;
         }else Berserk_Timer -= diff;
 
-        //Don't check if we're shapeshifted every UpdateAI
-        if (ShapeShiftCheck_Timer < diff)
+        if(ShapeShift_Timer < diff)
         {
-            //This will return true if we have bearform aura
-            inBearForm = m_creature->HasAura(SPELL_BEARFORM, 0);
-            ShapeShiftCheck_Timer = 1000;
-        }else ShapeShiftCheck_Timer -= diff;
-
-        //Spells for Troll Form (only to be casted if we NOT have bear phase aura)
-        if (!inBearForm)
-        {
-            //We just changed to troll form!
-            if (!ChangedToTroll)
+            if(inBearForm)
             {
+                m_creature->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_DISPLAY + 1, 5122);
                 DoYell(YELL_SHIFTEDTOTROLL, LANG_UNIVERSAL, NULL);
                 DoPlaySoundToSet(m_creature, SOUND_YELL_TOTROLL);
-                ChangedToTroll = true;
-                ChangedToBear = false;
-                //Reset spell timers
-                LaceratingSlash_Timer = 6000 + rand()%19000;
-                RendFlesh_Timer = 6000 + rand()%19000;
-                DeafeningRoar_Timer = 15000 + rand()%10000;
-                ShapeShiftCheck_Timer = 40000;
+                m_creature->RemoveAurasDueToSpell(SPELL_BEARFORM);
+                Surge_Timer = 15000 + rand()%5000;
+                BrutalSwipe_Timer = 7000 + rand()%5000;
+                Mangle_Timer = 10000 + rand()%5000;
+                ShapeShift_Timer = 45000 + rand()%5000;
+                inBearForm = false;
             }
+            else
+            {
+                m_creature->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_DISPLAY + 1, 0);
+                DoYell(YELL_SHIFTEDTOBEAR, LANG_UNIVERSAL, NULL);
+                DoPlaySoundToSet(m_creature, SOUND_YELL_TOBEAR);
+                DoCast(m_creature, SPELL_BEARFORM, true);
+                LaceratingSlash_Timer = 2000; // dur 18s
+                RendFlesh_Timer = 3000;  // dur 5s
+                DeafeningRoar_Timer = 5000 + rand()%5000;  // dur 2s
+                ShapeShift_Timer = 20000 + rand()%5000; // dur 30s
+                inBearForm = true;
+            }
+        }else ShapeShift_Timer -= diff;
 
-            //Brutal Swipe (some sources may say otherwise, but I've never seen this in Bear form)
-            if (BrutalSwipe_Timer < diff)
+        if(!inBearForm)
+        {
+            if(BrutalSwipe_Timer < diff)
             {
                 DoCast(m_creature->getVictim(), SPELL_BRUTALSWIPE);
-                BrutalSwipe_Timer = 7000 + rand()%13000;
+                BrutalSwipe_Timer = 7000 + rand()%5000;
             }else BrutalSwipe_Timer -= diff;
 
-            //Mangle
-            if (Mangle_Timer < diff)
+            if(Mangle_Timer < diff)
             {
-                DoCast(m_creature->getVictim(), SPELL_MANGLEEFFECT);
-                Mangle_Timer = 3000 + rand()%17000;
+                if(!m_creature->getVictim()->HasAura(SPELL_MANGLEEFFECT, 0))
+                {
+                    DoCast(m_creature->getVictim(), SPELL_MANGLE);
+                    Mangle_Timer = 1000;
+                }
+                else Mangle_Timer = 10000 + rand()%5000;
             }else Mangle_Timer -= diff;
 
-            //Surge
-            if (Surge_Timer < diff)
+            if(Surge_Timer < diff)
             {
-                //select a random unit other than the main tank
+                DoYell(YELL_SURGE, LANG_UNIVERSAL, NULL);
+                DoPlaySoundToSet(m_creature, SOUND_YELL_SURGE);
+
                 Unit *target = SelectUnit(SELECT_TARGET_RANDOM, 1);
+                if(!target) target = m_creature->getVictim();
+                isCharging = true;
+                ChargeTargetGUID = target->GetGUID();
 
-                //if there aren't other units, cast on the tank
-                if(!target)
-                    target = m_creature->getVictim();
+                float x, y, z;
+                target->GetContactPoint(m_creature, x, y, z);
+                m_creature->SetSpeed(MOVE_RUN, 5.0f);
+                m_creature->GetMotionMaster()->Clear();
+                m_creature->GetMotionMaster()->MovePoint(0, x, y, z);
 
-                DoCast(target, SPELL_SURGE);
-
-                DoYell(YELL_SURGE, LANG_UNIVERSAL, NULL);
-                DoPlaySoundToSet(m_creature, SOUND_YELL_SURGE);
-
-                Surge_Timer = 15000 + rand()%17500;
+                Surge_Timer = 15000 + rand()%5000;
+                return;
             }else Surge_Timer -= diff;
-
-            //Change to Bear Form if we're in Troll Form for 45sec
-            if (ChangeForm_Timer < diff)
-            {
-                DoCast(m_creature, SPELL_BEARFORM);
-                //And 30sec (bear form) + 45sec (troll form) before we should cast this again
-                ChangeForm_Timer = 75000;
-            }else ChangeForm_Timer -= diff;
         }
-        //Spells for Bear Form (only to be casted if we have bear phase aura)
         else
         {
-            //We just changed to bear form!
-            if (!ChangedToBear)
+            if(LaceratingSlash_Timer < diff)
             {
-                DoYell(YELL_SHIFTEDTOBEAR, LANG_UNIVERSAL, NULL);
-                DoPlaySoundToSet(m_creature, SOUND_YELL_TOBEAR);
-                ChangedToBear = true;
-                ChangedToTroll = false;
-                //Reset spell timers
-                Surge_Timer = 15000 + rand()%17500;
-                BrutalSwipe_Timer = 7000 + rand()%13000;
-                Mangle_Timer = 3000 + rand()%17000;
-                ShapeShiftCheck_Timer = 25000;
-            }
-
-            //Lacerating Slash
-            if (LaceratingSlash_Timer < diff)
-            {
-                DoCast(m_creature->getVictim(), SPELL_LACERATINGSLASH);
-                LaceratingSlash_Timer = 6000 + rand()%19000;
+                if(!m_creature->getVictim()->HasAura(SPELL_MANGLEEFFECT, 0))
+                    DoCast(m_creature->getVictim(), SPELL_LACERATINGSLASH);
+                else
+                {
+                    int32 bp0 = 3470;
+                    m_creature->CastCustomSpell(m_creature->getVictim(), SPELL_LACERATINGSLASH, &bp0, NULL, NULL, false);
+                }
+                LaceratingSlash_Timer = 18000 + rand()%5000;
             }else LaceratingSlash_Timer -= diff;
 
-            //Rend Flesh
-            if (RendFlesh_Timer < diff)
+            if(RendFlesh_Timer < diff)
             {
-                DoCast(m_creature->getVictim(), SPELL_RENDFLESH);
-                RendFlesh_Timer = 6000 + rand()%19000;
+                if(!m_creature->getVictim()->HasAura(SPELL_MANGLEEFFECT, 0))
+                    DoCast(m_creature->getVictim(), SPELL_RENDFLESH);
+                else
+                {
+                    int32 bp1 = 4670;
+                    m_creature->CastCustomSpell(m_creature->getVictim(), SPELL_RENDFLESH, NULL, &bp1, NULL, false);
+                }
+                RendFlesh_Timer = 5000 + rand()%5000;
             }else RendFlesh_Timer -= diff;
 
-            //Deafening Roar
-            if (DeafeningRoar_Timer < diff)
+            if(DeafeningRoar_Timer < diff)
             {
                 DoCast(m_creature->getVictim(), SPELL_DEAFENINGROAR);
-                DeafeningRoar_Timer = 15000 + rand()%10000;
+                DeafeningRoar_Timer = 15000 + rand()%5000;
             }else DeafeningRoar_Timer -= diff;
         }
 
Index: scripts/zone/zulaman/boss_zuljin.cpp
===================================================================
--- scripts/zone/zulaman/boss_zuljin.cpp	(revision 0)
+++ scripts/zone/zulaman/boss_zuljin.cpp	(revision 0)
@@ -0,0 +1,677 @@
+/* Copyright (C) 2006,2007,2008 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* ScriptData
+SDName: Boss_ZulJin
+SD%Complete: 85%
+SDComment: 
+EndScriptData */
+
+#include "precompiled.h"
+#include "def_zulaman.h"
+//#include "spell.h"
+
+//Speech
+#define YELL_TRANSFORM_TO_LYNX "Let me introduce to you my new bruddahs: fang and claw!"
+#define SOUND_TRANSFORM_TO_LYNX 12094
+
+#define YELL_TRANSFORM_TO_BEAR "Got me some new tricks...like me bruddah bear!"
+#define SOUND_TRANSFORM_TO_BEAR 12092
+
+#define YELL_TRANSFORM_TO_DRAGONHAWK "Ya don' have to look to da sky to see da dragonhawk!"
+#define SOUND_TRANSFORM_TO_DRAGONHAWK 12095
+
+#define YELL_TRANSFORM_TO_EAGLE "Dere be no hidin' from da eagle!"
+#define SOUND_TRANSFORM_TO_EAGLE 12093
+
+#define YELL_KILL_ONE "Da Amani de chuka!"
+#define SOUND_KILL_ONE 12098
+
+#define YELL_KILL_TWO "Lot more gonna fall like you!"
+#define SOUND_KILL_TWO 12099
+
+#define YELL_FIRE_BREATH "Fire kill you just as quick!"
+#define SOUND_FIRE_BRETH 12096
+
+#define YELL_AGGRO "Nobody badduh dan me!"
+#define SOUND_AGGRO 12091
+
+#define YELL_BERSERK "You too slow! Me too strong!"
+#define SOUND_BERSERK 12097
+
+#define YELL_DEATH "Mebbe me fall...but da Amani empire...never gonna die..."
+#define SOUND_DEATH 12100
+
+//Still not used, need more info
+#define YELL_INTRO "Everybody always wanna take from us. Now we gonna start takin' back. Anybody who get in our way...gonna drown in their own blood! De Amani empire be back now...seekin' vengeance. And we gonna start...with you!"
+#define SOUND_INTRO 12090
+
+//Spells:
+// ====== Troll Form
+#define SPELL_WHIRLWIND             17207
+#define SPELL_GRIEVOUS_THROW        43093   // remove debuff after full healed
+// ====== Bear Form
+#define SPELL_CREEPING_PARALYSIS    43095   // should cast on the whole raid
+#define SPELL_OVERPOWER             43456   // use after melee attack dodged
+// ====== Eagle Form
+#define SPELL_ENERGY_STORM          43983   // enemy area aura, trigger 42577
+#define SPELL_ZAP_INFORM            42577
+#define SPELL_ZAP_DAMAGE            43137   // 1250 damage
+#define SPELL_SUMMON_CYCLONE        43112   // summon four feather vortex
+#define CREATURE_FEATHER_VORTEX     24136
+#define SPELL_CYCLONE_VISUAL        43119   // trigger 43147 visual
+#define SPELL_CYCLONE_PASSIVE       43120   // trigger 43121 (4y aoe) every second
+//Lynx Form
+#define SPELL_CLAW_RAGE_HASTE       42583
+#define SPELL_CLAW_RAGE_TRIGGER     43149
+#define SPELL_CLAW_RAGE_DAMAGE      43150
+#define SPELL_LYNX_RUSH_HASTE       43152
+#define SPELL_LYNX_RUSH_DAMAGE      43153
+//Dragonhawk Form
+#define SPELL_FLAME_WHIRL           43213   // trigger two spells
+#define SPELL_FLAME_BREATH          43215
+#define SPELL_SUMMON_PILLAR         43216   // summon 24187
+#define CREATURE_COLUMN_OF_FIRE     24187
+#define SPELL_PILLAR_TRIGGER        43218   // trigger 43217
+
+//cosmetic
+#define SPELL_SPIRIT_AURA           42466
+#define SPELL_SIPHON_SOUL           43501
+
+//Transforms:
+#define SPELL_SHAPE_OF_THE_BEAR     42594   // 15% dmg
+#define SPELL_SHAPE_OF_THE_EAGLE    42606
+#define SPELL_SHAPE_OF_THE_LYNX     42607   // haste melee 30%
+#define SPELL_SHAPE_OF_THE_DRAGONHAWK   42608
+
+#define SPELL_BERSERK 45078
+
+
+#define PHASE_BEAR 0
+#define PHASE_EAGLE 1
+#define PHASE_LYNX 2
+#define PHASE_DRAGONHAWK 3
+#define PHASE_TROLL 4
+
+//coords for going for changing form
+#define CENTER_X 120.148811
+#define CENTER_Y 703.713684
+#define CENTER_Z 45.111477
+
+struct SpiritInfoStruct
+{
+    uint32 entry;
+    float x, y, z, orient;
+};
+
+static SpiritInfoStruct SpiritInfo[] =
+{
+    {23878, 147.87, 706.51, 45.11, 3.04},
+    {23880, 88.95, 705.49, 45.11, 6.11},
+    {23877, 137.23, 725.98, 45.11, 3.71},
+    {23879, 104.29, 726.43, 45.11, 5.43}
+};
+
+struct TransformStruct
+{
+    uint32 sound;
+    char* text;
+    uint32 spell, unaura;
+};
+
+static TransformStruct Transform[] =
+{
+    {SOUND_TRANSFORM_TO_BEAR, YELL_TRANSFORM_TO_BEAR, SPELL_SHAPE_OF_THE_BEAR, SPELL_WHIRLWIND},
+    {SOUND_TRANSFORM_TO_EAGLE, YELL_TRANSFORM_TO_EAGLE, SPELL_SHAPE_OF_THE_EAGLE, SPELL_SHAPE_OF_THE_BEAR},
+    {SOUND_TRANSFORM_TO_LYNX, YELL_TRANSFORM_TO_LYNX, SPELL_SHAPE_OF_THE_LYNX, SPELL_SHAPE_OF_THE_EAGLE},
+    {SOUND_TRANSFORM_TO_DRAGONHAWK, YELL_TRANSFORM_TO_DRAGONHAWK, SPELL_SHAPE_OF_THE_DRAGONHAWK, SPELL_SHAPE_OF_THE_LYNX}
+};
+
+struct MANGOS_DLL_DECL boss_zuljinAI : public ScriptedAI
+{
+    boss_zuljinAI(Creature *c) : ScriptedAI(c)
+    {
+        pInstance = ((ScriptedInstance*)c->GetInstanceData());
+        // wait for core patch be accepted
+        SpellEntry *TempSpell = (SpellEntry*)GetSpellStore()->LookupEntry(SPELL_CLAW_RAGE_DAMAGE);
+        if(TempSpell)
+        {
+            //if(TempSpell->DmgClass != SPELL_DAMAGE_CLASS_MELEE)
+            //    TempSpell->DmgClass = SPELL_DAMAGE_CLASS_MELEE;
+            if(TempSpell->EffectApplyAuraName[2] != SPELL_AURA_MOD_STUN)
+                TempSpell->EffectApplyAuraName[2] = SPELL_AURA_MOD_STUN;
+        }
+        Reset();
+    }
+    ScriptedInstance *pInstance;
+
+    uint64 SpiritGUID[4];
+    uint64 ClawTargetGUID;
+    uint64 TankGUID;
+
+    uint32 Phase;
+    uint32 health_20;
+
+    uint32 Intro_Timer;
+    uint32 Berserk_Timer;
+
+    uint32 Whirlwind_Timer;
+    uint32 Grievous_Throw_Timer;
+
+    uint32 Creeping_Paralysis_Timer;
+    uint32 Overpower_Timer;
+
+    uint32 Claw_Rage_Timer;
+    uint32 Lynx_Rush_Timer;
+    uint32 Claw_Counter;
+    uint32 Claw_Loop_Timer;
+
+    uint32 Flame_Whirl_Timer;
+    uint32 Flame_Breath_Timer;
+    uint32 Pillar_Of_Fire_Timer;
+
+    void Reset()
+    {
+        if(pInstance)
+            pInstance->SetData(DATA_ZULJINEVENT, NOT_STARTED);
+
+        Phase = 0;
+
+        health_20 = m_creature->GetMaxHealth()*0.2;
+
+        Intro_Timer = 37000;
+        Berserk_Timer = 600000;
+
+        Whirlwind_Timer = 7000;
+        Grievous_Throw_Timer = 8000;
+
+        Creeping_Paralysis_Timer = 7000;
+        Overpower_Timer = 0;
+
+        Claw_Rage_Timer = 5000;
+        Lynx_Rush_Timer = 14000;
+        Claw_Loop_Timer = 0;
+        Claw_Counter = 0;
+
+        Flame_Whirl_Timer = 5000;
+        Flame_Breath_Timer = 6000;
+        Pillar_Of_Fire_Timer = 7000;
+
+        ClawTargetGUID = 0;
+        TankGUID = 0;        
+
+        DespawnAdds();
+        DespawnSummons(CREATURE_FEATHER_VORTEX);
+        DespawnSummons(CREATURE_COLUMN_OF_FIRE);
+
+        m_creature->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_DISPLAY, 47174);
+        m_creature->SetUInt32Value(UNIT_VIRTUAL_ITEM_INFO, 218172674);
+        m_creature->SetByteValue(UNIT_FIELD_BYTES_2, 0, SHEATH_STATE_MELEE);
+    }
+
+    void Aggro(Unit *who)
+    {
+        if(pInstance)
+            pInstance->SetData(DATA_ZULJINEVENT, IN_PROGRESS);
+
+        DoZoneInCombat();
+        
+        DoYell(YELL_INTRO,LANG_UNIVERSAL,NULL);
+        DoPlaySoundToSet(m_creature, SOUND_INTRO);
+        SpawnAdds();
+        EnterPhase(0);
+    }
+
+    void KilledUnit(Unit* victim)    
+    {
+        if(Intro_Timer)
+            return;
+
+        switch(rand()%2)
+        {
+        case 0:
+            DoYell(YELL_KILL_ONE, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, SOUND_KILL_ONE);
+            break;
+        case 1:
+            DoYell(YELL_KILL_TWO, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, SOUND_KILL_TWO);
+            break;        
+        }
+    }
+
+    void JustDied(Unit* Killer)    
+    {
+        if(pInstance)
+            pInstance->SetData(DATA_ZULJINEVENT, DONE);
+
+        DoYell(YELL_DEATH, LANG_UNIVERSAL, NULL);
+        DoPlaySoundToSet(m_creature, SOUND_DEATH);
+        DespawnSummons(CREATURE_COLUMN_OF_FIRE);
+
+        if(Unit *Temp = Unit::GetUnit(*m_creature, SpiritGUID[3]))
+            Temp->SetUInt32Value(UNIT_FIELD_BYTES_1,PLAYER_STATE_DEAD);
+    }
+
+    void AttackStart(Unit *who)
+    {
+        if(!who)
+            return;
+
+        if (who->isTargetableForAttack())
+        {
+            if(Phase == 2)
+                m_creature->Attack(who, false);
+            else
+                AttackStart(who);
+        }
+    }
+
+    void DoMeleeAttackIfReady()
+    {
+        if( !m_creature->IsNonMeleeSpellCasted(false))
+        {
+            if(m_creature->isAttackReady() && m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+            {
+                if(Phase == 1 && !Overpower_Timer)
+                {
+                    uint32 health = m_creature->getVictim()->GetHealth();
+                    m_creature->AttackerStateUpdate(m_creature->getVictim());
+                    if(m_creature->getVictim() && health == m_creature->getVictim()->GetHealth())
+                    {
+                        m_creature->CastSpell(m_creature->getVictim(), SPELL_OVERPOWER, false);
+                        Overpower_Timer = 5000;
+                    }
+                }else m_creature->AttackerStateUpdate(m_creature->getVictim());
+                m_creature->resetAttackTimer();
+            }
+        }
+    }
+
+    void SpawnAdds()
+    {
+        Creature *pCreature = NULL;
+        for(uint8 i = 0; i < 4; i++)
+        {
+            pCreature = m_creature->SummonCreature(SpiritInfo[i].entry, SpiritInfo[i].x, SpiritInfo[i].y, SpiritInfo[i].z, SpiritInfo[i].orient, TEMPSUMMON_DEAD_DESPAWN, 0);
+            if(pCreature)
+            {
+                pCreature->CastSpell(pCreature, SPELL_SPIRIT_AURA, true);
+                pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                pCreature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                SpiritGUID[i] = pCreature->GetGUID();
+            }
+        }
+    }
+
+    void DespawnAdds()
+    {
+        for(uint8 i = 0; i < 4; i++)
+        {
+            Unit* Temp = NULL;
+            if(SpiritGUID[i])
+            {
+                if(Temp = Unit::GetUnit(*m_creature, SpiritGUID[i]))
+                {
+                    Temp->SetVisibility(VISIBILITY_OFF);
+                    Temp->setDeathState(DEAD);
+                }
+            }
+            SpiritGUID[i] = 0;
+        }
+    }
+
+    void DespawnSummons(uint32 entry)
+    {
+        std::list<Creature*> templist;
+        float x, y, z;
+        m_creature->GetPosition(x, y, z);
+
+        {
+            CellPair pair(MaNGOS::ComputeCellPair(x, y));
+            Cell cell(pair);
+            cell.data.Part.reserved = ALL_DISTRICT;
+            cell.SetNoCreate();
+
+            AllCreaturesOfEntryInRange check(m_creature, entry, 100);
+            MaNGOS::CreatureListSearcher<AllCreaturesOfEntryInRange> searcher(templist, check);
+
+            TypeContainerVisitor<MaNGOS::CreatureListSearcher<AllCreaturesOfEntryInRange>, GridTypeMapContainer> cSearcher(searcher);
+
+            CellLock<GridReadGuard> cell_lock(cell, pair);
+            cell_lock->Visit(cell_lock, cSearcher, *(m_creature->GetMap()));
+        }
+
+        for(std::list<Creature*>::iterator i = templist.begin(); i != templist.end(); ++i)
+        {
+            (*i)->SetVisibility(VISIBILITY_OFF);
+            (*i)->setDeathState(JUST_DIED);
+        }
+    }
+
+    void EnterPhase(uint32 NextPhase)
+    {
+        switch(NextPhase)
+        {
+        case 0:
+            break;
+        case 1:
+        case 2:
+        case 3:
+        case 4:
+            m_creature->Relocate(CENTER_X, CENTER_Y, CENTER_Z,0);
+            m_creature->SendMonsterMove(CENTER_X, CENTER_Y, CENTER_Z,0,0,100);
+            DoResetThreat();
+            m_creature->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_DISPLAY, 0);
+            m_creature->RemoveAurasDueToSpell(Transform[Phase].unaura);
+            DoCast(m_creature, Transform[Phase].spell);
+            DoYell(Transform[Phase].text, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, Transform[Phase].sound);
+            if(Phase > 0)
+            {
+                if(Unit *Temp = Unit::GetUnit(*m_creature, SpiritGUID[Phase - 1]))
+                    Temp->SetUInt32Value(UNIT_FIELD_BYTES_1,PLAYER_STATE_DEAD);
+            }
+            if(Unit *Temp = Unit::GetUnit(*m_creature, SpiritGUID[NextPhase - 1]))
+                Temp->CastSpell(m_creature, SPELL_SIPHON_SOUL, false); // should m cast on temp
+            if(NextPhase == 2)
+            {
+                m_creature->GetMotionMaster()->Clear();
+                m_creature->CastSpell(m_creature, SPELL_ENERGY_STORM, true); // enemy aura
+                for(uint8 i = 0; i < 4; i++)
+                {
+                    Creature* Vortex = DoSpawnCreature(CREATURE_FEATHER_VORTEX, 0, 0, 0, 0, TEMPSUMMON_CORPSE_DESPAWN, 0);
+                    if(Vortex)
+                    {
+                        Vortex->CastSpell(Vortex, SPELL_CYCLONE_PASSIVE, true);
+                        Vortex->CastSpell(Vortex, SPELL_CYCLONE_VISUAL, true);
+                        Vortex->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                        Vortex->SetSpeed(MOVE_RUN, 1.0f);
+                        Vortex->AI()->AttackStart(SelectUnit(SELECT_TARGET_RANDOM, 0));
+                        DoZoneInCombat(Vortex);
+                    }
+                }
+            }
+            else
+                m_creature->AI()->AttackStart(m_creature->getVictim());
+            if(NextPhase == 3)
+            {
+                m_creature->RemoveAurasDueToSpell(SPELL_ENERGY_STORM);
+                DespawnSummons(CREATURE_FEATHER_VORTEX);
+                m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
+            }
+            break;
+        default:
+            break;
+        }
+        Phase = NextPhase;
+    }
+    
+    void UpdateAI(const uint32 diff)
+    {
+        if(!TankGUID)
+        {
+            if(!m_creature->SelectHostilTarget() && !m_creature->getVictim())
+                return;
+
+            if(m_creature->GetHealth() < health_20 * (4 - Phase))
+                EnterPhase(Phase + 1);
+        }
+
+        if(Berserk_Timer < diff)
+        {
+            m_creature->CastSpell(m_creature, SPELL_BERSERK, true);
+            DoYell(YELL_BERSERK, LANG_UNIVERSAL, NULL);
+            DoPlaySoundToSet(m_creature, SOUND_BERSERK);
+            Berserk_Timer = 60000;
+        }else Berserk_Timer -= diff;
+
+        switch (Phase)
+        {
+        case 0:
+            if(Intro_Timer)
+            {
+                if(Intro_Timer <= diff)
+                {
+                    DoYell(YELL_AGGRO, LANG_UNIVERSAL, NULL);
+                    DoPlaySoundToSet(m_creature, SOUND_AGGRO);
+                    Intro_Timer = 0;
+                }else Intro_Timer -= diff;
+            }
+
+            if(Whirlwind_Timer < diff)
+            {
+                DoCast(m_creature, SPELL_WHIRLWIND);
+                Whirlwind_Timer = 15000 + rand()%5000;
+            }else Whirlwind_Timer -= diff;
+
+            if(Grievous_Throw_Timer < diff)
+            {
+                if(Unit *target = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                    m_creature->CastSpell(target, SPELL_GRIEVOUS_THROW, false);
+                Grievous_Throw_Timer = 10000;
+            }else Grievous_Throw_Timer -= diff;
+            break;
+
+        case 1:
+            if(Creeping_Paralysis_Timer < diff)
+            {
+                DoCast(m_creature, SPELL_CREEPING_PARALYSIS);
+                Creeping_Paralysis_Timer = 20000;
+            }else Creeping_Paralysis_Timer -= diff;
+
+            if(Overpower_Timer < diff)
+            {
+                // implemented in DoMeleeAttackIfReady()
+                Overpower_Timer = 0;
+            }else Overpower_Timer -= diff;
+            break;
+
+        case 2:
+            return;
+
+        case 3:
+            if(Claw_Rage_Timer <= diff)
+            {
+                if(!TankGUID)
+                {
+                    if(Unit* target = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                    {
+                        TankGUID = m_creature->getVictim()->GetGUID();
+                        m_creature->SetSpeed(MOVE_RUN, 5.0f);
+                        AttackStart(target); // change victim
+                        Claw_Rage_Timer = 0;
+                        Claw_Loop_Timer = 500;
+                        Claw_Counter = 0;
+                    }
+                }
+                else if(!Claw_Rage_Timer) // do not do this when Lynx_Rush
+                {
+                    if(Claw_Loop_Timer < diff)
+                    {
+                        Unit* target = m_creature->getVictim();
+                        if(!target || !target->isTargetableForAttack()) target = Unit::GetUnit(*m_creature, TankGUID);
+                        if(!target || !target->isTargetableForAttack()) target = SelectUnit(SELECT_TARGET_RANDOM, 0);
+                        if(target)
+                        {
+                            AttackStart(target);
+                            if(m_creature->IsWithinDistInMap(target, ATTACK_DISTANCE))
+                            {
+                                m_creature->CastSpell(target, SPELL_CLAW_RAGE_DAMAGE, true);
+                                Claw_Counter++;
+                                if(Claw_Counter == 12)
+                                {
+                                    Claw_Rage_Timer = 15000 + rand()%5000;
+                                    m_creature->SetSpeed(MOVE_RUN, 1.2f);
+                                    AttackStart(Unit::GetUnit(*m_creature, TankGUID));
+                                    TankGUID = 0;
+                                    return;
+                                }
+                                else
+                                    Claw_Loop_Timer = 500;
+                            }
+                        }else EnterEvadeMode(); // if(target)
+                    }else Claw_Loop_Timer -= diff;
+                } //if(TankGUID)
+            }else Claw_Rage_Timer -= diff;
+
+            if(Lynx_Rush_Timer <= diff)
+            {
+                if(!TankGUID)
+                {
+                    if(Unit* target = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                    {
+                        TankGUID = m_creature->getVictim()->GetGUID();
+                        m_creature->SetSpeed(MOVE_RUN, 5.0f);
+                        AttackStart(target); // change victim
+                        Lynx_Rush_Timer = 0;
+                        Claw_Counter = 0;
+                    }
+                }
+                else if(!Lynx_Rush_Timer)
+                {
+                    Unit* target = m_creature->getVictim();
+                    if(!target || !target->isTargetableForAttack())
+                    {
+                        target = SelectUnit(SELECT_TARGET_RANDOM, 0);
+                        AttackStart(target);
+                    }
+                    if(target)
+                    {
+                        if(m_creature->IsWithinDistInMap(target, ATTACK_DISTANCE))
+                        {
+                            m_creature->CastSpell(target, SPELL_LYNX_RUSH_DAMAGE, true);
+                            Claw_Counter++;
+                            if(Claw_Counter == 9)
+                            {
+                                Lynx_Rush_Timer = 15000 + rand()%5000;
+                                m_creature->SetSpeed(MOVE_RUN, 1.2f);
+                                AttackStart(Unit::GetUnit(*m_creature, TankGUID));
+                                TankGUID = 0;
+                            }
+                            else
+                                AttackStart(SelectUnit(SELECT_TARGET_RANDOM, 0));
+                        }
+                    }else EnterEvadeMode(); // if(target)
+                } //if(TankGUID)
+            }else Lynx_Rush_Timer -= diff;
+
+            break;
+        case 4:
+            if(Flame_Whirl_Timer < diff)
+            {
+                DoCast(m_creature, SPELL_FLAME_WHIRL);
+                Flame_Whirl_Timer = 12000;
+            }Flame_Whirl_Timer -= diff;
+
+            if(Pillar_Of_Fire_Timer < diff)
+            {
+                if(Unit* target = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                {
+                    float x, y, z;
+                    target->GetPosition(x, y, z);
+                    Creature* Pillar = m_creature->SummonCreature(CREATURE_COLUMN_OF_FIRE, x, y, z, 0, TEMPSUMMON_TIMED_DESPAWN, 30000);
+                    if(Pillar)
+                    {
+                        Pillar->CastSpell(Pillar, SPELL_PILLAR_TRIGGER, true);
+                        Pillar->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                    }
+                }
+                Pillar_Of_Fire_Timer = 10000;
+            }else Pillar_Of_Fire_Timer -= diff;
+
+            if(Flame_Breath_Timer < diff)
+            {
+                if(Unit* target = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                    m_creature->CastSpell(m_creature, SPELL_FLAME_BREATH, false);
+                Flame_Breath_Timer = 10000;
+            }else Flame_Breath_Timer -= diff;
+            break;
+
+        default:
+            break;
+        }
+
+        if(!TankGUID)
+            DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_boss_zuljin(Creature *_Creature)
+{
+    return new boss_zuljinAI (_Creature);
+}
+
+struct MANGOS_DLL_DECL do_nothingAI : public ScriptedAI
+{
+    do_nothingAI(Creature *c) : ScriptedAI(c) {}
+    void Reset() {}
+    void Aggro(Unit* who) {}
+    void AttackStart(Unit* who) {}
+    void MoveInLineOfSight(Unit* who) {}
+    void UpdateAI(const uint32 diff) {}
+};
+
+CreatureAI* GetAI_do_nothing(Creature *_Creature)
+{
+    return new do_nothingAI (_Creature);
+}
+
+struct MANGOS_DLL_DECL feather_vortexAI : public ScriptedAI
+{
+    feather_vortexAI(Creature *c) : ScriptedAI(c) {}
+
+    void Reset() {}
+
+    void Aggro(Unit* target) {}
+
+    void SpellHit(Unit *caster, const SpellEntry *spell)
+    {
+        if(spell->Id == SPELL_ZAP_INFORM)
+            m_creature->CastSpell(caster, SPELL_ZAP_DAMAGE, true);           
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        //if the vortex reach the target, it change his target to another player
+        if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+            AttackStart(SelectUnit(SELECT_TARGET_RANDOM, 0));
+    }
+};
+
+CreatureAI* GetAI_feather_vortexAI(Creature *_Creature)
+{
+    return new feather_vortexAI (_Creature);
+}
+
+void AddSC_boss_zuljin()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name="boss_zuljin";
+    newscript->GetAI = GetAI_boss_zuljin;
+    m_scripts[nrscripts++] = newscript;
+
+    newscript = new Script;
+    newscript->Name="do_nothing";
+    newscript->GetAI = GetAI_do_nothing;
+    m_scripts[nrscripts++] = newscript;
+
+    newscript = new Script;
+    newscript->Name="mob_zuljin_vortex";
+    newscript->GetAI = GetAI_feather_vortexAI;
+    m_scripts[nrscripts++] = newscript;
+}
Index: scripts/zone/zulaman/def_zulaman.h
===================================================================
--- scripts/zone/zulaman/def_zulaman.h	(revision 715)
+++ scripts/zone/zulaman/def_zulaman.h	(working copy)
@@ -5,13 +5,14 @@
 #ifndef DEF_ZULAMAN_H
 #define DEF_ZULAMAN_H
 
-#define DATA_JANALAI        1
-#define DATA_JANALAIEVENT   2
-#define DATA_J_EGGSLEFT     3
-#define DATA_J_EGGSRIGHT    4
-#define DATA_J_HATCHLEFT    5
-#define DATA_J_HATCHRIGHT   6
+#define DATA_NALORAKKEVENT  1
+#define DATA_AKILZONEVENT   2
+#define DATA_JANALAIEVENT   3
+#define DATA_HALAZZIEVENT   4
+#define DATA_HEXLORDEVENT   5
+#define DATA_ZULJINEVENT    6
+#define DATA_CHESTLOOTED    7
+#define TYPE_RAND_VENDOR_1  8
+#define TYPE_RAND_VENDOR_2  9
 
-#define TYPE_RAND_VENDOR_1  7
-#define TYPE_RAND_VENDOR_2  8
 #endif
Index: scripts/zone/zulaman/instance_zulaman.cpp
===================================================================
--- scripts/zone/zulaman/instance_zulaman.cpp	(revision 715)
+++ scripts/zone/zulaman/instance_zulaman.cpp	(working copy)
@@ -24,26 +24,58 @@
 #include "precompiled.h"
 #include "def_zulaman.h"
 
-#define ENCOUNTERS     1
+#define ENCOUNTERS     6
 #define RAND_VENDOR    2
 
+// Chests spawn at bear/eagle/dragonhawk/lynx bosses
+// The loots depend on how many bosses have been killed, but not the entries of the chests
+// But we cannot add loots to gameobject, so we have to use the fixed loot_template
+struct SHostageInfo
+{
+    uint32 npc, go;
+    float x, y, z, o;
+};
+
+static SHostageInfo HostageInfo[] =
+{
+    {23790, 186648, -57, 1343, 40.77, 3.2}, // bear
+    {23999, 187021, 400, 1414, 74.36, 3.3}, // eagle
+    {24001, 186672, -35, 1134, 18.71, 1.9}, // dragonhawk
+    {24024, 186667, 413, 1117,  6.32, 3.1}  // lynx
+    
+};
+
 struct MANGOS_DLL_DECL instance_zulaman : public ScriptedInstance
 {
     instance_zulaman(Map *Map) : ScriptedInstance(Map) {Initialize();};
 
-    uint64 janalai;
-    uint32 janalai_eggs_l;
-    uint32 janalai_eggs_r;
+    uint64 HexLordGateGUID;
+    uint64 ZulJinGateGUID;
+    uint64 AkilzonDoorGUID;
+    uint64 ZulJinDoorGUID;
+    uint64 HalazziDoorGUID;
 
+    uint32 QuestTimer;
+    uint16 BossKilled;
+    uint16 QuestMinute;
+    uint16 ChestLooted;
+
     uint32 Encounters[ENCOUNTERS];
     uint32 RandVendor[RAND_VENDOR];
 
     void Initialize()
     {
-        janalai = 0;
-        janalai_eggs_l = 20;
-        janalai_eggs_r = 20;
+        uint64 HexLordGateGUID = 0;
+        uint64 ZulJinGateGUID = 0;
+        uint64 AkilzonDoorGUID = 0;
+        uint64 HalazziDoorGUID = 0;
+        uint64 ZulJinDoorGUID = 0;
 
+        QuestTimer = 0;
+        QuestMinute = 21;
+        BossKilled = 0;
+        ChestLooted = 0;
+
         for(uint8 i = 0; i < ENCOUNTERS; i++)
             Encounters[i] = NOT_STARTED;
         for(uint8 i = 0; i < RAND_VENDOR; i++)
@@ -62,64 +94,200 @@
     {
         switch(creature_entry)
         {
-            case 23578:
-                janalai = creature->GetGUID();
-                break;
+        case 23578://janalai
+        case 23863://zuljin
+        case 24239://hexlord
+        case 23577://halazzi
+        case 23576://nalorakk
+        default: break;
         }
     }
 
-    uint64 GetData64(uint32 identifier)
+    void OnObjectCreate(GameObject *go)
     {
-        if(identifier  == DATA_JANALAI && janalai)
-            return janalai;
+        switch(go->GetEntry())
+        {
+        case 186303: HalazziDoorGUID = go->GetGUID(); break;
+        case 186304: ZulJinGateGUID  = go->GetGUID(); break;
+        case 186305: HexLordGateGUID = go->GetGUID(); break;
+        case 186858: AkilzonDoorGUID = go->GetGUID(); break;
+        case 186859: ZulJinDoorGUID  = go->GetGUID(); break;
+        default: break;
+        }
+        CheckInstanceStatus();
+    }
 
-        return 0;
+    void OpenDoor(uint64 DoorGUID, bool open)
+    {
+        if(((InstanceMap*)instance)->GetPlayers().size())
+            if(Player* first = ((InstanceMap*)instance)->GetPlayers().front())
+                if(GameObject *Door = GameObject::GetGameObject(*first, DoorGUID))
+                    Door->SetUInt32Value(GAMEOBJECT_STATE, open ? 0 : 1);
     }
 
+    void SummonHostage(uint8 num)
+    {
+        if(QuestMinute && ((InstanceMap*)instance)->GetPlayers().size())
+            if(Player* first = ((InstanceMap*)instance)->GetPlayers().front())
+                if(Unit* Hostage = first->SummonCreature(HostageInfo[num].npc, HostageInfo[num].x, HostageInfo[num].y, HostageInfo[num].z, HostageInfo[num].o, TEMPSUMMON_DEAD_DESPAWN, 0))
+                {
+                    Hostage->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    Hostage->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+                }
+    }
+
+    void CheckInstanceStatus()
+    {
+        if(BossKilled >= 4)
+            OpenDoor(HexLordGateGUID, true);
+
+        if(BossKilled >= 5)
+            OpenDoor(ZulJinGateGUID, true);
+    }
+
+    void UpdateWorldState(uint32 field, uint32 value)
+    {
+        WorldPacket data(SMSG_UPDATE_WORLD_STATE, 8);
+        data << field << value;
+        ((InstanceMap*)instance)->SendToPlayers(&data);
+    }
+
+    const char* Save()
+    {
+        std::ostringstream ss;
+        ss << "S " << BossKilled << " " << ChestLooted << " " << QuestMinute;
+        char* data = new char[ss.str().length()+1];
+        strcpy(data, ss.str().c_str());
+        //error_log("SD2: Zul'aman saved, %s.", data);
+        return data;
+    }
+
+    void Load(const char* load)
+    {
+        if(!load) return;
+        std::istringstream ss(load);
+        //error_log("SD2: Zul'aman loaded, %s.", ss.str().c_str());
+        char dataHead; // S
+        uint16 data1, data2, data3;
+        ss >> dataHead >> data1 >> data2 >> data3;
+        //error_log("SD2: Zul'aman loaded, %d %d %d.", data1, data2, data3);
+        if(dataHead == 'S')
+        {
+            BossKilled = data1;
+            ChestLooted = data2;
+            QuestMinute = data3;
+        }else error_log("SD2: Zul'aman: corrupted save data.");
+    }
+
     void SetData(uint32 type, uint32 data)
     {
         switch(type)
         {
-            case DATA_JANALAIEVENT:
-                if(data == 0)
+        case DATA_NALORAKKEVENT:
+            Encounters[0] = data;
+            if(data == DONE)
+            {
+                if(QuestMinute)
                 {
-                    janalai_eggs_l = 20;
-                    janalai_eggs_r = 20;
+                    QuestMinute += 15;
+                    UpdateWorldState(3106, QuestMinute);
                 }
-                Encounters[0] = data;
-                break;
-            case DATA_J_HATCHLEFT:
-                janalai_eggs_l -= data;
-                break;
-            case DATA_J_HATCHRIGHT:
-                janalai_eggs_r -= data;
-                break;
-            case TYPE_RAND_VENDOR_1:
-                RandVendor[0] = data;
-                break;
-            case TYPE_RAND_VENDOR_2:
-                RandVendor[1] = data;
-                break;
+                SummonHostage(0);
+            }
+            break;
+        case DATA_AKILZONEVENT:
+            Encounters[1] = data;
+            OpenDoor(AkilzonDoorGUID, data != IN_PROGRESS);
+            if(data == DONE)
+            {
+                if(QuestMinute)
+                {
+                    QuestMinute += 10;
+                    UpdateWorldState(3106, QuestMinute);
+                }
+                SummonHostage(1);
+            }
+            break;
+        case DATA_JANALAIEVENT:
+            Encounters[2] = data;
+            if(data == DONE) SummonHostage(2);
+            break;
+        case DATA_HALAZZIEVENT:
+            Encounters[3] = data;
+            OpenDoor(HalazziDoorGUID, data != IN_PROGRESS);
+            if(data == DONE) SummonHostage(3);
+            break;
+        case DATA_HEXLORDEVENT:
+            Encounters[4] = data;
+            if(data == IN_PROGRESS)
+                OpenDoor(HexLordGateGUID, false);
+            else if(data == NOT_STARTED)
+                CheckInstanceStatus();
+            break;
+        case DATA_ZULJINEVENT:
+            Encounters[5] = data;
+            OpenDoor(ZulJinDoorGUID, data != IN_PROGRESS);
+            break;
+        case DATA_CHESTLOOTED:
+            ChestLooted++;
+            SaveToDB();
+            break;
+        case TYPE_RAND_VENDOR_1:
+            RandVendor[0] = data;
+            break;
+        case TYPE_RAND_VENDOR_2:
+            RandVendor[1] = data;
+            break;
         }
+
+        if(data == DONE)
+        {
+            BossKilled++;
+            if(QuestMinute && BossKilled >= 4)
+            {
+                QuestMinute = 0;
+                UpdateWorldState(3104, 0);
+            }
+            CheckInstanceStatus();
+            SaveToDB();
+        }
     }
 
     uint32 GetData(uint32 type)
     {
         switch(type)
         {
-            case DATA_JANALAIEVENT:
-                return Encounters[0];
-            case DATA_J_EGGSLEFT:
-                return janalai_eggs_l;
-            case DATA_J_EGGSRIGHT:
-                return janalai_eggs_r;
-            case TYPE_RAND_VENDOR_1:
-                return RandVendor[0];
-            case TYPE_RAND_VENDOR_2:
-                return RandVendor[1];
+        case DATA_NALORAKKEVENT: return Encounters[0];
+        case DATA_AKILZONEVENT:  return Encounters[1];
+        case DATA_JANALAIEVENT:  return Encounters[2];
+        case DATA_HALAZZIEVENT:  return Encounters[3];
+        case DATA_HEXLORDEVENT:  return Encounters[4];
+        case DATA_ZULJINEVENT:   return Encounters[5];
+        case DATA_CHESTLOOTED:   return ChestLooted;
+        case TYPE_RAND_VENDOR_1: return RandVendor[0];
+        case TYPE_RAND_VENDOR_2: return RandVendor[1];                
+        default:                 return 0;
         }
-        return 0;
     }
+
+    void Update(uint32 diff)
+    {
+        if(QuestMinute)
+        {
+            if(QuestTimer < diff)
+            {
+                QuestMinute--;
+                SaveToDB();
+                QuestTimer += 60000;
+                if(QuestMinute)
+                {
+                    UpdateWorldState(3104, 1);
+                    UpdateWorldState(3106, QuestMinute);
+                }else UpdateWorldState(3104, 0);
+            }
+            QuestTimer -= diff;
+        }
+    }
 };
 
 InstanceData* GetInstanceData_instance_zulaman(Map* map)
Index: scripts/zone/zulaman/zulaman.cpp
===================================================================
--- scripts/zone/zulaman/zulaman.cpp	(revision 715)
+++ scripts/zone/zulaman/zulaman.cpp	(working copy)
@@ -97,6 +97,74 @@
     return new npc_forest_frogAI (_Creature);
 }
 
+/*######
+## npc_zulaman_hostage
+######*/
+
+#define GOSSIP_HOSTAGE1        "I am glad to help you."
+
+static uint32 HostageInfo[] = {23790, 23999, 24024, 24001};
+
+struct MANGOS_DLL_DECL npc_zulaman_hostageAI : public ScriptedAI
+{
+    npc_zulaman_hostageAI(Creature *c) : ScriptedAI(c) {IsLoot = false;}
+    bool IsLoot;
+    uint64 PlayerGUID;
+    void Reset() {}
+    void Aggro(Unit *who) {}
+    /*void JustDied(Unit *)
+    {
+        Player* player = (Player*)Unit::GetUnit(*m_creature, PlayerGUID);
+        if(player) player->SendLoot(m_creature->GetGUID(), LOOT_CORPSE);
+    }*/
+    void UpdateAI(const uint32 diff)
+    {
+        if(IsLoot) m_creature->CastSpell(m_creature, 7, false);
+    }
+};
+
+bool GossipHello_npc_zulaman_hostage(Player* player, Creature* _Creature)
+{
+    player->ADD_GOSSIP_ITEM(0, GOSSIP_HOSTAGE1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+    player->SEND_GOSSIP_MENU(_Creature->GetNpcTextId(), _Creature->GetGUID());
+    return true;
+}
+
+bool GossipSelect_npc_zulaman_hostage(Player* player, Creature* _Creature, uint32 sender, uint32 action)
+{
+    if(action == GOSSIP_ACTION_INFO_DEF + 1)
+        player->CLOSE_GOSSIP_MENU();
+
+    if(!_Creature->HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP))
+        return true;
+    _Creature->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+
+    ScriptedInstance* pInstance = ((ScriptedInstance*)_Creature->GetInstanceData());
+    if(pInstance)
+    {
+        uint8 progress = pInstance->GetData(DATA_CHESTLOOTED);
+        pInstance->SetData(DATA_CHESTLOOTED, 0);
+        float x, y, z;
+        _Creature->GetPosition(x, y, z);
+        //Creature* summon = _Creature->SummonCreature(HostageInfo[progress], x, y, z, 0, TEMPSUMMON_TIMED_DESPAWN, 300000);
+        Creature* summon = _Creature->SummonCreature(HostageInfo[progress], x-2, y, z, 0, TEMPSUMMON_DEAD_DESPAWN, 0);
+        if(summon)
+        {
+            ((npc_zulaman_hostageAI*)summon->AI())->PlayerGUID = player->GetGUID();
+            ((npc_zulaman_hostageAI*)summon->AI())->IsLoot = true;
+            summon->SetDisplayId(10056);
+            summon->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            summon->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+        }
+    }
+    return true;
+}
+
+CreatureAI* GetAI_npc_zulaman_hostage(Creature *_Creature)
+{
+    return new npc_zulaman_hostageAI(_Creature);
+}
+
 void AddSC_zulaman()
 {
     Script *newscript;
@@ -105,4 +173,11 @@
     newscript->Name="npc_forest_frog";
     newscript->GetAI = GetAI_npc_forest_frog;
     m_scripts[nrscripts++] = newscript;
+
+    newscript = new Script;
+    newscript->Name = "npc_zulaman_hostage";
+    newscript->GetAI = GetAI_npc_zulaman_hostage;
+    newscript->pGossipHello = GossipHello_npc_zulaman_hostage;
+    newscript->pGossipSelect = GossipSelect_npc_zulaman_hostage;
+    m_scripts[nrscripts++] = newscript;
 }
Index: VC71/71ScriptDev2.vcproj
===================================================================
--- VC71/71ScriptDev2.vcproj	(revision 715)
+++ VC71/71ScriptDev2.vcproj	(working copy)
@@ -263,6 +263,10 @@
 					<File
 						RelativePath="..\scripts\zone\deadmines\deadmines.cpp">
 					</File>
+					<File
+						RelativePath="..\scripts\zone\deadmines\def_deadmines.h"
+						>
+					</File>
 				</Filter>
 				<Filter
 					Name="Deadwind Pass">
Index: VC80/80ScriptDev2.vcproj
===================================================================
--- VC80/80ScriptDev2.vcproj	(revision 715)
+++ VC80/80ScriptDev2.vcproj	(working copy)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8.00"
+	Version="8,00"
 	Name="ScriptDev2"
 	ProjectGUID="{4295C8A9-79B7-4354-8064-F05FB9CA0C96}"
 	RootNamespace="ScriptDev2"
@@ -409,6 +409,18 @@
 				Name="guard"
 				>
 				<File
+					RelativePath="..\scripts\guard\ancient_of_war.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\archbishop_benedictus.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\g_marcus_jonathan.cpp"
+					>
+				</File>
+				<File
 					RelativePath="..\scripts\guard\guard_ai.cpp"
 					>
 				</File>
@@ -420,6 +432,30 @@
 					RelativePath="..\scripts\guard\guards.cpp"
 					>
 				</File>
+				<File
+					RelativePath="..\scripts\guard\high_fire_mage.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\high_sorcerer_andromath.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\highlord_bolvar_fordragon.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\officers.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\overlord_saurfang.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\thrall.cpp"
+					>
+				</File>
 			</Filter>
 			<Filter
 				Name="honor"
@@ -465,6 +501,10 @@
 					>
 				</File>
 				<File
+					RelativePath="..\scripts\custom\teleguy.cpp"
+					>
+				</File>
+				<File
 					RelativePath="..\scripts\custom\test.cpp"
 					>
 				</File>
@@ -551,6 +591,10 @@
 						RelativePath="..\scripts\zone\deadmines\deadmines.cpp"
 						>
 					</File>
+					<File
+						RelativePath="..\scripts\zone\deadmines\def_deadmines.h"
+						>
+					</File>
 				</Filter>
 				<Filter
 					Name="Deadwind Pass"
@@ -1615,6 +1659,10 @@
 							>
 						</File>
 						<File
+							RelativePath="..\scripts\zone\hellfire_citadel\shattered_halls\boss_warchief_kargath_bladefist.cpp"
+							>
+						</File>
+						<File
 							RelativePath="..\scripts\zone\hellfire_citadel\shattered_halls\def_shattered_halls.h"
 							>
 						</File>
@@ -2100,14 +2148,30 @@
 					Name="Zul&apos;Aman"
 					>
 					<File
+						RelativePath="..\scripts\zone\zulaman\boss_akilzon.cpp"
+						>
+					</File>
+					<File
 						RelativePath="..\scripts\zone\zulaman\boss_janalai.cpp"
 						>
 					</File>
 					<File
+						RelativePath="..\scripts\zone\zulaman\boss_halazzi.cpp"
+						>
+					</File>
+					<File
+						RelativePath="..\scripts\zone\zulaman\boss_hexlord.cpp"
+						>
+					</File>
+					<File
 						RelativePath="..\scripts\zone\zulaman\boss_nalorakk.cpp"
 						>
 					</File>
 					<File
+						RelativePath="..\scripts\zone\zulaman\boss_zuljin.cpp"
+						>
+					</File>
+					<File
 						RelativePath="..\scripts\zone\zulaman\def_zulaman.h"
 						>
 					</File>
Index: VC90/90ScriptDev2.vcproj
===================================================================
--- VC90/90ScriptDev2.vcproj	(revision 715)
+++ VC90/90ScriptDev2.vcproj	(working copy)
@@ -407,7 +407,23 @@
 			<Filter
 				Name="guard"
 				>
+ 				<File
+					RelativePath="..\scripts\guard\ancient_of_war.cpp"
+					>
+				</File>
 				<File
+					RelativePath="..\scripts\guard\archbishop_benedictus.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\g_marcus_jonathan.cpp"
+					>
+				</File>
+				<File
+ 					RelativePath="..\scripts\guard\guard_ai.cpp"
+ 					>
+ 				</File>
+				<File
 					RelativePath="..\scripts\guard\guard_ai.cpp"
 					>
 				</File>
@@ -419,6 +435,30 @@
 					RelativePath="..\scripts\guard\guards.cpp"
 					>
 				</File>
+				<File
+					RelativePath="..\scripts\guard\high_fire_mage.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\high_sorcerer_andromath.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\highlord_bolvar_fordragon.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\officers.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\overlord_saurfang.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\thrall.cpp"
+					>
+				</File>
 			</Filter>
 			<Filter
 				Name="honor"
@@ -464,6 +504,10 @@
 					>
 				</File>
 				<File
+					RelativePath="..\scripts\custom\teleguy.cpp"
+					>
+				</File>
+				<File
 					RelativePath="..\scripts\custom\test.cpp"
 					>
 				</File>
@@ -550,6 +594,10 @@
 						RelativePath="..\scripts\zone\deadmines\deadmines.cpp"
 						>
 					</File>
+					<File
+						RelativePath="..\scripts\zone\deadmines\def_deadmines.h"
+						>
+					</File>
 				</Filter>
 				<Filter
 					Name="Deadwind Pass"
@@ -1614,6 +1662,10 @@
 							>
 						</File>
 						<File
+							RelativePath="..\scripts\zone\hellfire_citadel\shattered_halls\boss_warchief_kargath_bladefist.cpp"
+							>
+						</File>
+						<File
 							RelativePath="..\scripts\zone\hellfire_citadel\shattered_halls\def_shattered_halls.h"
 							>
 						</File>
@@ -2099,14 +2151,30 @@
 					Name="Zul&apos;Aman"
 					>
 					<File
+						RelativePath="..\scripts\zone\zulaman\boss_akilzon.cpp"
+						>
+					</File>
+					<File
 						RelativePath="..\scripts\zone\zulaman\boss_janalai.cpp"
 						>
 					</File>
 					<File
+						RelativePath="..\scripts\zone\zulaman\boss_halazzi.cpp"
+						>
+					</File>
+					<File
+						RelativePath="..\scripts\zone\zulaman\boss_hexlord.cpp"
+						>
+					</File>
+					<File
 						RelativePath="..\scripts\zone\zulaman\boss_nalorakk.cpp"
 						>
 					</File>
 					<File
+						RelativePath="..\scripts\zone\zulaman\boss_zuljin.cpp"
+						>
+					</File>
+					<File
 						RelativePath="..\scripts\zone\zulaman\def_zulaman.h"
 						>
 					</File>
