Index: Makefile.am
===================================================================
--- Makefile.am	(revision 738)
+++ Makefile.am	(working copy)
@@ -52,9 +52,18 @@
 scripts/custom/custom_gossip_codebox.cpp \
 scripts/custom/test.cpp \
 scripts/go/go_scripts.cpp \
+scripts/guard/ancient_of_war.cpp \
+scripts/guard/g_marcus_jonathan.cpp \
 scripts/guard/guard_ai.cpp \
 scripts/guard/guard_ai.h \
 scripts/guard/guards.cpp \
+scripts/guard/officers.cpp \
+scripts/guard/overlord_saurfang.cpp \
+scripts/guard/archbishop_benedictus.cpp \
+scripts/guard/high_fire_mage.cpp \
+scripts/guard/high_sorcerer_andromath.cpp \
+scripts/guard/highlord_bolvar_fordragon.cpp \
+scripts/guard/thrall.cpp \
 scripts/item/item_scripts.cpp \
 scripts/item/item_test.cpp \
 scripts/npc/npc_escortAI.cpp \
Index: ScriptMgr.cpp
===================================================================
--- ScriptMgr.cpp	(revision 738)
+++ ScriptMgr.cpp	(working copy)
@@ -84,6 +84,15 @@
 
 // -- Guard --
 extern void AddSC_guards();
+extern void AddSC_city_officer();
+extern void AddSC_ancient_of_war();
+extern void AddSC_overlord_saurfang();
+extern void AddSC_g_marcus_jonathan();
+extern void AddSC_archbishop_benedictus();
+extern void AddSC_high_fire_mage();
+extern void AddSC_high_sorcerer_andromath();
+extern void AddSC_highlord_bolvar_fordragon();
+extern void AddSC_thrall();
 
 // -- Honor --
 
@@ -1266,6 +1275,15 @@
 
     // -- Guard --
     AddSC_guards();
+    AddSC_city_officer();
+    AddSC_ancient_of_war();
+    AddSC_overlord_saurfang();
+    AddSC_g_marcus_jonathan();
+    AddSC_archbishop_benedictus();
+    AddSC_high_fire_mage();
+    AddSC_high_sorcerer_andromath();
+    AddSC_highlord_bolvar_fordragon();
+    AddSC_thrall();
 
     // -- Honor --
 
Index: scripts/guard/ancient_of_war.cpp
===================================================================
--- scripts/guard/ancient_of_war.cpp	(revision 0)
+++ scripts/guard/ancient_of_war.cpp	(revision 0)
@@ -0,0 +1,234 @@
+/* 
+###############################
+ Ancient of War, of Lore v 2.0
+ (Darnassus protectors)
+###############################
+
+by Myav 
+*/
+
+#include "precompiled.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL ancient_of_warAI : public ScriptedAI
+{
+    ancient_of_warAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+
+    if(m_creature->GetEntry() == 3469)
+       m_creature->SetMaxHealth(167000);
+     else m_creature->SetMaxHealth(250000);
+    if(m_creature->GetEntry() == 3469)
+       m_creature->SetHealth(167000);
+     else m_creature->SetMaxHealth(250000);
+    m_creature->SetArmor(19200);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,1620);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,270);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DAZE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_KNOCKOUT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+3500,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+}
+
+void wood()
+{
+       float x;
+       float y;
+       float z;
+       float X;
+       float Y;
+       float Z;
+       m_creature->GetPosition(x,y,z);
+       m_creature->getVictim()->GetPosition(X,Y,Z);
+       if(x > X)
+           X = x + 20 + 10 - rand()%20;
+       else
+           X = x - 20 + 10 - rand()%20;
+       if(y > Y)
+           Y = y + 20 + 10 - rand()%20;
+       else
+           Y = y - 20 + 10 - rand()%20;
+       m_creature->GetRespawnCoord(x,y,z);        
+       Helper = DoSpawnCreature(4423, (float) (X - x), (float) (Y - y), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+       if(Helper && enemy)
+          ((CreatureAI*)Helper->AI())->AttackStart(enemy); 
+}
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    if(!Help && m_creature->GetEntry() == 3469)
+    {
+       for(int i = 0; i < 5;i++)
+       {
+            wood();
+       }
+       Help = 60000 + rand()%45000;
+    }
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+           int Change = 0;
+           int info = NULL;
+
+            if(!m_creature->HasAura(25640,0))
+            {
+                info = 25640;
+                Change = 1;
+            }
+            else
+            {
+                 if(enemy)
+                  {
+                   switch(rand()%5)
+                   {
+               case 0:
+                  info = 22924;
+                  break;
+               case 1:
+                    info = 35244;
+                    break;
+               case 2:
+                    info = 24648;
+                    break;
+               case 3:
+                    info = 40434;
+                    break;
+               case 4:
+                    info = 37592;
+                    break;
+               }//switch
+            }//if rage
+            }
+            if(m_creature->GetEntry() == 3468)
+                info = NULL;
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+        }//end attack ready
+    }// end attack distance
+/*    else 
+    { 
+     if(!m_creature->IsNonMeleeSpellCasted(false))
+     {
+         if ((*m_creature).GetMotionMaster()->top()->GetMovementGeneratorType()!=TARGETED_MOTION_TYPE)
+         {
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+         }
+     }
+    }//end else */
+}
+};
+CreatureAI* GetAI_ancient_of_war(Creature *_Creature)
+{
+    return new ancient_of_warAI (_Creature);
+}
+
+void AddSC_ancient_of_war()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "ancient_of_war";
+    newscript->GetAI = &GetAI_ancient_of_war;
+    newscript->RegisterSelf();
+}
Index: scripts/guard/archbishop_benedictus.cpp
===================================================================
--- scripts/guard/archbishop_benedictus.cpp	(revision 0)
+++ scripts/guard/archbishop_benedictus.cpp	(revision 0)
@@ -0,0 +1,344 @@
+/* 
+##############################
+ Archbishop Benedictus v 2.0
+##############################
+
+by Myav 
+*/
+
+#include "precompiled.h"
+#include "../creature/simple_ai.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL archbishop_benedictusAI : public ScriptedAI
+{
+    archbishop_benedictusAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    uint32 InnerTimer;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+
+    m_creature->SetMaxHealth(255000);
+    m_creature->SetHealth(255000);
+    m_creature->SetMaxPower(POWER_MANA,180000);
+    m_creature->SetPower(POWER_MANA,180000);
+    m_creature->SetArmor(5720);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DISARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_INTERRUPT_CAST, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CONFUSED, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM , true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR , true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DAZE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_BANISH, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+3000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+
+}
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if (InnerTimer > diff)
+        InnerTimer -= diff;
+    else InnerTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    if(!m_creature->HasAura(25431,0) && InnerTimer < diff && !m_creature->HasAura(27173,0) && !m_creature->HasAura(20924,0))
+    {
+     InnerTimer = 5000;
+     DoCast(m_creature, 25431);
+     return;
+    }
+    if(!m_creature->HasAura(25312,0))
+    {
+     DoCast(m_creature, 25312);
+     return;
+    }
+    if(!m_creature->HasAura(25431,0))
+    {
+     DoCast(m_creature, 25431);
+     return;
+    }
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+           int Change = 0;
+           int info = NULL;
+
+                 if(enemy)
+                  {
+                   switch(rand()%9)
+                   {
+               case 0:
+                  info = 32375;
+                  break;
+               case 1:
+                    info = 33206;
+                    Change = 1;
+                    break;
+               case 2:
+                    info = 10060;
+                    Change = 1;
+                    break;
+               case 3:
+                    info = 41373;
+                    Change = 1;
+                    break;
+               case 4:
+                    info = 34866;
+                    Change = 1;
+                    break;
+               case 5:
+                    info = 41380;
+                    break;
+               case 6:
+                    info = 37260;
+                    Change = 1;
+                    break;
+               case 7:
+                    info = 41471;
+                    break;
+               case 8:
+                    info = 39013;
+                    Change = 1;
+                    break;
+               }//switch
+            }
+
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+        }//end attack ready
+    }// end attack distance
+/*    else 
+    { 
+     if(!m_creature->IsNonMeleeSpellCasted(false))
+     {
+         if ((*m_creature).GetMotionMaster()->top()->GetMovementGeneratorType()!=TARGETED_MOTION_TYPE)
+         {
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+         }
+     }
+    }//end else */
+}
+};
+CreatureAI* GetAI_cathedral_of_light(Creature *_Creature)
+{
+    SimpleAI* ai = new SimpleAI (_Creature);
+
+    uint32 CreatureID = _Creature->GetEntry();
+
+    ai->m_creature->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_INTERRUPT_CAST, true);
+    ai->m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM, true);
+
+    switch (CreatureID) 
+    {
+        //Duthorian Rall
+    case 6171: 
+        ai->Spell[0].Enabled = true;               
+        ai->Spell[0].Spell_Id = 27155;      //Seal     
+        ai->Spell[0].Cooldown = 30000;                 
+        ai->Spell[0].First_Cast = 500;             
+        ai->Spell[0].Cast_Target_Type = CAST_SELF;  
+
+        ai->Spell[1].Enabled = true;               
+        ai->Spell[1].Spell_Id = 10308;      //Hammer     
+        ai->Spell[1].Cooldown = 45000;                 
+        ai->Spell[1].First_Cast = 10000;             
+        ai->Spell[1].Cast_Target_Type = CAST_HOSTILE_TARGET;  
+
+        ai->Spell[2].Enabled = true;               
+        ai->Spell[2].Spell_Id = 27141;      //Bless     
+        ai->Spell[2].Cooldown = 120000;                 
+        ai->Spell[2].First_Cast = 5000;             
+        ai->Spell[2].Cast_Target_Type = CAST_SELF;  
+
+        ai->Spell[3].Enabled = true;               
+        ai->Spell[3].Spell_Id = 33072;      //Shock     
+        ai->Spell[3].Cooldown = 20000;                 
+        ai->Spell[3].First_Cast = 15000;             
+        ai->Spell[3].Cast_Target_Type = CAST_HOSTILE_TARGET;  
+
+        ai->Spell[4].Enabled = true;               
+        ai->Spell[4].Spell_Id = 27136;      //Heal     
+        ai->Spell[4].Cooldown = 15000;                 
+        ai->Spell[4].First_Cast = 20000;             
+        ai->Spell[4].Cast_Target_Type = CAST_SELF;
+
+        ai->Spell[5].Enabled = true;               
+        ai->Spell[5].Spell_Id = 35396;      //Strike     
+        ai->Spell[5].Cooldown = 15000;                 
+        ai->Spell[5].First_Cast = 30000;             
+        ai->Spell[5].Cast_Target_Type = CAST_HOSTILE_TARGET;
+        break;
+
+        //High Priestess Laurena
+    case 376: 
+        ai->Spell[0].Enabled = true;               
+        ai->Spell[0].Spell_Id = 25431;      //Inner     
+        ai->Spell[0].Cooldown = 120000;                 
+        ai->Spell[0].First_Cast = 500;             
+        ai->Spell[0].Cast_Target_Type = CAST_SELF;  
+
+        ai->Spell[1].Enabled = true;               
+        ai->Spell[1].Spell_Id = 27801;      //Holy Nova     
+        ai->Spell[1].Cooldown = 30000;                 
+        ai->Spell[1].First_Cast = 10000;             
+        ai->Spell[1].Cast_Target_Type = CAST_HOSTILE_TARGET;  
+
+        ai->Spell[2].Enabled = true;               
+        ai->Spell[2].Spell_Id = 25218;      //Shield     
+        ai->Spell[2].Cooldown = 15000;                 
+        ai->Spell[2].First_Cast = 5000;             
+        ai->Spell[2].Cast_Target_Type = CAST_SELF;  
+
+        ai->Spell[3].Enabled = true;               
+        ai->Spell[3].Spell_Id = 25364;      //Smite     
+        ai->Spell[3].Cooldown = 20000;                 
+        ai->Spell[3].First_Cast = 15000;             
+        ai->Spell[3].Cast_Target_Type = CAST_HOSTILE_TARGET;  
+
+        ai->Spell[4].Enabled = true;               
+        ai->Spell[4].Spell_Id = 34866;      //Circle Heal     
+        ai->Spell[4].Cooldown = 15000;                 
+        ai->Spell[4].First_Cast = 20000;             
+        ai->Spell[4].Cast_Target_Type = CAST_SELF;
+
+        ai->Spell[5].Enabled = true;               
+        ai->Spell[5].Spell_Id = 25222;      //Renew     
+        ai->Spell[5].Cooldown = 25000;                 
+        ai->Spell[5].First_Cast = 25000;             
+        ai->Spell[5].Cast_Target_Type = CAST_SELF;
+
+        ai->Spell[6].Enabled = true;               
+        ai->Spell[6].Spell_Id = 25314;      //Heal     
+        ai->Spell[6].Cooldown = 15000;                 
+        ai->Spell[6].First_Cast = 30000;             
+        ai->Spell[6].Cast_Target_Type = CAST_SELF;
+
+        ai->Spell[7].Enabled = true;               
+        ai->Spell[7].Spell_Id = 25308;      //Prayer of Healing     
+        ai->Spell[7].Cooldown = 25000;                 
+        ai->Spell[7].First_Cast = 35000;             
+        ai->Spell[7].Cast_Target_Type = CAST_SELF;
+        break;
+    }
+
+    ai->Reset();
+
+    return ai;
+}
+CreatureAI* GetAI_archbishop_benedictus(Creature *_Creature)
+{
+    return new archbishop_benedictusAI (_Creature);
+}
+
+void AddSC_archbishop_benedictus()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "archbishop_benedictus";
+    newscript->GetAI = &GetAI_archbishop_benedictus;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "cathedral_of_light";
+    newscript->GetAI = &GetAI_cathedral_of_light;
+    newscript->RegisterSelf();
+}
Index: scripts/guard/g_marcus_jonathan.cpp
===================================================================
--- scripts/guard/g_marcus_jonathan.cpp	(revision 0)
+++ scripts/guard/g_marcus_jonathan.cpp	(revision 0)
@@ -0,0 +1,200 @@
+/* 
+###############################
+ General Marcus Jonathan v 1.0
+ (Stormwind protector)
+###############################
+
+by Myav 
+*/
+
+#include "precompiled.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL g_marcus_jonathanAI : public ScriptedAI
+{
+    g_marcus_jonathanAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    Unit* enemy;
+    Creature* Helper;
+    
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+
+    m_creature->SetMaxHealth(98000);
+    m_creature->SetHealth(98000);
+    m_creature->SetArmor(11520);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_KNOCKOUT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+3000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+}
+
+void grunts()
+{
+       float x;
+       float y;
+       float z;
+       float X;
+       float Y;
+       float Z;
+       m_creature->GetPosition(x,y,z);
+       m_creature->getVictim()->GetPosition(X,Y,Z);
+       if(x > X)
+           X = x + 20 + 10 - rand()%20;
+       else
+           X = x - 20 + 10 - rand()%20;
+       if(y > Y)
+           Y = y + 20 + 10 - rand()%20;
+       else
+           Y = y - 20 + 10 - rand()%20;
+       m_creature->GetRespawnCoord(x,y,z);        
+       Helper = DoSpawnCreature(68, (float) (X - x), (float) (Y - y), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+       if(Helper && enemy)
+          ((CreatureAI*)Helper->AI())->AttackStart(enemy); 
+}
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    if(!Help)
+    {
+
+       for(int i = 0; i < 4;i++)
+       {
+            grunts();
+       }
+       Help = 60000 + rand()%45000;
+    }
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+           int Change = 0;
+           int info = NULL;
+
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+        }//end attack ready
+    }// end attack distance
+/*    else 
+    { 
+     if(!m_creature->IsNonMeleeSpellCasted(false))
+     {
+         if ((*m_creature).GetMotionMaster()->top()->GetMovementGeneratorType()!=TARGETED_MOTION_TYPE)
+         {
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+         }
+     }
+    }//end else */
+}
+};
+CreatureAI* GetAI_g_marcus_jonathan(Creature *_Creature)
+{
+    return new g_marcus_jonathanAI (_Creature);
+}
+
+void AddSC_g_marcus_jonathan()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "g_marcus_jonathan";
+    newscript->GetAI = &GetAI_g_marcus_jonathan;
+    newscript->RegisterSelf();
+}
Index: scripts/guard/guard_ai.cpp
===================================================================
--- scripts/guard/guard_ai.cpp	(revision 738)
+++ scripts/guard/guard_ai.cpp	(working copy)
@@ -1,26 +1,12 @@
-/* Copyright (C) 2006 - 2008 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+/* 
+###################
+ City Guards v 4
+###################
 
-/* ScriptData
-SDName: Guard_AI
-SD%Complete: 90
-SDComment:
-SDCategory: Guards
-EndScriptData */
+by Myav
+*/
 
+
 #include "precompiled.h"
 #include "guard_ai.h"
 
@@ -30,26 +16,188 @@
 
 void guardAI::Reset()
 {
+    if(_Aggro == 2)
+     _Aggro = 1;
     GlobalCooldown = 0;
-    BuffTimer = 0;                                          //Rebuff as soon as we can
+    Bandage = 0;
+    Potion = 0;
+    OffHand = 0;
+    Help = 30000 + rand()%20000;
+    yell = false;
+    //m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+750,true);
+    if(!(m_creature->GetEntry() == 2041 || m_creature->GetEntry() == 4423))
+    {
+       m_creature->setPowerType(POWER_RAGE); 
+       m_creature->SetMaxPower(POWER_RAGE,500);
+       m_creature->SetPower(POWER_RAGE,0); 
+       bool elite = false;
+       int temp3 = 0;
+       int temp4 = 0;
+       int temp5 = 0; 
+       int temp6 = 0;
+       temp3 = m_creature->getLevel();
+       elite = m_creature->isElite();
+       if(elite)
+       {
+          temp4 = temp3 * 200;
+          temp5 = temp3 * 120;          
+          temp6 = temp3 * 8;
+       }
+        else
+        {
+           if(temp3 < 71)
+           {
+               temp4 = temp3 * 125;
+               temp5 = temp3 * 75;
+               temp6 = temp3 * 5;
+           }
+           else
+           {
+              temp4 = temp3 * 175;
+              temp5 = temp3 * 105;          
+              temp6 = temp3 * 7;
+           }       
+        }
+       if(m_creature->GetEntry() == 12481)
+        temp4 = temp4 * 4;
+       if(m_creature->GetEntry() == 12480)
+        temp4 = temp4 * 6;
+       if(m_creature->GetEntry() == 5624)
+        temp4 = temp4 * 3;
+       m_creature->SetMaxHealth(temp4);
+       m_creature->SetHealth(temp4);
+       m_creature->SetArmor(temp5);
+       m_creature->SetResistance(SPELL_SCHOOL_NORMAL,temp6);
+       m_creature->SetResistance(SPELL_SCHOOL_HOLY,temp6);
+       m_creature->SetResistance(SPELL_SCHOOL_FIRE,temp6);
+       m_creature->SetResistance(SPELL_SCHOOL_NATURE,temp6);
+       m_creature->SetResistance(SPELL_SCHOOL_FROST,temp6);
+       m_creature->SetResistance(SPELL_SCHOOL_SHADOW,temp6);
+       m_creature->SetResistance(SPELL_SCHOOL_ARCANE,temp6);
+    } 
+    //if(m_creature->getLevel() > 70 || m_creature->isElite())
+       //m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+900,false);
+    //else m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+500,false);
+    //if(m_creature->GetEntry() == 12481)
+        //m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+1600,false);
+    //if(m_creature->GetEntry() == 12480)
+        //m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+1900,false);
 }
 
 void guardAI::Aggro(Unit *who)
 {
-}
-
-void guardAI::JustDied(Unit *Killer)
-{
     //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
-    if( Killer->GetTypeId() == TYPEID_PLAYER )
-        m_creature->SendZoneUnderAttackMessage((Player*)Killer);
-    else if( Unit *owner = Killer->GetOwner() )
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
     {
-        if( owner->GetTypeId() == TYPEID_PLAYER )
-            m_creature->SendZoneUnderAttackMessage((Player*)owner);
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
     }
+    if(m_creature->getFaction() == 85 && !yell)
+    {
+       yell = true;
+       switch(rand()%4)
+       {
+           case 0:
+              DoYell("We are under Attack !!",LANG_ORCISH,NULL);
+              DoPlaySoundToSet(m_creature,6198);
+              break;
+           case 1:
+              DoSay("Time to Killing!",LANG_ORCISH,NULL);
+              DoPlaySoundToSet(m_creature,6205);
+              break;
+           case 2:
+              DoSay("Yargh!",LANG_ORCISH,NULL);
+              DoPlaySoundToSet(m_creature,6206);
+              break;
+           case 3:
+              DoSay("Time to Die!",LANG_ORCISH,NULL);
+              DoPlaySoundToSet(m_creature,6207);
+              break;
+       }
+    }
+    if(m_creature->getFaction() == 11 && !yell)
+    {
+       yell = true;
+       switch(rand()%4)
+       {
+       case 0:
+          DoYell("We are under Attack !!",LANG_COMMON,NULL);
+          break;
+       case 1:
+          DoSay("Time to Killing!",LANG_COMMON,NULL);
+          break;
+       case 2:
+          DoSay("Yahn!",LANG_COMMON,NULL);
+          break;
+       case 3:
+          DoSay("Time to Die!",LANG_COMMON,NULL);
+          break;
+       }
+    }
+    if(m_creature->getFaction() == 79 && !yell)
+    {
+       yell = true;
+       switch(rand()%4)
+       {
+           case 0:
+              DoYell("We are under Attack !!",LANG_DARNASSIAN,NULL);
+              break;
+           case 1:
+              DoSay("Time to Killing!",LANG_DARNASSIAN,NULL);
+              break;
+           case 2:
+              DoSay("Yahn!",LANG_DARNASSIAN,NULL);
+              break;
+           case 3:
+              DoSay("Time to Die!",LANG_DARNASSIAN,NULL);
+              break;
+       }
+    }
 }
+void guardAI::DamageDeal(Unit *done_to, uint32 &damage)
+{
+   if(m_creature->GetEntry() == 4423)
+       return;
+   temp1 = m_creature->GetPower(POWER_RAGE);
+   temp2 = 0;
+   temp2 = temp1;
+   switch(rand()%4)
+   {
+      case 0:temp1 = temp2 + 40;break;
+      case 1:temp1 = temp2 + 50;break;
+      case 2:temp1 = temp2 + 60;break;
+      case 3:temp1 = temp2 + 70;break;
+   }
+   if(temp1 > 500)
+      m_creature->SetPower(POWER_RAGE,500);   
+   else
+      m_creature->SetPower(POWER_RAGE,temp1);
+}
 
+void guardAI::DamageTaken(Unit *done_by, uint32 &damage)
+{
+    if(damage > m_creature->GetHealth())
+        return;
+
+   if(m_creature->GetEntry() == 4423)
+       return;
+
+   temp1 = m_creature->GetPower(POWER_RAGE);
+   temp2 = 0;
+   temp2 = temp1;
+   switch(rand()%4)
+   {
+      case 0:temp1 = temp2 + 20;break;
+      case 1:temp1 = temp2 + 30;break;
+      case 2:temp1 = temp2 + 40;break;
+      case 3:temp1 = temp2 + 50;break;
+   }
+   if(temp1 > 500)
+      m_creature->SetPower(POWER_RAGE,500);   
+   else
+      m_creature->SetPower(POWER_RAGE,temp1); 
+}
+
 void guardAI::UpdateAI(const uint32 diff)
 {
     //Always decrease our global cooldown first
@@ -57,61 +205,278 @@
         GlobalCooldown -= diff;
     else GlobalCooldown = 0;
 
-    //Buff timer (only buff when we are alive and not in combat
-    if (m_creature->isAlive() && !InCombat)
-        if (BuffTimer < diff )
-    {
-        //Find a spell that targets friendly and applies an aura (these are generally buffs)
-        SpellEntry const *info = SelectSpell(m_creature, -1, -1, SELECT_TARGET_ANY_FRIEND, 0, 0, 0, 0, SELECT_EFFECT_AURA);
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
 
-        if (info && !GlobalCooldown)
-        {
-            //Cast the buff spell
-            DoCastSpell(m_creature, info);
+    //Always decrease Bandage
+    if (Bandage > diff)
+        Bandage -= diff;
+    else Bandage = 0;
 
-            //Set our global cooldown
-            GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+    //Always decrease OffHand
+    if (OffHand > diff)
+        OffHand -= diff;
+    else OffHand = 0;
 
-            //Set our timer to 10 minutes before rebuff
-            BuffTimer = 600000;
-        }                                                   //Try agian in 30 seconds
-        else BuffTimer = 30000;
-    }else BuffTimer -= diff;
+    //Always decrease Potion
+    if (Potion > diff)
+        Potion -= diff;
+    else Potion = 0;
 
+    if(!m_creature->isAlive())
+        return;
+
+    if (!InCombat && !(m_creature->GetEntry() == 2041 || m_creature->GetEntry() == 4423))
+    {
+       temp1 = m_creature->GetPower(POWER_RAGE);
+       temp2 = temp1;
+       temp1 = temp2 - 3;
+       if(temp1 > 0)
+          m_creature->SetPower(POWER_RAGE,temp1);
+       else
+          m_creature->SetPower(POWER_RAGE,0);
+    }
+
     //Return since we have no target
     if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
         return;
 
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    if(!Help && !(m_creature->GetEntry() == 2041 || m_creature->GetEntry() == 4423))
+    {
+       int entry = m_creature->GetEntry();
+       float x;
+       float y;
+       float z;
+       float X;
+       float Y;
+       float Z;
+       m_creature->GetPosition(x,y,z);
+       m_creature->getVictim()->GetPosition(X,Y,Z);
+       if(x > X)
+           X = x + 20;
+       else
+           X = x - 20;
+       if(y > Y)
+           Y = y + 20;
+       else
+           Y = y - 20;
+       m_creature->GetRespawnCoord(x,y,z); 
+
+          if(entry != 12480 && entry != 12481)
+           {
+       Helper = DoSpawnCreature(entry, (float) (X - x), (float) (Y - y), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+    /*   Helper = DoSpawnCreature(entry, 0, 0, 0, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000); */
+       if(Helper && enemy)
+          ((CreatureAI*)Helper->AI())->AttackStart(enemy); 
+           }else
+             {
+       Helper = DoSpawnCreature(68, (float) (X - x + 3), (float) (Y - y - 3), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+           if(Helper && enemy)
+           ((CreatureAI*)Helper->AI())->AttackStart(enemy); 
+           Creature* Helper2 = NULL;
+       Helper2 = DoSpawnCreature(68, (float) (X - x - 3), (float) (Y - y + 3), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+           if(Helper2 && enemy)
+           ((CreatureAI*)Helper2->AI())->AttackStart(enemy); 
+            Creature* Helper3 = NULL;
+       Helper3 = DoSpawnCreature(68, (float) (X - x + 3), (float) (Y - y + 3), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+           if(Helper3 && enemy)
+           ((CreatureAI*)Helper3->AI())->AttackStart(enemy); 
+             }
+
+       Help = 45000 + rand()%30000;
+    }
+
     // Make sure our attack is ready and we arn't currently casting
     if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
     {
+            if(m_creature->getVictim() && m_creature->SelectHostilTarget() && m_creature->GetEntry() == 3084 && OffHand > 0 && OffHand < 500)
+            {
+                m_creature->HandleEmoteCommand(EMOTE_ONESHOT_ATTACKOFF);
+                m_creature->AttackerStateUpdate(m_creature->getVictim());
+                m_creature->resetAttackTimer();
+                OffHand = 0;
+            }
         //If we are within range melee the target
         if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
         {
+
+           if(_Aggro != 2 && m_creature->GetEntry() != 2041 && m_creature->GetEntry() != 5624)
+           {
+              _Aggro = 2;
+              DoCast(m_creature,2457);
+              return;
+           }
+
+           if(m_creature->GetHealth()*100 / m_creature->GetMaxHealth() > 39 && m_creature->HasAura(2458,0) && m_creature->GetEntry() != 2041 && m_creature->GetEntry() != 5624)
+           {
+              DoCast(m_creature,2457);
+              return; 
+           }
+
             bool Healing = false;
-            SpellEntry const *info = NULL;
+            int Change = 0;
+            int info = NULL;
 
             //Select a healing spell if less than 30% hp
-            if (m_creature->GetHealth()*100 / m_creature->GetMaxHealth() < 30)
-                info = SelectSpell(m_creature, -1, -1, SELECT_TARGET_ANY_FRIEND, 0, 0, 0, 0, SELECT_EFFECT_HEALING);
+            if (m_creature->GetHealth()*100 / m_creature->GetMaxHealth() < 40)
+            {
+               if(Potion == 0 && !Healing)
+               {
+                  Potion = 60000;
+                  info = 17534;
+                  Healing = true;
+               }
+               else
+               {
+                  if(Bandage == 0 && !Healing)
+                  {
+                     Bandage = 60000;
+                     info = 38919;
+                     Healing = true;
+                  }
+                  else
+                      if(m_creature->HasAura(2457,0))
+                      {
+                         info = 2458;
+                         Change = 3;
+                      }  
+               }//if bandage
+            }//if health <40%
+            else
+            {
+                         if(!m_creature->HasAura(2048,0) && m_creature->GetPower(POWER_RAGE) > 100)
+                         {
+                            info = 2048;
+                            Change = 3;    
+                         }
+                         else
+                         {
+                            if(enemy && !enemy->HasAura(25203,0) && m_creature->GetPower(POWER_RAGE) > 100)
+                            {
+                               info = 25203;
+                               Change = 4;    
+                            }
+                            //select a hostile spell
+                            else
+                            {
+                               if(enemy && m_creature->GetPower(POWER_RAGE) > 100)
+                               {
+                                  switch(rand()%8)
+                                  {
+                                     case 0:
+                                        info = 29707;
+                                        break;
+                                     case 1:
+                                        info = 11574;
+                                        break;
+                                     case 2:
+                                        info = 30022;
+                                        break;
+                                     case 3:
+                                        info = 11597;
+                                        break;
+                                     case 4:
+                                        if(m_creature->HasAura(2457,0))
+                                           info = 25248;
+                                        else info = 20569;
+                                        break;
+                                     case 5:
+                                        if(m_creature->HasAura(2457,0))
+                                           info = 20560;
+                                        else info = 6554;
+                                        break;
+                                     case 6:
+                                        if(m_creature->HasAura(2457,0))
+                                           info = 11581;
+                                        else info = 1680;
+                                        break;
+                                     case 7:
+                                        info = 11597;
+                                        break;
+                                  }//switch
+                               }//if rage
+                            }//else hostile spell
+                         }//if no demoralizing
+                     }//if no battle shout
 
-            //No healing spell available, select a hostile spell
-            if (info) Healing = true;
-            else info = SelectSpell(m_creature->getVictim(), -1, -1, SELECT_TARGET_ANY_ENEMY, 0, 0, 0, 0, SELECT_EFFECT_DONTCARE);
+            if(m_creature->GetEntry() == 4423)
+               info = NULL;
 
-            //20% chance to replace our white hit with a spell
-            if (info && rand() % 5 == 0 && !GlobalCooldown)
+            if(m_creature->GetEntry() == 5624)
             {
-                //Cast the spell
-                if (Healing)DoCastSpell(m_creature, info);
-                else DoCastSpell(m_creature->getVictim(), info);
+                info = NULL;
+                if(!m_creature->HasAura(41924,0))
+                    DoCast(m_creature, 41924);
+            }
 
+            //50% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Healing)DoCast(m_creature, info);
+                else
+                {
+                         if(Change == 3)
+                         {
+                            DoCast(m_creature, info);                            
+                            if(m_creature->getFaction() == 85)
+                            {
+                               DoYell("Warcry",LANG_ORCISH,NULL); 
+                               DoPlaySoundToSet(m_creature,6204);
+                            }
+                         }
+                         else
+                         {
+                            if(Change == 4)
+                               DoCast(enemy, info);
+                            else
+                                DoCast(enemy, info);
+                         }              
+                }
                 //Set our global cooldown
                 GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
-            }
+            }//end 50% change
             else m_creature->AttackerStateUpdate(m_creature->getVictim());
 
             m_creature->resetAttackTimer();
+            if(m_creature->GetEntry() == 3084)
+                OffHand = 1000;
         }
     }
     else
Index: scripts/guard/guard_ai.h
===================================================================
--- scripts/guard/guard_ai.h	(revision 738)
+++ scripts/guard/guard_ai.h	(working copy)
@@ -1,4 +1,4 @@
-/* Copyright (C) 2006 - 2008 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+/* Copyright (C) 2006,2007 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
  * This program is free software licensed under GPL version 2
  * Please see the included DOCS/LICENSE.TXT for more information */
 
@@ -9,17 +9,29 @@
 
 struct MANGOS_DLL_DECL guardAI : public ScriptedAI
 {
-    guardAI(Creature *c) : ScriptedAI(c) {Reset();}
+    guardAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0; _Aggro = 0;}
 
-    uint32 GlobalCooldown;                                  //This variable acts like the global cooldown that players have (1.5 seconds)
-    uint32 BuffTimer;                                       //This variable keeps track of buffs
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Bandage;
+    uint32 Potion;
+    uint32 Help;
+    uint32 OffHand;
+    uint32 ZoneAttackMsgTimer;
+    bool yell;
+    int _Aggro;
+    float temp1;
+    float temp2;
+    Unit* enemy;
+    Creature* Helper;
 
     void Reset();
 
     void Aggro(Unit *who);
 
-    void JustDied(Unit *Killer);
+    void DamageDeal(Unit *done_to, uint32 &damage);
 
+    void DamageTaken(Unit *done_by, uint32 &damage);
+
     void UpdateAI(const uint32 diff);
 };
 #endif
Index: scripts/guard/high_fire_mage.cpp
===================================================================
--- scripts/guard/high_fire_mage.cpp	(revision 0)
+++ scripts/guard/high_fire_mage.cpp	(revision 0)
@@ -0,0 +1,207 @@
+/* 
+##############################
+ Lady Catrana Prestor v 1.0
+##############################
+
+by Myav 
+*/
+
+#include "precompiled.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL high_fire_mageAI : public ScriptedAI
+{
+    high_fire_mageAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+
+    m_creature->SetMaxHealth(120000);
+    m_creature->SetHealth(120000);
+    m_creature->SetMaxPower(POWER_MANA,90000);
+    m_creature->SetPower(POWER_MANA,90000);
+    m_creature->SetArmor(5720);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_KNOCKOUT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+1000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+}
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    if(!m_creature->HasAura(30482,0))
+    {
+     DoCast(m_creature, 30482);
+     return;
+    }
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+           int Change = 0;
+           int info = NULL;
+
+                 if(enemy)
+                  {
+                   switch(rand()%9)
+                   {
+               case 0:
+                  info = 38151;
+                  Change = 1;
+                  break;
+               case 1:
+                    info = 38536;
+                    break;
+               case 2:
+                    info = 33043;
+                    break;
+               case 3:
+                    info = 27079;
+                    break;
+               case 4:
+                    info = 41383;
+                    break;
+               case 5:
+                    info = 38535;
+                    break;
+               case 6:
+                    info = 12598;
+                    break;
+               case 7:
+                    info = 12042;
+                    Change = 1;
+                    break;
+               case 8:
+                    info = 38636;
+                    break;
+               }//switch
+            }
+
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+        }//end attack ready
+    }// end attack distance
+/*    else 
+    { 
+     if(!m_creature->IsNonMeleeSpellCasted(false))
+     {
+         if ((*m_creature).GetMotionMaster()->top()->GetMovementGeneratorType()!=TARGETED_MOTION_TYPE)
+         {
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+         }
+     }
+    }//end else */
+}
+};
+CreatureAI* GetAI_high_fire_mage(Creature *_Creature)
+{
+    return new high_fire_mageAI (_Creature);
+}
+
+void AddSC_high_fire_mage()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "high_fire_mage";
+    newscript->GetAI = &GetAI_high_fire_mage;
+    newscript->RegisterSelf();
+}
Index: scripts/guard/high_sorcerer_andromath.cpp
===================================================================
--- scripts/guard/high_sorcerer_andromath.cpp	(revision 0)
+++ scripts/guard/high_sorcerer_andromath.cpp	(revision 0)
@@ -0,0 +1,205 @@
+/* 
+##############################
+ High Sorcerer Andromath v 1.0
+##############################
+
+by Myav 
+*/
+
+#include "precompiled.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL high_sorcerer_andromathAI : public ScriptedAI
+{
+    high_sorcerer_andromathAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+
+    m_creature->SetMaxHealth(120000);
+    m_creature->SetHealth(120000);
+    m_creature->SetMaxPower(POWER_MANA,90000);
+    m_creature->SetPower(POWER_MANA,90000);
+    m_creature->SetArmor(5720);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_KNOCKOUT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+1000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+}
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    if(!m_creature->HasAura(27124,0))
+    {
+     DoCast(m_creature, 27124);
+    }
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+           int Change = 0;
+           int info = NULL;
+
+                 if(enemy)
+                  {
+                   switch(rand()%9)
+                   {
+               case 0:
+                  info = 33405;
+                  Change = 1;
+                  break;
+               case 1:
+                    info = 41382;
+                    break;
+               case 2:
+                    info = 5164;
+                    break;
+               case 3:
+                    info = 39348;
+                    break;
+               case 4:
+                    info = 29717;
+                    break;
+               case 5:
+                    info = 31250;
+                    break;
+               case 6:
+                    info = 24857;
+                    break;
+               case 7:
+                    info = 41486;
+                    break;
+               case 8:
+                    info = 39414;
+                    break;
+               }//switch
+            }
+
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+        }//end attack ready
+    }// end attack distance
+/*    else 
+    { 
+     if(!m_creature->IsNonMeleeSpellCasted(false))
+     {
+         if ((*m_creature).GetMotionMaster()->top()->GetMovementGeneratorType()!=TARGETED_MOTION_TYPE)
+         {
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+         }
+     }
+    }//end else */
+}
+};
+CreatureAI* GetAI_high_sorcerer_andromath(Creature *_Creature)
+{
+    return new high_sorcerer_andromathAI (_Creature);
+}
+
+void AddSC_high_sorcerer_andromath()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "high_sorcerer_andromath";
+    newscript->GetAI = &GetAI_high_sorcerer_andromath;
+    newscript->RegisterSelf();
+}
Index: scripts/guard/highlord_bolvar_fordragon.cpp
===================================================================
--- scripts/guard/highlord_bolvar_fordragon.cpp	(revision 0)
+++ scripts/guard/highlord_bolvar_fordragon.cpp	(revision 0)
@@ -0,0 +1,226 @@
+/* 
+#################################
+ highlord Bolvar Fordragon v 1.0
+#################################
+
+by Myav 
+*/
+
+#include "precompiled.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL highlord_bolvar_fordragonAI : public ScriptedAI
+{
+    highlord_bolvar_fordragonAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+
+    m_creature->SetMaxHealth(380000);
+    m_creature->SetHealth(380000);
+    m_creature->SetMaxPower(POWER_MANA,150000);
+    m_creature->SetPower(POWER_MANA,150000);
+    m_creature->SetArmor(11520);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DISARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_INTERRUPT_CAST, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CONFUSED, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM , true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR , true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DAZE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_BANISH, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+3000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+}
+
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    if(!m_creature->HasAura(27150,0))
+    {
+     DoCast(m_creature, 27150);
+     return;
+    }
+
+    if(!m_creature->HasAura(27158,0))
+    {
+     DoCast(m_creature, 27158);
+     return;
+    }
+
+    if(!m_creature->HasAura(20217,0))
+    {
+     DoCast(m_creature, 20217);
+     return;
+    }
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+           int Change = 0;
+           int info = NULL;
+
+              if(enemy)
+                  {
+                   switch(rand()%9)
+                   {
+               case 0:
+                  info = 36946;
+                  break;
+               case 1:
+                    info = 38921;
+                    break;
+               case 2:
+                    info = 32700;
+                    break;
+               case 3:
+                    info = 41367;
+                    Change = 1;
+                    break;
+               case 4:
+                    info = 10308;
+                    break;
+               case 5:
+                    info = 31904;
+                    Change = 1;
+                    break;
+               case 6:
+                    info = 41450;
+                    Change = 1;
+                    break;
+               case 7:
+                    info = 31884;
+                    Change = 1;
+                    break;
+               case 8:
+                    info = 35395;
+                    break;
+               }//switch
+            }
+
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+        }//end attack ready
+    }// end attack distance
+/*    else 
+    { 
+     if(!m_creature->IsNonMeleeSpellCasted(false))
+     {
+         if ((*m_creature).GetMotionMaster()->top()->GetMovementGeneratorType()!=TARGETED_MOTION_TYPE)
+         {
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+         }
+     }
+    }//end else */
+}
+};
+CreatureAI* GetAI_highlord_bolvar_fordragon(Creature *_Creature)
+{
+    return new highlord_bolvar_fordragonAI (_Creature);
+}
+
+void AddSC_highlord_bolvar_fordragon()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "highlord_bolvar_fordragon";
+    newscript->GetAI = &GetAI_highlord_bolvar_fordragon;
+    newscript->RegisterSelf();
+}
Index: scripts/guard/officers.cpp
===================================================================
--- scripts/guard/officers.cpp	(revision 0)
+++ scripts/guard/officers.cpp	(revision 0)
@@ -0,0 +1,379 @@
+/* 
+#####################
+ City Officers v 4
+#####################
+
+by Myav
+*/
+
+#include "precompiled.h"
+#include "guard_ai.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL city_officerAI : public ScriptedAI
+{
+    city_officerAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0; _Aggro = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 OffHand;
+    uint32 ZoneAttackMsgTimer;
+    bool yell;
+    int _Aggro;
+    float temp1;
+    float temp2;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 5000;
+    OffHand = 0;
+    yell = false;
+
+    m_creature->setPowerType(POWER_RAGE); 
+    m_creature->SetMaxPower(POWER_RAGE,500);
+    m_creature->SetPower(POWER_RAGE,0); 
+    if(m_creature->GetEntry() != 2041 && m_creature->GetEntry() != 18103)   
+        m_creature->SetMaxHealth(33600);
+    else 
+    {
+    if(m_creature->GetEntry() == 18103)
+         m_creature->SetMaxHealth(47400);
+     else m_creature->SetMaxHealth(67000);
+    }
+    if(m_creature->GetEntry() != 2041 && m_creature->GetEntry() != 18103)
+        m_creature->SetHealth(33600);
+    else
+    {
+    if(m_creature->GetEntry() == 18103)
+         m_creature->SetHealth(47400);
+     else m_creature->SetHealth(67000);
+    }
+    if(m_creature->GetEntry() == 21970 || m_creature->GetEntry() == 21971)
+        m_creature->SetMaxHealth(45725);
+    if(m_creature->GetEntry() == 21970 || m_creature->GetEntry() == 21971)
+        m_creature->SetHealth(45725);
+    m_creature->SetArmor(9600);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,540);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,540);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,540);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,540);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,540);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,540);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,540);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+1000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+
+}
+
+void DamageDeal(Unit *done_to, uint32 &damage)
+{
+   if(m_creature->GetEntry() == 2041 || m_creature->GetEntry() == 18103)
+       return;
+   temp1 = m_creature->GetPower(POWER_RAGE);
+   temp2 = 0;
+   temp2 = temp1;
+   switch(rand()%4)
+   {
+      case 0:temp1 = temp2 + 40;break;
+      case 1:temp1 = temp2 + 50;break;
+      case 2:temp1 = temp2 + 60;break;
+      case 3:temp1 = temp2 + 70;break;
+   }
+   if(temp1 > 500)
+      m_creature->SetPower(POWER_RAGE,500);   
+   else
+      m_creature->SetPower(POWER_RAGE,temp1);
+}
+
+void DamageTaken(Unit *done_by, uint32 &damage)
+{
+    if(damage > m_creature->GetHealth())
+        return;
+
+   if(m_creature->GetEntry() == 2041 || m_creature->GetEntry() == 18103)
+       return;
+
+   temp1 = m_creature->GetPower(POWER_RAGE);
+   temp2 = 0;
+   temp2 = temp1;
+   switch(rand()%4)
+   {
+      case 0:temp1 = temp2 + 20;break;
+      case 1:temp1 = temp2 + 30;break;
+      case 2:temp1 = temp2 + 40;break;
+      case 3:temp1 = temp2 + 50;break;
+   }
+   if(temp1 > 500)
+      m_creature->SetPower(POWER_RAGE,500);   
+   else
+      m_creature->SetPower(POWER_RAGE,temp1); 
+}
+
+
+void guards()
+{
+       int entry = NULL;
+       float x;
+       float y;
+       float z;
+       float X;
+       float Y;
+       float Z;
+       m_creature->GetPosition(x,y,z);
+       m_creature->getVictim()->GetPosition(X,Y,Z);
+       if(x > X)
+           X = x + 20 + 10 - rand()%20;
+       else
+           X = x - 20 + 10 - rand()%20;
+       if(y > Y)
+           Y = y + 20 + 10 - rand()%20;
+       else
+           Y = y - 20 + 10 - rand()%20;
+       m_creature->GetRespawnCoord(x,y,z); 
+       if(m_creature->getFaction() == 85)
+           entry = 3296;
+       if(m_creature->getFaction() == 79)
+           entry = 4262;
+       if(m_creature->getFaction() == 11)
+           entry = 68;
+       if(m_creature->getFaction() == 71)
+           entry = 5624;
+       if(m_creature->getFaction() == 57)
+           entry = 5595;
+       if(m_creature->getFaction() == 105)
+           entry = 3084;    
+       if(m_creature->getFaction() == 1638)
+           entry = 16733;
+       if(m_creature->getFaction() == 1604)
+           entry = 16222;
+       Helper = DoSpawnCreature(entry, (float) (X - x), (float) (Y - y), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+    /*   Helper = DoSpawnCreature(entry, 0, 0, 0, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000); */
+       if(Helper && enemy)
+          ((CreatureAI*)Helper->AI())->AttackStart(enemy); 
+}
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease our OffHand cooldown first
+    if (OffHand > diff)
+        OffHand -= diff;
+    else OffHand = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    //Buff timer (only buff when we are alive and not in combat
+    if (!InCombat)
+    {
+       temp1 = m_creature->GetPower(POWER_RAGE);
+       temp2 = temp1;
+       temp1 = temp2 - 3;
+       if(temp1 > 0)
+          m_creature->SetPower(POWER_RAGE,temp1);
+       else
+          m_creature->SetPower(POWER_RAGE,0);
+    }
+
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    if(!Help && m_creature->GetEntry() != 2041 && m_creature->GetEntry() != 18103)
+    {
+       if(m_creature->getFaction() == 85)
+        DoYell("Orgrimmar is under Invasion! Guards!! Help me!",LANG_ORCISH,NULL);
+       if(m_creature->getFaction() == 79)
+        DoYell("Darnassus is under Invasion! Guards!! Help me!",LANG_DARNASSIAN,NULL);
+       if(m_creature->getFaction() == 11)
+        DoYell("Stormwind is under Invasion! Guards!! Help me!",LANG_COMMON,NULL);
+       if(m_creature->getFaction() == 71)
+        DoYell("Undercity is under Invasion! Guards!! Help me!",LANG_GUTTERSPEAK,NULL);
+       if(m_creature->getFaction() == 57)
+        DoYell("Ironforge is under Invasion! Guards!! Help me!",LANG_DWARVISH,NULL);
+       if(m_creature->getFaction() == 105)
+        DoYell("Thunder Bluff is under Invasion! Guards!! Help me!",LANG_TAURAHE,NULL);
+       if(m_creature->getFaction() == 1638)
+        DoYell("The Exodar is under Invasion! Guards!! Help me!",LANG_DRAENEI,NULL);
+       if(m_creature->getFaction() == 1604)
+        DoYell("Silvermoon is under Invasion! Guards!! Help me!",LANG_THALASSIAN,NULL);
+       m_creature->HandleEmoteCommand(EMOTE_ONESHOT_BATTLEROAR);
+       for(int i = 0; i < 3;i++)
+       {
+            guards();
+       }
+       Help = 60000 + rand()%45000;
+    }
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+            if(m_creature->getVictim() && m_creature->SelectHostilTarget() && OffHand > 0 && OffHand < 500)
+            {
+                m_creature->HandleEmoteCommand(EMOTE_ONESHOT_ATTACKOFF);
+                m_creature->AttackerStateUpdate(m_creature->getVictim());
+                m_creature->resetAttackTimer();
+                OffHand = 0;
+            }
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+
+           if(_Aggro != 2 && m_creature->GetEntry() != 2041 && m_creature->GetEntry() != 18103)
+           {
+              _Aggro = 2;
+              DoCast(m_creature,2457);
+              return;
+           }
+
+           int Change = 0;
+           int info = NULL;
+
+       /*     if(!m_creature->HasAura(469,0) && m_creature->GetPower(POWER_RAGE) > 50)
+            {
+                info = 469;
+                Change = 1;
+            }
+            else
+            { */
+                if(!m_creature->HasAura(2048,0) && m_creature->GetPower(POWER_RAGE) > 50)
+                {
+                    info = 2048;
+                    Change = 1;
+                }
+                else
+                 if(enemy && m_creature->GetPower(POWER_RAGE) > 100)
+                  {
+                   switch(rand()%9)
+                   {
+               case 0:
+                  info = 30324;
+                  break;
+               case 1:
+                    info = 30335;
+                    break;
+               case 2:
+                    info = 12323;
+                    break;
+               case 3:
+                    info = 5246;
+                    break;
+               case 4:
+                    info = 12809;
+                    break;
+               case 5:
+
+                    info = 38474;
+                    break;
+               case 6:
+                    info = 31955;
+                    break;
+               case 7:
+                    info = 30989;
+                    break;
+               case 8:
+                    info = 13736;
+                    break;
+               }//switch
+            }//if rage
+        /*    } */
+
+            if(m_creature->GetEntry() == 2041 || m_creature->GetEntry() == 18103)
+                info = NULL;
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 3 < 2 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+            OffHand = 1000;
+        }//end attack ready
+    }// end attack distance
+}
+};
+CreatureAI* GetAI_city_officer(Creature *_Creature)
+{
+    return new city_officerAI (_Creature);
+}
+CreatureAI* GetAI_city_guard(Creature *_Creature)
+{
+    return new guardAI (_Creature);
+}
+void AddSC_city_officer()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "city_officer";
+    newscript->GetAI = &GetAI_city_officer;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "city_guard";
+    newscript->GetAI = &GetAI_city_guard;
+    newscript->RegisterSelf();
+}
Index: scripts/guard/overlord_saurfang.cpp
===================================================================
--- scripts/guard/overlord_saurfang.cpp	(revision 0)
+++ scripts/guard/overlord_saurfang.cpp	(revision 0)
@@ -0,0 +1,235 @@
+/* 
+##############################
+ High Overlord Saurfang v 1.0
+ (Orgrimmar protector)
+##############################
+
+by Myav 
+*/
+
+#include "precompiled.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL overlord_saurfangAI : public ScriptedAI
+{
+    overlord_saurfangAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+    m_creature->SetMaxHealth(98000);
+    m_creature->SetHealth(98000);
+    m_creature->SetArmor(11520);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_KNOCKOUT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+2000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+}
+
+void grunts()
+{
+       float x;
+       float y;
+       float z;
+       float X;
+       float Y;
+       float Z;
+       m_creature->GetPosition(x,y,z);
+       m_creature->getVictim()->GetPosition(X,Y,Z);
+       if(x > X)
+           X = x + 20 + 10 - rand()%20;
+       else
+           X = x - 20 + 10 - rand()%20;
+       if(y > Y)
+           Y = y + 20 + 10 - rand()%20;
+       else
+           Y = y - 20 + 10 - rand()%20;
+       m_creature->GetRespawnCoord(x,y,z);        
+       Helper = DoSpawnCreature(3296, (float) (X - x), (float) (Y - y), (float) (Z -z), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+       if(Helper && enemy)
+          ((CreatureAI*)Helper->AI())->AttackStart(enemy); 
+}
+
+void JustDied(Unit*)
+{
+    GlobalCooldown = 0;
+    Help = 45000 + rand()%30000;
+    m_creature->RemoveAllAttackers();
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+2000,false);
+}
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+    if(!Help)
+    {
+
+       for(int i = 0; i < 4;i++)
+       {
+            grunts();
+       }
+       Help = 60000 + rand()%45000;
+    }
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+           int Change = 0;
+           int info = NULL;
+
+            if(!m_creature->HasAura(8269,0))
+            {
+                info = 8269;
+                Change = 1;
+            }
+            else
+            {
+                 if(enemy)
+                  {
+                   switch(rand()%5)
+                   {
+               case 0:
+                  info = 11430;
+                  break;
+               case 1:
+                    info = 31955;
+                    break;
+               case 2:
+                    info = 5164;
+                    break;
+               case 3:
+                    info = 41400;
+                    break;
+               case 4:
+                    info = 41197;
+                    break;
+               }//switch
+            }//if rage
+            }
+
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 2 == 0 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+        }//end attack ready
+    }// end attack distance
+/*    else 
+    { 
+     if(!m_creature->IsNonMeleeSpellCasted(false))
+     {
+         if ((*m_creature).GetMotionMaster()->top()->GetMovementGeneratorType()!=TARGETED_MOTION_TYPE)
+         {
+            (*m_creature).GetMotionMaster()->Clear(false);
+            (*m_creature).GetMotionMaster()->MoveChase(m_creature->getVictim());
+         }
+     }
+    }//end else */
+}
+};
+CreatureAI* GetAI_overlord_saurfang(Creature *_Creature)
+{
+    return new overlord_saurfangAI (_Creature);
+}
+
+void AddSC_overlord_saurfang()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "overlord_saurfang";
+    newscript->GetAI = &GetAI_overlord_saurfang;
+    newscript->RegisterSelf();
+}
Index: scripts/guard/thrall.cpp
===================================================================
--- scripts/guard/thrall.cpp	(revision 0)
+++ scripts/guard/thrall.cpp	(revision 0)
@@ -0,0 +1,278 @@
+/* 
+############
+ Thrall v 1
+############
+
+by Myav
+*/
+
+#include "precompiled.h"
+#include "guard_ai.h"
+
+#define GENERIC_CREATURE_COOLDOWN 5000
+
+struct MANGOS_DLL_DECL thrallAI : public ScriptedAI
+{
+    thrallAI(Creature *c) : ScriptedAI(c) {Reset(); ZoneAttackMsgTimer = 0;}
+
+    uint32 GlobalCooldown;      //This variable acts like the global cooldown that players have (1.5 seconds)
+    uint32 Help;
+    uint32 ZoneAttackMsgTimer;
+    bool yell;
+    int _Aggro;
+    float temp1;
+    float temp2;
+    Unit* enemy;
+    Creature* Helper;
+
+void Reset()
+{
+    GlobalCooldown = 0;
+    Help = 5000;
+    yell = false;
+    m_creature->setPowerType(POWER_RAGE); 
+    m_creature->SetMaxPower(POWER_RAGE,500);
+    m_creature->SetPower(POWER_RAGE,0);    
+    m_creature->SetMaxHealth(360000);
+    m_creature->SetHealth(360000);
+    m_creature->SetArmor(11520);
+    m_creature->SetResistance(SPELL_SCHOOL_NORMAL,810);
+    m_creature->SetResistance(SPELL_SCHOOL_NATURE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_HOLY,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FIRE,810);
+    m_creature->SetResistance(SPELL_SCHOOL_FROST,810);
+    m_creature->SetResistance(SPELL_SCHOOL_SHADOW,810);
+    m_creature->SetResistance(SPELL_SCHOOL_ARCANE,810);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DISARM, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_INTERRUPT_CAST, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CONFUSED, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM , true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR , true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_ROOT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FREEZE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DAZE, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_BANISH, true);
+    m_creature->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND,BASE_VALUE,+3000,true);
+}
+
+void Aggro(Unit *who)
+{
+    //Send Zone Under Attack message to the LocalDefense and WorldDefense Channels
+    if (who->GetTypeId() == TYPEID_PLAYER && !ZoneAttackMsgTimer)
+    {
+        m_creature->SendZoneUnderAttackMessage((Player*)who);
+        ZoneAttackMsgTimer = 30000;
+    }
+}
+
+void DamageDeal(Unit *done_to, uint32 &damage)
+{
+   temp1 = m_creature->GetPower(POWER_RAGE);
+   temp2 = 0;
+   temp2 = temp1;
+   switch(rand()%4)
+   {
+      case 0:temp1 = temp2 + 40;break;
+      case 1:temp1 = temp2 + 50;break;
+      case 2:temp1 = temp2 + 60;break;
+      case 3:temp1 = temp2 + 70;break;
+   }
+   if(temp1 > 500)
+      m_creature->SetPower(POWER_RAGE,500);   
+   else
+      m_creature->SetPower(POWER_RAGE,temp1);
+}
+
+void DamageTaken(Unit *done_by, uint32 &damage)
+{
+    if(damage > m_creature->GetHealth())
+        return;
+
+   temp1 = m_creature->GetPower(POWER_RAGE);
+   temp2 = 0;
+   temp2 = temp1;
+   switch(rand()%4)
+   {
+      case 0:temp1 = temp2 + 20;break;
+      case 1:temp1 = temp2 + 30;break;
+      case 2:temp1 = temp2 + 40;break;
+      case 3:temp1 = temp2 + 50;break;
+   }
+   if(temp1 > 500)
+      m_creature->SetPower(POWER_RAGE,500);   
+   else
+      m_creature->SetPower(POWER_RAGE,temp1); 
+}
+
+
+void UpdateAI(const uint32 diff)
+{
+    //Always decrease our global cooldown first
+    if (GlobalCooldown > diff)
+        GlobalCooldown -= diff;
+    else GlobalCooldown = 0;
+
+    //Always decrease ZoneAttackMsgTimer
+    if (ZoneAttackMsgTimer > diff)
+        ZoneAttackMsgTimer -= diff;
+    else ZoneAttackMsgTimer = 0;
+
+    if(!m_creature->isAlive())
+        return;
+
+    //Buff timer (only buff when we are alive and not in combat
+    if (!InCombat)
+    {
+       temp1 = m_creature->GetPower(POWER_RAGE);
+       temp2 = temp1;
+       temp1 = temp2 - 3;
+       if(temp1 > 0)
+          m_creature->SetPower(POWER_RAGE,temp1);
+       else
+          m_creature->SetPower(POWER_RAGE,0);
+    }
+
+    //Return since we have no target
+    if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+        return;
+
+    Unit *target = m_creature->getVictim();
+
+       if(target == SelectUnit(SELECT_TARGET_TOPAGGRO,0) && !target->isAlive() && !m_creature->IsNonMeleeSpellCasted(false))
+       {
+          Unit* target2 = NULL;
+          target2 = SelectUnit(SELECT_TARGET_TOPAGGRO,1);
+          m_creature->getThreatManager().modifyThreatPercent(target,-100);
+          if(target2 && target2->isAlive())
+              {
+                 m_creature->AddThreat(target2,1);
+                 m_creature->Attack(target2,true);
+                 AttackStart(target2);
+                 return;
+              }
+          else
+          {
+              Reset();
+              return;
+          }
+       }
+
+    if(m_creature->IsHostileTo(target))
+           enemy = target;
+
+    if(enemy)
+        if(!enemy->isAlive())
+            enemy = NULL;
+
+
+    //Always decrease Help when in combat
+    if (Help > diff)
+        Help -= diff;
+    else Help = 0;
+
+           if(!m_creature->HasAura(41447,0))
+           {
+              DoCast(m_creature,41447);
+              return;
+           }
+
+    //If we are within range melee the target
+    if( m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+    {
+        //Make sure our attack is ready and we arn't currently casting
+        if( m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+        {
+
+           if(_Aggro != 2 && m_creature->GetEntry() != 2041)
+           {
+              _Aggro = 2;
+              DoCast(m_creature,2457);
+              return;
+           }
+
+           int Change = 0;
+           int info = NULL;
+
+       /*     if(!m_creature->HasAura(469,0) && m_creature->GetPower(POWER_RAGE) > 50)
+            {
+                info = 469;
+                Change = 1;
+            }
+            else
+            { */
+                if(!m_creature->getVictim()->HasAura(29584,0) && m_creature->GetPower(POWER_RAGE) > 50)
+                {
+                    info = 29584;
+                }
+                else
+                 if(enemy && m_creature->GetPower(POWER_RAGE) > 100)
+                  {
+                   switch(rand()%8)
+                   {
+               case 0:
+                  info = 37476;
+                  break;
+               case 1:
+                    info = 36706;
+                    break;
+               case 2:
+                    info = 38618;
+                    break;
+               case 3:
+                    info = 12975;
+                    Change = 1;
+                    break;
+               case 4:
+                    info = 12809;
+                    break;
+               case 5:
+                    info = 36138;
+                    break;
+               case 6:
+                    info = 5246;
+                    break;
+               case 7:
+                    info = 34620;
+                    break;
+               }//switch
+            }//if rage
+        /*    } */
+
+            if(m_creature->GetEntry() == 2041)
+                info = NULL;
+            //65% chance to replace our white hit with a spell
+            if (info && rand() % 3 < 2 && !GlobalCooldown)
+            {
+                //Cast the spell   
+                if (Change == 1)DoCast(m_creature, info);
+                else DoCast(enemy, info);
+
+                //Set our global cooldown
+                GlobalCooldown = GENERIC_CREATURE_COOLDOWN;
+            }//end 50% change
+            else m_creature->AttackerStateUpdate(m_creature->getVictim());
+
+            m_creature->resetAttackTimer();
+
+        }//end attack ready
+    }// end attack distance
+}
+};
+CreatureAI* GetAI_thrall(Creature *_Creature)
+{
+    return new thrallAI (_Creature);
+}
+void AddSC_thrall()
+{   
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "thrall";
+    newscript->GetAI = &GetAI_thrall;
+    newscript->RegisterSelf();
+}
Index: VC80/80ScriptDev2.vcproj
===================================================================
--- VC80/80ScriptDev2.vcproj	(revision 738)
+++ VC80/80ScriptDev2.vcproj	(working copy)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8.00"
+	Version="8,00"
 	Name="ScriptDev2"
 	ProjectGUID="{4295C8A9-79B7-4354-8064-F05FB9CA0C96}"
 	RootNamespace="ScriptDev2"
@@ -409,6 +409,18 @@
 				Name="guard"
 				>
 				<File
+					RelativePath="..\scripts\guard\ancient_of_war.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\archbishop_benedictus.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\g_marcus_jonathan.cpp"
+					>
+				</File>
+				<File
 					RelativePath="..\scripts\guard\guard_ai.cpp"
 					>
 				</File>
@@ -420,6 +432,30 @@
 					RelativePath="..\scripts\guard\guards.cpp"
 					>
 				</File>
+				<File
+					RelativePath="..\scripts\guard\high_fire_mage.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\high_sorcerer_andromath.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\highlord_bolvar_fordragon.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\officers.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\overlord_saurfang.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\thrall.cpp"
+					>
+				</File>
 			</Filter>
 			<Filter
 				Name="honor"
Index: VC90/90ScriptDev2.vcproj
===================================================================
--- VC90/90ScriptDev2.vcproj	(revision 738)
+++ VC90/90ScriptDev2.vcproj	(working copy)
@@ -408,6 +408,18 @@
 				Name="guard"
 				>
 				<File
+					RelativePath="..\scripts\guard\ancient_of_war.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\archbishop_benedictus.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\g_marcus_jonathan.cpp"
+					>
+				</File>
+				<File
 					RelativePath="..\scripts\guard\guard_ai.cpp"
 					>
 				</File>
@@ -419,6 +431,30 @@
 					RelativePath="..\scripts\guard\guards.cpp"
 					>
 				</File>
+				<File
+					RelativePath="..\scripts\guard\high_fire_mage.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\high_sorcerer_andromath.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\highlord_bolvar_fordragon.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\officers.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\overlord_saurfang.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\scripts\guard\thrall.cpp"
+					>
+				</File>
 			</Filter>
 			<Filter
 				Name="honor"
