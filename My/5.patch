diff --git a/src/game/AggressorAI.cpp b/src/game/AggressorAI.cpp
index 637410c..9be41e5 100644
--- a/src/game/AggressorAI.cpp
+++ b/src/game/AggressorAI.cpp
@@ -55,7 +55,7 @@ AggressorAI::MoveInLineOfSight(Unit *u)
         if(i_creature.IsWithinDistInMap(u, attackRadius) && i_creature.IsWithinLOSInMap(u) )
         {
             AttackStart(u);
-            u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
+            //u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
         }
     }
 }
diff --git a/src/game/ChatHandler.cpp b/src/game/ChatHandler.cpp
index a6e05aa..9bef693 100644
--- a/src/game/ChatHandler.cpp
+++ b/src/game/ChatHandler.cpp
@@ -18,6 +18,7 @@
 
 #include "Common.h"
 #include "Log.h"
+#include "ChatLog.h"
 #include "WorldPacket.h"
 #include "WorldSession.h"
 #include "World.h"
@@ -159,11 +160,23 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
                 break;
 
             if(type == CHAT_MSG_SAY)
+            {
+                sChatLog.ChatMsg(GetPlayer(), msg, type);
+
                 GetPlayer()->Say(msg, lang);
+            }
             else if(type == CHAT_MSG_EMOTE)
+            {
+                sChatLog.ChatMsg(GetPlayer(), msg, type);
+
                 GetPlayer()->TextEmote(msg);
+            }
             else if(type == CHAT_MSG_YELL)
+            {
+                sChatLog.ChatMsg(GetPlayer(), msg, type);
+
                 GetPlayer()->Yell(msg, lang);
+            }
         } break;
 
         case CHAT_MSG_WHISPER:
@@ -180,6 +193,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.WhisperMsg(GetPlayer(), to, msg);
+
             if(!normalizePlayerName(to))
             {
                 WorldPacket data(SMSG_CHAT_PLAYER_NOT_FOUND, (to.size()+1));
@@ -233,6 +248,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.PartyMsg(GetPlayer(), msg);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group)
                 return;
@@ -260,6 +277,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.GuildMsg(GetPlayer(), msg, false);
+
             if (GetPlayer()->GetGuildId())
             {
                 Guild *guild = objmgr.GetGuildById(GetPlayer()->GetGuildId());
@@ -287,6 +306,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.GuildMsg(GetPlayer(), msg, true);
+
             if (GetPlayer()->GetGuildId())
             {
                 Guild *guild = objmgr.GetGuildById(GetPlayer()->GetGuildId());
@@ -313,6 +334,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.RaidMsg(GetPlayer(), msg, type);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isRaidGroup())
                 return;
@@ -339,6 +362,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.RaidMsg(GetPlayer(), msg, type);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isRaidGroup() || !group->IsLeader(GetPlayer()->GetGUID()))
                 return;
@@ -359,6 +384,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.RaidMsg(GetPlayer(), msg, type);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isRaidGroup() || !(group->IsLeader(GetPlayer()->GetGUID()) || group->IsAssistant(GetPlayer()->GetGUID())))
                 return;
@@ -380,6 +407,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.BattleGroundMsg(GetPlayer(), msg, type);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isRaidGroup())
                 return;
@@ -401,6 +430,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.BattleGroundMsg(GetPlayer(), msg, type);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isRaidGroup() || !group->IsLeader(GetPlayer()->GetGUID()))
                 return;
@@ -427,6 +458,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.ChannelMsg(GetPlayer(), channel, msg);
+
             if(ChannelMgr* cMgr = channelMgr(_player->GetTeam()))
             {
                 if(Channel *chn = cMgr->GetChannel(channel,_player))
diff --git a/src/game/ChatLexicsCutter.cpp b/src/game/ChatLexicsCutter.cpp
new file mode 100644
index 0000000..1c1d555
--- /dev/null
+++ b/src/game/ChatLexicsCutter.cpp
@@ -0,0 +1,274 @@
+/* 
+ * Copyright (C) 2005,2006,2007 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "Common.h"
+#include "ChatLexicsCutter.h"
+
+LexicsCutter::LexicsCutter()
+{
+    InvalidChars = "~`!@#$%^&*()-_+=[{]}|\\;:'\",<.>/?";
+}
+
+bool LexicsCutter::ReadUTF8(std::string& in, std::string& out, unsigned int& pos)
+{
+    if (pos >= in.length()) return false;
+    
+    out = "";
+    unsigned char c = in[pos++];
+    out += c;
+    int toread = trailingBytesForUTF8[(int) c];
+    while ((pos < in.length()) && (toread > 0))
+    {
+        out += in[pos++];
+        toread--;
+    }
+    
+    return true;
+}
+
+std::string LexicsCutter::trim(std::string& s, const std::string& drop)
+{
+    std::string r = s.erase(s.find_last_not_of(drop) + 1);
+    return r.erase(0, r.find_first_not_of(drop));
+}
+
+bool LexicsCutter::Read_Letter_Analogs(std::string& FileName)
+{
+    FILE *ma_file;
+    char line[1024];
+    unsigned int pos;
+    std::string line_s;
+    std::string lchar;
+    std::string lanalog;
+    
+    ma_file = fopen(FileName.c_str(), "rb");
+    
+    while (!feof(ma_file))
+    {
+        line[0] = 0x0;
+        fgets(line, 1020, ma_file);
+
+        // check for UTF8 prefix and comments
+        if (strlen(line) >= 3)
+        {
+            if (line[0] == '\xEF' && line[1] == '\xBB' && line[2] == '\xBF')
+            {
+                strncpy(&line[0], &line[3], strlen(line) - 3);
+            }
+        }
+
+        if (strlen(line) >= 2)
+        {
+            if (line[0] == '/' && line[1] == '/') continue;
+        }
+
+        // check for empty string
+        line_s = line; 
+        line_s = trim(line_s, "\x0A\x0D\x20");
+        if (line_s == "") continue;
+
+        // process line without CR/LF
+        line_s = line; 
+        line_s = trim(line_s, "\x0A\x0D");
+    
+        pos = 0;
+        if (ReadUTF8(line_s, lchar, pos))
+        {
+            // create analogs vector
+            LC_AnalogVector av;
+            while (ReadUTF8(line_s, lanalog, pos))
+            {
+                av.push_back(lanalog);
+            }
+        
+            // store vector in hash map
+            AnalogMap[lchar] = av;
+        }
+    }
+    
+    fclose(ma_file);
+    
+    return true;
+}
+
+bool LexicsCutter::Read_Innormative_Words(std::string& FileName)
+{
+    FILE *ma_file;
+    char line[1024];
+    unsigned int pos;
+    std::string line_s;
+    std::string lchar;
+    
+    ma_file = fopen(FileName.c_str(), "rb");
+    
+    while (!feof(ma_file))
+    {
+        line[0] = 0x0;
+        fgets(line, 1020, ma_file);
+
+        // check for UTF8 prefix and comment
+        if (strlen(line) >= 3)
+        {
+            if (line[0] == '\xEF' && line[1] == '\xBB' && line[2] == '\xBF')
+            {
+                strncpy(&line[0], &line[3], strlen(line) - 3);
+            }
+        }
+
+        if (strlen(line) >= 2)
+        {
+            if (line[0] == '/' && line[1] == '/') continue;
+        }
+
+        // check for empty string
+        line_s = line; 
+        line_s = trim(line_s, "\x0A\x0D\x20");
+        if (line_s == "") continue;
+
+        // process line without CR/LF
+        line_s = line; 
+        line_s = trim(line_s, "\x0A\x0D");
+    
+        // create word vector of vectors
+        LC_WordVector vw;
+        pos = 0;
+        while (ReadUTF8(line_s, lchar, pos))
+        {
+            // create letter set
+            LC_LetterSet vl;
+        
+            // initialize letter set with letter read
+            vl.insert(lchar);
+        
+            // find letter analogs and push them onto the vector
+            LC_AnalogMap::iterator itr = AnalogMap.find(lchar);
+            if (itr != AnalogMap.end())
+            {
+                // analogs present, iterate
+                for (LC_AnalogVector::iterator itr2 = itr->second.begin(); itr2 != itr->second.end(); itr2++)
+                {
+                    vl.insert(*itr2);
+                }
+            }
+        
+            // add letter vector to word vector
+            vw.push_back(vl);
+        }
+
+        // push new word to words list
+        WordList.push_back(vw);
+    }
+    
+    fclose(ma_file);
+    
+    return true;
+}
+
+void LexicsCutter::Map_Innormative_Words()
+{
+    // process all the words in the vector
+    for (unsigned int i = 0; i < WordList.size(); i++)
+    {
+        // parse all analogs in the first word letter
+        for (LC_LetterSet::iterator itr = (*WordList[i].begin()).begin(); itr != (*WordList[i].begin()).end(); itr++)
+        {
+            // map the word to its first letter variants
+            WordMap.insert(std::pair< std::string, unsigned int >(*itr, i));
+        }
+    }
+}
+
+bool LexicsCutter::Compare_Word(std::string& str, unsigned int pos, LC_WordVector word)
+{
+   std::string lchar_prev;
+    std::string lchar;
+
+   // read first letter of the word into lchar_prev
+   ReadUTF8(str, lchar, pos);    
+
+    // okay, here we go, comparing word
+    // first letter is already okay, we do begin from second and go on
+    LC_WordVector::iterator i = word.begin();
+    i++;
+    while (i != word.end())
+    {
+        // get letter from word, return false if the string is shorter
+        if (!ReadUTF8(str, lchar, pos)) return(false);
+        // check, if the letter is in the set
+        LC_LetterSet ls = *i;
+        if (ls.count(lchar) == 0)
+       {
+           // letter is not in set, but we must check, if it is not space or repeat
+           if ( (!(IgnoreMiddleSpaces && (lchar == " "))) &&
+               (!(IgnoreLetterRepeat && (lchar == lchar_prev))) )
+           {
+               // no checks viable
+               return(false);
+           }
+       }
+       else
+       {
+           // next word letter
+           i++;
+       }
+       // set previous string letter to compare if needed (this check can really conserve time)
+       if (IgnoreLetterRepeat) lchar_prev = lchar;
+   }
+    
+    return(true);
+}
+
+bool LexicsCutter::Check_Lexics(std::string& Phrase)
+{
+    std::string lchar;
+    LC_WordMap::iterator i;
+    std::pair< LC_WordMap::iterator, LC_WordMap::iterator > ii;
+
+    if (Phrase.size() == 0) return(false);
+    
+    // first, convert the string, adding spaces and removing invalid characters
+    // also create fast position vector for the new positions
+    std::string str = " ";
+    unsigned int pos = 0;
+    while (ReadUTF8(Phrase, lchar, pos))
+    {
+        if (InvalidChars.find(lchar) == std::string::npos)
+        {
+            str.append(lchar);
+        }
+    }
+    
+    // string prepared, now parse it and scan for all the words
+   unsigned int pos_prev = 0;
+    pos = 0;
+    while (ReadUTF8(str, lchar, pos))
+    {
+        // got character, now try to find wordmap for it
+        ii = WordMap.equal_range(lchar);
+        // iterate over all found words
+        for (i = ii.first; i != ii.second; i++)
+        {
+            // compare word at initial position
+            if (Compare_Word(str, pos_prev, WordList[i->second])) return(true);
+        }
+       // set initial position to the current position
+       pos_prev = pos;
+    }
+    
+    return(false);
+}
diff --git a/src/game/ChatLexicsCutter.h b/src/game/ChatLexicsCutter.h
new file mode 100644
index 0000000..38d636c
--- /dev/null
+++ b/src/game/ChatLexicsCutter.h
@@ -0,0 +1,67 @@
+/* 
+ * Copyright (C) 2005,2006,2007 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef MANGOSSERVER_CHATLEXICSCUTTER_H
+#define MANGOSSERVER_CHATLEXICSCUTTER_H
+
+typedef std::vector< std::string > LC_AnalogVector;
+typedef std::map< std::string, LC_AnalogVector > LC_AnalogMap;
+typedef std::set< std::string > LC_LetterSet;
+typedef std::vector< LC_LetterSet > LC_WordVector;
+typedef std::vector< LC_WordVector > LC_WordList;
+typedef std::multimap< std::string, unsigned int > LC_WordMap;
+
+static int trailingBytesForUTF8[256] = {
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5
+};
+
+class LexicsCutter
+{
+    protected:
+        LC_AnalogMap AnalogMap;
+        LC_WordList WordList;
+        LC_WordMap WordMap;
+
+        std::string InvalidChars;
+
+    public:
+        LexicsCutter();
+
+        static bool ReadUTF8(std::string& in, std::string& out, unsigned int& pos);
+
+        std::string trim(std::string& s, const std::string& drop = " ");
+        bool Read_Letter_Analogs(std::string& FileName);
+        bool Read_Innormative_Words(std::string& FileName);
+        void Map_Innormative_Words();
+        bool Compare_Word(std::string& str, unsigned int pos, LC_WordVector word);
+        bool Check_Lexics(std::string& Phrase);
+        
+        std::vector< std::pair< unsigned int, unsigned int > > Found;
+        bool IgnoreMiddleSpaces;
+        bool IgnoreLetterRepeat;
+};
+
+#endif
+
diff --git a/src/game/ChatLog.cpp b/src/game/ChatLog.cpp
new file mode 100644
index 0000000..ef5e203
--- /dev/null
+++ b/src/game/ChatLog.cpp
@@ -0,0 +1,855 @@
+/* 
+ * Copyright (C) 2005,2006,2007 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "Common.h"
+#include "ChatLexicsCutter.h"
+#include "ChatLog.h"
+#include "Chat.h"
+#include "Group.h"
+#include "Guild.h"
+#include "ObjectMgr.h"
+#include "SpellAuras.h"
+#include "Policies/SingletonImp.h"
+#include "Config/ConfigEnv.h"
+
+INSTANTIATE_SINGLETON_1( ChatLog );
+
+ChatLog::ChatLog()
+{
+    for (int i = 0; i <= CHATLOG_CHAT_TYPES_COUNT - 1; i++)
+    {
+        names[i] = "";
+        files[i] = NULL;
+    }
+    
+    Lexics = NULL;
+    fn_innormative = "";
+    f_innormative = NULL;
+    
+    Initialize();
+}
+
+ChatLog::~ChatLog()
+{
+    // close all files (avoiding double-close)
+    CloseAllFiles();
+
+    if (Lexics)
+    {
+        delete Lexics;
+        Lexics = NULL;
+    }
+}
+
+void ChatLog::Initialize()
+{
+    // determine, if the chat logs are enabled
+    ChatLogEnable = sConfig.GetBoolDefault("ChatLogEnable", false);
+    ChatLogDateSplit = sConfig.GetBoolDefault("ChatLogDateSplit", false);
+    ChatLogUTFHeader = sConfig.GetBoolDefault("ChatLogUTFHeader", false);
+    ChatLogIgnoreUnprintable = sConfig.GetBoolDefault("ChatLogIgnoreUnprintable", false);
+    
+    if (ChatLogEnable)
+    {
+        // read chat log file names
+        names[CHAT_LOG_CHAT] = sConfig.GetStringDefault("ChatLogChatFile", "");
+        names[CHAT_LOG_PARTY] = sConfig.GetStringDefault("ChatLogPartyFile", "");
+        names[CHAT_LOG_GUILD] = sConfig.GetStringDefault("ChatLogGuildFile", "");
+        names[CHAT_LOG_WHISPER] = sConfig.GetStringDefault("ChatLogWhisperFile", "");
+        names[CHAT_LOG_CHANNEL] = sConfig.GetStringDefault("ChatLogChannelFile", "");
+        names[CHAT_LOG_RAID] = sConfig.GetStringDefault("ChatLogRaidFile", "");
+        names[CHAT_LOG_BATTLEGROUND] = sConfig.GetStringDefault("ChatLogBattleGroundFile", "");
+
+        // read screen log flags
+        screenflag[CHAT_LOG_CHAT] = sConfig.GetBoolDefault("ChatLogChatScreen", false);
+        screenflag[CHAT_LOG_PARTY] = sConfig.GetBoolDefault("ChatLogPartyScreen", false);
+        screenflag[CHAT_LOG_GUILD] = sConfig.GetBoolDefault("ChatLogGuildScreen", false);
+        screenflag[CHAT_LOG_WHISPER] = sConfig.GetBoolDefault("ChatLogWhisperScreen", false);
+        screenflag[CHAT_LOG_CHANNEL] = sConfig.GetBoolDefault("ChatLogChannelScreen", false);
+        screenflag[CHAT_LOG_RAID] = sConfig.GetBoolDefault("ChatLogRaidScreen", false);
+        screenflag[CHAT_LOG_BATTLEGROUND] = sConfig.GetBoolDefault("ChatLogBattleGroundScreen", false);
+    }
+
+    // lexics cutter
+    LexicsCutterEnable = sConfig.GetBoolDefault("LexicsCutterEnable", false);
+
+    if (LexicsCutterEnable)
+    {
+        // initialize lexics cutter parameters
+        LexicsCutterInnormativeCut = sConfig.GetBoolDefault("LexicsCutterInnormativeCut", true);
+        LexicsCutterNoActionOnGM = sConfig.GetBoolDefault("LexicsCutterNoActionOnGM", true);
+        LexicsCutterScreenLog = sConfig.GetBoolDefault("LexicsCutterScreenLog", false);
+        LexicsCutterCutReplacement = sConfig.GetStringDefault("LexicsCutterCutReplacement", "&!@^%!^&*!!! [gibberish]");
+        LexicsCutterAction = sConfig.GetIntDefault("LexicsCutterAction", 0);
+        LexicsCutterActionDuration = sConfig.GetIntDefault("LexicsCutterActionDuration", 60000);
+        std::string fn_analogsfile = sConfig.GetStringDefault("LexicsCutterAnalogsFile", "");
+        std::string fn_wordsfile = sConfig.GetStringDefault("LexicsCutterWordsFile", "");
+
+        // read lexics cutter flags
+        cutflag[CHAT_LOG_CHAT] = sConfig.GetBoolDefault("LexicsCutInChat", true);
+        cutflag[CHAT_LOG_PARTY] = sConfig.GetBoolDefault("LexicsCutInParty", true);
+        cutflag[CHAT_LOG_GUILD] = sConfig.GetBoolDefault("LexicsCutInGuild", true);
+        cutflag[CHAT_LOG_WHISPER] = sConfig.GetBoolDefault("LexicsCutInWhisper", true);
+        cutflag[CHAT_LOG_CHANNEL] = sConfig.GetBoolDefault("LexicsCutInChannel", true);
+        cutflag[CHAT_LOG_RAID] = sConfig.GetBoolDefault("LexicsCutInRaid", true);
+        cutflag[CHAT_LOG_BATTLEGROUND] = sConfig.GetBoolDefault("LexicsCutInBattleGround", true);
+
+        if (fn_analogsfile == "" || fn_wordsfile == "")
+        {
+            LexicsCutterEnable = false;
+        }
+        else
+        {
+            // initialize lexics cutter
+            Lexics = new LexicsCutter;
+            if (Lexics) Lexics->Read_Letter_Analogs(fn_analogsfile);
+            if (Lexics) Lexics->Read_Innormative_Words(fn_wordsfile);
+            if (Lexics) Lexics->Map_Innormative_Words();
+
+            // read additional parameters
+            Lexics->IgnoreLetterRepeat = sConfig.GetBoolDefault("LexicsCutterIgnoreRepeats", true);
+            Lexics->IgnoreMiddleSpaces = sConfig.GetBoolDefault("LexicsCutterIgnoreSpaces", true);
+            fn_innormative = sConfig.GetStringDefault("LexicsCutterLogFile", "");
+        }
+    }
+
+    // open all files (with aliasing)
+    OpenAllFiles();
+
+    // write timestamps (init)
+    WriteInitStamps();
+}
+
+bool ChatLog::_ChatCommon(int ChatType, Player *player, std::string &msg)
+{
+    if (LexicsCutterEnable && Lexics && cutflag[ChatType] && Lexics->Check_Lexics(msg)) ChatBadLexicsAction(player, msg);
+
+    if (!ChatLogEnable) return(false);
+
+    if (ChatLogIgnoreUnprintable)
+    {
+        // have to ignore unprintables, verify string by UTF8 here
+        unsigned int pos = 0;
+        std::string lchar;
+        while (LexicsCutter::ReadUTF8(msg, lchar, pos))
+        {
+            if (lchar.size() == 1)
+            {
+                if (lchar[0] < ' ') return(false); // unprintable detected
+            }
+        }
+    }
+
+    return(true);
+}
+        
+void ChatLog::ChatMsg(Player *player, std::string &msg, uint32 type)
+{
+    if (!_ChatCommon(CHAT_LOG_CHAT, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    switch (type)
+    {
+        case CHAT_MSG_EMOTE:
+        log_str.append("{EMOTE} ");
+        break;
+
+        case CHAT_MSG_YELL:
+        log_str.append("{YELL} ");
+        break;
+    }
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("] ");
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_CHAT]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_CHAT])
+    {
+        OutTimestamp(files[CHAT_LOG_CHAT]);
+        fprintf(files[CHAT_LOG_CHAT], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_CHAT]);
+    }
+}
+
+void ChatLog::PartyMsg(Player *player, std::string &msg)
+{
+    if (!_ChatCommon(CHAT_LOG_PARTY, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("]->GROUP:");
+    
+    Group *group = player->GetGroup();
+    if (!group)
+    {
+        log_str.append("[unknown group] ");
+    }
+    else
+    {
+        // obtain group information
+        log_str.append("[");
+
+        uint8 gm_count = group->GetMembersCount();
+        uint8 gm_count_m1 = gm_count - 1;
+        uint64 gm_leader_GUID = group->GetLeaderGUID();
+        Player *gm_member;
+
+        gm_member = objmgr.GetPlayer(gm_leader_GUID);
+        if (gm_member)
+        {
+            log_str.append(gm_member->GetName());
+            log_str.append(",");
+        }
+
+        Group::MemberSlotList g_members = group->GetMemberSlots();
+        
+        for (Group::member_citerator itr = g_members.begin(); itr != g_members.end(); itr++)
+        {
+            if (itr->guid == gm_leader_GUID) continue;
+
+            gm_member = objmgr.GetPlayer(itr->guid);
+            if (gm_member)
+            {
+                log_str.append(itr->name);
+                log_str.append(",");
+            }
+        }
+
+        log_str.erase(log_str.length() - 1);
+        log_str.append("] ");
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+    
+    if (screenflag[CHAT_LOG_PARTY]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_PARTY])
+    {
+        OutTimestamp(files[CHAT_LOG_PARTY]);
+        fprintf(files[CHAT_LOG_PARTY], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_PARTY]);
+    }
+}
+
+void ChatLog::GuildMsg(Player *player, std::string &msg, bool officer)
+{
+    if (!_ChatCommon(CHAT_LOG_GUILD, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append((officer ? "]->GUILD_OFF:" : "]->GUILD:"));
+    
+    if (!player->GetGuildId())
+    {
+        log_str.append("[unknown guild] ");
+    }
+    else
+    {
+        Guild *guild = objmgr.GetGuildById(player->GetGuildId());
+        if (!guild)
+        {
+            log_str.append("[unknown guild] ");
+        }
+        else
+        {
+            // obtain guild information
+            log_str.append("(");
+            log_str.append(guild->GetName());
+            log_str.append(") ");
+        }
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+    
+    if (screenflag[CHAT_LOG_GUILD]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_GUILD])
+    {
+        OutTimestamp(files[CHAT_LOG_GUILD]);
+        fprintf(files[CHAT_LOG_GUILD], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_GUILD]);
+    }
+}
+
+void ChatLog::WhisperMsg(Player *player, std::string &to, std::string &msg)
+{
+    if (!_ChatCommon(CHAT_LOG_WHISPER, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("]->");
+    
+    if (to.size() == 0)
+    {
+        log_str.append("[???] ");
+    }
+    else
+    {
+        normalizePlayerName(to);
+        log_str.append("[");
+        log_str.append(to);
+        log_str.append("] ");
+    }
+    
+    log_str.append(msg);
+
+    log_str.append("\n");
+    
+    if (screenflag[CHAT_LOG_WHISPER]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_WHISPER])
+    {
+        OutTimestamp(files[CHAT_LOG_WHISPER]);
+        fprintf(files[CHAT_LOG_WHISPER], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_WHISPER]);
+    }
+}
+
+void ChatLog::ChannelMsg(Player *player, std::string &channel, std::string &msg)
+{
+    if (!_ChatCommon(CHAT_LOG_CHANNEL, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("]->CHANNEL:");
+    
+    if (channel.size() == 0)
+    {
+        log_str.append("[unknown channel] ");
+    }
+    else
+    {
+        log_str.append("[");
+        log_str.append(channel);
+        log_str.append("] ");
+    }
+    
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_CHANNEL]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_CHANNEL])
+    {
+        OutTimestamp(files[CHAT_LOG_CHANNEL]);
+        fprintf(files[CHAT_LOG_CHANNEL], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_CHANNEL]);
+    }
+}
+
+void ChatLog::RaidMsg(Player *player, std::string &msg, uint32 type)
+{
+    if (!_ChatCommon(CHAT_LOG_RAID, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+
+    switch (type)
+    {
+        case CHAT_MSG_RAID:
+        log_str.append("]->RAID:");
+        break;
+
+        case CHAT_MSG_RAID_LEADER:
+        log_str.append("]->RAID_LEADER:");
+        break;
+
+        case CHAT_MSG_RAID_WARNING:
+        log_str.append("]->RAID_WARN:");
+        break;
+
+        default:
+        log_str.append("]->RAID_UNKNOWN:");
+    }
+    
+    Group *group = player->GetGroup();
+    if (!group)
+    {
+        log_str.append("[unknown raid] ");
+    }
+    else
+    {
+        // obtain group information
+        log_str.append("[");
+
+        uint8 gm_count = group->GetMembersCount();
+        uint8 gm_count_m1 = gm_count - 1;
+        uint64 gm_leader_GUID = group->GetLeaderGUID();
+        Player *gm_member;
+
+        gm_member = objmgr.GetPlayer(gm_leader_GUID);
+        if (gm_member)
+        {
+            log_str.append(gm_member->GetName());
+            log_str.append(",");
+        }
+
+        Group::MemberSlotList g_members = group->GetMemberSlots();
+    
+        for (Group::member_citerator itr = g_members.begin(); itr != g_members.end(); itr++)
+        {
+            if (itr->guid == gm_leader_GUID) continue;
+
+            gm_member = objmgr.GetPlayer(itr->guid);
+            if (gm_member)
+            {
+                log_str.append(itr->name);
+                log_str.append(",");
+            }
+        }
+    
+        log_str.erase(log_str.length() - 1);
+        log_str.append("] ");
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_RAID]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_RAID])
+    {
+        OutTimestamp(files[CHAT_LOG_RAID]);
+        fprintf(files[CHAT_LOG_RAID], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_RAID]);
+    }
+}
+
+void ChatLog::BattleGroundMsg(Player *player, std::string &msg, uint32 type)
+{
+    if (!_ChatCommon(CHAT_LOG_BATTLEGROUND, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+
+    switch (type)
+    {
+        case CHAT_MSG_BATTLEGROUND:
+        log_str.append("]->BG:");
+        break;
+
+        case CHAT_MSG_BATTLEGROUND_LEADER:
+        log_str.append("]->BG_LEADER:");
+        break;
+
+        default:
+        log_str.append("]->BG_UNKNOWN:");
+    }
+    
+    Group *group = player->GetGroup();
+    if (!group)
+    {
+        log_str.append("[unknown group] ");
+    }
+    else
+    {
+        // obtain group information
+        log_str.append("[");
+
+        uint8 gm_count = group->GetMembersCount();
+        uint8 gm_count_m1 = gm_count - 1;
+        uint64 gm_leader_GUID = group->GetLeaderGUID();
+        Player *gm_member;
+
+        gm_member = objmgr.GetPlayer(gm_leader_GUID);
+        if (gm_member)
+        {
+            log_str.append(gm_member->GetName());
+            log_str.append(",");
+        }
+
+        Group::MemberSlotList g_members = group->GetMemberSlots();
+    
+        for (Group::member_citerator itr = g_members.begin(); itr != g_members.end(); itr++)
+        {
+            if (itr->guid == gm_leader_GUID) continue;
+
+            gm_member = objmgr.GetPlayer(itr->guid);
+            if (gm_member)
+            {
+                log_str.append(itr->name);
+                log_str.append(",");
+            }
+        }
+    
+        log_str.erase(log_str.length() - 1);
+        log_str.append("] ");
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_BATTLEGROUND]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_BATTLEGROUND])
+    {
+        OutTimestamp(files[CHAT_LOG_BATTLEGROUND]);
+        fprintf(files[CHAT_LOG_BATTLEGROUND], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_BATTLEGROUND]);
+    }
+}
+
+void ChatLog::OpenAllFiles()
+{
+    std::string tempname;
+    char dstr[12];
+
+    if (ChatLogDateSplit)
+    {
+        time_t t = time(NULL);
+        tm* aTm = localtime(&t);
+        sprintf(dstr, "%-4d-%02d-%02d", aTm->tm_year + 1900, aTm->tm_mon + 1, aTm->tm_mday);
+    }
+
+    if (ChatLogEnable)
+    {
+        for (int i = 0; i <= CHATLOG_CHAT_TYPES_COUNT - 1; i++)
+        {
+            if (names[i] != "")
+            {
+                for (int j = i - 1; j >= 0; j--)
+                {
+                    if (names[i] == names[j])
+                    {
+                        files[i] = files[j];
+                        break;
+                    }
+                }
+                if (!files[i])
+                {
+                    tempname = names[i];
+                    if (ChatLogDateSplit)
+                    {
+                        // append date instead of $d if applicable
+                        int dpos = tempname.find("$d");
+                        if (dpos != tempname.npos)
+                        {
+                            tempname.replace(dpos, 2, &dstr[0], 10);
+                        }
+                    }
+                    files[i] = fopen(tempname.c_str(), "a+b");
+                    if (ChatLogUTFHeader && (ftell(files[i]) == 0)) fputs("\xEF\xBB\xBF", files[i]);
+                }
+            }
+        }
+    }
+
+    // initialize innormative log
+    if (LexicsCutterEnable)
+    {
+        if (fn_innormative != "")
+        {
+            tempname = fn_innormative;
+            if (ChatLogDateSplit)
+            {
+                // append date instead of $d if applicable
+                int dpos = tempname.find("$d");
+                if (dpos != tempname.npos)
+                {
+                    tempname.replace(dpos, 2, &dstr[0], 10);
+                }
+            }
+            f_innormative = fopen(tempname.c_str(), "a+b");
+            if (ChatLogUTFHeader && (ftell(f_innormative) == 0)) fputs("\xEF\xBB\xBF", f_innormative);
+        }
+    }
+}
+
+void ChatLog::CloseAllFiles()
+{
+    for (int i = 0; i <= CHATLOG_CHAT_TYPES_COUNT - 1; i++)
+    {
+        if (files[i])
+        {
+            for (int j = i + 1; j <= CHATLOG_CHAT_TYPES_COUNT - 1; j++)
+            {
+                if (files[j] == files[i]) files[j] = NULL;
+            }
+        
+            fclose(files[i]);
+            files[i] = NULL;
+        }
+    }
+
+    if (f_innormative)
+    {
+        fclose(f_innormative);
+        f_innormative = NULL;
+    }
+}
+
+void ChatLog::CheckDateSwitch()
+{
+    if (ChatLogDateSplit)
+    {
+        time_t t = time(NULL);
+        tm* aTm = localtime(&t);
+        if (lastday != aTm->tm_mday)
+        {
+            // date switched
+            CloseAllFiles();
+            OpenAllFiles();
+            WriteInitStamps();
+        }
+    }
+}
+
+void ChatLog::WriteInitStamps()
+{
+    // remember date
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    lastday = aTm->tm_mday;
+
+    if (files[CHAT_LOG_CHAT])
+    {
+        OutTimestamp(files[CHAT_LOG_CHAT]);
+        fprintf(files[CHAT_LOG_CHAT], "%s", "[SYSTEM] Chat Log Initialized\n");
+    }
+    if (files[CHAT_LOG_PARTY])
+    {
+        OutTimestamp(files[CHAT_LOG_PARTY]);
+        fprintf(files[CHAT_LOG_PARTY], "%s", "[SYSTEM] Party Chat Log Initialized\n");
+    }
+    if (files[CHAT_LOG_GUILD])
+    {
+        OutTimestamp(files[CHAT_LOG_GUILD]);
+        fprintf(files[CHAT_LOG_GUILD], "%s", "[SYSTEM] Guild Chat Log Initialized\n");
+    }
+    if (files[CHAT_LOG_WHISPER])
+    {
+        OutTimestamp(files[CHAT_LOG_WHISPER]);
+        fprintf(files[CHAT_LOG_WHISPER], "%s", "[SYSTEM] Whisper Log Initialized\n");
+    }
+    if (files[CHAT_LOG_CHANNEL])
+    {
+        OutTimestamp(files[CHAT_LOG_CHANNEL]);
+        fprintf(files[CHAT_LOG_CHANNEL], "%s", "[SYSTEM] Chat Channels Log Initialized\n");
+    }
+    if (files[CHAT_LOG_RAID])
+    {
+        OutTimestamp(files[CHAT_LOG_RAID]);
+        fprintf(files[CHAT_LOG_RAID], "%s", "[SYSTEM] Raid Party Chat Log Initialized\n");
+    }
+
+    if (f_innormative)
+    {
+        OutTimestamp(f_innormative);
+        fprintf(f_innormative, "%s", "[SYSTEM] Innormative Lexics Log Initialized\n");
+    }
+}
+
+void ChatLog::OutTimestamp(FILE* file)
+{
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    fprintf(file, "%-4d-%02d-%02d %02d:%02d:%02d ", aTm->tm_year + 1900, aTm->tm_mon + 1, aTm->tm_mday, aTm->tm_hour, aTm->tm_min, aTm->tm_sec);
+}
+
+void ChatLog::ChatBadLexicsAction(Player* player, std::string& msg)
+{
+    // logging
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("] ");
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (LexicsCutterScreenLog) printf("<INNORMATIVE!> %s", log_str.c_str());
+    if (f_innormative)
+    {
+        OutTimestamp(f_innormative);
+        fprintf(f_innormative, "%s", log_str.c_str());
+        fflush(f_innormative);
+    }
+
+    // cutting innormative lexics
+    if (LexicsCutterInnormativeCut)
+    {
+        msg = LexicsCutterCutReplacement;
+    }
+
+    if (!player || !player->GetSession()) return;
+
+    if (LexicsCutterNoActionOnGM && player->GetSession()->GetSecurity()) return;
+
+    // special action
+    const SpellEntry* sl;
+
+    switch (LexicsCutterAction)
+    {
+        case LEXICS_ACTION_SHEEP:
+        {
+            // sheep me, yeah, yeah, sheep me
+            sl = sSpellStore.LookupEntry(118);
+            if (sl)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    Aura* Aur = CreateAura(sl, i, NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        case LEXICS_ACTION_STUN:
+        {
+            // stunned surprised
+            sl = sSpellStore.LookupEntry(13005);
+            if (sl)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    Aura* Aur = CreateAura(sl, i, NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        case LEXICS_ACTION_DIE:
+        {
+            // oops, kicked the bucket
+            player->DealDamage(player, player->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }
+        break;
+
+        case LEXICS_ACTION_DRAIN:
+        {
+            // living corpse :)
+            player->DealDamage(player, player->GetHealth() - 5, NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }
+        break;
+
+
+        case LEXICS_ACTION_SILENCE:
+        {
+            // glue the mouth
+            time_t mutetime = time(NULL) + (int) (LexicsCutterActionDuration / 1000);
+            player->GetSession()->m_muteTime = mutetime;
+        }
+        break;
+
+        case LEXICS_ACTION_STUCK:
+        {
+            // yo, the Matrix has had you :) [by KAPATEJIb]
+            sl = sSpellStore.LookupEntry(23312);
+            if (sl)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    Aura* Aur = CreateAura(sl, i, NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        case LEXICS_ACTION_SICKNESS:
+        {
+            // for absence of censorship, there is punishment [by Koshei]
+            sl = sSpellStore.LookupEntry(15007);
+            if (sl)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    Aura* Aur = CreateAura(sl, i, NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        case LEXICS_ACTION_SHEAR:
+        {
+            // Lord Illidan to watch you [by Koshei]
+            sl = sSpellStore.LookupEntry(41032);
+            if (sl)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    Aura* Aur = CreateAura(sl, i, NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        default:
+        // no action except logging
+        break;
+    }
+}
diff --git a/src/game/ChatLog.h b/src/game/ChatLog.h
new file mode 100644
index 0000000..7460b92
--- /dev/null
+++ b/src/game/ChatLog.h
@@ -0,0 +1,107 @@
+/* 
+ * Copyright (C) 2005,2006,2007 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef MANGOSSERVER_CHATLOG_H
+#define MANGOSSERVER_CHATLOG_H
+
+#include "SharedDefines.h"
+#include "ChatLexicsCutter.h"
+#include "ObjectMgr.h"
+#include "Policies/Singleton.h"
+
+#define CHATLOG_CHAT_TYPES_COUNT 7
+
+enum ChatLogFiles
+{
+    CHAT_LOG_CHAT = 0,
+    CHAT_LOG_PARTY = 1,
+    CHAT_LOG_GUILD = 2,
+    CHAT_LOG_WHISPER = 3,
+    CHAT_LOG_CHANNEL = 4,
+    CHAT_LOG_RAID = 5,
+    CHAT_LOG_BATTLEGROUND = 6,
+};
+
+enum LexicsActions
+{
+    LEXICS_ACTION_LOG = 0,
+    LEXICS_ACTION_SHEEP = 1,
+    LEXICS_ACTION_STUN = 2,
+    LEXICS_ACTION_DIE = 3,
+    LEXICS_ACTION_DRAIN = 4,
+    LEXICS_ACTION_SILENCE = 5,
+    LEXICS_ACTION_STUCK = 6,
+    LEXICS_ACTION_SICKNESS = 7,
+    LEXICS_ACTION_SHEAR = 8,
+};
+
+class ChatLog : public MaNGOS::Singleton<ChatLog, MaNGOS::ClassLevelLockable<ChatLog, ZThread::FastMutex> >
+{
+    public:
+        ChatLog();
+        ~ChatLog();
+
+        void Initialize();
+        
+        void ChatMsg(Player *player, std::string &msg, uint32 type);
+        void PartyMsg(Player *player, std::string &msg);
+        void GuildMsg(Player *player, std::string &msg, bool officer);
+        void WhisperMsg(Player *player, std::string &to, std::string &msg);
+        void ChannelMsg(Player *player, std::string &channel, std::string &msg);
+        void RaidMsg(Player *player, std::string &msg, uint32 type);
+        void BattleGroundMsg(Player *player, std::string &msg, uint32 type);
+        
+        void ChatBadLexicsAction(Player *player, std::string &msg);
+        
+    private:
+        bool _ChatCommon(int ChatType, Player *player, std::string &msg);
+
+        bool ChatLogEnable;
+        bool ChatLogDateSplit;
+        bool ChatLogUTFHeader;
+        bool ChatLogIgnoreUnprintable;
+
+        int lastday;
+   
+        FILE* files[CHATLOG_CHAT_TYPES_COUNT];
+        std::string names[CHATLOG_CHAT_TYPES_COUNT];
+        bool screenflag[CHATLOG_CHAT_TYPES_COUNT];
+   
+        LexicsCutter* Lexics;
+        bool cutflag[CHATLOG_CHAT_TYPES_COUNT];
+
+        bool LexicsCutterEnable;
+        bool LexicsCutterInnormativeCut;
+        bool LexicsCutterNoActionOnGM;
+        bool LexicsCutterScreenLog;
+        std::string LexicsCutterCutReplacement;
+        int LexicsCutterAction;
+        int LexicsCutterActionDuration;
+        std::string fn_innormative;
+        FILE* f_innormative;
+
+        void OpenAllFiles();
+        void CloseAllFiles();
+        void CheckDateSwitch();
+
+        void WriteInitStamps();
+        void OutTimestamp(FILE *file);
+};
+
+#define sChatLog MaNGOS::Singleton<ChatLog>::Instance()
+#endif
diff --git a/src/game/GuardAI.cpp b/src/game/GuardAI.cpp
index 5672f14..b07146d 100644
--- a/src/game/GuardAI.cpp
+++ b/src/game/GuardAI.cpp
@@ -50,7 +50,7 @@ void GuardAI::MoveInLineOfSight(Unit *u)
         {
             //Need add code to let guard support player
             AttackStart(u);
-            u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
+            //u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
         }
     }
 }
diff --git a/src/game/Language.h b/src/game/Language.h
index 7dcee62..4aa3437 100644
--- a/src/game/Language.h
+++ b/src/game/Language.h
@@ -21,6 +21,8 @@
 
 enum MangosStrings
 {
+	LANG_AUTO_BROADCAST                 = 2001,
+
     // for chat commands
     LANG_SELECT_CHAR_OR_CREATURE        = 1,
     LANG_SELECT_CREATURE                = 2,
diff --git a/src/game/Level1.cpp b/src/game/Level1.cpp
index 37b8b14..24cd067 100644
--- a/src/game/Level1.cpp
+++ b/src/game/Level1.cpp
@@ -1188,7 +1188,7 @@ bool ChatHandler::HandleModifyScaleCommand(const char* args)
         return false;
 
     float Scale = (float)atof((char*)args);
-    if (Scale > 3.0f || Scale <= 0.0f)
+    if (Scale > 15.0f || Scale <= 0.0f)
     {
         SendSysMessage(LANG_BAD_VALUE);
         SetSentErrorMessage(true);
diff --git a/src/game/Makefile.am b/src/game/Makefile.am
index 03dbeef..7ce54dc 100644
--- a/src/game/Makefile.am
+++ b/src/game/Makefile.am
@@ -73,6 +73,10 @@ libmangosgame_a_SOURCES = \
     Chat.cpp \
     Chat.h \
     ChatHandler.cpp \
+    ChatLexicsCutter.cpp \
+    ChatLexicsCutter.h \
+    ChatLog.cpp \
+    ChatLog.h \
     CombatHandler.cpp \
     ConfusedMovementGenerator.cpp \
     ConfusedMovementGenerator.h \
diff --git a/src/game/PetAI.cpp b/src/game/PetAI.cpp
index 144b2d7..b16877a 100644
--- a/src/game/PetAI.cpp
+++ b/src/game/PetAI.cpp
@@ -55,7 +55,7 @@ void PetAI::MoveInLineOfSight(Unit *u)
             if(i_pet.IsWithinLOSInMap(u))
             {
                 AttackStart(u);
-                u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
+                //u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
             }
         }
     }
diff --git a/src/game/Unit.cpp b/src/game/Unit.cpp
index b64f538..d0aed7f 100644
--- a/src/game/Unit.cpp
+++ b/src/game/Unit.cpp
@@ -437,19 +437,6 @@ bool Unit::HasAuraType(AuraType auraType) const
     return (!m_modAuras[auraType].empty());
 }
 
-/* Called by DealDamage for auras that have a chance to be dispelled on damage taken. */
-void Unit::RemoveSpellbyDamageTaken(AuraType auraType, uint32 damage)
-{
-    if(!HasAuraType(auraType))
-        return;
-
-    // The chance to dispel an aura depends on the damage taken with respect to the casters level.
-    uint32 max_dmg = getLevel() > 8 ? 25 * getLevel() - 150 : 50;
-    float chance = float(damage) / max_dmg * 100.0f;
-    if (roll_chance_f(chance))
-        RemoveSpellsCausingAura(auraType);
-}
-
 uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDamage, DamageEffectType damagetype, SpellSchoolMask damageSchoolMask, SpellEntry const *spellProto, bool durabilityLoss)
 {
     if (!pVictim->isAlive() || pVictim->isInFlight() || pVictim->GetTypeId() == TYPEID_UNIT && ((Creature*)pVictim)->IsInEvadeMode())
@@ -497,11 +484,6 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
         return 0;
     }
 
-    pVictim->RemoveSpellbyDamageTaken(SPELL_AURA_MOD_FEAR, damage);
-    // root type spells do not dispel the root effect
-    if(!spellProto || spellProto->Mechanic != MECHANIC_ROOT)
-        pVictim->RemoveSpellbyDamageTaken(SPELL_AURA_MOD_ROOT, damage);
-
     if(pVictim->GetTypeId() != TYPEID_PLAYER)
     {
         // no xp,health if type 8 /critters/
@@ -853,6 +835,16 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
                     // FIXME: this may cause the auras with proc chance to be rerolled several times
                     next = vAuras.begin();
                 }
+            } 
+            else if ( (se->Attributes & 0x40000000LL) && (!spellProto || se->Id != spellProto->Id) )
+            {
+                uint32 max_dmg = pVictim->getLevel() > 8 ? 25 * pVictim->getLevel() - 150 : 50;
+                float chance = float(damage) / max_dmg * 100.0f;
+                if (roll_chance_f(chance))
+                {
+                    pVictim->RemoveAurasDueToSpell(i->second->GetId());
+                    next = vAuras.begin();
+                }
             }
         }
 
diff --git a/src/game/Unit.h b/src/game/Unit.h
index 5d598fb..42374c5 100644
--- a/src/game/Unit.h
+++ b/src/game/Unit.h
@@ -910,8 +910,6 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
 
         bool isFrozen() const;
 
-        void RemoveSpellbyDamageTaken(AuraType auraType, uint32 damage);
-
         bool isTargetableForAttack() const;
         virtual bool IsInWater() const;
         virtual bool IsUnderWater() const;
diff --git a/src/game/World.cpp b/src/game/World.cpp
index 11b95cf..8278843 100644
--- a/src/game/World.cpp
+++ b/src/game/World.cpp
@@ -58,6 +58,7 @@
 #include "WaypointManager.h"
 #include "GMTicketMgr.h"
 #include "Util.h"
+#include "Language.h"
 
 INSTANTIATE_SINGLETON_1( World );
 
@@ -1160,6 +1161,9 @@ void World::SetInitialWorldSettings()
     WorldDatabase.PExecute("INSERT INTO uptime (startstring, starttime, uptime) VALUES('%s', " I64FMTD ", 0)",
         isoDate, uint64(m_startTime));
 
+	static uint32 abtimer = 0;
+	abtimer = sConfig.GetIntDefault("AutoBroadcast.Timer", 60000);
+	
     m_timers[WUPDATE_OBJECTS].SetInterval(0);
     m_timers[WUPDATE_SESSIONS].SetInterval(0);
     m_timers[WUPDATE_WEATHERS].SetInterval(1000);
@@ -1167,6 +1171,7 @@ void World::SetInitialWorldSettings()
     m_timers[WUPDATE_UPTIME].SetInterval(m_configs[CONFIG_UPTIME_UPDATE]*MINUTE*1000);
                                                             //Update "uptime" table based on configuration entry in minutes.
     m_timers[WUPDATE_CORPSES].SetInterval(20*MINUTE*1000);  //erase corpses every 20 minutes
+	m_timers[WUPDATE_AUTOBROADCAST].SetInterval(abtimer);
 
     //to set mailtimer to return mails every day between 4 and 5 am
     //mailtimer is increased when updating auctions
@@ -1404,6 +1409,17 @@ void World::Update(time_t diff)
         m_timers[WUPDATE_EVENTS].Reset();
     }
 
+	static uint32 autobroadcaston = 0;
+	autobroadcaston = sConfig.GetIntDefault("AutoBroadcast.On", 0);
+	if(autobroadcaston == 1)
+	{
+		if (m_timers[WUPDATE_AUTOBROADCAST].Passed())
+		{
+			m_timers[WUPDATE_AUTOBROADCAST].Reset();
+			SendRNDBroadcast();
+		}
+	}
+	
     /// </ul>
     ///- Move all creatures with "delayed move" and remove and delete all objects with "delayed remove"
     MapManager::Instance().DoDelayedMovesAndRemoves();
@@ -2467,6 +2483,45 @@ void World::ProcessCliCommands()
     zprint("mangos>");
 }
 
+void World::SendRNDBroadcast()
+{
+	std::string msg;
+	QueryResult *result = WorldDatabase.PQuery("SELECT `text` FROM `autobroadcast` ORDER BY RAND() LIMIT 1");
+	
+	if(!result)
+		return;
+	
+	msg = result->Fetch()[0].GetString();
+	delete result;
+
+	static uint32 abcenter = 0;
+    abcenter = sConfig.GetIntDefault("AutoBroadcast.Center", 0);
+    if(abcenter == 0)
+    {
+		sWorld.SendWorldText(LANG_AUTO_BROADCAST, msg.c_str());
+
+		sLog.outString("AutoBroadcast: '%s'",msg.c_str());
+	}
+	if(abcenter == 1)
+	{
+		WorldPacket data(SMSG_NOTIFICATION, (msg.size()+1));
+		data << msg;
+		sWorld.SendGlobalMessage(&data);
+
+		sLog.outString("AutoBroadcast: '%s'",msg.c_str());
+	}
+	if(abcenter == 2)
+	{
+		sWorld.SendWorldText(LANG_AUTO_BROADCAST, msg.c_str());
+
+		WorldPacket data(SMSG_NOTIFICATION, (msg.size()+1));
+		data << msg;
+		sWorld.SendGlobalMessage(&data);
+
+		sLog.outString("AutoBroadcast: '%s'",msg.c_str());
+	}
+}
+
 void World::InitResultQueue()
 {
     m_resultQueue = new SqlResultQueue;
diff --git a/src/game/World.h b/src/game/World.h
index 108b1bb..d101500 100644
--- a/src/game/World.h
+++ b/src/game/World.h
@@ -59,7 +59,8 @@ enum WorldTimers
     WUPDATE_UPTIME      = 4,
     WUPDATE_CORPSES     = 5,
     WUPDATE_EVENTS      = 6,
-    WUPDATE_COUNT       = 7
+    WUPDATE_AUTOBROADCAST = 7,
+	WUPDATE_COUNT 		= 8
 };
 
 /// Configuration elements
@@ -318,6 +319,7 @@ class World
 
         WorldSession* FindSession(uint32 id) const;
         void AddSession(WorldSession *s);
+		void SendRNDBroadcast();
         bool RemoveSession(uint32 id);
         /// Get the number of current active sessions
         void UpdateMaxSessionCounters();
diff --git a/src/mangosd/mangosd.conf.dist.in b/src/mangosd/mangosd.conf.dist.in
index 4c69f2d..d53c894 100644
--- a/src/mangosd/mangosd.conf.dist.in
+++ b/src/mangosd/mangosd.conf.dist.in
@@ -294,6 +294,78 @@ GmLogTimestamp = 0
 RaLogFile = ""
 LogColors = ""
 
+# Chat log parameters
+ChatLogEnable = 0
+
+# If this is enabled, all $d in file names are replaced with current date
+# This does include innormative lexics log
+ChatLogDateSplit = 1
+
+# If this is enabled, UTF8 header is written into new files
+ChatLogUTFHeader = 1
+
+# If this is enabled, chat log will ignore messages with unprintable chars
+ChatLogIgnoreUnprintable = 1
+
+# Chat log files
+ChatLogChatFile = main_chat-$d.log
+ChatLogPartyFile = party_chat-$d.log
+ChatLogGuildFile = guild_chat-$d.log
+ChatLogWhisperFile = whisper_chat-$d.log
+ChatLogChannelFile = channel_chat-$d.log
+ChatLogRaidFile = raid_chat-$d.log
+ChatLogBattleGroundFile = bg_chat-$d.log
+
+# Chat log screen logging
+ChatLogChatScreen = 0
+ChatLogPartyScreen = 0
+ChatLogGuildScreen = 0
+ChatLogWhisperScreen = 0
+ChatLogChannelScreen = 0
+ChatLogRaidScreen = 0
+ChatLogBattleGroundScreen = 0
+
+# Lexics cutter parameters
+LexicsCutterEnable = 1
+
+LexicsCutterInnormativeCut = 1
+LexicsCutterCutReplacement = &!@^%!^&*!!!
+LexicsCutterLogFile = innormative-$d.log
+LexicsCutterScreenLog = 0
+LexicsCutterAnalogsFile = letter_analogs.txt
+LexicsCutterWordsFile = innormative_words.txt
+
+# Where to cut lexics
+LexicsCutInChat = 1
+LexicsCutInParty = 1
+LexicsCutInGuild = 1
+LexicsCutInWhisper = 1
+LexicsCutInChannel = 1
+LexicsCutInRaid = 1
+LexicsCutInBattleGround = 1
+
+# Ignore word spaces like: W O R D
+LexicsCutterIgnoreSpaces = 1
+
+# Ignore repeats like: WWOOOORRRRRD
+LexicsCutterIgnoreRepeats = 1
+
+# --- Action:
+# ---   0: log only
+# ---   1: sheep
+# ---   2: stun
+# ---   3: kill
+# ---   4: leave 5 health
+# ---   5: disable chat
+# ---   6: stuck (works as stun + 50% health) [by KAPATEJIb]
+# ---   7: resurrection sickness [by Koshei]
+# ---   8: shear [by Koshei]
+LexicsCutterAction = 0
+LexicsCutterActionDuration = 60000
+
+# Do not perform action on GM if this is enabled
+LexicsCutterNoActionOnGM = 1
+
 ###################################################################################################################
 # SERVER SETTINGS
 #
@@ -1079,3 +1151,26 @@ Ra.IP = 0.0.0.0
 Ra.Port = 3443
 Ra.MinLevel = 3
 Ra.Secure = 1
+
+###################################################################################################################
+# AUTO BROADCAST
+#
+#    AutoBroadcast.On
+#        Enable auto broadcast
+#        Default: 0 - off
+#                 1 - on
+#
+#    AutoBroadcast.Center
+#        Display method
+#        Default: 0 - announce
+#                 1 - notify
+#                 2 - both
+#
+#    AutoBroadcast.Timer
+#        Timer for auto broadcast
+#
+###################################################################################################################
+
+AutoBroadcast.On = 0
+AutoBroadcast.Center = 0
+AutoBroadcast.Timer = 60000
diff --git a/win/VC71/game.vcproj b/win/VC71/game.vcproj
index d131d0f..1560e49 100644
--- a/win/VC71/game.vcproj
+++ b/win/VC71/game.vcproj
@@ -240,6 +240,18 @@
 			<File
 				RelativePath="..\..\src\game\ChatHandler.cpp">
 			</File>
+            <File
+                RelativePath="..\..\src\game\ChatLexicsCutter.cpp">
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLexicsCutter.h">
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLog.cpp">
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLog.h">
+            </File>
 			<File
 				RelativePath="..\..\src\game\CombatHandler.cpp">
 			</File>
diff --git a/win/VC80/game.vcproj b/win/VC80/game.vcproj
index 80aa58b..e54493e 100644
--- a/win/VC80/game.vcproj
+++ b/win/VC80/game.vcproj
@@ -494,6 +494,22 @@
 				RelativePath="..\..\src\game\ChatHandler.cpp"
 				>
 			</File>
+            <File
+                RelativePath="..\..\src\game\ChatLexicsCutter.cpp"
+                >
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLexicsCutter.h"
+                >
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLog.cpp"
+                >
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLog.h"
+                >
+            </File>
 			<File
 				RelativePath="..\..\src\game\CombatHandler.cpp"
 				>
diff --git a/win/VC90/game.vcproj b/win/VC90/game.vcproj
index 19b0ae4..232c013 100644
--- a/win/VC90/game.vcproj
+++ b/win/VC90/game.vcproj
@@ -496,6 +496,22 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\game\ChatLexicsCutter.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\ChatLexicsCutter.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\ChatLog.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\ChatLog.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\CombatHandler.cpp"
 				>
 			</File>
