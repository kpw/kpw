diff --git a/src/game/AggressorAI.cpp b/src/game/AggressorAI.cpp
index 637410c..9be41e5 100644
--- a/src/game/AggressorAI.cpp
+++ b/src/game/AggressorAI.cpp
@@ -55,7 +55,7 @@ AggressorAI::MoveInLineOfSight(Unit *u)
         if(i_creature.IsWithinDistInMap(u, attackRadius) && i_creature.IsWithinLOSInMap(u) )
         {
             AttackStart(u);
-            u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
+            //u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
         }
     }
 }
diff --git a/src/game/AuctionHouseBot.cpp b/src/game/AuctionHouseBot.cpp
new file mode 100644
index 0000000..304ea5f
--- /dev/null
+++ b/src/game/AuctionHouseBot.cpp
@@ -0,0 +1,697 @@
+#include "AuctionHouseBot.h"
+#include "Bag.h"
+#include "Config/ConfigEnv.h"
+#include "Database/DatabaseEnv.h"
+#include "Item.h"
+#include "Log.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+#include "World.h"
+#include "WorldSession.h"
+#include <vector>
+
+using namespace std;
+
+//#define NO_VENDOR_ITEMS
+#define ONLY_LOOT_ITEMS
+
+static vector<uint32> whiteTradeGoods;
+static vector<uint32> greenTradeGoods;
+static vector<uint32> blueTradeGoods;
+static vector<uint32> purpleTradeGoods;
+static vector<uint32> whiteItems;
+static vector<uint32> greenItems;
+static vector<uint32> blueItems;
+static vector<uint32> purpleItems;
+
+static uint32 AHBplayerAccount = 0; 
+static uint32 AHBplayerGUID = 0; 
+static uint32 noMail = 0; 
+static uint32 numAllianceItems = 0;
+static uint32 numMinAllianceItems = 0;
+static uint32 numHordeItems = 0;
+static uint32 numMinHordeItems = 0;
+static uint32 numNeutralItems = 0;
+static uint32 numMinNeutralItems = 0;
+static uint32 minTime = 0;
+static uint32 maxTime = 0;
+static uint32 percentWhiteTradeGoods = 0;
+static uint32 percentGreenTradeGoods = 0;
+static uint32 percentBlueTradeGoods = 0;
+static uint32 percentPurpleTradeGoods = 0;
+static uint32 percentWhiteItems = 0;
+static uint32 percentGreenItems = 0;
+static uint32 percentBlueItems = 0;
+static uint32 percentPurpleItems = 0;
+static uint32 minPriceWhite = 0;
+static uint32 maxPriceWhite = 0;
+static uint32 bidPriceWhite = 0;
+static uint32 maxStackWhite = 0;
+static uint32 minPriceGreen = 0;
+static uint32 maxPriceGreen = 0;
+static uint32 bidPriceGreen = 0;
+static uint32 maxStackGreen = 0;
+static uint32 minPriceBlue = 0;
+static uint32 maxPriceBlue = 0;
+static uint32 bidPriceBlue = 0;
+static uint32 maxStackBlue = 0;
+static uint32 minPricePurple = 0;
+static uint32 maxPricePurple = 0;
+static uint32 bidPricePurple = 0;
+static uint32 maxStackPurple = 0;
+
+///////////////////////////////////////////////////////////////////////////////
+//
+///////////////////////////////////////////////////////////////////////////////
+uint32 AuctionHouseBotNoMail()
+{
+   return noMail != 0 ? AHBplayerGUID : 0;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+///////////////////////////////////////////////////////////////////////////////
+static inline uint32 minValue(uint32 a, uint32 b)
+{
+   return a <= b ? a : b;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+///////////////////////////////////////////////////////////////////////////////
+static void deleteOldAuctions(uint32 ahMapID)
+{
+   AuctionHouseObject* auctionHouse = objmgr.GetAuctionsMap(ahMapID);
+
+   AuctionHouseObject::AuctionEntryMap::iterator itr;
+   itr = auctionHouse->GetAuctionsBegin();
+
+   while (itr != auctionHouse->GetAuctionsEnd())
+   {
+      AuctionHouseObject::AuctionEntryMap::iterator tmp = itr;
+      ++itr;
+
+      if (tmp->second->owner != AHBplayerGUID)
+         continue;
+
+      if (tmp->second->bidder != 0)
+         continue;
+
+      if (tmp->second->time > sWorld.GetGameTime())
+         continue;
+
+      // quietly delete the item and auction...
+
+      Item* item = objmgr.GetAItem(tmp->second->item_guidlow);
+      if (item != NULL)
+      {
+         objmgr.RemoveAItem(tmp->second->item_guidlow);
+         item->DeleteFromDB();
+         delete item;
+      }
+      else
+      {
+         sLog.outString("AuctionHouseBot: "
+                        "clearing auction for non-existant item_guidlow (%d)",
+                        tmp->second->item_guidlow);
+      }
+
+	CharacterDatabase.PExecute("DELETE FROM `auctionhouse` WHERE `id` = '%u'",
+                                 tmp->second->Id);
+       AuctionEntry* auctionEntry = tmp->second;
+       auctionHouse->RemoveAuction(auctionEntry->Id);
+       delete auctionEntry;
+   }
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+///////////////////////////////////////////////////////////////////////////////
+static void addNewAuctions(uint32 ahMapID, uint32 maxAuctions, uint32 minAuctions, Player *AHBplayer)
+{
+   AuctionHouseObject* auctionHouse = objmgr.GetAuctionsMap(ahMapID);
+
+   if (auctionHouse->Getcount() > minAuctions)
+      return;
+
+   uint32 whiteTradeGoodsBin = percentWhiteTradeGoods;
+   uint32 greenTradeGoodsBin = percentGreenTradeGoods + whiteTradeGoodsBin;
+   uint32 blueTradeGoodsBin = percentBlueTradeGoods + greenTradeGoodsBin;
+   uint32 purpleTradeGoodsBin = percentPurpleTradeGoods + blueTradeGoodsBin;
+   uint32 whiteItemBin = percentWhiteItems + purpleTradeGoodsBin;
+   uint32 greenItemBin = percentGreenItems + whiteItemBin;
+   uint32 blueItemBin = percentBlueItems + greenItemBin;
+   uint32 purpleItemBin = percentPurpleItems + blueItemBin;
+
+   // only insert 100 at a time, so as not to peg the processor
+   for (uint32 count = 0; 
+        (count < 100) && (auctionHouse->Getcount() < maxAuctions); 
+        count++)
+   {
+      uint32 itemID = purpleItems[urand(0, purpleItems.size() - 1)];
+      uint32 value = urand(1, 100);
+      
+      if (value <= blueItemBin)
+         itemID = blueItems[urand(0, blueItems.size() - 1)];
+
+      if (value <= greenItemBin)
+         itemID = greenItems[urand(0, greenItems.size() - 1)];
+
+      if (value <= whiteItemBin)
+         itemID = whiteItems[urand(0, whiteItems.size() - 1)];
+
+      if (value <= purpleTradeGoodsBin)
+         itemID = purpleTradeGoods[urand(0, purpleTradeGoods.size() - 1)];
+
+      if (value <= blueTradeGoodsBin)
+         itemID = blueTradeGoods[urand(0, blueTradeGoods.size() - 1)];
+
+      if (value <= greenTradeGoodsBin)
+         itemID = greenTradeGoods[urand(0, greenTradeGoods.size() - 1)];
+
+      if (value <= whiteTradeGoodsBin)
+         itemID = whiteTradeGoods[urand(0, whiteTradeGoods.size() - 1)];
+
+      ItemPrototype const* prototype = objmgr.GetItemPrototype(itemID);
+      if (prototype == NULL)
+      {
+         sLog.outString("AuctionHouseBot: Huh?!?! prototype == NULL");
+         continue;
+      }
+
+      Item* item = Item::CreateItem(itemID, 1, AHBplayer);
+	  item->AddToUpdateQueueOf(AHBplayer);
+      if (item == NULL)
+      {
+         sLog.outString("AuctionHouseBot: Item::CreateItem() returned NULL");
+         break;
+      }
+
+      uint32 randomPropertyId = Item::GenerateItemRandomPropertyId(itemID);
+      if (randomPropertyId != 0)
+         item->SetItemRandomProperties(randomPropertyId);
+
+      uint32 buyoutPrice = prototype->BuyPrice * item->GetCount();
+      uint32 bidPrice = 0;
+      uint32 stackCount = urand(1, item->GetMaxStackCount());
+
+      switch (prototype->Quality)
+      {
+         case 1:
+            if (maxStackWhite != 0)
+            {
+               stackCount = urand(1, minValue(item->GetMaxStackCount(), 
+                                              maxStackWhite));
+            }
+
+            buyoutPrice *= urand(minPriceWhite, maxPriceWhite) * stackCount;
+            buyoutPrice /= 100;
+            bidPrice = buyoutPrice * bidPriceWhite;
+            bidPrice /= 100;
+
+            break;
+
+         case 2:
+            if (maxStackGreen != 0)
+            {
+               stackCount = urand(1, minValue(item->GetMaxStackCount(), 
+                                              maxStackGreen));
+            }
+
+            buyoutPrice *= urand(minPriceGreen, maxPriceGreen) * stackCount;
+            buyoutPrice /= 100;
+            bidPrice = buyoutPrice * bidPriceGreen;
+            bidPrice /= 100;
+
+            break;
+
+         case 3:
+            if (maxStackBlue != 0)
+            {
+               stackCount = urand(1, minValue(item->GetMaxStackCount(), 
+                                              maxStackBlue));
+            }
+
+            buyoutPrice *= urand(minPriceBlue, maxPriceBlue) * stackCount;
+            buyoutPrice /= 100;
+            bidPrice = buyoutPrice * bidPriceBlue;
+            bidPrice /= 100;
+
+            break;
+
+         case 4:
+            if (maxStackPurple != 0)
+            {
+               stackCount = urand(1, minValue(item->GetMaxStackCount(), 
+                                              maxStackPurple));
+            }
+
+            buyoutPrice *= urand(minPricePurple, maxPricePurple) * stackCount;
+            buyoutPrice /= 100;
+            bidPrice = buyoutPrice * bidPricePurple;
+            bidPrice /= 100;
+
+            break;
+      }
+
+      item->SetCount(stackCount);
+
+      AuctionEntry* auctionEntry = new AuctionEntry;
+      auctionEntry->Id = objmgr.GenerateAuctionID();
+      auctionEntry->auctioneer = 0;
+      auctionEntry->item_guidlow = item->GetGUIDLow();
+      auctionEntry->item_template = item->GetEntry();
+      auctionEntry->owner = AHBplayer->GetGUIDLow();
+      auctionEntry->startbid = bidPrice;
+      auctionEntry->buyout = buyoutPrice;
+      auctionEntry->bidder = 0;
+      auctionEntry->bid = 0;
+      auctionEntry->deposit = 0;
+      auctionEntry->location = ahMapID;
+      auctionEntry->time = (time_t) (urand(minTime, maxTime) * 60 * 60 + 
+                                     time(NULL));
+      
+      item->SaveToDB();
+      item->RemoveFromUpdateQueueOf(AHBplayer);
+      objmgr.AddAItem(item);
+      auctionHouse->AddAuction(auctionEntry);
+
+      CharacterDatabase.PExecute("INSERT INTO `auctionhouse` (`id`,"
+                                 "`auctioneerguid`,`itemguid`,`item_template`,"
+                                 "`itemowner`,`buyoutprice`,`time`,`buyguid`,"
+                                 "`lastbid`,`startbid`,`deposit`,`location`) "
+                                 "VALUES ('%u', '%u', '%u', '%u', '%u', '%u', "
+                                 "'" I64FMTD "', '%u', '%u', '%u', '%u', '%u')",
+                                 auctionEntry->Id, 
+                                 auctionEntry->auctioneer,
+                                 auctionEntry->item_guidlow, 
+                                 auctionEntry->item_template, 
+                                 auctionEntry->owner, 
+                                 auctionEntry->buyout, 
+                                 (uint64) auctionEntry->time, 
+                                 auctionEntry->bidder, 
+                                 auctionEntry->bid, 
+                                 auctionEntry->startbid, 
+                                 auctionEntry->deposit, 
+                                 auctionEntry->location);
+   }
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+///////////////////////////////////////////////////////////////////////////////
+void AuctionHouseBot()
+{
+   if ((AHBplayerAccount == 0) || (AHBplayerGUID == 0))
+      return;
+
+   WorldSession _session(AHBplayerAccount, NULL, 0, true, 0, LOCALE_enUS);
+   Player _AHBplayer(&_session);
+   _AHBplayer.MinimalLoadFromDB(NULL, AHBplayerGUID);
+   ObjectAccessor::Instance().AddObject(&_AHBplayer);
+
+   deleteOldAuctions(2);
+   deleteOldAuctions(6);
+   deleteOldAuctions(7);
+
+   addNewAuctions(2, numAllianceItems, numMinAllianceItems, &_AHBplayer);
+   addNewAuctions(6, numHordeItems, numMinHordeItems, &_AHBplayer);
+   addNewAuctions(7, numNeutralItems, numMinNeutralItems, &_AHBplayer);
+   
+   ObjectAccessor::Instance().RemoveObject(&_AHBplayer);
+}
+///////////////////////////////////////////////////////////////////////////////
+//
+///////////////////////////////////////////////////////////////////////////////
+void AuctionHouseBotInit()
+{
+   AHBplayerAccount = sConfig.GetIntDefault("AuctionHouseBot.Account", 0);
+   AHBplayerGUID = sConfig.GetIntDefault("AuctionHouseBot.GUID", 0);
+                         
+   if ((AHBplayerAccount == 0) || (AHBplayerGUID == 0))
+   {
+      sLog.outString("AuctionHouseBot disabled");
+      return;            
+   }
+
+   noMail = sConfig.GetIntDefault("AuctionHouseBot.NoMail", 0);
+
+   numAllianceItems = sConfig.GetIntDefault("AuctionHouseBot.AllianceItems", 0);
+   numMinAllianceItems = sConfig.GetIntDefault("AuctionHouseBot.MinAllianceItems", -1);
+   numHordeItems = sConfig.GetIntDefault("AuctionHouseBot.HordeItems", 0);
+   numMinHordeItems = sConfig.GetIntDefault("AuctionHouseBot.MinHordeItems", -1);
+   numNeutralItems = sConfig.GetIntDefault("AuctionHouseBot.NeutralItems", 0);
+   numMinNeutralItems = sConfig.GetIntDefault("AuctionHouseBot.MinNeutralItems", -1);
+
+   if (numMinAllianceItems < 0)
+	   numMinAllianceItems = numAllianceItems;
+
+   if (numMinHordeItems  < 0)
+	   numMinHordeItems = numHordeItems;
+
+   if (numMinNeutralItems  < 0)
+	   numMinNeutralItems = numNeutralItems;
+
+   if (numMinAllianceItems > numAllianceItems)
+	   numMinAllianceItems = numAllianceItems;
+
+   if (numMinHordeItems > numHordeItems)
+	   numMinHordeItems = numHordeItems;
+
+   if (numMinNeutralItems > numNeutralItems)
+	   numMinNeutralItems = numNeutralItems;
+
+   minTime = sConfig.GetIntDefault("AuctionHouseBot.MinTime", 8);
+   maxTime = sConfig.GetIntDefault("AuctionHouseBot.MaxTime", 24);
+
+   if (minTime < 1)
+      minTime = 1;
+
+   if (maxTime > 24)
+      maxTime = 24;
+
+   if (minTime > maxTime)
+      minTime = maxTime;
+
+   percentWhiteTradeGoods = sConfig.GetIntDefault("AuctionHouseBot."
+                                                  "PercentWhiteTradeGoods",
+                                                  27);
+   percentGreenTradeGoods = sConfig.GetIntDefault("AuctionHouseBot."
+                                                  "PercentGreenTradeGoods",
+                                                  12);
+   percentBlueTradeGoods = sConfig.GetIntDefault("AuctionHouseBot."
+                                                  "PercentBlueTradeGoods",
+                                                  10);
+   percentPurpleTradeGoods = sConfig.GetIntDefault("AuctionHouseBot."
+                                                  "PercentPurpleTradeGoods",
+                                                  1);
+   percentWhiteItems = sConfig.GetIntDefault("AuctionHouseBot."
+                                             "PercentWhiteItems",
+                                             10);
+   percentGreenItems = sConfig.GetIntDefault("AuctionHouseBot."
+                                             "PercentGreenItems",
+                                             30);
+   percentBlueItems = sConfig.GetIntDefault("AuctionHouseBot."
+                                            "PercentBlueItems",
+                                            8);
+   percentPurpleItems = sConfig.GetIntDefault("AuctionHouseBot."
+                                              "PercentPurpleItems",
+                                              2);
+
+   uint32 totalPercent = percentWhiteTradeGoods + percentGreenTradeGoods +
+                         percentBlueTradeGoods + percentPurpleTradeGoods +
+                         percentWhiteItems + percentGreenItems + 
+                         percentBlueItems + percentPurpleItems;
+
+   if (totalPercent == 0)
+   {
+      numAllianceItems = 0;
+      numHordeItems = 0;
+      numNeutralItems = 0;
+   }
+   else if (totalPercent != 100)
+   {
+      double scale = (double) 100 / (double) totalPercent;
+
+      percentPurpleItems = (uint32) (scale * (double) percentPurpleItems);
+      percentBlueItems = (uint32) (scale * (double) percentBlueItems);
+      percentGreenItems = (uint32) (scale * (double) percentGreenItems);
+      percentWhiteItems = (uint32) (scale * (double) percentWhiteItems);
+      percentPurpleTradeGoods = (uint32) (scale * 
+                                          (double) percentPurpleTradeGoods);
+      percentBlueTradeGoods = (uint32) (scale * 
+                                        (double) percentBlueTradeGoods);
+      percentGreenTradeGoods = (uint32) (scale * 
+                                         (double) percentGreenTradeGoods);
+      percentWhiteTradeGoods = 100 - 
+                               percentGreenTradeGoods - 
+                               percentBlueTradeGoods -
+                               percentPurpleTradeGoods -
+                               percentWhiteItems -
+                               percentGreenItems -
+                               percentBlueItems -
+                               percentPurpleItems;
+
+      sLog.outString("AuctionHouseBot:");
+      sLog.outString("sum of item percentages not equal to 100, adjusting...");
+      sLog.outString("AuctionHouseBot.PercentWhiteTradeGoods = %d",
+                     percentWhiteTradeGoods);
+      sLog.outString("AuctionHouseBot.PercentGreenTradeGoods = %d",
+                     percentGreenTradeGoods);
+      sLog.outString("AuctionHouseBot.PercentBlueTradeGoods = %d",
+                     percentBlueTradeGoods);
+      sLog.outString("AuctionHouseBot.PercentPurpleTradeGoods = %d",
+                     percentPurpleTradeGoods);
+      sLog.outString("AuctionHouseBot.PercentWhiteItems = %d",
+                     percentWhiteItems);
+      sLog.outString("AuctionHouseBot.PercentGreenItems = %d",
+                     percentGreenItems);
+      sLog.outString("AuctionHouseBot.PercentBlueItems = %d",
+                     percentBlueItems);
+      sLog.outString("AuctionHouseBot.PercentPurpleItems = %d",
+                     percentPurpleItems);
+   }
+
+   minPriceWhite = sConfig.GetIntDefault("AuctionHouseBot.MinPriceWhite",
+                                         150);
+   maxPriceWhite = sConfig.GetIntDefault("AuctionHouseBot.MaxPriceWhite",
+                                         250);
+
+   if (minPriceWhite == 0)
+      minPriceWhite = 1;
+
+   if (maxPriceWhite == 0)
+      maxPriceWhite = 1;
+
+   if (minPriceWhite > maxPriceWhite)
+      minPriceWhite = maxPriceWhite;
+
+   bidPriceWhite = sConfig.GetIntDefault("AuctionHouseBot.BidPriceWhite",
+                                         100);
+   if (bidPriceWhite > 100)
+      bidPriceWhite = 100;
+
+   maxStackWhite = sConfig.GetIntDefault("AuctionHouseBot.MaxStackWhite", 0);
+
+   minPriceGreen = sConfig.GetIntDefault("AuctionHouseBot.MinPriceGreen",
+                                         200);
+   maxPriceGreen = sConfig.GetIntDefault("AuctionHouseBot.MaxPriceGreen",
+                                         300);
+
+   if (minPriceGreen == 0)
+      minPriceGreen = 1;
+
+   if (maxPriceGreen == 0)
+      maxPriceGreen = 1;
+
+   if (minPriceGreen > maxPriceGreen)
+      minPriceGreen = maxPriceGreen;
+
+   bidPriceGreen = sConfig.GetIntDefault("AuctionHouseBot.BidPriceGreen",
+                                         100);
+   if (bidPriceGreen > 100)
+      bidPriceGreen = 100;
+
+   maxStackGreen = sConfig.GetIntDefault("AuctionHouseBot.MaxStackGreen", 0);
+
+   minPriceBlue = sConfig.GetIntDefault("AuctionHouseBot.MinPriceBlue",
+                                        250);
+   maxPriceBlue = sConfig.GetIntDefault("AuctionHouseBot.MaxPriceBlue",
+                                        350);
+
+   if (minPriceBlue == 0)
+      minPriceBlue = 1;
+
+   if (maxPriceBlue == 0)
+      maxPriceBlue = 1;
+
+   if (minPriceBlue > maxPriceBlue)
+      minPriceBlue = maxPriceBlue;
+
+   bidPriceBlue = sConfig.GetIntDefault("AuctionHouseBot.BidPriceBlue",
+                                        100);
+   if (bidPriceBlue > 100)
+      bidPriceBlue = 100;
+
+   maxStackBlue = sConfig.GetIntDefault("AuctionHouseBot.MaxStackBlue", 0);
+
+   minPricePurple = sConfig.GetIntDefault("AuctionHouseBot.MinPricePurple",
+                                          300);
+   maxPricePurple = sConfig.GetIntDefault("AuctionHouseBot.MaxPricePurple",
+                                          450);
+
+   if (minPricePurple == 0)
+      minPricePurple = 1;
+
+   if (maxPricePurple == 0)
+      maxPricePurple = 1;
+
+   if (minPricePurple > maxPricePurple)
+      minPricePurple = maxPricePurple;
+
+   bidPricePurple = sConfig.GetIntDefault("AuctionHouseBot.BidPricePurple",
+                                          100);
+   if (bidPricePurple > 100)
+      bidPricePurple = 100;
+
+   maxStackPurple = sConfig.GetIntDefault("AuctionHouseBot.MaxStackPurple", 0);
+
+   QueryResult* results = (QueryResult*) NULL;
+
+#ifdef NO_VENDOR_ITEMS
+   vector<uint32> npcItems;
+
+   char npcQuery[] = "SELECT `item` FROM `npc_vendor`";
+
+   results = WorldDatabase.PQuery(npcQuery);
+   if (results != NULL)
+   {
+      do
+      {
+         Field* fields = results->Fetch();
+         npcItems.push_back(fields[0].GetUInt32());
+
+      } while (results->NextRow());
+
+      delete results;
+   }
+   else
+   {
+      sLog.outString("AuctionHouseBot: \"%s\" failed", npcQuery);
+   }
+#endif
+
+#ifdef ONLY_LOOT_ITEMS
+   vector<uint32> lootItems;
+
+   char lootQuery[] = "SELECT `item` FROM `creature_loot_template` UNION "
+                      "SELECT `item` FROM `disenchant_loot_template` UNION "
+                      "SELECT `item` FROM `fishing_loot_template` UNION "
+                      "SELECT `item` FROM `gameobject_loot_template` UNION "
+                      "SELECT `item` FROM `item_loot_template` UNION "
+                      "SELECT `item` FROM `pickpocketing_loot_template` UNION "
+                      "SELECT `item` FROM `prospecting_loot_template` UNION "
+                      "SELECT `item` FROM `skinning_loot_template`";
+
+   results = WorldDatabase.PQuery(lootQuery);
+   if (results != NULL)
+   {
+      do
+      {
+         Field* fields = results->Fetch();
+         lootItems.push_back(fields[0].GetUInt32());
+   
+      } while (results->NextRow());
+   
+      delete results;
+   }
+   else
+   {
+      sLog.outString("AuctionHouseBot: \"%s\" failed", lootQuery);
+   }
+#endif
+
+   for (uint32 itemID = 0; itemID < sItemStorage.MaxEntry; itemID++)
+   {
+      ItemPrototype const* prototype = objmgr.GetItemPrototype(itemID);
+
+      if (prototype == NULL)
+         continue;
+
+      if ((prototype->Bonding != NO_BIND) &&
+          (prototype->Bonding != BIND_WHEN_EQUIPED))
+      {
+         continue;
+      }
+
+      if (prototype->BuyPrice == 0)
+         continue;
+         
+      if ((prototype->Quality < 1) || (prototype->Quality > 4))
+         continue;
+
+#ifdef NO_VENDOR_ITEMS
+      bool isVendorItem = false;
+
+      for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorItem); i++)
+      {         
+         if (itemID == npcItems[i])
+            isVendorItem = true;
+      }
+
+      if (isVendorItem)
+         continue;
+#endif
+
+#ifdef ONLY_LOOT_ITEMS
+      bool isLootItem = false;
+
+      for (unsigned int i = 0; (i < lootItems.size()) && (!isLootItem); i++)
+      {         
+         if (itemID == lootItems[i])
+            isLootItem = true;
+      }
+      
+      if (!isLootItem)
+         continue;
+#endif
+
+      switch (prototype->Quality)
+      {
+         case 1:
+            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+               whiteTradeGoods.push_back(itemID);
+            else
+               whiteItems.push_back(itemID);
+            break;
+   
+         case 2:
+            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+               greenTradeGoods.push_back(itemID);
+            else
+               greenItems.push_back(itemID);
+            break;
+   
+         case 3:
+            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+               blueTradeGoods.push_back(itemID);
+            else
+               blueItems.push_back(itemID);
+            break;
+   
+         case 4:
+            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+               purpleTradeGoods.push_back(itemID);
+            else
+               purpleItems.push_back(itemID);
+            break;
+      }
+   }
+   
+   if ((whiteTradeGoods.size() == 0) ||
+       (greenTradeGoods.size() == 0) ||
+       (blueTradeGoods.size() == 0) ||
+       (purpleTradeGoods.size() == 0) ||
+       (whiteItems.size() == 0) ||
+       (greenItems.size() == 0) ||
+       (blueItems.size() == 0) ||
+       (purpleItems.size() == 0))
+   {
+      sLog.outString("AuctionHouseBot: not loaded DB error?");
+      AHBplayerAccount = 0;
+      AHBplayerGUID = 0;
+      return;
+   }
+  
+   sLog.outString("AuctionHouseBot:");
+   sLog.outString("loaded %d white trade goods", whiteTradeGoods.size());
+   sLog.outString("loaded %d green trade goods", greenTradeGoods.size());
+   sLog.outString("loaded %d blue trade goods", blueTradeGoods.size());
+   sLog.outString("loaded %d purple trade goods", purpleTradeGoods.size());
+   sLog.outString("loaded %d white items", whiteItems.size());
+   sLog.outString("loaded %d green items", greenItems.size());
+   sLog.outString("loaded %d blue items", blueItems.size());
+   sLog.outString("loaded %d purple items", purpleItems.size());
+   sLog.outString("AuctionHouseBot v5.8.6691 by |Paradox| (original by ChrisK)  has been loaded.");
+
+}
diff --git a/src/game/AuctionHouseBot.h b/src/game/AuctionHouseBot.h
new file mode 100644
index 0000000..04815b7
--- /dev/null
+++ b/src/game/AuctionHouseBot.h
@@ -0,0 +1,10 @@
+#ifndef AUCTION_HOUSE_BOT_H
+#define AUCTION_HOUSE_BOT_H
+
+#include "Common.h"
+
+uint32 AuctionHouseBotNoMail();
+void AuctionHouseBot();
+void AuctionHouseBotInit();
+
+#endif
diff --git a/src/game/Chat.cpp b/src/game/Chat.cpp
index 1f2bcdd..8e97290 100644
--- a/src/game/Chat.cpp
+++ b/src/game/Chat.cpp
@@ -484,6 +484,8 @@ ChatCommand * ChatHandler::getCommandTable()
         { "gps",            SEC_MODERATOR,      false, &ChatHandler::HandleGPSCommand,                 "", NULL },
         { "guid",           SEC_GAMEMASTER,     false, &ChatHandler::HandleGUIDCommand,                "", NULL },
         { "help",           SEC_PLAYER,         true,  &ChatHandler::HandleHelpCommand,                "", NULL },
+        { "ahexpire",       SEC_ADMINISTRATOR,  false, &ChatHandler::HandleAHExpireCommand,            "", NULL },
+        { "ahdelete",       SEC_ADMINISTRATOR,  false, &ChatHandler::HandleAHDeleteCommand,            "", NULL },
         { "itemmove",       SEC_GAMEMASTER,     false, &ChatHandler::HandleItemMoveCommand,            "", NULL },
         { "cooldown",       SEC_ADMINISTRATOR,  false, &ChatHandler::HandleCooldownCommand,            "", NULL },
         { "unlearn",        SEC_ADMINISTRATOR,  false, &ChatHandler::HandleUnLearnCommand,             "", NULL },
diff --git a/src/game/Chat.h b/src/game/Chat.h
index 28d1b3c..d10dde3 100644
--- a/src/game/Chat.h
+++ b/src/game/Chat.h
@@ -149,6 +149,8 @@ class ChatHandler
         bool HandleLookupSkillCommand(const char* args);
         bool HandleLookupSpellCommand(const char* args);
         bool HandleLookupTeleCommand(const char * args);
+        bool HandleAHExpireCommand(const char * args);
+        bool HandleAHDeleteCommand(const char * args);
 
         bool HandleModifyKnownTitlesCommand(const char* args);
         bool HandleModifyHPCommand(const char* args);
diff --git a/src/game/ChatHandler.cpp b/src/game/ChatHandler.cpp
index a6e05aa..9bef693 100644
--- a/src/game/ChatHandler.cpp
+++ b/src/game/ChatHandler.cpp
@@ -18,6 +18,7 @@
 
 #include "Common.h"
 #include "Log.h"
+#include "ChatLog.h"
 #include "WorldPacket.h"
 #include "WorldSession.h"
 #include "World.h"
@@ -159,11 +160,23 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
                 break;
 
             if(type == CHAT_MSG_SAY)
+            {
+                sChatLog.ChatMsg(GetPlayer(), msg, type);
+
                 GetPlayer()->Say(msg, lang);
+            }
             else if(type == CHAT_MSG_EMOTE)
+            {
+                sChatLog.ChatMsg(GetPlayer(), msg, type);
+
                 GetPlayer()->TextEmote(msg);
+            }
             else if(type == CHAT_MSG_YELL)
+            {
+                sChatLog.ChatMsg(GetPlayer(), msg, type);
+
                 GetPlayer()->Yell(msg, lang);
+            }
         } break;
 
         case CHAT_MSG_WHISPER:
@@ -180,6 +193,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.WhisperMsg(GetPlayer(), to, msg);
+
             if(!normalizePlayerName(to))
             {
                 WorldPacket data(SMSG_CHAT_PLAYER_NOT_FOUND, (to.size()+1));
@@ -233,6 +248,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.PartyMsg(GetPlayer(), msg);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group)
                 return;
@@ -260,6 +277,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.GuildMsg(GetPlayer(), msg, false);
+
             if (GetPlayer()->GetGuildId())
             {
                 Guild *guild = objmgr.GetGuildById(GetPlayer()->GetGuildId());
@@ -287,6 +306,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.GuildMsg(GetPlayer(), msg, true);
+
             if (GetPlayer()->GetGuildId())
             {
                 Guild *guild = objmgr.GetGuildById(GetPlayer()->GetGuildId());
@@ -313,6 +334,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.RaidMsg(GetPlayer(), msg, type);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isRaidGroup())
                 return;
@@ -339,6 +362,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.RaidMsg(GetPlayer(), msg, type);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isRaidGroup() || !group->IsLeader(GetPlayer()->GetGUID()))
                 return;
@@ -359,6 +384,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.RaidMsg(GetPlayer(), msg, type);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isRaidGroup() || !(group->IsLeader(GetPlayer()->GetGUID()) || group->IsAssistant(GetPlayer()->GetGUID())))
                 return;
@@ -380,6 +407,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.BattleGroundMsg(GetPlayer(), msg, type);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isRaidGroup())
                 return;
@@ -401,6 +430,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.BattleGroundMsg(GetPlayer(), msg, type);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isRaidGroup() || !group->IsLeader(GetPlayer()->GetGUID()))
                 return;
@@ -427,6 +458,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.ChannelMsg(GetPlayer(), channel, msg);
+
             if(ChannelMgr* cMgr = channelMgr(_player->GetTeam()))
             {
                 if(Channel *chn = cMgr->GetChannel(channel,_player))
diff --git a/src/game/ChatLexicsCutter.cpp b/src/game/ChatLexicsCutter.cpp
new file mode 100644
index 0000000..1c1d555
--- /dev/null
+++ b/src/game/ChatLexicsCutter.cpp
@@ -0,0 +1,274 @@
+/* 
+ * Copyright (C) 2005,2006,2007 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "Common.h"
+#include "ChatLexicsCutter.h"
+
+LexicsCutter::LexicsCutter()
+{
+    InvalidChars = "~`!@#$%^&*()-_+=[{]}|\\;:'\",<.>/?";
+}
+
+bool LexicsCutter::ReadUTF8(std::string& in, std::string& out, unsigned int& pos)
+{
+    if (pos >= in.length()) return false;
+    
+    out = "";
+    unsigned char c = in[pos++];
+    out += c;
+    int toread = trailingBytesForUTF8[(int) c];
+    while ((pos < in.length()) && (toread > 0))
+    {
+        out += in[pos++];
+        toread--;
+    }
+    
+    return true;
+}
+
+std::string LexicsCutter::trim(std::string& s, const std::string& drop)
+{
+    std::string r = s.erase(s.find_last_not_of(drop) + 1);
+    return r.erase(0, r.find_first_not_of(drop));
+}
+
+bool LexicsCutter::Read_Letter_Analogs(std::string& FileName)
+{
+    FILE *ma_file;
+    char line[1024];
+    unsigned int pos;
+    std::string line_s;
+    std::string lchar;
+    std::string lanalog;
+    
+    ma_file = fopen(FileName.c_str(), "rb");
+    
+    while (!feof(ma_file))
+    {
+        line[0] = 0x0;
+        fgets(line, 1020, ma_file);
+
+        // check for UTF8 prefix and comments
+        if (strlen(line) >= 3)
+        {
+            if (line[0] == '\xEF' && line[1] == '\xBB' && line[2] == '\xBF')
+            {
+                strncpy(&line[0], &line[3], strlen(line) - 3);
+            }
+        }
+
+        if (strlen(line) >= 2)
+        {
+            if (line[0] == '/' && line[1] == '/') continue;
+        }
+
+        // check for empty string
+        line_s = line; 
+        line_s = trim(line_s, "\x0A\x0D\x20");
+        if (line_s == "") continue;
+
+        // process line without CR/LF
+        line_s = line; 
+        line_s = trim(line_s, "\x0A\x0D");
+    
+        pos = 0;
+        if (ReadUTF8(line_s, lchar, pos))
+        {
+            // create analogs vector
+            LC_AnalogVector av;
+            while (ReadUTF8(line_s, lanalog, pos))
+            {
+                av.push_back(lanalog);
+            }
+        
+            // store vector in hash map
+            AnalogMap[lchar] = av;
+        }
+    }
+    
+    fclose(ma_file);
+    
+    return true;
+}
+
+bool LexicsCutter::Read_Innormative_Words(std::string& FileName)
+{
+    FILE *ma_file;
+    char line[1024];
+    unsigned int pos;
+    std::string line_s;
+    std::string lchar;
+    
+    ma_file = fopen(FileName.c_str(), "rb");
+    
+    while (!feof(ma_file))
+    {
+        line[0] = 0x0;
+        fgets(line, 1020, ma_file);
+
+        // check for UTF8 prefix and comment
+        if (strlen(line) >= 3)
+        {
+            if (line[0] == '\xEF' && line[1] == '\xBB' && line[2] == '\xBF')
+            {
+                strncpy(&line[0], &line[3], strlen(line) - 3);
+            }
+        }
+
+        if (strlen(line) >= 2)
+        {
+            if (line[0] == '/' && line[1] == '/') continue;
+        }
+
+        // check for empty string
+        line_s = line; 
+        line_s = trim(line_s, "\x0A\x0D\x20");
+        if (line_s == "") continue;
+
+        // process line without CR/LF
+        line_s = line; 
+        line_s = trim(line_s, "\x0A\x0D");
+    
+        // create word vector of vectors
+        LC_WordVector vw;
+        pos = 0;
+        while (ReadUTF8(line_s, lchar, pos))
+        {
+            // create letter set
+            LC_LetterSet vl;
+        
+            // initialize letter set with letter read
+            vl.insert(lchar);
+        
+            // find letter analogs and push them onto the vector
+            LC_AnalogMap::iterator itr = AnalogMap.find(lchar);
+            if (itr != AnalogMap.end())
+            {
+                // analogs present, iterate
+                for (LC_AnalogVector::iterator itr2 = itr->second.begin(); itr2 != itr->second.end(); itr2++)
+                {
+                    vl.insert(*itr2);
+                }
+            }
+        
+            // add letter vector to word vector
+            vw.push_back(vl);
+        }
+
+        // push new word to words list
+        WordList.push_back(vw);
+    }
+    
+    fclose(ma_file);
+    
+    return true;
+}
+
+void LexicsCutter::Map_Innormative_Words()
+{
+    // process all the words in the vector
+    for (unsigned int i = 0; i < WordList.size(); i++)
+    {
+        // parse all analogs in the first word letter
+        for (LC_LetterSet::iterator itr = (*WordList[i].begin()).begin(); itr != (*WordList[i].begin()).end(); itr++)
+        {
+            // map the word to its first letter variants
+            WordMap.insert(std::pair< std::string, unsigned int >(*itr, i));
+        }
+    }
+}
+
+bool LexicsCutter::Compare_Word(std::string& str, unsigned int pos, LC_WordVector word)
+{
+   std::string lchar_prev;
+    std::string lchar;
+
+   // read first letter of the word into lchar_prev
+   ReadUTF8(str, lchar, pos);    
+
+    // okay, here we go, comparing word
+    // first letter is already okay, we do begin from second and go on
+    LC_WordVector::iterator i = word.begin();
+    i++;
+    while (i != word.end())
+    {
+        // get letter from word, return false if the string is shorter
+        if (!ReadUTF8(str, lchar, pos)) return(false);
+        // check, if the letter is in the set
+        LC_LetterSet ls = *i;
+        if (ls.count(lchar) == 0)
+       {
+           // letter is not in set, but we must check, if it is not space or repeat
+           if ( (!(IgnoreMiddleSpaces && (lchar == " "))) &&
+               (!(IgnoreLetterRepeat && (lchar == lchar_prev))) )
+           {
+               // no checks viable
+               return(false);
+           }
+       }
+       else
+       {
+           // next word letter
+           i++;
+       }
+       // set previous string letter to compare if needed (this check can really conserve time)
+       if (IgnoreLetterRepeat) lchar_prev = lchar;
+   }
+    
+    return(true);
+}
+
+bool LexicsCutter::Check_Lexics(std::string& Phrase)
+{
+    std::string lchar;
+    LC_WordMap::iterator i;
+    std::pair< LC_WordMap::iterator, LC_WordMap::iterator > ii;
+
+    if (Phrase.size() == 0) return(false);
+    
+    // first, convert the string, adding spaces and removing invalid characters
+    // also create fast position vector for the new positions
+    std::string str = " ";
+    unsigned int pos = 0;
+    while (ReadUTF8(Phrase, lchar, pos))
+    {
+        if (InvalidChars.find(lchar) == std::string::npos)
+        {
+            str.append(lchar);
+        }
+    }
+    
+    // string prepared, now parse it and scan for all the words
+   unsigned int pos_prev = 0;
+    pos = 0;
+    while (ReadUTF8(str, lchar, pos))
+    {
+        // got character, now try to find wordmap for it
+        ii = WordMap.equal_range(lchar);
+        // iterate over all found words
+        for (i = ii.first; i != ii.second; i++)
+        {
+            // compare word at initial position
+            if (Compare_Word(str, pos_prev, WordList[i->second])) return(true);
+        }
+       // set initial position to the current position
+       pos_prev = pos;
+    }
+    
+    return(false);
+}
diff --git a/src/game/ChatLexicsCutter.h b/src/game/ChatLexicsCutter.h
new file mode 100644
index 0000000..38d636c
--- /dev/null
+++ b/src/game/ChatLexicsCutter.h
@@ -0,0 +1,67 @@
+/* 
+ * Copyright (C) 2005,2006,2007 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef MANGOSSERVER_CHATLEXICSCUTTER_H
+#define MANGOSSERVER_CHATLEXICSCUTTER_H
+
+typedef std::vector< std::string > LC_AnalogVector;
+typedef std::map< std::string, LC_AnalogVector > LC_AnalogMap;
+typedef std::set< std::string > LC_LetterSet;
+typedef std::vector< LC_LetterSet > LC_WordVector;
+typedef std::vector< LC_WordVector > LC_WordList;
+typedef std::multimap< std::string, unsigned int > LC_WordMap;
+
+static int trailingBytesForUTF8[256] = {
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5
+};
+
+class LexicsCutter
+{
+    protected:
+        LC_AnalogMap AnalogMap;
+        LC_WordList WordList;
+        LC_WordMap WordMap;
+
+        std::string InvalidChars;
+
+    public:
+        LexicsCutter();
+
+        static bool ReadUTF8(std::string& in, std::string& out, unsigned int& pos);
+
+        std::string trim(std::string& s, const std::string& drop = " ");
+        bool Read_Letter_Analogs(std::string& FileName);
+        bool Read_Innormative_Words(std::string& FileName);
+        void Map_Innormative_Words();
+        bool Compare_Word(std::string& str, unsigned int pos, LC_WordVector word);
+        bool Check_Lexics(std::string& Phrase);
+        
+        std::vector< std::pair< unsigned int, unsigned int > > Found;
+        bool IgnoreMiddleSpaces;
+        bool IgnoreLetterRepeat;
+};
+
+#endif
+
diff --git a/src/game/ChatLog.cpp b/src/game/ChatLog.cpp
new file mode 100644
index 0000000..ef5e203
--- /dev/null
+++ b/src/game/ChatLog.cpp
@@ -0,0 +1,855 @@
+/* 
+ * Copyright (C) 2005,2006,2007 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "Common.h"
+#include "ChatLexicsCutter.h"
+#include "ChatLog.h"
+#include "Chat.h"
+#include "Group.h"
+#include "Guild.h"
+#include "ObjectMgr.h"
+#include "SpellAuras.h"
+#include "Policies/SingletonImp.h"
+#include "Config/ConfigEnv.h"
+
+INSTANTIATE_SINGLETON_1( ChatLog );
+
+ChatLog::ChatLog()
+{
+    for (int i = 0; i <= CHATLOG_CHAT_TYPES_COUNT - 1; i++)
+    {
+        names[i] = "";
+        files[i] = NULL;
+    }
+    
+    Lexics = NULL;
+    fn_innormative = "";
+    f_innormative = NULL;
+    
+    Initialize();
+}
+
+ChatLog::~ChatLog()
+{
+    // close all files (avoiding double-close)
+    CloseAllFiles();
+
+    if (Lexics)
+    {
+        delete Lexics;
+        Lexics = NULL;
+    }
+}
+
+void ChatLog::Initialize()
+{
+    // determine, if the chat logs are enabled
+    ChatLogEnable = sConfig.GetBoolDefault("ChatLogEnable", false);
+    ChatLogDateSplit = sConfig.GetBoolDefault("ChatLogDateSplit", false);
+    ChatLogUTFHeader = sConfig.GetBoolDefault("ChatLogUTFHeader", false);
+    ChatLogIgnoreUnprintable = sConfig.GetBoolDefault("ChatLogIgnoreUnprintable", false);
+    
+    if (ChatLogEnable)
+    {
+        // read chat log file names
+        names[CHAT_LOG_CHAT] = sConfig.GetStringDefault("ChatLogChatFile", "");
+        names[CHAT_LOG_PARTY] = sConfig.GetStringDefault("ChatLogPartyFile", "");
+        names[CHAT_LOG_GUILD] = sConfig.GetStringDefault("ChatLogGuildFile", "");
+        names[CHAT_LOG_WHISPER] = sConfig.GetStringDefault("ChatLogWhisperFile", "");
+        names[CHAT_LOG_CHANNEL] = sConfig.GetStringDefault("ChatLogChannelFile", "");
+        names[CHAT_LOG_RAID] = sConfig.GetStringDefault("ChatLogRaidFile", "");
+        names[CHAT_LOG_BATTLEGROUND] = sConfig.GetStringDefault("ChatLogBattleGroundFile", "");
+
+        // read screen log flags
+        screenflag[CHAT_LOG_CHAT] = sConfig.GetBoolDefault("ChatLogChatScreen", false);
+        screenflag[CHAT_LOG_PARTY] = sConfig.GetBoolDefault("ChatLogPartyScreen", false);
+        screenflag[CHAT_LOG_GUILD] = sConfig.GetBoolDefault("ChatLogGuildScreen", false);
+        screenflag[CHAT_LOG_WHISPER] = sConfig.GetBoolDefault("ChatLogWhisperScreen", false);
+        screenflag[CHAT_LOG_CHANNEL] = sConfig.GetBoolDefault("ChatLogChannelScreen", false);
+        screenflag[CHAT_LOG_RAID] = sConfig.GetBoolDefault("ChatLogRaidScreen", false);
+        screenflag[CHAT_LOG_BATTLEGROUND] = sConfig.GetBoolDefault("ChatLogBattleGroundScreen", false);
+    }
+
+    // lexics cutter
+    LexicsCutterEnable = sConfig.GetBoolDefault("LexicsCutterEnable", false);
+
+    if (LexicsCutterEnable)
+    {
+        // initialize lexics cutter parameters
+        LexicsCutterInnormativeCut = sConfig.GetBoolDefault("LexicsCutterInnormativeCut", true);
+        LexicsCutterNoActionOnGM = sConfig.GetBoolDefault("LexicsCutterNoActionOnGM", true);
+        LexicsCutterScreenLog = sConfig.GetBoolDefault("LexicsCutterScreenLog", false);
+        LexicsCutterCutReplacement = sConfig.GetStringDefault("LexicsCutterCutReplacement", "&!@^%!^&*!!! [gibberish]");
+        LexicsCutterAction = sConfig.GetIntDefault("LexicsCutterAction", 0);
+        LexicsCutterActionDuration = sConfig.GetIntDefault("LexicsCutterActionDuration", 60000);
+        std::string fn_analogsfile = sConfig.GetStringDefault("LexicsCutterAnalogsFile", "");
+        std::string fn_wordsfile = sConfig.GetStringDefault("LexicsCutterWordsFile", "");
+
+        // read lexics cutter flags
+        cutflag[CHAT_LOG_CHAT] = sConfig.GetBoolDefault("LexicsCutInChat", true);
+        cutflag[CHAT_LOG_PARTY] = sConfig.GetBoolDefault("LexicsCutInParty", true);
+        cutflag[CHAT_LOG_GUILD] = sConfig.GetBoolDefault("LexicsCutInGuild", true);
+        cutflag[CHAT_LOG_WHISPER] = sConfig.GetBoolDefault("LexicsCutInWhisper", true);
+        cutflag[CHAT_LOG_CHANNEL] = sConfig.GetBoolDefault("LexicsCutInChannel", true);
+        cutflag[CHAT_LOG_RAID] = sConfig.GetBoolDefault("LexicsCutInRaid", true);
+        cutflag[CHAT_LOG_BATTLEGROUND] = sConfig.GetBoolDefault("LexicsCutInBattleGround", true);
+
+        if (fn_analogsfile == "" || fn_wordsfile == "")
+        {
+            LexicsCutterEnable = false;
+        }
+        else
+        {
+            // initialize lexics cutter
+            Lexics = new LexicsCutter;
+            if (Lexics) Lexics->Read_Letter_Analogs(fn_analogsfile);
+            if (Lexics) Lexics->Read_Innormative_Words(fn_wordsfile);
+            if (Lexics) Lexics->Map_Innormative_Words();
+
+            // read additional parameters
+            Lexics->IgnoreLetterRepeat = sConfig.GetBoolDefault("LexicsCutterIgnoreRepeats", true);
+            Lexics->IgnoreMiddleSpaces = sConfig.GetBoolDefault("LexicsCutterIgnoreSpaces", true);
+            fn_innormative = sConfig.GetStringDefault("LexicsCutterLogFile", "");
+        }
+    }
+
+    // open all files (with aliasing)
+    OpenAllFiles();
+
+    // write timestamps (init)
+    WriteInitStamps();
+}
+
+bool ChatLog::_ChatCommon(int ChatType, Player *player, std::string &msg)
+{
+    if (LexicsCutterEnable && Lexics && cutflag[ChatType] && Lexics->Check_Lexics(msg)) ChatBadLexicsAction(player, msg);
+
+    if (!ChatLogEnable) return(false);
+
+    if (ChatLogIgnoreUnprintable)
+    {
+        // have to ignore unprintables, verify string by UTF8 here
+        unsigned int pos = 0;
+        std::string lchar;
+        while (LexicsCutter::ReadUTF8(msg, lchar, pos))
+        {
+            if (lchar.size() == 1)
+            {
+                if (lchar[0] < ' ') return(false); // unprintable detected
+            }
+        }
+    }
+
+    return(true);
+}
+        
+void ChatLog::ChatMsg(Player *player, std::string &msg, uint32 type)
+{
+    if (!_ChatCommon(CHAT_LOG_CHAT, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    switch (type)
+    {
+        case CHAT_MSG_EMOTE:
+        log_str.append("{EMOTE} ");
+        break;
+
+        case CHAT_MSG_YELL:
+        log_str.append("{YELL} ");
+        break;
+    }
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("] ");
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_CHAT]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_CHAT])
+    {
+        OutTimestamp(files[CHAT_LOG_CHAT]);
+        fprintf(files[CHAT_LOG_CHAT], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_CHAT]);
+    }
+}
+
+void ChatLog::PartyMsg(Player *player, std::string &msg)
+{
+    if (!_ChatCommon(CHAT_LOG_PARTY, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("]->GROUP:");
+    
+    Group *group = player->GetGroup();
+    if (!group)
+    {
+        log_str.append("[unknown group] ");
+    }
+    else
+    {
+        // obtain group information
+        log_str.append("[");
+
+        uint8 gm_count = group->GetMembersCount();
+        uint8 gm_count_m1 = gm_count - 1;
+        uint64 gm_leader_GUID = group->GetLeaderGUID();
+        Player *gm_member;
+
+        gm_member = objmgr.GetPlayer(gm_leader_GUID);
+        if (gm_member)
+        {
+            log_str.append(gm_member->GetName());
+            log_str.append(",");
+        }
+
+        Group::MemberSlotList g_members = group->GetMemberSlots();
+        
+        for (Group::member_citerator itr = g_members.begin(); itr != g_members.end(); itr++)
+        {
+            if (itr->guid == gm_leader_GUID) continue;
+
+            gm_member = objmgr.GetPlayer(itr->guid);
+            if (gm_member)
+            {
+                log_str.append(itr->name);
+                log_str.append(",");
+            }
+        }
+
+        log_str.erase(log_str.length() - 1);
+        log_str.append("] ");
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+    
+    if (screenflag[CHAT_LOG_PARTY]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_PARTY])
+    {
+        OutTimestamp(files[CHAT_LOG_PARTY]);
+        fprintf(files[CHAT_LOG_PARTY], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_PARTY]);
+    }
+}
+
+void ChatLog::GuildMsg(Player *player, std::string &msg, bool officer)
+{
+    if (!_ChatCommon(CHAT_LOG_GUILD, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append((officer ? "]->GUILD_OFF:" : "]->GUILD:"));
+    
+    if (!player->GetGuildId())
+    {
+        log_str.append("[unknown guild] ");
+    }
+    else
+    {
+        Guild *guild = objmgr.GetGuildById(player->GetGuildId());
+        if (!guild)
+        {
+            log_str.append("[unknown guild] ");
+        }
+        else
+        {
+            // obtain guild information
+            log_str.append("(");
+            log_str.append(guild->GetName());
+            log_str.append(") ");
+        }
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+    
+    if (screenflag[CHAT_LOG_GUILD]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_GUILD])
+    {
+        OutTimestamp(files[CHAT_LOG_GUILD]);
+        fprintf(files[CHAT_LOG_GUILD], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_GUILD]);
+    }
+}
+
+void ChatLog::WhisperMsg(Player *player, std::string &to, std::string &msg)
+{
+    if (!_ChatCommon(CHAT_LOG_WHISPER, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("]->");
+    
+    if (to.size() == 0)
+    {
+        log_str.append("[???] ");
+    }
+    else
+    {
+        normalizePlayerName(to);
+        log_str.append("[");
+        log_str.append(to);
+        log_str.append("] ");
+    }
+    
+    log_str.append(msg);
+
+    log_str.append("\n");
+    
+    if (screenflag[CHAT_LOG_WHISPER]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_WHISPER])
+    {
+        OutTimestamp(files[CHAT_LOG_WHISPER]);
+        fprintf(files[CHAT_LOG_WHISPER], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_WHISPER]);
+    }
+}
+
+void ChatLog::ChannelMsg(Player *player, std::string &channel, std::string &msg)
+{
+    if (!_ChatCommon(CHAT_LOG_CHANNEL, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("]->CHANNEL:");
+    
+    if (channel.size() == 0)
+    {
+        log_str.append("[unknown channel] ");
+    }
+    else
+    {
+        log_str.append("[");
+        log_str.append(channel);
+        log_str.append("] ");
+    }
+    
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_CHANNEL]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_CHANNEL])
+    {
+        OutTimestamp(files[CHAT_LOG_CHANNEL]);
+        fprintf(files[CHAT_LOG_CHANNEL], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_CHANNEL]);
+    }
+}
+
+void ChatLog::RaidMsg(Player *player, std::string &msg, uint32 type)
+{
+    if (!_ChatCommon(CHAT_LOG_RAID, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+
+    switch (type)
+    {
+        case CHAT_MSG_RAID:
+        log_str.append("]->RAID:");
+        break;
+
+        case CHAT_MSG_RAID_LEADER:
+        log_str.append("]->RAID_LEADER:");
+        break;
+
+        case CHAT_MSG_RAID_WARNING:
+        log_str.append("]->RAID_WARN:");
+        break;
+
+        default:
+        log_str.append("]->RAID_UNKNOWN:");
+    }
+    
+    Group *group = player->GetGroup();
+    if (!group)
+    {
+        log_str.append("[unknown raid] ");
+    }
+    else
+    {
+        // obtain group information
+        log_str.append("[");
+
+        uint8 gm_count = group->GetMembersCount();
+        uint8 gm_count_m1 = gm_count - 1;
+        uint64 gm_leader_GUID = group->GetLeaderGUID();
+        Player *gm_member;
+
+        gm_member = objmgr.GetPlayer(gm_leader_GUID);
+        if (gm_member)
+        {
+            log_str.append(gm_member->GetName());
+            log_str.append(",");
+        }
+
+        Group::MemberSlotList g_members = group->GetMemberSlots();
+    
+        for (Group::member_citerator itr = g_members.begin(); itr != g_members.end(); itr++)
+        {
+            if (itr->guid == gm_leader_GUID) continue;
+
+            gm_member = objmgr.GetPlayer(itr->guid);
+            if (gm_member)
+            {
+                log_str.append(itr->name);
+                log_str.append(",");
+            }
+        }
+    
+        log_str.erase(log_str.length() - 1);
+        log_str.append("] ");
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_RAID]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_RAID])
+    {
+        OutTimestamp(files[CHAT_LOG_RAID]);
+        fprintf(files[CHAT_LOG_RAID], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_RAID]);
+    }
+}
+
+void ChatLog::BattleGroundMsg(Player *player, std::string &msg, uint32 type)
+{
+    if (!_ChatCommon(CHAT_LOG_BATTLEGROUND, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+
+    switch (type)
+    {
+        case CHAT_MSG_BATTLEGROUND:
+        log_str.append("]->BG:");
+        break;
+
+        case CHAT_MSG_BATTLEGROUND_LEADER:
+        log_str.append("]->BG_LEADER:");
+        break;
+
+        default:
+        log_str.append("]->BG_UNKNOWN:");
+    }
+    
+    Group *group = player->GetGroup();
+    if (!group)
+    {
+        log_str.append("[unknown group] ");
+    }
+    else
+    {
+        // obtain group information
+        log_str.append("[");
+
+        uint8 gm_count = group->GetMembersCount();
+        uint8 gm_count_m1 = gm_count - 1;
+        uint64 gm_leader_GUID = group->GetLeaderGUID();
+        Player *gm_member;
+
+        gm_member = objmgr.GetPlayer(gm_leader_GUID);
+        if (gm_member)
+        {
+            log_str.append(gm_member->GetName());
+            log_str.append(",");
+        }
+
+        Group::MemberSlotList g_members = group->GetMemberSlots();
+    
+        for (Group::member_citerator itr = g_members.begin(); itr != g_members.end(); itr++)
+        {
+            if (itr->guid == gm_leader_GUID) continue;
+
+            gm_member = objmgr.GetPlayer(itr->guid);
+            if (gm_member)
+            {
+                log_str.append(itr->name);
+                log_str.append(",");
+            }
+        }
+    
+        log_str.erase(log_str.length() - 1);
+        log_str.append("] ");
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_BATTLEGROUND]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_BATTLEGROUND])
+    {
+        OutTimestamp(files[CHAT_LOG_BATTLEGROUND]);
+        fprintf(files[CHAT_LOG_BATTLEGROUND], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_BATTLEGROUND]);
+    }
+}
+
+void ChatLog::OpenAllFiles()
+{
+    std::string tempname;
+    char dstr[12];
+
+    if (ChatLogDateSplit)
+    {
+        time_t t = time(NULL);
+        tm* aTm = localtime(&t);
+        sprintf(dstr, "%-4d-%02d-%02d", aTm->tm_year + 1900, aTm->tm_mon + 1, aTm->tm_mday);
+    }
+
+    if (ChatLogEnable)
+    {
+        for (int i = 0; i <= CHATLOG_CHAT_TYPES_COUNT - 1; i++)
+        {
+            if (names[i] != "")
+            {
+                for (int j = i - 1; j >= 0; j--)
+                {
+                    if (names[i] == names[j])
+                    {
+                        files[i] = files[j];
+                        break;
+                    }
+                }
+                if (!files[i])
+                {
+                    tempname = names[i];
+                    if (ChatLogDateSplit)
+                    {
+                        // append date instead of $d if applicable
+                        int dpos = tempname.find("$d");
+                        if (dpos != tempname.npos)
+                        {
+                            tempname.replace(dpos, 2, &dstr[0], 10);
+                        }
+                    }
+                    files[i] = fopen(tempname.c_str(), "a+b");
+                    if (ChatLogUTFHeader && (ftell(files[i]) == 0)) fputs("\xEF\xBB\xBF", files[i]);
+                }
+            }
+        }
+    }
+
+    // initialize innormative log
+    if (LexicsCutterEnable)
+    {
+        if (fn_innormative != "")
+        {
+            tempname = fn_innormative;
+            if (ChatLogDateSplit)
+            {
+                // append date instead of $d if applicable
+                int dpos = tempname.find("$d");
+                if (dpos != tempname.npos)
+                {
+                    tempname.replace(dpos, 2, &dstr[0], 10);
+                }
+            }
+            f_innormative = fopen(tempname.c_str(), "a+b");
+            if (ChatLogUTFHeader && (ftell(f_innormative) == 0)) fputs("\xEF\xBB\xBF", f_innormative);
+        }
+    }
+}
+
+void ChatLog::CloseAllFiles()
+{
+    for (int i = 0; i <= CHATLOG_CHAT_TYPES_COUNT - 1; i++)
+    {
+        if (files[i])
+        {
+            for (int j = i + 1; j <= CHATLOG_CHAT_TYPES_COUNT - 1; j++)
+            {
+                if (files[j] == files[i]) files[j] = NULL;
+            }
+        
+            fclose(files[i]);
+            files[i] = NULL;
+        }
+    }
+
+    if (f_innormative)
+    {
+        fclose(f_innormative);
+        f_innormative = NULL;
+    }
+}
+
+void ChatLog::CheckDateSwitch()
+{
+    if (ChatLogDateSplit)
+    {
+        time_t t = time(NULL);
+        tm* aTm = localtime(&t);
+        if (lastday != aTm->tm_mday)
+        {
+            // date switched
+            CloseAllFiles();
+            OpenAllFiles();
+            WriteInitStamps();
+        }
+    }
+}
+
+void ChatLog::WriteInitStamps()
+{
+    // remember date
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    lastday = aTm->tm_mday;
+
+    if (files[CHAT_LOG_CHAT])
+    {
+        OutTimestamp(files[CHAT_LOG_CHAT]);
+        fprintf(files[CHAT_LOG_CHAT], "%s", "[SYSTEM] Chat Log Initialized\n");
+    }
+    if (files[CHAT_LOG_PARTY])
+    {
+        OutTimestamp(files[CHAT_LOG_PARTY]);
+        fprintf(files[CHAT_LOG_PARTY], "%s", "[SYSTEM] Party Chat Log Initialized\n");
+    }
+    if (files[CHAT_LOG_GUILD])
+    {
+        OutTimestamp(files[CHAT_LOG_GUILD]);
+        fprintf(files[CHAT_LOG_GUILD], "%s", "[SYSTEM] Guild Chat Log Initialized\n");
+    }
+    if (files[CHAT_LOG_WHISPER])
+    {
+        OutTimestamp(files[CHAT_LOG_WHISPER]);
+        fprintf(files[CHAT_LOG_WHISPER], "%s", "[SYSTEM] Whisper Log Initialized\n");
+    }
+    if (files[CHAT_LOG_CHANNEL])
+    {
+        OutTimestamp(files[CHAT_LOG_CHANNEL]);
+        fprintf(files[CHAT_LOG_CHANNEL], "%s", "[SYSTEM] Chat Channels Log Initialized\n");
+    }
+    if (files[CHAT_LOG_RAID])
+    {
+        OutTimestamp(files[CHAT_LOG_RAID]);
+        fprintf(files[CHAT_LOG_RAID], "%s", "[SYSTEM] Raid Party Chat Log Initialized\n");
+    }
+
+    if (f_innormative)
+    {
+        OutTimestamp(f_innormative);
+        fprintf(f_innormative, "%s", "[SYSTEM] Innormative Lexics Log Initialized\n");
+    }
+}
+
+void ChatLog::OutTimestamp(FILE* file)
+{
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    fprintf(file, "%-4d-%02d-%02d %02d:%02d:%02d ", aTm->tm_year + 1900, aTm->tm_mon + 1, aTm->tm_mday, aTm->tm_hour, aTm->tm_min, aTm->tm_sec);
+}
+
+void ChatLog::ChatBadLexicsAction(Player* player, std::string& msg)
+{
+    // logging
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("] ");
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (LexicsCutterScreenLog) printf("<INNORMATIVE!> %s", log_str.c_str());
+    if (f_innormative)
+    {
+        OutTimestamp(f_innormative);
+        fprintf(f_innormative, "%s", log_str.c_str());
+        fflush(f_innormative);
+    }
+
+    // cutting innormative lexics
+    if (LexicsCutterInnormativeCut)
+    {
+        msg = LexicsCutterCutReplacement;
+    }
+
+    if (!player || !player->GetSession()) return;
+
+    if (LexicsCutterNoActionOnGM && player->GetSession()->GetSecurity()) return;
+
+    // special action
+    const SpellEntry* sl;
+
+    switch (LexicsCutterAction)
+    {
+        case LEXICS_ACTION_SHEEP:
+        {
+            // sheep me, yeah, yeah, sheep me
+            sl = sSpellStore.LookupEntry(118);
+            if (sl)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    Aura* Aur = CreateAura(sl, i, NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        case LEXICS_ACTION_STUN:
+        {
+            // stunned surprised
+            sl = sSpellStore.LookupEntry(13005);
+            if (sl)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    Aura* Aur = CreateAura(sl, i, NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        case LEXICS_ACTION_DIE:
+        {
+            // oops, kicked the bucket
+            player->DealDamage(player, player->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }
+        break;
+
+        case LEXICS_ACTION_DRAIN:
+        {
+            // living corpse :)
+            player->DealDamage(player, player->GetHealth() - 5, NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }
+        break;
+
+
+        case LEXICS_ACTION_SILENCE:
+        {
+            // glue the mouth
+            time_t mutetime = time(NULL) + (int) (LexicsCutterActionDuration / 1000);
+            player->GetSession()->m_muteTime = mutetime;
+        }
+        break;
+
+        case LEXICS_ACTION_STUCK:
+        {
+            // yo, the Matrix has had you :) [by KAPATEJIb]
+            sl = sSpellStore.LookupEntry(23312);
+            if (sl)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    Aura* Aur = CreateAura(sl, i, NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        case LEXICS_ACTION_SICKNESS:
+        {
+            // for absence of censorship, there is punishment [by Koshei]
+            sl = sSpellStore.LookupEntry(15007);
+            if (sl)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    Aura* Aur = CreateAura(sl, i, NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        case LEXICS_ACTION_SHEAR:
+        {
+            // Lord Illidan to watch you [by Koshei]
+            sl = sSpellStore.LookupEntry(41032);
+            if (sl)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    Aura* Aur = CreateAura(sl, i, NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        default:
+        // no action except logging
+        break;
+    }
+}
diff --git a/src/game/ChatLog.h b/src/game/ChatLog.h
new file mode 100644
index 0000000..7460b92
--- /dev/null
+++ b/src/game/ChatLog.h
@@ -0,0 +1,107 @@
+/* 
+ * Copyright (C) 2005,2006,2007 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef MANGOSSERVER_CHATLOG_H
+#define MANGOSSERVER_CHATLOG_H
+
+#include "SharedDefines.h"
+#include "ChatLexicsCutter.h"
+#include "ObjectMgr.h"
+#include "Policies/Singleton.h"
+
+#define CHATLOG_CHAT_TYPES_COUNT 7
+
+enum ChatLogFiles
+{
+    CHAT_LOG_CHAT = 0,
+    CHAT_LOG_PARTY = 1,
+    CHAT_LOG_GUILD = 2,
+    CHAT_LOG_WHISPER = 3,
+    CHAT_LOG_CHANNEL = 4,
+    CHAT_LOG_RAID = 5,
+    CHAT_LOG_BATTLEGROUND = 6,
+};
+
+enum LexicsActions
+{
+    LEXICS_ACTION_LOG = 0,
+    LEXICS_ACTION_SHEEP = 1,
+    LEXICS_ACTION_STUN = 2,
+    LEXICS_ACTION_DIE = 3,
+    LEXICS_ACTION_DRAIN = 4,
+    LEXICS_ACTION_SILENCE = 5,
+    LEXICS_ACTION_STUCK = 6,
+    LEXICS_ACTION_SICKNESS = 7,
+    LEXICS_ACTION_SHEAR = 8,
+};
+
+class ChatLog : public MaNGOS::Singleton<ChatLog, MaNGOS::ClassLevelLockable<ChatLog, ZThread::FastMutex> >
+{
+    public:
+        ChatLog();
+        ~ChatLog();
+
+        void Initialize();
+        
+        void ChatMsg(Player *player, std::string &msg, uint32 type);
+        void PartyMsg(Player *player, std::string &msg);
+        void GuildMsg(Player *player, std::string &msg, bool officer);
+        void WhisperMsg(Player *player, std::string &to, std::string &msg);
+        void ChannelMsg(Player *player, std::string &channel, std::string &msg);
+        void RaidMsg(Player *player, std::string &msg, uint32 type);
+        void BattleGroundMsg(Player *player, std::string &msg, uint32 type);
+        
+        void ChatBadLexicsAction(Player *player, std::string &msg);
+        
+    private:
+        bool _ChatCommon(int ChatType, Player *player, std::string &msg);
+
+        bool ChatLogEnable;
+        bool ChatLogDateSplit;
+        bool ChatLogUTFHeader;
+        bool ChatLogIgnoreUnprintable;
+
+        int lastday;
+   
+        FILE* files[CHATLOG_CHAT_TYPES_COUNT];
+        std::string names[CHATLOG_CHAT_TYPES_COUNT];
+        bool screenflag[CHATLOG_CHAT_TYPES_COUNT];
+   
+        LexicsCutter* Lexics;
+        bool cutflag[CHATLOG_CHAT_TYPES_COUNT];
+
+        bool LexicsCutterEnable;
+        bool LexicsCutterInnormativeCut;
+        bool LexicsCutterNoActionOnGM;
+        bool LexicsCutterScreenLog;
+        std::string LexicsCutterCutReplacement;
+        int LexicsCutterAction;
+        int LexicsCutterActionDuration;
+        std::string fn_innormative;
+        FILE* f_innormative;
+
+        void OpenAllFiles();
+        void CloseAllFiles();
+        void CheckDateSwitch();
+
+        void WriteInitStamps();
+        void OutTimestamp(FILE *file);
+};
+
+#define sChatLog MaNGOS::Singleton<ChatLog>::Instance()
+#endif
diff --git a/src/game/GuardAI.cpp b/src/game/GuardAI.cpp
index 5672f14..b07146d 100644
--- a/src/game/GuardAI.cpp
+++ b/src/game/GuardAI.cpp
@@ -50,7 +50,7 @@ void GuardAI::MoveInLineOfSight(Unit *u)
         {
             //Need add code to let guard support player
             AttackStart(u);
-            u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
+            //u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
         }
     }
 }
diff --git a/src/game/Language.h b/src/game/Language.h
index 7dcee62..4aa3437 100644
--- a/src/game/Language.h
+++ b/src/game/Language.h
@@ -21,6 +21,8 @@
 
 enum MangosStrings
 {
+	LANG_AUTO_BROADCAST                 = 2001,
+
     // for chat commands
     LANG_SELECT_CHAR_OR_CREATURE        = 1,
     LANG_SELECT_CREATURE                = 2,
diff --git a/src/game/Level1.cpp b/src/game/Level1.cpp
index 37b8b14..24cd067 100644
--- a/src/game/Level1.cpp
+++ b/src/game/Level1.cpp
@@ -1188,7 +1188,7 @@ bool ChatHandler::HandleModifyScaleCommand(const char* args)
         return false;
 
     float Scale = (float)atof((char*)args);
-    if (Scale > 3.0f || Scale <= 0.0f)
+    if (Scale > 15.0f || Scale <= 0.0f)
     {
         SendSysMessage(LANG_BAD_VALUE);
         SetSentErrorMessage(true);
diff --git a/src/game/Level3.cpp b/src/game/Level3.cpp
index 2a12a53..bd29a1e 100644
--- a/src/game/Level3.cpp
+++ b/src/game/Level3.cpp
@@ -4846,6 +4846,92 @@ bool ChatHandler::HandleCompleteQuest(const char* args)
     return true;
 }
 
+bool ChatHandler::HandleAHExpireCommand(const char* args)
+{
+   if (args == NULL)
+      return false;
+
+   char* ahMapIdStr = strtok((char*) args, " ");
+   char* playerGuidStr = strtok(NULL, " ");
+
+   if ((ahMapIdStr == NULL) || (playerGuidStr == NULL))
+      return false;
+
+   uint32 ahMapID = (uint32) strtoul(ahMapIdStr, NULL, 0);
+   uint32 playerGUID = (uint32) strtoul(playerGuidStr, NULL, 0);
+
+   AuctionHouseObject* auctionHouse = objmgr.GetAuctionsMap(ahMapID);
+
+   if (auctionHouse == NULL)
+      return false;
+
+   AuctionHouseObject::AuctionEntryMap::iterator itr;
+   itr = auctionHouse->GetAuctionsBegin();
+
+   while (itr != auctionHouse->GetAuctionsEnd())
+   {
+      if (itr->second->owner == playerGUID)
+         itr->second->time = sWorld.GetGameTime();
+
+      ++itr;
+   }
+
+   return true;
+}
+
+bool ChatHandler::HandleAHDeleteCommand(const char* args)
+{
+   if (args == NULL)
+      return false;
+
+   char* ahMapIdStr = strtok((char*) args, " ");
+   char* playerGuidStr = strtok(NULL, " ");
+
+   if ((ahMapIdStr == NULL) || (playerGuidStr == NULL))
+      return false;
+
+   uint32 ahMapID = (uint32) strtoul(ahMapIdStr, NULL, 0);
+   uint32 playerGUID = (uint32) strtoul(playerGuidStr, NULL, 0);
+
+   AuctionHouseObject* auctionHouse = objmgr.GetAuctionsMap(ahMapID);
+
+   if (auctionHouse == NULL)
+      return false;
+
+   AuctionHouseObject::AuctionEntryMap::iterator itr;
+   itr = auctionHouse->GetAuctionsBegin();
+
+   while (itr != auctionHouse->GetAuctionsEnd())
+   {
+      AuctionHouseObject::AuctionEntryMap::iterator tmp = itr;
+      ++itr;
+
+      if (tmp->second->owner != playerGUID)
+         continue;
+
+      Item* item = objmgr.GetAItem(tmp->second->item_guidlow);
+      if (item != NULL)
+      {
+         objmgr.RemoveAItem(tmp->second->item_guidlow);
+         item->DeleteFromDB();
+         delete item;
+      }
+      else
+      {
+         sLog.outString("ahdelete: "
+                        "clearing auction for non-existant item_guidlow (%d)",
+                        tmp->second->item_guidlow);
+      }
+
+      CharacterDatabase.PExecute("DELETE FROM `auctionhouse` WHERE `id` = '%u'",
+                                 tmp->second->Id);
+      auctionHouse->RemoveAuction(tmp->second->Id);
+      delete tmp->second;
+   }
+
+   return true;
+}
+
 bool ChatHandler::HandleBanAccountCommand(const char* args)
 {
     return HandleBanHelper(BAN_ACCOUNT,args);
diff --git a/src/game/Makefile.am b/src/game/Makefile.am
index 03dbeef..51cfdd1 100644
--- a/src/game/Makefile.am
+++ b/src/game/Makefile.am
@@ -38,6 +38,8 @@ libmangosgame_a_SOURCES = \
     ArenaTeam.cpp \
     ArenaTeam.h \
     ArenaTeamHandler.cpp \
+    AuctionHouseBot.cpp \
+    AuctionHouseBot.h \
     AuctionHouse.cpp \
     AuctionHouseObject.h \
     Bag.cpp \
@@ -73,6 +75,10 @@ libmangosgame_a_SOURCES = \
     Chat.cpp \
     Chat.h \
     ChatHandler.cpp \
+    ChatLexicsCutter.cpp \
+    ChatLexicsCutter.h \
+    ChatLog.cpp \
+    ChatLog.h \
     CombatHandler.cpp \
     ConfusedMovementGenerator.cpp \
     ConfusedMovementGenerator.h \
diff --git a/src/game/ObjectMgr.cpp b/src/game/ObjectMgr.cpp
index 7740f83..5bd7e8a 100644
--- a/src/game/ObjectMgr.cpp
+++ b/src/game/ObjectMgr.cpp
@@ -20,6 +20,7 @@
 #include "Database/DatabaseEnv.h"
 #include "Database/SQLStorage.h"
 
+#include "AuctionHouseBot.h"
 #include "Log.h"
 #include "MapManager.h"
 #include "ObjectMgr.h"
@@ -415,6 +416,9 @@ void ObjectMgr::SendAuctionSalePendingMail( AuctionEntry * auction )
 //call this method to send mail to auction owner, when auction is successful, it does not clear ram
 void ObjectMgr::SendAuctionSuccessfulMail( AuctionEntry * auction )
 {
+    if (auction->owner == AuctionHouseBotNoMail())
+        return;
+
     uint64 owner_guid = MAKE_NEW_GUID(auction->owner, 0, HIGHGUID_PLAYER);
     Player *owner = GetPlayer(owner_guid);
 
diff --git a/src/game/Pet.cpp b/src/game/Pet.cpp
index b0ac1f6..f2d10cc 100644
--- a/src/game/Pet.cpp
+++ b/src/game/Pet.cpp
@@ -619,7 +619,7 @@ void Pet::RegenerateFocus()
     AuraList const& ModPowerRegenPCTAuras = GetAurasByType(SPELL_AURA_MOD_POWER_REGEN_PERCENT);
     for(AuraList::const_iterator i = ModPowerRegenPCTAuras.begin(); i != ModPowerRegenPCTAuras.end(); ++i)
         if ((*i)->GetModifier()->m_miscvalue == POWER_FOCUS)
-            addvalue *= ((*i)->GetModifier()->m_amount + 100) / 100.0f;
+            addvalue *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount + 100) / 100.0f;
 
     ModifyPower(POWER_FOCUS, (int32)addvalue);
 }
diff --git a/src/game/PetAI.cpp b/src/game/PetAI.cpp
index 144b2d7..b16877a 100644
--- a/src/game/PetAI.cpp
+++ b/src/game/PetAI.cpp
@@ -55,7 +55,7 @@ void PetAI::MoveInLineOfSight(Unit *u)
             if(i_pet.IsWithinLOSInMap(u))
             {
                 AttackStart(u);
-                u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
+                //u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
             }
         }
     }
diff --git a/src/game/Player.cpp b/src/game/Player.cpp
index bdda338..4b5658d 100644
--- a/src/game/Player.cpp
+++ b/src/game/Player.cpp
@@ -766,7 +766,7 @@ void Player::HandleDrowning()
 
     AuraList const& mModWaterBreathing = GetAurasByType(SPELL_AURA_MOD_WATER_BREATHING);
     for(AuraList::const_iterator i = mModWaterBreathing.begin(); i != mModWaterBreathing.end(); ++i)
-        UnderWaterTime = uint32(UnderWaterTime * (100.0f + (*i)->GetModifier()->m_amount) / 100.0f);
+        UnderWaterTime = uint32(UnderWaterTime * (100.0f + (*i)->GetModifier()->m_amount * (*i)->m_stackAmount) / 100.0f);
 
     if ((m_isunderwater & 0x01) && !(m_isunderwater & 0x80) && isAlive())
     {
@@ -1796,7 +1796,7 @@ void Player::Regenerate(Powers power)
         AuraList const& ModPowerRegenPCTAuras = GetAurasByType(SPELL_AURA_MOD_POWER_REGEN_PERCENT);
         for(AuraList::const_iterator i = ModPowerRegenPCTAuras.begin(); i != ModPowerRegenPCTAuras.end(); ++i)
             if ((*i)->GetModifier()->m_miscvalue == power)
-                addvalue *= ((*i)->GetModifier()->m_amount + 100) / 100.0f;
+                addvalue *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount + 100) / 100.0f;
     }
 
     if (power != POWER_RAGE)
@@ -1837,7 +1837,7 @@ void Player::RegenerateHealth()
         {
             AuraList const& mModHealthRegenPct = GetAurasByType(SPELL_AURA_MOD_HEALTH_REGEN_PERCENT);
             for(AuraList::const_iterator i = mModHealthRegenPct.begin(); i != mModHealthRegenPct.end(); ++i)
-                addvalue *= (100.0f + (*i)->GetModifier()->m_amount) / 100.0f;
+                addvalue *= (100.0f + (*i)->GetModifier()->m_amount * (*i)->m_stackAmount) / 100.0f;
         }
         else if(HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT))
             addvalue *= GetTotalAuraModifier(SPELL_AURA_MOD_REGEN_DURING_COMBAT) / 100.0f;
@@ -2034,7 +2034,7 @@ void Player::GiveXP(uint32 xp, Unit* victim)
     // handle SPELL_AURA_MOD_XP_PCT auras
     Unit::AuraList const& ModXPPctAuras = GetAurasByType(SPELL_AURA_MOD_XP_PCT);
     for(Unit::AuraList::const_iterator i = ModXPPctAuras.begin();i != ModXPPctAuras.end(); ++i)
-        xp = uint32(xp*(1.0f + (*i)->GetModifier()->m_amount / 100.0f));
+        xp = uint32(xp*(1.0f + (*i)->GetModifier()->m_amount * (*i)->m_stackAmount / 100.0f));
 
     // XP resting bonus for kill
     uint32 rested_bonus_xp = victim ? GetXPRestBonus(xp) : 0;
@@ -5922,7 +5922,7 @@ bool Player::RewardHonor(Unit *uVictim, uint32 groupsize, float honor)
             if (!cVictim->isRacialLeader())
                 return false;
 
-            honor = 100;                                    // ??? need more info
+            honor = 2000;                                    // ??? need more info
             victim_rank = 19;                               // HK: Leader
         }
     }
@@ -6583,7 +6583,7 @@ void Player::_ApplyWeaponDependentAuraCritMod(Item *item, WeaponAttackType attac
 
     if (item->IsFitToSpellRequirements(aura->GetSpellProto()))
     {
-        HandleBaseModValue(mod, FLAT_MOD, float (aura->GetModifier()->m_amount), apply);
+        HandleBaseModValue(mod, FLAT_MOD, float (aura->GetModifier()->m_amount * aura->m_stackAmount), apply);
     }
 }
 
@@ -6617,7 +6617,7 @@ void Player::_ApplyWeaponDependentAuraDamageMod(Item *item, WeaponAttackType att
 
     if (item->IsFitToSpellRequirements(aura->GetSpellProto()))
     {
-        HandleStatModifier(unitMod, unitModType, float(modifier->m_amount),apply);
+        HandleStatModifier(unitMod, unitModType, float(modifier->m_amount * aura->m_stackAmount),apply);
     }
 }
 
diff --git a/src/game/SharedDefines.h b/src/game/SharedDefines.h
index 817ae81..241bd48 100644
--- a/src/game/SharedDefines.h
+++ b/src/game/SharedDefines.h
@@ -798,14 +798,16 @@ enum Targets
     TARGET_AREAEFFECT_PARTY            = 37,
     TARGET_SCRIPT                      = 38,
     TARGET_SELF_FISHING                = 39,
-    TARGET_TOTEM_EARTH                 = 41,
-    TARGET_TOTEM_WATER                 = 42,
-    TARGET_TOTEM_AIR                   = 43,
-    TARGET_TOTEM_FIRE                  = 44,
+    TARGET_LOCATION_FRONT_LEFT         = 41,
+    TARGET_LOCATION_BACK_LEFT          = 42,
+    TARGET_LOCATION_BACK_RIGHT         = 43,
+    TARGET_LOCATION_FRONT_RIGHT        = 44,
     TARGET_CHAIN_HEAL                  = 45,
     TARGET_SCRIPT_COORDINATES          = 46,
-    TARGET_DYNAMIC_OBJECT              = 47,
-    TARGET_SUMMON                      = 48,
+    TARGET_LOCATION_FRONT              = 47,
+    TARGET_LOCATION_BACK               = 48,
+    TARGET_LOCATION_LEFT               = 49,
+    TARGET_LOCATION_RIGHT              = 50,
     TARGET_AREAEFFECT_CUSTOM_2         = 52,
     TARGET_CURRENT_ENEMY_COORDINATES   = 53,                // set unit coordinates as dest, only 16 target B imlemented
     TARGET_RANDOM_RAID_MEMBER          = 56,
@@ -813,8 +815,12 @@ enum Targets
     TARGET_AREAEFFECT_PARTY_AND_CLASS  = 61,
     TARGET_DUELVSPLAYER_COORDINATES    = 63,
     TARGET_BEHIND_VICTIM               = 65,                // uses in teleport behind spells
+    TARGET_LOCATION_RANDOM_AROUND_CASTER    = 72,
+    TARGET_LOCATION_RADIUS_AROUND_CASTER    = 73,
+    TARGET_LOCATION_RANDOM_IN_AREA     = 74,
     TARGET_SINGLE_ENEMY                = 77,
-    TARGET_SELF2                       = 87,
+    TARGET_LOCATION_AROUND_DEST        = 86,
+    TARGET_LOCATION_AT_DEST            = 87,
     TARGET_NONCOMBAT_PET               = 90,
 };
 
diff --git a/src/game/Spell.cpp b/src/game/Spell.cpp
index 7faf701..2f3930e 100644
--- a/src/game/Spell.cpp
+++ b/src/game/Spell.cpp
@@ -946,6 +946,9 @@ void Spell::DoAllEffectOnTarget(TargetInfo *target)
 
 void Spell::DoSpellHitOnUnit(Unit *unit, const uint32 effectMask)
 {
+    if (m_caster->hasUnitState(UNIT_STAT_DIED)) 
+        return;
+
     if(!unit || !effectMask)
         return;
 
@@ -969,10 +972,7 @@ void Spell::DoSpellHitOnUnit(Unit *unit, const uint32 effectMask)
                 return;
             }
 
-            // exclude Arcane Missiles Dummy Aura aura for now (attack on hit)
-            // TODO: find way to not need this?
-            if(!(m_spellInfo->SpellFamilyName == SPELLFAMILY_MAGE &&
-                m_spellInfo->SpellFamilyFlags & 0x800LL))
+            if(!IsPositiveSpell(m_spellInfo->Id))
             {
                 unit->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
 
@@ -1173,16 +1173,99 @@ void Spell::SetTargetMap(uint32 i,uint32 cur,std::list<Unit*> &TagUnitMap)
     uint32 unMaxTargets = m_spellInfo->MaxAffectedTargets;
     switch(cur)
     {
-        case TARGET_TOTEM_EARTH:
-        case TARGET_TOTEM_WATER:
-        case TARGET_TOTEM_AIR:
-        case TARGET_TOTEM_FIRE:
+        case TARGET_LOCATION_FRONT_LEFT:
+        case TARGET_LOCATION_BACK_LEFT:
+        case TARGET_LOCATION_BACK_RIGHT:
+        case TARGET_LOCATION_FRONT_RIGHT:
+        case TARGET_LOCATION_FRONT:
+        case TARGET_LOCATION_BACK:
+        case TARGET_LOCATION_LEFT:
+        case TARGET_LOCATION_RIGHT:
+        case TARGET_LOCATION_RANDOM_AROUND_CASTER:
+        case TARGET_LOCATION_RADIUS_AROUND_CASTER:
+        {
+            float x, y, z, angle, dist;
+
+            if (m_spellInfo->EffectRadiusIndex[i])
+                dist = GetSpellRadius(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
+            else
+                dist = 3.0f;
+            if (cur == TARGET_LOCATION_RANDOM_AROUND_CASTER)
+                dist *= rand_norm(); // This case we need to consider caster size
+            else
+                dist -= m_caster->GetObjectSize(); // Size is calculated in GetNearPoint(), but we do not need it 
+
+            switch(cur)
+            {
+                case TARGET_LOCATION_FRONT_LEFT:
+                    angle = -M_PI/4;
+                    break;
+                case TARGET_LOCATION_BACK_LEFT:
+                    angle = -3*M_PI/4;
+                    break;
+                case TARGET_LOCATION_BACK_RIGHT:
+                    angle = 3*M_PI/4;
+                    break;
+                case TARGET_LOCATION_FRONT_RIGHT:
+                    angle = M_PI/4;
+                    break;
+                case TARGET_LOCATION_FRONT:
+                    angle = 0.0f;
+                    break;
+                case TARGET_LOCATION_BACK:
+                    angle = M_PI;
+                    break;
+                case TARGET_LOCATION_LEFT:
+                    angle = -M_PI/2;
+                    break;
+                case TARGET_LOCATION_RIGHT:
+                    angle = M_PI/2;
+                    break;
+                default:
+                    angle = rand_norm()*2*M_PI;
+                    break;
+            }
+
+            m_caster->GetClosePoint(x, y, z, 0, dist, angle);
+            m_targets.setDestination(x, y, z);
+            if (m_targets.getUnitTarget())
+                TagUnitMap.push_back(m_targets.getUnitTarget());
+            else
+                TagUnitMap.push_back(m_caster); 
+        }break;
+        case TARGET_LOCATION_RANDOM_IN_AREA:
+        case TARGET_LOCATION_AROUND_DEST:
+        {
+            float x, y, z, dist, px, py, pz;
+            dist = GetSpellRadius(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
+            if (m_targets.m_targetMask & TARGET_FLAG_DEST_LOCATION)
+            {
+                x = m_targets.m_destX;
+                y = m_targets.m_destY;
+                z = m_targets.m_destZ;
+            }
+            else if (m_targets.getUnitTarget()) // Do not know if possible
+                m_targets.getUnitTarget()->GetPosition(x, y, z);
+            else
+                m_caster->GetPosition(x, y, z);
+
+            m_caster->GetRandomPoint(x, y, z, dist, px, py, pz);
+            m_targets.setDestination(px, py, pz);
+            if (m_targets.getUnitTarget())
+                TagUnitMap.push_back(m_targets.getUnitTarget());
+            else
+                TagUnitMap.push_back(m_caster);
+        }break;
+        case TARGET_LOCATION_AT_DEST:
+        {
+            if (m_targets.getUnitTarget())
+                TagUnitMap.push_back(m_targets.getUnitTarget());
+            else
+                TagUnitMap.push_back(m_caster);
+        }break;
         case TARGET_SELF:
-        case TARGET_SELF2:
-        case TARGET_DYNAMIC_OBJECT:
         case TARGET_AREAEFFECT_CUSTOM:
         case TARGET_AREAEFFECT_CUSTOM_2:
-        case TARGET_SUMMON:
         {
             TagUnitMap.push_back(m_caster);
             break;
@@ -1664,11 +1747,11 @@ void Spell::SetTargetMap(uint32 i,uint32 cur,std::list<Unit*> &TagUnitMap)
                     // IsHostileTo check duel and controlled by enemy
                     if(Target && Target->GetSubGroup()==subgroup && !m_caster->IsHostileTo(Target))
                     {
-                        if( pTarget->IsWithinDistInMap(Target, radius) )
+                        if(Target->getLevel()+10 >= m_spellInfo->spellLevel && pTarget->IsWithinDistInMap(Target, radius))
                             TagUnitMap.push_back(Target);
 
                         if(Pet* pet = Target->GetPet())
-                            if( pTarget->IsWithinDistInMap(pet, radius) )
+                            if(pet->getLevel()+10 >= m_spellInfo->spellLevel && pTarget->IsWithinDistInMap(pet, radius) )
                                 TagUnitMap.push_back(pet);
                     }
                 }
@@ -1683,7 +1766,7 @@ void Spell::SetTargetMap(uint32 i,uint32 cur,std::list<Unit*> &TagUnitMap)
                 TagUnitMap.push_back(pTarget);
 
                 if(Pet* pet = pTarget->GetPet())
-                    if( m_caster->IsWithinDistInMap(pet, radius) )
+                    if(pet->getLevel()+10 >= m_spellInfo->spellLevel && m_caster->IsWithinDistInMap(pet, radius) )
                         TagUnitMap.push_back(pet);
             }
 
@@ -1809,9 +1892,7 @@ void Spell::SetTargetMap(uint32 i,uint32 cur,std::list<Unit*> &TagUnitMap)
                     Player* Target = itr->getSource();
 
                     // IsHostileTo check duel and controlled by enemy
-                    if( Target && targetPlayer->IsWithinDistInMap(Target, radius) &&
-                        targetPlayer->getClass() == Target->getClass() &&
-                        !m_caster->IsHostileTo(Target) )
+                    if( Target && Target->getLevel()+10 >= m_spellInfo->spellLevel && targetPlayer->getClass() == Target->getClass() && !m_caster->IsHostileTo(Target) && targetPlayer->IsWithinDistInMap(Target, radius) )
                     {
                         TagUnitMap.push_back(Target);
                     }
@@ -2490,7 +2571,24 @@ void Spell::finish(bool ok)
     // other code related only to successfully finished spells
     if(!ok)
         return;
-
+    //holy nova heal
+    if(m_spellInfo->SpellFamilyName == SPELLFAMILY_PRIEST && m_spellInfo->SpellIconID == 1874)
+    {
+        int holy_nova_heal = 0;
+        switch(m_spellInfo->Id)
+        {
+            case 15237: holy_nova_heal = 23455; break;
+            case 15430: holy_nova_heal = 23458; break;
+            case 15431: holy_nova_heal = 23459; break;
+            case 27799: holy_nova_heal = 27803; break;
+            case 27804: holy_nova_heal = 27800; break;
+            case 27801: holy_nova_heal = 27805; break;
+            case 25331: holy_nova_heal = 25329; break;
+            default:break;
+        }
+        if(holy_nova_heal)
+            m_caster->CastSpell(m_caster, holy_nova_heal, true);
+    }
     //handle SPELL_AURA_ADD_TARGET_TRIGGER auras
     Unit::AuraList const& targetTriggers = m_caster->GetAurasByType(SPELL_AURA_ADD_TARGET_TRIGGER);
     for(Unit::AuraList::const_iterator i = targetTriggers.begin(); i != targetTriggers.end(); ++i)
@@ -2510,7 +2608,8 @@ void Spell::finish(bool ok)
                     int32 chance = m_caster->CalculateSpellDamage(auraSpellInfo, auraSpellIdx, (*i)->GetBasePoints(),unit);
 
                     if(roll_chance_i(chance))
-                        m_caster->CastSpell(unit, auraSpellInfo->EffectTriggerSpell[auraSpellIdx], true, NULL, (*i));
+                        for ( int j=0; j != (*i)->m_stackAmount; ++j)
+                            m_caster->CastSpell(unit, auraSpellInfo->EffectTriggerSpell[auraSpellIdx], true, NULL, (*i));
                 }
             }
         }
@@ -4081,9 +4180,16 @@ uint8 Spell::CheckCasterAuras() const
 {
     // Flag drop spells totally immuned to caster auras
     // FIXME: find more nice check for all totally immuned spells
-    // AttributesEx3 & 0x10000000?
-    if(m_spellInfo->Id==23336 || m_spellInfo->Id==23334 || m_spellInfo->Id==34991)
-        return 0;
+    switch(m_spellInfo->Id)
+    {
+        case 23336:     // Alliance Flag Drop
+        case 23334:     // Horde Flag Drop
+        case 34991:     // Summon Netherstorm Flag
+        case 22812:     // Barkskin
+            return 0;
+        default:
+            break;
+    }
 
     uint8 school_immune = 0;
     uint32 mechanic_immune = 0;
diff --git a/src/game/SpellAuras.cpp b/src/game/SpellAuras.cpp
index 6732fc5..d854d34 100644
--- a/src/game/SpellAuras.cpp
+++ b/src/game/SpellAuras.cpp
@@ -315,7 +315,7 @@ pAuraHandler AuraHandler[TOTAL_AURAS]=
 };
 
 Aura::Aura(SpellEntry const* spellproto, uint32 eff, int32 *currentBasePoints, Unit *target, Unit *caster, Item* castItem) :
-m_procCharges(0), m_spellmod(NULL), m_effIndex(eff), m_caster_guid(0), m_target(target),
+m_procCharges(0), m_stackAmount(1), m_spellmod(NULL), m_effIndex(eff), m_caster_guid(0), m_target(target),
 m_timeCla(1000), m_castItemGuid(castItem?castItem->GetGUID():0), m_auraSlot(MAX_AURAS),
 m_positive(false), m_permanent(false), m_isPeriodic(false), m_isTrigger(false), m_isAreaAura(false),
 m_isPersistent(false), m_updated(false), m_removeMode(AURA_REMOVE_BY_DEFAULT), m_isRemovedOnShapeLost(true), m_in_use(false),
@@ -858,7 +858,6 @@ void Aura::_AddAura()
         return;
 
     // we can found aura in NULL_AURA_SLOT and then need store state instead check slot != NULL_AURA_SLOT
-    bool samespell = false;
     bool secondaura = false;
     uint8 slot = NULL_AURA_SLOT;
 
@@ -870,15 +869,13 @@ void Aura::_AddAura()
             // allow use single slot only by auras from same caster
             if(itr->second->GetCasterGUID()==GetCasterGUID())
             {
-                samespell = true;
-                if (m_effIndex > itr->second->GetEffIndex())
-                     secondaura = true;
+                secondaura = true;
                 slot = itr->second->GetAuraSlot();
                 break;
             }
         }
 
-        if(samespell)
+        if(secondaura)
             break;
     }
 
@@ -907,7 +904,7 @@ void Aura::_AddAura()
     if((!m_isPassive || (caster && caster->GetTypeId() == TYPEID_UNIT && ((Creature*)caster)->isTotem())) &&
         (m_spellProto->Effect[GetEffIndex()] != SPELL_EFFECT_APPLY_AREA_AURA_ENEMY || m_target != caster))
     {
-        if(!samespell)                                      // new slot need
+        if(!secondaura)                                     // new slot need
         {
             if (IsPositive())                               // empty positive slot
             {
@@ -935,30 +932,24 @@ void Aura::_AddAura()
             SetAuraSlot( slot );
 
             // Not update fields for not first spell's aura, all data already in fields
-            if(!secondaura)
+            if(slot < MAX_AURAS)                        // slot found
             {
-                if(slot < MAX_AURAS)                        // slot found
-                {
-                    SetAura(slot, false);
-                    SetAuraFlag(slot, true);
-                    SetAuraLevel(slot,caster ? caster->getLevel() : sWorld.getConfig(CONFIG_MAX_PLAYER_LEVEL));
-                    UpdateAuraCharges();
-
-                    // update for out of range group members
-                    m_target->UpdateAuraForGroup(slot);
-                }
-
-                UpdateAuraDuration();
+                SetAura(slot, false);
+                SetAuraFlag(slot, true);
+                SetAuraLevel(slot,caster ? caster->getLevel() : sWorld.getConfig(CONFIG_MAX_PLAYER_LEVEL));
+                UpdateAuraCharges();
+                
+                // update for out of range group members
+                m_target->UpdateAuraForGroup(slot);
             }
         }
         else                                                // use found slot
         {
             SetAuraSlot( slot );
-            // Not recalculate stack count for second aura of the same spell
-            if (!secondaura)
-                UpdateSlotCounterAndDuration(true);
         }
 
+        UpdateSlotCounterAndDuration();
+
         // Update Seals information
         if( IsSealSpell(GetSpellProto()) )
             m_target->ModifyAuraState(AURA_STATE_JUDGEMENT, true);
@@ -1009,7 +1000,6 @@ void Aura::_RemoveAura()
         return;
 
     bool samespell = false;
-    bool sameaura = false;
 
     // find other aura in same slot (current already removed from list)
     for(uint8 i = 0; i < 3; i++)
@@ -1020,10 +1010,6 @@ void Aura::_RemoveAura()
             if(itr->second->GetAuraSlot()==slot)
             {
                 samespell = true;
-
-                if(GetEffIndex()==i)
-                    sameaura = true;
-
                 break;
             }
         }
@@ -1075,8 +1061,6 @@ void Aura::_RemoveAura()
                 ((Player*)caster)->SendCooldownEvent(GetSpellProto());
         }
     }
-    else if(sameaura)                                       // decrease count for spell, only for same aura effect, or this spell auras in remove process.
-        UpdateSlotCounterAndDuration(false);
 }
 
 void Aura::SetAuraFlag(uint32 slot, bool add)
@@ -1115,35 +1099,13 @@ void Aura::SetAuraApplication(uint32 slot, int8 count)
     m_target->SetUInt32Value(UNIT_FIELD_AURAAPPLICATIONS + index, val);
 }
 
-void Aura::UpdateSlotCounterAndDuration(bool add)
+void Aura::UpdateSlotCounterAndDuration()
 {
     uint8 slot = GetAuraSlot();
     if(slot >= MAX_AURAS)
         return;
 
-    // calculate amount of similar auras by same effect index (similar different spells)
-    int8 count = 0;
-
-    // calculate auras and update durations in case aura adding
-    Unit::AuraList const& aura_list = m_target->GetAurasByType(GetModifier()->m_auraname);
-    for(Unit::AuraList::const_iterator i = aura_list.begin();i != aura_list.end(); ++i)
-    {
-        if( (*i)->GetId()==GetId() && (*i)->GetEffIndex()==m_effIndex &&
-            (*i)->GetCasterGUID()==GetCasterGUID() )
-        {
-            ++count;
-
-            if(add)
-                (*i)->SetAuraDuration(GetAuraDuration());
-        }
-    }
-
-    // at aura add aura not added yet, at aura remove aura already removed
-    // in field stored (count-1)
-    if(!add)
-        --count;
-
-    SetAuraApplication(slot, count);
+    SetAuraApplication(slot, m_stackAmount - 1);
 
     UpdateAuraDuration();
 }
@@ -1177,7 +1139,7 @@ void Aura::HandleAddModifier(bool apply, bool Real)
 
         SpellModifier *mod = new SpellModifier;
         mod->op = SpellModOp(m_modifier.m_miscvalue);
-        mod->value = m_modifier.m_amount;
+        mod->value = m_modifier.m_amount * m_stackAmount;
         mod->type = SpellModType(m_modifier.m_auraname);    // SpellModType value == spell aura types
         mod->spellId = GetId();
         mod->effectId = m_effIndex;
@@ -1867,8 +1829,8 @@ void Aura::TriggerSpell()
                     {
                         switch((*i)->GetModifier()->m_miscvalue)
                         {
-                            case STAT_INTELLECT: intelectLoss += (*i)->GetModifier()->m_amount; break;
-                            case STAT_SPIRIT:    spiritLoss   += (*i)->GetModifier()->m_amount; break;
+                            case STAT_INTELLECT: intelectLoss += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount; break;
+                            case STAT_SPIRIT:    spiritLoss   += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount; break;
                             default: break;
                         }
                     }
@@ -2789,7 +2751,7 @@ void Aura::HandleAuraModSkill(bool apply, bool Real)
         return;
 
     uint32 prot=GetSpellProto()->EffectMiscValue[m_effIndex];
-    int32 points = GetModifier()->m_amount;
+    int32 points = GetModifier()->m_amount * m_stackAmount;
 
     ((Player*)m_target)->ModifySkillBonus(prot,(apply ? points: -points),m_modifier.m_auraname==SPELL_AURA_MOD_SKILL_TALENT);
     if(prot == SKILL_DEFENSE)
@@ -2878,7 +2840,7 @@ void Aura::HandleAuraTrackStealthed(bool apply, bool Real)
 
 void Aura::HandleAuraModScale(bool apply, bool Real)
 {
-    m_target->ApplyPercentModFloatValue(OBJECT_FIELD_SCALE_X,m_modifier.m_amount,apply);
+    m_target->ApplyPercentModFloatValue(OBJECT_FIELD_SCALE_X,m_modifier.m_amount * m_stackAmount,apply);
 }
 
 void Aura::HandleModPossess(bool apply, bool Real)
@@ -3180,6 +3142,9 @@ void Aura::HandleAuraModDisarm(bool apply, bool Real)
 
 void Aura::HandleAuraModStun(bool apply, bool Real)
 {
+    if(m_target->isInFlight())
+        return;
+
     if(!Real)
         return;
 
@@ -3490,15 +3455,11 @@ void Aura::HandleAuraModSilence(bool apply, bool Real)
                     return;
 
                 // Search Mana Tap auras on caster
-                int32 energy = 0;
-                Unit::AuraList const& m_dummyAuras = caster->GetAurasByType(SPELL_AURA_DUMMY);
-                for(Unit::AuraList::const_iterator i = m_dummyAuras.begin(); i != m_dummyAuras.end(); ++i)
-                    if ((*i)->GetId() == 28734)
-                        ++energy;
-                if (energy)
+                Aura * dummy = caster->GetDummyAura(28734);
+                if (dummy)
                 {
-                    energy *= 10;
-                    caster->CastCustomSpell(caster, 25048, &energy, NULL, NULL, true);
+                    int32 bp = dummy->m_stackAmount * 10;
+                    caster->CastCustomSpell(caster, 25048, &bp, NULL, NULL, true);
                     caster->RemoveAurasDueToSpell(28734);
                 }
             }
@@ -3551,7 +3512,7 @@ void Aura::HandleModThreat(bool apply, bool Real)
         if(m_modifier.m_miscvalue & int32(1<<x))
         {
             if(m_target->GetTypeId() == TYPEID_PLAYER)
-                ApplyPercentModFloatVar(m_target->m_threatModifier[x], m_positive ? m_modifier.m_amount : -m_modifier.m_amount, apply);
+                ApplyPercentModFloatVar(m_target->m_threatModifier[x], m_positive ? m_modifier.m_amount * m_stackAmount : -m_modifier.m_amount * m_stackAmount, apply);
         }
     }
 }
@@ -3572,9 +3533,9 @@ void Aura::HandleAuraModTotalThreat(bool apply, bool Real)
 
     float threatMod = 0.0f;
     if(apply)
-        threatMod = float(m_modifier.m_amount);
+        threatMod = float(m_modifier.m_amount * m_stackAmount);
     else
-        threatMod =  float(-m_modifier.m_amount);
+        threatMod =  float(-m_modifier.m_amount * m_stackAmount);
 
     m_target->getHostilRefManager().threatAssist(caster, threatMod);
 }
@@ -4012,6 +3973,40 @@ void Aura::HandlePeriodicDamage(bool apply, bool Real)
 
     Unit *caster = GetCaster();
 
+    // Blood Frenzy, remove when no longer bleeding
+    if (Real && !apply && m_spellProto->SpellFamilyName==SPELLFAMILY_WARRIOR && (m_spellProto->SpellFamilyFlags & 0x1000000020LL) )
+    {
+         // search for another rend or deep wounds
+         bool found = false;
+         Unit::AuraList const& auras = m_target->GetAurasByType(SPELL_AURA_PERIODIC_DAMAGE);
+         for(Unit::AuraList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+         {
+              SpellEntry const* itr_spell = (*itr)->GetSpellProto();
+              if(itr_spell && itr_spell->SpellFamilyName==SPELLFAMILY_WARRIOR && (itr_spell->SpellFamilyFlags & 0x1000000020LL) )
+              {
+                   found = true;
+                   break;
+              }
+         }
+         if(!found)
+         {
+              Unit::AuraList const& auras = m_target->GetAurasByType(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN);
+              for(Unit::AuraList::const_iterator itr = auras.begin(); itr != auras.end();)
+              {
+                   SpellEntry const* itr_spell = (*itr)->GetSpellProto();
+                   if(itr_spell && itr_spell->SpellIconID == 2005 )
+                   {
+                        m_target->RemoveAurasDueToSpell(itr_spell->Id);
+                        itr = auras.begin();
+                   }
+                   else
+                   {
+                       itr++;
+                   }
+              }
+         }
+    }
+
     switch (m_spellProto->SpellFamilyName)
     {
         case SPELLFAMILY_GENERIC:
@@ -4229,9 +4224,9 @@ void Aura::HandleAuraModResistanceExclusive(bool apply, bool Real)
     {
         if(m_modifier.m_miscvalue & int32(1<<x))
         {
-            m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + x), BASE_VALUE, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + x), BASE_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
             if(m_target->GetTypeId() == TYPEID_PLAYER)
-                m_target->ApplyResistanceBuffModsMod(SpellSchools(x),m_positive,m_modifier.m_amount, apply);
+                m_target->ApplyResistanceBuffModsMod(SpellSchools(x),m_positive,m_modifier.m_amount * m_stackAmount, apply);
         }
     }
 }
@@ -4242,9 +4237,9 @@ void Aura::HandleAuraModResistance(bool apply, bool Real)
     {
         if(m_modifier.m_miscvalue & int32(1<<x))
         {
-            m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + x), TOTAL_VALUE, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + x), TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
             if(m_target->GetTypeId() == TYPEID_PLAYER || ((Creature*)m_target)->isPet())
-                m_target->ApplyResistanceBuffModsMod(SpellSchools(x),m_positive,m_modifier.m_amount, apply);
+                m_target->ApplyResistanceBuffModsMod(SpellSchools(x),m_positive,m_modifier.m_amount * m_stackAmount, apply);
         }
     }
 
@@ -4264,14 +4259,14 @@ void Aura::HandleAuraModBaseResistancePCT(bool apply, bool Real)
     {
         //pets only have base armor
         if(((Creature*)m_target)->isPet() && (m_modifier.m_miscvalue & SPELL_SCHOOL_MASK_NORMAL))
-            m_target->HandleStatModifier(UNIT_MOD_ARMOR, BASE_PCT, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_ARMOR, BASE_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
     }
     else
     {
         for(int8 x = SPELL_SCHOOL_NORMAL; x < MAX_SPELL_SCHOOL;x++)
         {
             if(m_modifier.m_miscvalue & int32(1<<x))
-                m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + x), BASE_PCT, float(m_modifier.m_amount), apply);
+                m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + x), BASE_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
         }
     }
 }
@@ -4282,11 +4277,11 @@ void Aura::HandleModResistancePercent(bool apply, bool Real)
     {
         if(m_modifier.m_miscvalue & int32(1<<i))
         {
-            m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + i), TOTAL_PCT, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + i), TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
             if(m_target->GetTypeId() == TYPEID_PLAYER || ((Creature*)m_target)->isPet())
             {
-                m_target->ApplyResistanceBuffModsPercentMod(SpellSchools(i),true,m_modifier.m_amount, apply);
-                m_target->ApplyResistanceBuffModsPercentMod(SpellSchools(i),false,m_modifier.m_amount, apply);
+                m_target->ApplyResistanceBuffModsPercentMod(SpellSchools(i),true,m_modifier.m_amount * m_stackAmount, apply);
+                m_target->ApplyResistanceBuffModsPercentMod(SpellSchools(i),false,m_modifier.m_amount * m_stackAmount, apply);
             }
         }
     }
@@ -4299,13 +4294,13 @@ void Aura::HandleModBaseResistance(bool apply, bool Real)
     {
         //only pets have base stats
         if(((Creature*)m_target)->isPet() && (m_modifier.m_miscvalue & SPELL_SCHOOL_MASK_NORMAL))
-            m_target->HandleStatModifier(UNIT_MOD_ARMOR, TOTAL_VALUE, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_ARMOR, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
     }
     else
     {
         for(int i = SPELL_SCHOOL_NORMAL; i < MAX_SPELL_SCHOOL; i++)
             if(m_modifier.m_miscvalue & (1<<i))
-                m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + i), TOTAL_VALUE, float(m_modifier.m_amount), apply);
+                m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + i), TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
     }
 }
 
@@ -4327,9 +4322,9 @@ void Aura::HandleAuraModStat(bool apply, bool Real)
         if (m_modifier.m_miscvalue < 0 || m_modifier.m_miscvalue == i)
         {
             //m_target->ApplyStatMod(Stats(i), m_modifier.m_amount,apply);
-            m_target->HandleStatModifier(UnitMods(UNIT_MOD_STAT_START + i), TOTAL_VALUE, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UnitMods(UNIT_MOD_STAT_START + i), TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
             if(m_target->GetTypeId() == TYPEID_PLAYER || ((Creature*)m_target)->isPet())
-                m_target->ApplyStatBuffMod(Stats(i),m_modifier.m_amount,apply);
+                m_target->ApplyStatBuffMod(Stats(i),m_modifier.m_amount * m_stackAmount,apply);
         }
     }
 }
@@ -4349,7 +4344,7 @@ void Aura::HandleModPercentStat(bool apply, bool Real)
     for (int32 i = STAT_STRENGTH; i < MAX_STATS; ++i)
     {
         if(m_modifier.m_miscvalue == i || m_modifier.m_miscvalue == -1)
-            m_target->HandleStatModifier(UnitMods(UNIT_MOD_STAT_START + i), BASE_PCT, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UnitMods(UNIT_MOD_STAT_START + i), BASE_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
     }
 }
 
@@ -4427,9 +4422,9 @@ void Aura::HandleModTotalPercentStat(bool apply, bool Real)
     {
         if(m_modifier.m_miscvalue == i || m_modifier.m_miscvalue == -1)
         {
-            m_target->HandleStatModifier(UnitMods(UNIT_MOD_STAT_START + i), TOTAL_PCT, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UnitMods(UNIT_MOD_STAT_START + i), TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
             if(m_target->GetTypeId() == TYPEID_PLAYER || ((Creature*)m_target)->isPet())
-                m_target->ApplyStatPercentBuffMod(Stats(i), m_modifier.m_amount, apply );
+                m_target->ApplyStatPercentBuffMod(Stats(i), m_modifier.m_amount * m_stackAmount, apply );
         }
     }
 
@@ -4527,7 +4522,7 @@ void Aura::HandleModRegen(bool apply, bool Real)            // eating
         if(m_periodicTimer <= 0)
         {
             m_periodicTimer += 5000;
-            int32 gain = m_target->ModifyHealth(m_modifier.m_amount);
+            int32 gain = m_target->ModifyHealth(m_modifier.m_amount * m_stackAmount);
             Unit *caster = GetCaster();
             if (caster)
             {
@@ -4543,6 +4538,18 @@ void Aura::HandleModRegen(bool apply, bool Real)            // eating
 
 void Aura::HandleModPowerRegen(bool apply, bool Real)       // drinking
 {
+    // remove old auras from drinking
+    if (apply && (GetSpellProto()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED))
+    {
+        Unit::AuraList const& m_ModPowerRegen = m_target->GetAurasByType(SPELL_AURA_MOD_POWER_REGEN);
+        for(Unit::AuraList::const_iterator i = m_ModPowerRegen.begin(); i != m_ModPowerRegen.end(); ++i)
+            if ( ((*i)->GetSpellProto()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED) && GetSpellProto() != (*i)->GetSpellProto() )
+            {
+                m_target->RemoveAurasDueToSpell( (*i)->GetSpellProto()->Id );
+                break;
+            }
+    }
+
     if ((GetSpellProto()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED) && apply && !m_target->IsSitState())
         m_target->SetStandState(PLAYER_STATE_SIT);
 
@@ -4643,7 +4650,7 @@ void Aura::HandleAuraModIncreaseHealth(bool apply, bool Real)
     }
 
     // generic case
-    m_target->HandleStatModifier(UNIT_MOD_HEALTH, TOTAL_VALUE, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_HEALTH, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void  Aura::HandleAuraModIncreaseMaxHealth(bool apply, bool Real)
@@ -4651,7 +4658,7 @@ void  Aura::HandleAuraModIncreaseMaxHealth(bool apply, bool Real)
     uint32 oldhealth = m_target->GetHealth();
     double healthPercentage = (double)oldhealth / (double)m_target->GetMaxHealth();
 
-    m_target->HandleStatModifier(UNIT_MOD_HEALTH, TOTAL_VALUE, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_HEALTH, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
 
     // refresh percentage
     if(oldhealth > 0)
@@ -4670,7 +4677,7 @@ void Aura::HandleAuraModIncreaseEnergy(bool apply, bool Real)
     if(int32(powerType) != m_modifier.m_miscvalue)
         return;
 
-    m_target->HandleStatModifier(UnitMods(UNIT_MOD_POWER_START + powerType), TOTAL_VALUE, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UnitMods(UNIT_MOD_POWER_START + powerType), TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void Aura::HandleAuraModIncreaseEnergyPercent(bool apply, bool Real)
@@ -4679,13 +4686,13 @@ void Aura::HandleAuraModIncreaseEnergyPercent(bool apply, bool Real)
     if(int32(powerType) != m_modifier.m_miscvalue)
         return;
 
-    m_target->HandleStatModifier(UnitMods(UNIT_MOD_POWER_START + powerType), TOTAL_PCT, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UnitMods(UNIT_MOD_POWER_START + powerType), TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void Aura::HandleAuraModIncreaseHealthPercent(bool apply, bool Real)
 {
     //m_target->ApplyMaxHealthPercentMod(m_modifier.m_amount,apply);
-    m_target->HandleStatModifier(UNIT_MOD_HEALTH, TOTAL_PCT, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_HEALTH, TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 /********************************/
@@ -4749,9 +4756,9 @@ void Aura::HandleAuraModCritPercent(bool apply, bool Real)
 
     if (GetSpellProto()->EquippedItemClass == -1)
     {
-        ((Player*)m_target)->HandleBaseModValue(CRIT_PERCENTAGE,         FLAT_MOD, float (m_modifier.m_amount), apply);
-        ((Player*)m_target)->HandleBaseModValue(OFFHAND_CRIT_PERCENTAGE, FLAT_MOD, float (m_modifier.m_amount), apply);
-        ((Player*)m_target)->HandleBaseModValue(RANGED_CRIT_PERCENTAGE,  FLAT_MOD, float (m_modifier.m_amount), apply);
+        ((Player*)m_target)->HandleBaseModValue(CRIT_PERCENTAGE,         FLAT_MOD, float (m_modifier.m_amount * m_stackAmount), apply);
+        ((Player*)m_target)->HandleBaseModValue(OFFHAND_CRIT_PERCENTAGE, FLAT_MOD, float (m_modifier.m_amount * m_stackAmount), apply);
+        ((Player*)m_target)->HandleBaseModValue(RANGED_CRIT_PERCENTAGE,  FLAT_MOD, float (m_modifier.m_amount * m_stackAmount), apply);
     }
     else
     {
@@ -4761,13 +4768,13 @@ void Aura::HandleAuraModCritPercent(bool apply, bool Real)
 
 void Aura::HandleModHitChance(bool apply, bool Real)
 {
-    m_target->m_modMeleeHitChance += apply ? m_modifier.m_amount : (-m_modifier.m_amount);
-    m_target->m_modRangedHitChance += apply ? m_modifier.m_amount : (-m_modifier.m_amount);
+    m_target->m_modMeleeHitChance += apply ? m_modifier.m_amount * m_stackAmount : (-m_modifier.m_amount * m_stackAmount);
+    m_target->m_modRangedHitChance += apply ? m_modifier.m_amount * m_stackAmount : (-m_modifier.m_amount * m_stackAmount);
 }
 
 void Aura::HandleModSpellHitChance(bool apply, bool Real)
 {
-    m_target->m_modSpellHitChance += apply ? m_modifier.m_amount: (-m_modifier.m_amount);
+    m_target->m_modSpellHitChance += apply ? m_modifier.m_amount * m_stackAmount: (-m_modifier.m_amount * m_stackAmount);
 }
 
 void Aura::HandleModSpellCritChance(bool apply, bool Real)
@@ -4782,7 +4789,7 @@ void Aura::HandleModSpellCritChance(bool apply, bool Real)
     }
     else
     {
-        m_target->m_baseSpellCritChance += apply ? m_modifier.m_amount:(-m_modifier.m_amount);
+        m_target->m_baseSpellCritChance += apply ? m_modifier.m_amount * m_stackAmount:(-m_modifier.m_amount * m_stackAmount);
     }
 }
 
@@ -4806,49 +4813,47 @@ void Aura::HandleModSpellCritChanceShool(bool /*apply*/, bool Real)
 
 void Aura::HandleModCastingSpeed(bool apply, bool Real)
 {
-    m_target->ApplyCastTimePercentMod(m_modifier.m_amount,apply);
+    m_target->ApplyCastTimePercentMod(m_modifier.m_amount * m_stackAmount,apply);
 }
 
 void Aura::HandleModMeleeRangedSpeedPct(bool apply, bool Real)
 {
-    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,m_modifier.m_amount,apply);
-    m_target->ApplyAttackTimePercentMod(OFF_ATTACK,m_modifier.m_amount,apply);
-    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK, m_modifier.m_amount, apply);
+    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,m_modifier.m_amount * m_stackAmount,apply);
+    m_target->ApplyAttackTimePercentMod(OFF_ATTACK,m_modifier.m_amount * m_stackAmount,apply);
+    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK, m_modifier.m_amount * m_stackAmount, apply);
 }
 
 void Aura::HandleModCombatSpeedPct(bool apply, bool Real)
 {
-    m_target->ApplyCastTimePercentMod(m_modifier.m_amount,apply);
-    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,m_modifier.m_amount,apply);
-    m_target->ApplyAttackTimePercentMod(OFF_ATTACK,m_modifier.m_amount,apply);
-    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK, m_modifier.m_amount, apply);
+    m_target->ApplyCastTimePercentMod(m_modifier.m_amount * m_stackAmount,apply);
+    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,m_modifier.m_amount * m_stackAmount,apply);
+    m_target->ApplyAttackTimePercentMod(OFF_ATTACK,m_modifier.m_amount * m_stackAmount,apply);
+    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK, m_modifier.m_amount * m_stackAmount, apply);
 }
 
-void Aura::HandleModAttackSpeed(bool apply, bool Real)
-{
-    if(!m_target->isAlive() )
-        return;
-
-    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,m_modifier.m_amount,apply);
-}
+ void Aura::HandleModAttackSpeed(bool apply, bool Real)
+ {
+    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,m_modifier.m_amount * m_stackAmount,apply);
+    m_target->UpdateDamagePhysical(BASE_ATTACK);
+ }
 
 void Aura::HandleHaste(bool apply, bool Real)
 {
-    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,  m_modifier.m_amount,apply);
-    m_target->ApplyAttackTimePercentMod(OFF_ATTACK,   m_modifier.m_amount,apply);
-    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK,m_modifier.m_amount,apply);
+    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,  m_modifier.m_amount * m_stackAmount,apply);
+    m_target->ApplyAttackTimePercentMod(OFF_ATTACK,   m_modifier.m_amount * m_stackAmount,apply);
+    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK,m_modifier.m_amount * m_stackAmount,apply);
 }
 
 void Aura::HandleAuraModRangedHaste(bool apply, bool Real)
 {
-    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK, m_modifier.m_amount, apply);
+    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK, m_modifier.m_amount * m_stackAmount, apply);
 }
 
 void Aura::HandleRangedAmmoHaste(bool apply, bool Real)
 {
     if(m_target->GetTypeId() != TYPEID_PLAYER)
         return;
-    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK,m_modifier.m_amount, apply);
+    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK,m_modifier.m_amount * m_stackAmount, apply);
 }
 
 /********************************/
@@ -4857,7 +4862,7 @@ void Aura::HandleRangedAmmoHaste(bool apply, bool Real)
 
 void Aura::HandleAuraModAttackPower(bool apply, bool Real)
 {
-    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void Aura::HandleAuraModRangedAttackPower(bool apply, bool Real)
@@ -4865,13 +4870,13 @@ void Aura::HandleAuraModRangedAttackPower(bool apply, bool Real)
     if((m_target->getClassMask() & CLASSMASK_WAND_USERS)!=0)
         return;
 
-    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void Aura::HandleAuraModAttackPowerPercent(bool apply, bool Real)
 {
     //UNIT_FIELD_ATTACK_POWER_MULTIPLIER = multiplier - 1
-    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_PCT, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void Aura::HandleAuraModRangedAttackPowerPercent(bool apply, bool Real)
@@ -4880,7 +4885,7 @@ void Aura::HandleAuraModRangedAttackPowerPercent(bool apply, bool Real)
         return;
 
     //UNIT_FIELD_RANGED_ATTACK_POWER_MULTIPLIER = multiplier - 1
-    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_PCT, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void Aura::HandleAuraModRangedAttackPowerOfStatPercent(bool apply, bool Real)
@@ -4930,9 +4935,9 @@ void Aura::HandleModDamageDone(bool apply, bool Real)
         // apply generic physical damage bonuses including wand case
         if (GetSpellProto()->EquippedItemClass == -1 || m_target->GetTypeId() != TYPEID_PLAYER)
         {
-            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_VALUE, float(m_modifier.m_amount), apply);
-            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_VALUE, float(m_modifier.m_amount), apply);
-            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_RANGED, TOTAL_VALUE, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_RANGED, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
         }
         else
         {
@@ -4942,9 +4947,9 @@ void Aura::HandleModDamageDone(bool apply, bool Real)
         if(m_target->GetTypeId() == TYPEID_PLAYER)
         {
             if(m_positive)
-                m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS,m_modifier.m_amount,apply);
+                m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS,m_modifier.m_amount * m_stackAmount,apply);
             else
-                m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_NEG,m_modifier.m_amount,apply);
+                m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_NEG,m_modifier.m_amount * m_stackAmount,apply);
         }
     }
 
@@ -4970,7 +4975,7 @@ void Aura::HandleModDamageDone(bool apply, bool Real)
             for(int i = SPELL_SCHOOL_HOLY; i < MAX_SPELL_SCHOOL; i++)
             {
                 if((m_modifier.m_miscvalue & (1<<i)) != 0)
-                    m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS+i,m_modifier.m_amount,apply);
+                    m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS+i,m_modifier.m_amount * m_stackAmount,apply);
             }
         }
         else
@@ -4978,7 +4983,7 @@ void Aura::HandleModDamageDone(bool apply, bool Real)
             for(int i = SPELL_SCHOOL_HOLY; i < MAX_SPELL_SCHOOL; i++)
             {
                 if((m_modifier.m_miscvalue & (1<<i)) != 0)
-                    m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_NEG+i,m_modifier.m_amount,apply);
+                    m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_NEG+i,m_modifier.m_amount * m_stackAmount,apply);
             }
         }
         Pet* pet = m_target->GetPet();
@@ -5013,9 +5018,9 @@ void Aura::HandleModDamagePercentDone(bool apply, bool Real)
         // apply generic physical damage bonuses including wand case
         if (GetSpellProto()->EquippedItemClass == -1 || m_target->GetTypeId() != TYPEID_PLAYER)
         {
-            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT, float(m_modifier.m_amount), apply);
-            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT, float(m_modifier.m_amount), apply);
-            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
         }
         else
         {
@@ -5054,7 +5059,7 @@ void Aura::HandleModOffhandDamagePercent(bool apply, bool Real)
 
     sLog.outDebug("AURA MOD OFFHAND DAMAGE");
 
-    m_target->HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 /********************************/
@@ -5067,7 +5072,7 @@ void Aura::HandleModPowerCostPCT(bool apply, bool Real)
     if(!Real)
         return;
 
-    float amount = m_modifier.m_amount/100.0f;
+    float amount = m_modifier.m_amount * m_stackAmount /100.0f;
     for(int i = 0; i < MAX_SPELL_SCHOOL; ++i)
         if(m_modifier.m_miscvalue & (1<<i))
             m_target->ApplyModSignedFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER+i,amount,apply);
@@ -5081,7 +5086,7 @@ void Aura::HandleModPowerCost(bool apply, bool Real)
 
     for(int i = 0; i < MAX_SPELL_SCHOOL; ++i)
         if(m_modifier.m_miscvalue & (1<<i))
-            m_target->ApplyModInt32Value(UNIT_FIELD_POWER_COST_MODIFIER+i,m_modifier.m_amount,apply);
+            m_target->ApplyModInt32Value(UNIT_FIELD_POWER_COST_MODIFIER+i,m_modifier.m_amount * m_stackAmount,apply);
 }
 
 /*********************************************************/
@@ -5302,7 +5307,7 @@ void Aura::HandleModRating(bool apply, bool Real)
 
     for (uint32 rating = 0; rating < MAX_COMBAT_RATING; ++rating)
         if (m_modifier.m_miscvalue & (1 << rating))
-            ((Player*)m_target)->ApplyRatingMod(CombatRating(rating), m_modifier.m_amount, apply);
+            ((Player*)m_target)->ApplyRatingMod(CombatRating(rating), m_modifier.m_amount * m_stackAmount, apply);
 }
 
 void Aura::HandleForceMoveForward(bool apply, bool Real)
@@ -5333,11 +5338,11 @@ void Aura::HandleModTargetResistance(bool apply, bool Real)
 
     // show armor penetration
     if (m_target->GetTypeId() == TYPEID_PLAYER && (m_modifier.m_miscvalue & SPELL_SCHOOL_MASK_NORMAL))
-        m_target->ApplyModInt32Value(PLAYER_FIELD_MOD_TARGET_PHYSICAL_RESISTANCE,m_modifier.m_amount, apply);
+        m_target->ApplyModInt32Value(PLAYER_FIELD_MOD_TARGET_PHYSICAL_RESISTANCE,m_modifier.m_amount * m_stackAmount, apply);
 
     // show as spell penetration only full spell penetration bonuses (all resistances except armor and holy
     if (m_target->GetTypeId() == TYPEID_PLAYER && (m_modifier.m_miscvalue & SPELL_SCHOOL_MASK_SPELL)==SPELL_SCHOOL_MASK_SPELL)
-        m_target->ApplyModInt32Value(PLAYER_FIELD_MOD_TARGET_RESISTANCE,m_modifier.m_amount, apply);
+        m_target->ApplyModInt32Value(PLAYER_FIELD_MOD_TARGET_RESISTANCE,m_modifier.m_amount * m_stackAmount, apply);
 }
 
 void Aura::HandleShieldBlockValue(bool apply, bool Real)
@@ -5347,7 +5352,7 @@ void Aura::HandleShieldBlockValue(bool apply, bool Real)
         modType = PCT_MOD;
 
     if(m_target->GetTypeId() == TYPEID_PLAYER)
-        ((Player*)m_target)->HandleBaseModValue(SHIELD_BLOCK_VALUE, modType, float(m_modifier.m_amount), apply);
+        ((Player*)m_target)->HandleBaseModValue(SHIELD_BLOCK_VALUE, modType, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void Aura::HandleAuraRetainComboPoints(bool apply, bool Real)
@@ -5365,7 +5370,7 @@ void Aura::HandleAuraRetainComboPoints(bool apply, bool Real)
     // remove only if aura expire by time (in case combo points amount change aura removed without combo points lost)
     if( !apply && m_duration==0 && target->GetComboTarget())
         if(Unit* unit = ObjectAccessor::GetUnit(*m_target,target->GetComboTarget()))
-            target->AddComboPoints(unit, -m_modifier.m_amount);
+            target->AddComboPoints(unit, -m_modifier.m_amount * m_stackAmount);
 }
 
 void Aura::HandleModUnattackable( bool Apply, bool Real )
@@ -5574,6 +5579,8 @@ void Aura::PeriodicTick()
             else
                 pdamage = uint32(m_target->GetMaxHealth()*amount/100);
 
+            pdamage *= m_stackAmount;
+
             //As of 2.2 resilience reduces damage from DoT ticks as much as the chance to not be critically hit
             // Reduce dot damage from resilience for players
             if (m_target->GetTypeId()==TYPEID_PLAYER)
@@ -5692,6 +5699,8 @@ void Aura::PeriodicTick()
                 }
             }
 
+            pdamage *= m_stackAmount;
+
             //As of 2.2 resilience reduces damage from DoT ticks as much as the chance to not be critically hit
             // Reduce dot damage from resilience for players
             if (m_target->GetTypeId()==TYPEID_PLAYER)
@@ -5761,6 +5770,8 @@ void Aura::PeriodicTick()
 
             pdamage = pCaster->SpellHealingBonus(GetSpellProto(), pdamage, DOT, m_target);
 
+            pdamage *= m_stackAmount;
+
             sLog.outDetail("PeriodicTick: %u (TypeId: %u) heal of %u (TypeId: %u) for %u health inflicted by %u",
                 GUID_LOPART(GetCasterGUID()), GuidHigh2TypeId(GUID_HIPART(GetCasterGUID())), m_target->GetGUIDLow(), m_target->GetTypeId(), pdamage, GetId());
 
@@ -5842,6 +5853,8 @@ void Aura::PeriodicTick()
             // ignore non positive values (can be result apply spellmods to aura damage
             uint32 pdamage = m_modifier.m_amount > 0 ? m_modifier.m_amount : 0;
 
+            pdamage *= m_stackAmount;
+
             sLog.outDetail("PeriodicTick: %u (TypeId: %u) power leech of %u (TypeId: %u) for %u dmg inflicted by %u",
                 GUID_LOPART(GetCasterGUID()), GuidHigh2TypeId(GUID_HIPART(GetCasterGUID())), m_target->GetGUIDLow(), m_target->GetTypeId(), pdamage, GetId());
 
@@ -5897,6 +5910,8 @@ void Aura::PeriodicTick()
             // ignore non positive values (can be result apply spellmods to aura damage
             uint32 pdamage = m_modifier.m_amount > 0 ? m_modifier.m_amount : 0;
 
+            pdamage *= m_stackAmount;
+
             sLog.outDetail("PeriodicTick: %u (TypeId: %u) energize %u (TypeId: %u) for %u dmg inflicted by %u",
                 GUID_LOPART(GetCasterGUID()), GuidHigh2TypeId(GUID_HIPART(GetCasterGUID())), m_target->GetGUIDLow(), m_target->GetTypeId(), pdamage, GetId());
 
@@ -5931,6 +5946,8 @@ void Aura::PeriodicTick()
 
             uint32 pdamage = uint32(m_target->GetMaxPower(POWER_MANA) * amount/100);
 
+            pdamage *= m_stackAmount;
+
             sLog.outDetail("PeriodicTick: %u (TypeId: %u) energize %u (TypeId: %u) for %u mana inflicted by %u",
                 GUID_LOPART(GetCasterGUID()), GuidHigh2TypeId(GUID_HIPART(GetCasterGUID())), m_target->GetGUIDLow(), m_target->GetTypeId(), pdamage, GetId());
 
@@ -5965,6 +5982,8 @@ void Aura::PeriodicTick()
 
             int32 pdamage = m_modifier.m_amount > 0 ? m_modifier.m_amount : 0;
 
+            pdamage *= m_stackAmount;
+
             Powers powerType = Powers(m_modifier.m_miscvalue);
 
             if(!m_target->isAlive() || m_target->getPowerType() != powerType)
diff --git a/src/game/SpellAuras.h b/src/game/SpellAuras.h
index ea4f25f..c58ebf2 100644
--- a/src/game/SpellAuras.h
+++ b/src/game/SpellAuras.h
@@ -228,6 +228,7 @@ class MANGOS_DLL_SPEC Aura
         time_t GetAuraApplyTime() { return m_applyTime; }
         void UpdateAuraDuration();
         void SendAuraDurationForCaster(Player* caster);
+        void UpdateSlotCounterAndDuration();
 
         uint64 const& GetCasterGUID() const { return m_caster_guid; }
         Unit* GetCaster() const;
@@ -281,6 +282,8 @@ class MANGOS_DLL_SPEC Aura
 
         int32 m_procCharges;
 
+        int32 m_stackAmount;
+
         virtual Unit* GetTriggerTarget() const { return m_target; }
 
         // add/remove SPELL_AURA_MOD_SHAPESHIFT (36) linked auras
@@ -328,7 +331,6 @@ class MANGOS_DLL_SPEC Aura
         uint32 m_PeriodicEventId;
         DiminishingGroup m_AuraDRGroup;
     private:
-        void UpdateSlotCounterAndDuration(bool add);
         void CleanupTriggeredSpells();
         void SetAura(uint32 slot, bool remove) { m_target->SetUInt32Value(UNIT_FIELD_AURA + slot, remove ? 0 : GetId()); }
         void SetAuraFlag(uint32 slot, bool add);
diff --git a/src/game/SpellEffects.cpp b/src/game/SpellEffects.cpp
index ef129fa..b9e0c9d 100644
--- a/src/game/SpellEffects.cpp
+++ b/src/game/SpellEffects.cpp
@@ -915,16 +915,12 @@ void Spell::EffectDummy(uint32 i)
                 }
                 case 28730:                                 // Arcane Torrent (Mana)
                 {
-                    int32 count = 0;
-                    Unit::AuraList const& m_dummyAuras = m_caster->GetAurasByType(SPELL_AURA_DUMMY);
-                    for(Unit::AuraList::const_iterator i = m_dummyAuras.begin(); i != m_dummyAuras.end(); ++i)
-                        if ((*i)->GetId() == 28734)
-                            ++count;
-                    if (count)
-                    {
-                        m_caster->RemoveAurasDueToSpell(28734);
-                        int32 bp = damage * count;
+                    Aura * dummy = m_caster->GetDummyAura(28734);
+                    if (dummy)
+                    {                        
+                        int32 bp = damage * dummy->m_stackAmount;
                         m_caster->CastCustomSpell(m_caster, 28733, &bp, NULL, NULL, true);
+                        m_caster->RemoveAurasDueToSpell(28734);
                     }
                     return;
                 }
@@ -2332,7 +2328,7 @@ void Spell::EffectHeal( uint32 /*i*/ )
             Unit::AuraList const& mDummyAuras = m_caster->GetAurasByType(SPELL_AURA_DUMMY);
             for(Unit::AuraList::const_iterator i = mDummyAuras.begin();i != mDummyAuras.end(); ++i)
                 if((*i)->GetId() == 45062)
-                    damageAmount+=(*i)->GetModifier()->m_amount;
+                    damageAmount+=(*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
             if (damageAmount)
                 m_caster->RemoveAurasDueToSpell(45062);
 
diff --git a/src/game/StatSystem.cpp b/src/game/StatSystem.cpp
index f215701..689c372 100644
--- a/src/game/StatSystem.cpp
+++ b/src/game/StatSystem.cpp
@@ -153,7 +153,7 @@ void Player::UpdateArmor()
     {
         Modifier* mod = (*i)->GetModifier();
         if(mod->m_miscvalue & SPELL_SCHOOL_MASK_NORMAL)
-            value += int32(GetStat(Stats((*i)->GetMiscBValue())) * mod->m_amount / 100.0f);
+            value += int32(GetStat(Stats((*i)->GetMiscBValue())) * mod->m_amount * (*i)->m_stackAmount / 100.0f);
     }
 
     value *= GetModifierValue(unitMod, TOTAL_PCT);
@@ -311,7 +311,7 @@ void Player::UpdateAttackPowerAndDamage(bool ranged )
     {
         AuraList const& mRAPbyIntellect = GetAurasByType(SPELL_AURA_MOD_RANGED_ATTACK_POWER_OF_STAT_PERCENT);
         for(AuraList::const_iterator i = mRAPbyIntellect.begin();i != mRAPbyIntellect.end(); ++i)
-            attPowerMod += int32(GetStat(Stats((*i)->GetModifier()->m_miscvalue)) * (*i)->GetModifier()->m_amount / 100.0f);
+            attPowerMod += int32(GetStat(Stats((*i)->GetModifier()->m_miscvalue)) * (*i)->GetModifier()->m_amount * (*i)->m_stackAmount / 100.0f);
     }
 
     float attPowerMultiplier = GetModifierValue(unitMod, TOTAL_PCT) - 1.0f;
@@ -393,6 +393,12 @@ void Player::CalculateMinMaxDamage(WeaponAttackType attType, bool normalized, fl
         weapon_maxdamage += GetAmmoDPS() * att_speed;
     }
 
+    if (attType == BASE_ATTACK)
+    {
+        int32 ModSpeed = GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKSPEED);
+        base_pct = base_pct * 100.0f/(100.0f+float(ModSpeed));
+    }
+
     min_damage = ((base_value + weapon_mindamage) * base_pct + total_value) * total_pct;
     max_damage = ((base_value + weapon_maxdamage) * base_pct + total_value) * total_pct;
 }
@@ -570,10 +576,10 @@ void Player::UpdateExpertise(WeaponAttackType attack)
     {
         // item neutral spell
         if((*itr)->GetSpellProto()->EquippedItemClass == -1)
-            expertise += (*itr)->GetModifier()->m_amount;
+            expertise += (*itr)->GetModifier()->m_amount * (*itr)->m_stackAmount;
         // item dependent spell
         else if(weapon && weapon->IsFitToSpellRequirements((*itr)->GetSpellProto()))
-            expertise += (*itr)->GetModifier()->m_amount;
+            expertise += (*itr)->GetModifier()->m_amount * (*itr)->m_stackAmount;
     }
 
     if(expertise < 0)
@@ -603,7 +609,7 @@ void Player::UpdateManaRegen()
     for(AuraList::const_iterator i = regenAura.begin();i != regenAura.end(); ++i)
     {
         Modifier* mod = (*i)->GetModifier();
-        power_regen_mp5 += GetStat(Stats(mod->m_miscvalue)) * mod->m_amount / 500.0f;
+        power_regen_mp5 += GetStat(Stats(mod->m_miscvalue)) * mod->m_amount * (*i)->m_stackAmount / 500.0f;
     }
 
     // Bonus from some dummy auras
@@ -731,6 +737,9 @@ void Creature::UpdateDamagePhysical(WeaponAttackType attType)
     float weapon_mindamage = GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE);
     float weapon_maxdamage = GetWeaponDamageRange(BASE_ATTACK, MAXDAMAGE);
 
+    int32 ModSpeed = GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKSPEED);
+    base_pct = base_pct * 100.0f/(100.0f+float(ModSpeed));
+
     float mindamage = ((base_value + weapon_mindamage) * base_pct + total_value) * total_pct ;
     float maxdamage = ((base_value + weapon_maxdamage) * base_pct + total_value) * total_pct ;
 
@@ -936,6 +945,9 @@ void Pet::UpdateDamagePhysical(WeaponAttackType attType)
     float weapon_mindamage = GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE);
     float weapon_maxdamage = GetWeaponDamageRange(BASE_ATTACK, MAXDAMAGE);
 
+    int32 ModSpeed = GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKSPEED);
+    base_pct = base_pct * 100.0f/(100.0f+float(ModSpeed));
+
     float mindamage = ((base_value + weapon_mindamage) * base_pct + total_value) * total_pct;
     float maxdamage = ((base_value + weapon_maxdamage) * base_pct + total_value) * total_pct;
 
diff --git a/src/game/Unit.cpp b/src/game/Unit.cpp
index b64f538..4bf308e 100644
--- a/src/game/Unit.cpp
+++ b/src/game/Unit.cpp
@@ -437,19 +437,6 @@ bool Unit::HasAuraType(AuraType auraType) const
     return (!m_modAuras[auraType].empty());
 }
 
-/* Called by DealDamage for auras that have a chance to be dispelled on damage taken. */
-void Unit::RemoveSpellbyDamageTaken(AuraType auraType, uint32 damage)
-{
-    if(!HasAuraType(auraType))
-        return;
-
-    // The chance to dispel an aura depends on the damage taken with respect to the casters level.
-    uint32 max_dmg = getLevel() > 8 ? 25 * getLevel() - 150 : 50;
-    float chance = float(damage) / max_dmg * 100.0f;
-    if (roll_chance_f(chance))
-        RemoveSpellsCausingAura(auraType);
-}
-
 uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDamage, DamageEffectType damagetype, SpellSchoolMask damageSchoolMask, SpellEntry const *spellProto, bool durabilityLoss)
 {
     if (!pVictim->isAlive() || pVictim->isInFlight() || pVictim->GetTypeId() == TYPEID_UNIT && ((Creature*)pVictim)->IsInEvadeMode())
@@ -497,11 +484,6 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
         return 0;
     }
 
-    pVictim->RemoveSpellbyDamageTaken(SPELL_AURA_MOD_FEAR, damage);
-    // root type spells do not dispel the root effect
-    if(!spellProto || spellProto->Mechanic != MECHANIC_ROOT)
-        pVictim->RemoveSpellbyDamageTaken(SPELL_AURA_MOD_ROOT, damage);
-
     if(pVictim->GetTypeId() != TYPEID_PLAYER)
     {
         // no xp,health if type 8 /critters/
@@ -853,6 +835,16 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
                     // FIXME: this may cause the auras with proc chance to be rerolled several times
                     next = vAuras.begin();
                 }
+            } 
+            else if ( (se->Attributes & 0x40000000LL) && (!spellProto || se->Id != spellProto->Id) )
+            {
+                uint32 max_dmg = pVictim->getLevel() > 8 ? 25 * pVictim->getLevel() - 150 : 50;
+                float chance = float(damage) / max_dmg * 100.0f;
+                if (roll_chance_f(chance))
+                {
+                    pVictim->RemoveAurasDueToSpell(i->second->GetId());
+                    next = vAuras.begin();
+                }
             }
         }
 
@@ -1129,7 +1121,7 @@ void Unit::DealFlatDamage(Unit *pVictim, SpellEntry const *spellInfo, uint32 *da
                     AuraList const& mDamageDoneVersus = GetAurasByType(SPELL_AURA_MOD_CRIT_PERCENT_VERSUS);
                     for(AuraList::const_iterator i = mDamageDoneVersus.begin();i != mDamageDoneVersus.end(); ++i)
                         if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-                            bonusDmg = uint32(bonusDmg * ((*i)->GetModifier()->m_amount+100.0f)/100.0f);
+                            bonusDmg = uint32(bonusDmg * ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount +100.0f)/100.0f);
 
                     *damage += bonusDmg;
 
@@ -1811,7 +1803,7 @@ void Unit::DoAttackDamage (Unit *pVictim, uint32 *damage, CleanDamage *cleanDama
                 AuraList const& mDamageDoneVersus = GetAurasByType(SPELL_AURA_MOD_CRIT_PERCENT_VERSUS);
                 for(AuraList::const_iterator i = mDamageDoneVersus.begin();i != mDamageDoneVersus.end(); ++i)
                     if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-                        crit_bonus = uint32(crit_bonus * ((*i)->GetModifier()->m_amount+100.0f)/100.0f);
+                        crit_bonus = uint32(crit_bonus * ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount +100.0f)/100.0f);
             }
 
             *damage += crit_bonus;
@@ -2146,7 +2138,7 @@ void Unit::DoAttackDamage (Unit *pVictim, uint32 *damage, CleanDamage *cleanDama
         if (alreadyDone.find(*i) == alreadyDone.end())
         {
             alreadyDone.insert(*i);
-            pVictim->SpellNonMeleeDamageLog(this, (*i)->GetId(), (*i)->GetModifier()->m_amount, false, false);
+            pVictim->SpellNonMeleeDamageLog(this, (*i)->GetId(), (*i)->GetModifier()->m_amount * (*i)->m_stackAmount, false, false);
             if (pVictim->m_removedAuras > removedAuras)
             {
                 removedAuras = pVictim->m_removedAuras;
@@ -2819,7 +2811,7 @@ SpellMissInfo Unit::SpellHitResult(Unit *pVictim, SpellEntry const *spell, bool
         {
             if((*i)->GetModifier()->m_miscvalue & GetSpellSchoolMask(spell))
             {
-                int32 reflectchance = (*i)->GetModifier()->m_amount;
+                int32 reflectchance = (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
                 if (reflectchance > 0 && roll_chance_i(reflectchance))
                 {
                     if((*i)->m_procCharges > 0)
@@ -2837,7 +2829,7 @@ SpellMissInfo Unit::SpellHitResult(Unit *pVictim, SpellEntry const *spell, bool
         Unit::AuraList const& mReflectSpells = pVictim->GetAurasByType(SPELL_AURA_REFLECT_SPELLS);
         for(Unit::AuraList::const_iterator i = mReflectSpells.begin(); i != mReflectSpells.end(); ++i)
         {
-            int32 reflectchance = (*i)->GetModifier()->m_amount;
+            int32 reflectchance = (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
             if (reflectchance > 0 && roll_chance_i(reflectchance))
             {
                 if((*i)->m_procCharges > 0)
@@ -3452,7 +3444,7 @@ int32 Unit::GetTotalAuraModifier(AuraType auratype) const
 
     AuraList const& mTotalAuraList = GetAurasByType(auratype);
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
-        modifier += (*i)->GetModifier()->m_amount;
+        modifier += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
 
     return modifier;
 }
@@ -3463,7 +3455,7 @@ float Unit::GetTotalAuraMultiplier(AuraType auratype) const
 
     AuraList const& mTotalAuraList = GetAurasByType(auratype);
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
-        multiplier *= (100.0f + (*i)->GetModifier()->m_amount)/100.0f;
+        multiplier *= (100.0f + (*i)->GetModifier()->m_amount * (*i)->m_stackAmount)/100.0f;
 
     return multiplier;
 }
@@ -3474,8 +3466,11 @@ int32 Unit::GetMaxPositiveAuraModifier(AuraType auratype) const
 
     AuraList const& mTotalAuraList = GetAurasByType(auratype);
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
-        if ((*i)->GetModifier()->m_amount > modifier)
-            modifier = (*i)->GetModifier()->m_amount;
+    {
+        int32 amount = (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
+        if (amount > modifier)
+            modifier = amount;
+    }
 
     return modifier;
 }
@@ -3486,8 +3481,11 @@ int32 Unit::GetMaxNegativeAuraModifier(AuraType auratype) const
 
     AuraList const& mTotalAuraList = GetAurasByType(auratype);
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
-        if ((*i)->GetModifier()->m_amount < modifier)
-            modifier = (*i)->GetModifier()->m_amount;
+    {
+        int32 amount = (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
+        if (amount < modifier)
+            modifier = amount;
+    }
 
     return modifier;
 }
@@ -3501,7 +3499,7 @@ int32 Unit::GetTotalAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask)
     {
         Modifier* mod = (*i)->GetModifier();
         if (mod->m_miscvalue & misc_mask)
-            modifier += mod->m_amount;
+            modifier += mod->m_amount * (*i)->m_stackAmount;
     }
     return modifier;
 }
@@ -3515,7 +3513,7 @@ float Unit::GetTotalAuraMultiplierByMiscMask(AuraType auratype, uint32 misc_mask
     {
         Modifier* mod = (*i)->GetModifier();
         if (mod->m_miscvalue & misc_mask)
-            multiplier *= (100.0f + mod->m_amount)/100.0f;
+            multiplier *= (100.0f + mod->m_amount * (*i)->m_stackAmount)/100.0f;
     }
     return multiplier;
 }
@@ -3528,8 +3526,9 @@ int32 Unit::GetMaxPositiveAuraModifierByMiscMask(AuraType auratype, uint32 misc_
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
     {
         Modifier* mod = (*i)->GetModifier();
-        if (mod->m_miscvalue & misc_mask && mod->m_amount > modifier)
-            modifier = mod->m_amount;
+        int32 amount = mod->m_amount * (*i)->m_stackAmount;
+        if (mod->m_miscvalue & misc_mask && amount > modifier)
+            modifier = amount;
     }
 
     return modifier;
@@ -3543,8 +3542,9 @@ int32 Unit::GetMaxNegativeAuraModifierByMiscMask(AuraType auratype, uint32 misc_
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
     {
         Modifier* mod = (*i)->GetModifier();
-        if (mod->m_miscvalue & misc_mask && mod->m_amount < modifier)
-            modifier = mod->m_amount;
+        int32 amount = mod->m_amount * (*i)->m_stackAmount;
+        if (mod->m_miscvalue & misc_mask && amount < modifier)
+            modifier = amount;
     }
 
     return modifier;
@@ -3559,7 +3559,7 @@ int32 Unit::GetTotalAuraModifierByMiscValue(AuraType auratype, int32 misc_value)
     {
         Modifier* mod = (*i)->GetModifier();
         if (mod->m_miscvalue == misc_value)
-            modifier += mod->m_amount;
+            modifier += mod->m_amount * (*i)->m_stackAmount;
     }
     return modifier;
 }
@@ -3573,7 +3573,7 @@ float Unit::GetTotalAuraMultiplierByMiscValue(AuraType auratype, int32 misc_valu
     {
         Modifier* mod = (*i)->GetModifier();
         if (mod->m_miscvalue == misc_value)
-            multiplier *= (100.0f + mod->m_amount)/100.0f;
+            multiplier *= (100.0f + mod->m_amount * (*i)->m_stackAmount)/100.0f;
     }
     return multiplier;
 }
@@ -3586,8 +3586,9 @@ int32 Unit::GetMaxPositiveAuraModifierByMiscValue(AuraType auratype, int32 misc_
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
     {
         Modifier* mod = (*i)->GetModifier();
-        if (mod->m_miscvalue == misc_value && mod->m_amount > modifier)
-            modifier = mod->m_amount;
+        int32 amount = mod->m_amount * (*i)->m_stackAmount;
+        if (mod->m_miscvalue == misc_value && amount > modifier)
+            modifier = amount;
     }
 
     return modifier;
@@ -3601,8 +3602,9 @@ int32 Unit::GetMaxNegativeAuraModifierByMiscValue(AuraType auratype, int32 misc_
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
     {
         Modifier* mod = (*i)->GetModifier();
-        if (mod->m_miscvalue == misc_value && mod->m_amount < modifier)
-            modifier = mod->m_amount;
+        int32 amount = mod->m_amount * (*i)->m_stackAmount;
+        if (mod->m_miscvalue == misc_value && amount < modifier)
+            modifier = amount;
     }
 
     return modifier;
@@ -3641,8 +3643,10 @@ bool Unit::AddAura(Aura *Aur)
             // replace aura if next will > spell StackAmount
             if(aurSpellInfo->StackAmount)
             {
-                if(m_Auras.count(spair) >= aurSpellInfo->StackAmount)
-                    RemoveAura(i,AURA_REMOVE_BY_STACK);
+                Aur->m_stackAmount = i->second->m_stackAmount;
+                if(Aur->m_stackAmount < aurSpellInfo->StackAmount)
+                    ++Aur->m_stackAmount;
+                RemoveAura(i,AURA_REMOVE_BY_STACK);
             }
             // if StackAmount==0 not allow auras from same caster
             else
@@ -4025,7 +4029,19 @@ void Unit::RemoveSingleAuraFromStack(uint32 spellId, uint32 effindex)
 {
     AuraMap::iterator iter = m_Auras.find(spellEffectPair(spellId, effindex));
     if(iter != m_Auras.end())
+    {
+        if(iter->second->m_stackAmount > 1)
+        {
+            // reapply modifier with reduced stack amount
+            iter->second->ApplyModifier(false,true);
+            --iter->second->m_stackAmount;
+            iter->second->ApplyModifier(true,true);
+
+            iter->second->UpdateSlotCounterAndDuration();
+            return; // not remove aura if stack amount > 1
+        }
         RemoveAura(iter);
+    }
 }
 
 void Unit::RemoveAurasDueToSpell(uint32 spellId, Aura* except)
@@ -4130,6 +4146,9 @@ void Unit::RemoveAura(AuraMap::iterator &i, AuraRemoveMode mode)
 
     sLog.outDebug("Aura %u now is remove mode %d",Aur->GetModifier()->m_auraname, mode);
     Aur->ApplyModifier(false,true);
+
+    Aur->m_stackAmount = 0;
+
     Aur->_RemoveAura();
     delete Aur;
 
@@ -6088,14 +6107,12 @@ bool Unit::HandleProcTriggerSpell(Unit *pVictim, uint32 damage, Aura* triggeredB
                         ((Player*)this)->AddSpellCooldown(37657,0,time(NULL)+(roll_chance_i(50) ? 2 : 3));
 
                         // counting
-                        uint32 count = 0;
-                        AuraList const& dummyAura = GetAurasByType(SPELL_AURA_DUMMY);
-                        for(AuraList::const_iterator itr = dummyAura.begin(); itr != dummyAura.end(); ++itr)
-                            if((*itr)->GetId()==37658)
-                                ++count;
+                        Aura * dummy = GetDummyAura(37658);
+                        if (!dummy)
+                            return false;
 
                         // release at 3 aura in stack
-                        if(count <= 2)
+                        if(dummy->m_stackAmount <= 2)
                             return true;                    // main triggered spell casted anyway
 
                         RemoveAurasDueToSpell(37658);
@@ -7217,7 +7234,7 @@ uint32 Unit::SpellDamageBonus(Unit *pVictim, SpellEntry const *spellProto, uint3
             (*i)->GetSpellProto()->EquippedItemInventoryTypeMask == 0 )
                                                             // 0 == any inventory type (not wand then)
         {
-            DoneTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+            DoneTotalMod *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount +100.0f)/100.0f;
         }
     }
 
@@ -7225,13 +7242,13 @@ uint32 Unit::SpellDamageBonus(Unit *pVictim, SpellEntry const *spellProto, uint3
     AuraList const& mDamageDoneVersus = GetAurasByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS);
     for(AuraList::const_iterator i = mDamageDoneVersus.begin();i != mDamageDoneVersus.end(); ++i)
         if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-            DoneTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+            DoneTotalMod *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount +100.0f)/100.0f;
 
     // ..taken
     AuraList const& mModDamagePercentTaken = pVictim->GetAurasByType(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN);
     for(AuraList::const_iterator i = mModDamagePercentTaken.begin(); i != mModDamagePercentTaken.end(); ++i)
         if( (*i)->GetModifier()->m_miscvalue & GetSpellSchoolMask(spellProto) )
-            TakenTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+            TakenTotalMod *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount +100.0f)/100.0f;
 
     // .. taken pct: scripted (increases damage of * against targets *)
     AuraList const& mOverrideClassScript = GetAurasByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
@@ -7542,7 +7559,7 @@ int32 Unit::SpellBaseDamageBonus(SpellSchoolMask schoolMask)
                                                             // -1 == any item class (not wand then)
         (*i)->GetSpellProto()->EquippedItemInventoryTypeMask == 0 )
                                                             // 0 == any inventory type (not wand then)
-            DoneAdvertisedBenefit += (*i)->GetModifier()->m_amount;
+            DoneAdvertisedBenefit += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
 
     if (GetTypeId() == TYPEID_PLAYER)
     {
@@ -7560,14 +7577,14 @@ int32 Unit::SpellBaseDamageBonus(SpellSchoolMask schoolMask)
                 if(eff < 2 && iSpellProto->EffectApplyAuraName[eff+1]==SPELL_AURA_MOD_SPELL_HEALING_OF_STAT_PERCENT)
                     usedStat = Stats(iSpellProto->EffectMiscValue[eff+1]);
 
-                DoneAdvertisedBenefit += int32(GetStat(usedStat) * (*i)->GetModifier()->m_amount / 100.0f);
+                DoneAdvertisedBenefit += int32(GetStat(usedStat) * (*i)->GetModifier()->m_amount * (*i)->m_stackAmount / 100.0f);
             }
         }
         // ... and attack power
         AuraList const& mDamageDonebyAP = GetAurasByType(SPELL_AURA_MOD_SPELL_DAMAGE_OF_ATTACK_POWER);
         for(AuraList::const_iterator i =mDamageDonebyAP.begin();i != mDamageDonebyAP.end(); ++i)
             if ((*i)->GetModifier()->m_miscvalue & schoolMask)
-                DoneAdvertisedBenefit += int32(GetTotalAttackPowerValue(BASE_ATTACK) * (*i)->GetModifier()->m_amount / 100.0f);
+                DoneAdvertisedBenefit += int32(GetTotalAttackPowerValue(BASE_ATTACK) * (*i)->GetModifier()->m_amount * (*i)->m_stackAmount / 100.0f);
 
     }
     return DoneAdvertisedBenefit;
@@ -7582,13 +7599,13 @@ int32 Unit::SpellBaseDamageBonusForVictim(SpellSchoolMask schoolMask, Unit *pVic
     AuraList const& mDamageDoneCreature = GetAurasByType(SPELL_AURA_MOD_DAMAGE_DONE_CREATURE);
     for(AuraList::const_iterator i = mDamageDoneCreature.begin();i != mDamageDoneCreature.end(); ++i)
         if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-            TakenAdvertisedBenefit += (*i)->GetModifier()->m_amount;
+            TakenAdvertisedBenefit += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
 
     // ..taken
     AuraList const& mDamageTaken = pVictim->GetAurasByType(SPELL_AURA_MOD_DAMAGE_TAKEN);
     for(AuraList::const_iterator i = mDamageTaken.begin();i != mDamageTaken.end(); ++i)
         if(((*i)->GetModifier()->m_miscvalue & schoolMask) != 0)
-            TakenAdvertisedBenefit += (*i)->GetModifier()->m_amount;
+            TakenAdvertisedBenefit += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
 
     return TakenAdvertisedBenefit;
 }
@@ -7791,6 +7808,11 @@ uint32 Unit::SpellHealingBonus(SpellEntry const *spellProto, uint32 healamount,
         // Exception
         switch (spellProto->SpellFamilyName)
         {
+            case  SPELLFAMILY_GENERIC:      
+                // Frenzied Regeneration triggered Spell
+                if( spellProto->Id == 22845 )
+                    CastingTime = 0;
+                break;      
             case  SPELLFAMILY_SHAMAN:
                 // Healing stream from totem (add 6% per tick from hill bonus owner)
                 if (spellProto->SpellFamilyFlags & 0x000000002000LL)
@@ -7856,7 +7878,7 @@ uint32 Unit::SpellHealingBonus(SpellEntry const *spellProto, uint32 healamount,
     // Healing done percent
     AuraList const& mHealingDonePct = GetAurasByType(SPELL_AURA_MOD_HEALING_DONE_PERCENT);
     for(AuraList::const_iterator i = mHealingDonePct.begin();i != mHealingDonePct.end(); ++i)
-        heal *= (100.0f + (*i)->GetModifier()->m_amount) / 100.0f;
+        heal *= (100.0f + (*i)->GetModifier()->m_amount * (*i)->m_stackAmount) / 100.0f;
 
     // apply spellmod to Done amount
     if(Player* modOwner = GetSpellModOwner())
@@ -7897,7 +7919,7 @@ int32 Unit::SpellBaseHealingBonus(SpellSchoolMask schoolMask)
     AuraList const& mHealingDone = GetAurasByType(SPELL_AURA_MOD_HEALING_DONE);
     for(AuraList::const_iterator i = mHealingDone.begin();i != mHealingDone.end(); ++i)
         if(((*i)->GetModifier()->m_miscvalue & schoolMask) != 0)
-            AdvertisedBenefit += (*i)->GetModifier()->m_amount;
+            AdvertisedBenefit += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
 
     // Healing bonus of spirit, intellect and strength
     if (GetTypeId() == TYPEID_PLAYER)
@@ -7908,14 +7930,14 @@ int32 Unit::SpellBaseHealingBonus(SpellSchoolMask schoolMask)
         {
             // stat used dependent from misc value (stat index)
             Stats usedStat = Stats((*i)->GetSpellProto()->EffectMiscValue[(*i)->GetEffIndex()]);
-            AdvertisedBenefit += int32(GetStat(usedStat) * (*i)->GetModifier()->m_amount / 100.0f);
+            AdvertisedBenefit += int32(GetStat(usedStat) * (*i)->GetModifier()->m_amount * (*i)->m_stackAmount / 100.0f);
         }
 
         // ... and attack power
         AuraList const& mHealingDonebyAP = GetAurasByType(SPELL_AURA_MOD_SPELL_HEALING_OF_ATTACK_POWER);
         for(AuraList::const_iterator i = mHealingDonebyAP.begin();i != mHealingDonebyAP.end(); ++i)
             if ((*i)->GetModifier()->m_miscvalue & schoolMask)
-                AdvertisedBenefit += int32(GetTotalAttackPowerValue(BASE_ATTACK) * (*i)->GetModifier()->m_amount / 100.0f);
+                AdvertisedBenefit += int32(GetTotalAttackPowerValue(BASE_ATTACK) * (*i)->GetModifier()->m_amount * (*i)->m_stackAmount / 100.0f);
     }
     return AdvertisedBenefit;
 }
@@ -7926,7 +7948,7 @@ int32 Unit::SpellBaseHealingBonusForVictim(SpellSchoolMask schoolMask, Unit *pVi
     AuraList const& mDamageTaken = pVictim->GetAurasByType(SPELL_AURA_MOD_HEALING);
     for(AuraList::const_iterator i = mDamageTaken.begin();i != mDamageTaken.end(); ++i)
         if(((*i)->GetModifier()->m_miscvalue & schoolMask) != 0)
-            AdvertisedBenefit += (*i)->GetModifier()->m_amount;
+            AdvertisedBenefit += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
     return AdvertisedBenefit;
 }
 
@@ -8079,7 +8101,7 @@ void Unit::MeleeDamageBonus(Unit *pVictim, uint32 *pdamage,WeaponAttackType attT
     AuraList const& mDamageDoneCreature = GetAurasByType(SPELL_AURA_MOD_DAMAGE_DONE_CREATURE);
     for(AuraList::const_iterator i = mDamageDoneCreature.begin();i != mDamageDoneCreature.end(); ++i)
         if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-            DoneFlatBenefit += (*i)->GetModifier()->m_amount;
+            DoneFlatBenefit += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
 
     // ..done
     // SPELL_AURA_MOD_DAMAGE_DONE included in weapon damage
@@ -8094,7 +8116,7 @@ void Unit::MeleeDamageBonus(Unit *pVictim, uint32 *pdamage,WeaponAttackType attT
         AuraList const& mCreatureAttackPower = GetAurasByType(SPELL_AURA_MOD_RANGED_ATTACK_POWER_VERSUS);
         for(AuraList::const_iterator i = mCreatureAttackPower.begin();i != mCreatureAttackPower.end(); ++i)
             if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-                APbonus += (*i)->GetModifier()->m_amount;
+                APbonus += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
     }
     else
     {
@@ -8104,7 +8126,7 @@ void Unit::MeleeDamageBonus(Unit *pVictim, uint32 *pdamage,WeaponAttackType attT
         AuraList const& mCreatureAttackPower = GetAurasByType(SPELL_AURA_MOD_MELEE_ATTACK_POWER_VERSUS);
         for(AuraList::const_iterator i = mCreatureAttackPower.begin();i != mCreatureAttackPower.end(); ++i)
             if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-                APbonus += (*i)->GetModifier()->m_amount;
+                APbonus += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
     }
 
     if (APbonus!=0)                                         // Can be negative
@@ -8129,7 +8151,7 @@ void Unit::MeleeDamageBonus(Unit *pVictim, uint32 *pdamage,WeaponAttackType attT
     AuraList const& mDamageTaken = pVictim->GetAurasByType(SPELL_AURA_MOD_DAMAGE_TAKEN);
     for(AuraList::const_iterator i = mDamageTaken.begin();i != mDamageTaken.end(); ++i)
         if((*i)->GetModifier()->m_miscvalue & GetMeleeDamageSchoolMask())
-            TakenFlatBenefit += (*i)->GetModifier()->m_amount;
+            TakenFlatBenefit += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
 
     if(attType!=RANGED_ATTACK)
         TakenFlatBenefit += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN);
@@ -8147,13 +8169,13 @@ void Unit::MeleeDamageBonus(Unit *pVictim, uint32 *pdamage,WeaponAttackType attT
     AuraList const& mDamageDoneVersus = GetAurasByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS);
     for(AuraList::const_iterator i = mDamageDoneVersus.begin();i != mDamageDoneVersus.end(); ++i)
         if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-            DoneTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+            DoneTotalMod *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount+100.0f)/100.0f;
 
     // ..taken
     AuraList const& mModDamagePercentTaken = pVictim->GetAurasByType(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN);
     for(AuraList::const_iterator i = mModDamagePercentTaken.begin(); i != mModDamagePercentTaken.end(); ++i)
         if((*i)->GetModifier()->m_miscvalue & GetMeleeDamageSchoolMask())
-            TakenTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+            TakenTotalMod *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount+100.0f)/100.0f;
 
     // .. taken pct: dummy auras
     AuraList const& mDummyAuras = pVictim->GetAurasByType(SPELL_AURA_DUMMY);
@@ -8211,13 +8233,13 @@ void Unit::MeleeDamageBonus(Unit *pVictim, uint32 *pdamage,WeaponAttackType attT
     {
         AuraList const& mModMeleeDamageTakenPercent = pVictim->GetAurasByType(SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN_PCT);
         for(AuraList::const_iterator i = mModMeleeDamageTakenPercent.begin(); i != mModMeleeDamageTakenPercent.end(); ++i)
-            TakenTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+            TakenTotalMod *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount+100.0f)/100.0f;
     }
     else
     {
         AuraList const& mModRangedDamageTakenPercent = pVictim->GetAurasByType(SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN_PCT);
         for(AuraList::const_iterator i = mModRangedDamageTakenPercent.begin(); i != mModRangedDamageTakenPercent.end(); ++i)
-            TakenTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+            TakenTotalMod *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount+100.0f)/100.0f;
     }
 
     float tmpDamage = float(int32(*pdamage) + DoneFlatBenefit) * DoneTotalMod;
diff --git a/src/game/Unit.h b/src/game/Unit.h
index 5d598fb..42374c5 100644
--- a/src/game/Unit.h
+++ b/src/game/Unit.h
@@ -910,8 +910,6 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
 
         bool isFrozen() const;
 
-        void RemoveSpellbyDamageTaken(AuraType auraType, uint32 damage);
-
         bool isTargetableForAttack() const;
         virtual bool IsInWater() const;
         virtual bool IsUnderWater() const;
diff --git a/src/game/World.cpp b/src/game/World.cpp
index 11b95cf..52a8ed8 100644
--- a/src/game/World.cpp
+++ b/src/game/World.cpp
@@ -41,6 +41,7 @@
 #include "Database/DBCStores.h"
 #include "LootMgr.h"
 #include "ItemEnchantmentMgr.h"
+#include "AuctionHouseBot.h"
 #include "MapManager.h"
 #include "ScriptCalls.h"
 #include "CreatureAIRegistry.h"
@@ -58,6 +59,7 @@
 #include "WaypointManager.h"
 #include "GMTicketMgr.h"
 #include "Util.h"
+#include "Language.h"
 
 INSTANTIATE_SINGLETON_1( World );
 
@@ -1160,6 +1162,9 @@ void World::SetInitialWorldSettings()
     WorldDatabase.PExecute("INSERT INTO uptime (startstring, starttime, uptime) VALUES('%s', " I64FMTD ", 0)",
         isoDate, uint64(m_startTime));
 
+	static uint32 abtimer = 0;
+	abtimer = sConfig.GetIntDefault("AutoBroadcast.Timer", 60000);
+	
     m_timers[WUPDATE_OBJECTS].SetInterval(0);
     m_timers[WUPDATE_SESSIONS].SetInterval(0);
     m_timers[WUPDATE_WEATHERS].SetInterval(1000);
@@ -1167,6 +1172,7 @@ void World::SetInitialWorldSettings()
     m_timers[WUPDATE_UPTIME].SetInterval(m_configs[CONFIG_UPTIME_UPDATE]*MINUTE*1000);
                                                             //Update "uptime" table based on configuration entry in minutes.
     m_timers[WUPDATE_CORPSES].SetInterval(20*MINUTE*1000);  //erase corpses every 20 minutes
+	m_timers[WUPDATE_AUTOBROADCAST].SetInterval(abtimer);
 
     //to set mailtimer to return mails every day between 4 and 5 am
     //mailtimer is increased when updating auctions
@@ -1203,6 +1209,8 @@ void World::SetInitialWorldSettings()
     uint32 nextGameEvent = gameeventmgr.Initialize();
     m_timers[WUPDATE_EVENTS].SetInterval(nextGameEvent);    //depend on next event
 
+    AuctionHouseBotInit();
+
     sLog.outString( "WORLD: World initialized" );
 }
 
@@ -1271,6 +1279,7 @@ void World::Update(time_t diff)
     /// <ul><li> Handle auctions when the timer has passed
     if (m_timers[WUPDATE_AUCTIONS].Passed())
     {
+        AuctionHouseBot();
         m_timers[WUPDATE_AUCTIONS].Reset();
 
         ///- Update mails (return old mails with item, or delete them)
@@ -1404,6 +1413,17 @@ void World::Update(time_t diff)
         m_timers[WUPDATE_EVENTS].Reset();
     }
 
+	static uint32 autobroadcaston = 0;
+	autobroadcaston = sConfig.GetIntDefault("AutoBroadcast.On", 0);
+	if(autobroadcaston == 1)
+	{
+		if (m_timers[WUPDATE_AUTOBROADCAST].Passed())
+		{
+			m_timers[WUPDATE_AUTOBROADCAST].Reset();
+			SendRNDBroadcast();
+		}
+	}
+	
     /// </ul>
     ///- Move all creatures with "delayed move" and remove and delete all objects with "delayed remove"
     MapManager::Instance().DoDelayedMovesAndRemoves();
@@ -2467,6 +2487,45 @@ void World::ProcessCliCommands()
     zprint("mangos>");
 }
 
+void World::SendRNDBroadcast()
+{
+	std::string msg;
+	QueryResult *result = WorldDatabase.PQuery("SELECT `text` FROM `autobroadcast` ORDER BY RAND() LIMIT 1");
+	
+	if(!result)
+		return;
+	
+	msg = result->Fetch()[0].GetString();
+	delete result;
+
+	static uint32 abcenter = 0;
+    abcenter = sConfig.GetIntDefault("AutoBroadcast.Center", 0);
+    if(abcenter == 0)
+    {
+		sWorld.SendWorldText(LANG_AUTO_BROADCAST, msg.c_str());
+
+		sLog.outString("AutoBroadcast: '%s'",msg.c_str());
+	}
+	if(abcenter == 1)
+	{
+		WorldPacket data(SMSG_NOTIFICATION, (msg.size()+1));
+		data << msg;
+		sWorld.SendGlobalMessage(&data);
+
+		sLog.outString("AutoBroadcast: '%s'",msg.c_str());
+	}
+	if(abcenter == 2)
+	{
+		sWorld.SendWorldText(LANG_AUTO_BROADCAST, msg.c_str());
+
+		WorldPacket data(SMSG_NOTIFICATION, (msg.size()+1));
+		data << msg;
+		sWorld.SendGlobalMessage(&data);
+
+		sLog.outString("AutoBroadcast: '%s'",msg.c_str());
+	}
+}
+
 void World::InitResultQueue()
 {
     m_resultQueue = new SqlResultQueue;
diff --git a/src/game/World.h b/src/game/World.h
index 108b1bb..d101500 100644
--- a/src/game/World.h
+++ b/src/game/World.h
@@ -59,7 +59,8 @@ enum WorldTimers
     WUPDATE_UPTIME      = 4,
     WUPDATE_CORPSES     = 5,
     WUPDATE_EVENTS      = 6,
-    WUPDATE_COUNT       = 7
+    WUPDATE_AUTOBROADCAST = 7,
+	WUPDATE_COUNT 		= 8
 };
 
 /// Configuration elements
@@ -318,6 +319,7 @@ class World
 
         WorldSession* FindSession(uint32 id) const;
         void AddSession(WorldSession *s);
+		void SendRNDBroadcast();
         bool RemoveSession(uint32 id);
         /// Get the number of current active sessions
         void UpdateMaxSessionCounters();
diff --git a/src/mangosd/mangosd.conf.dist.in b/src/mangosd/mangosd.conf.dist.in
index 4c69f2d..c9d7251 100644
--- a/src/mangosd/mangosd.conf.dist.in
+++ b/src/mangosd/mangosd.conf.dist.in
@@ -294,6 +294,78 @@ GmLogTimestamp = 0
 RaLogFile = ""
 LogColors = ""
 
+# Chat log parameters
+ChatLogEnable = 0
+
+# If this is enabled, all $d in file names are replaced with current date
+# This does include innormative lexics log
+ChatLogDateSplit = 1
+
+# If this is enabled, UTF8 header is written into new files
+ChatLogUTFHeader = 1
+
+# If this is enabled, chat log will ignore messages with unprintable chars
+ChatLogIgnoreUnprintable = 1
+
+# Chat log files
+ChatLogChatFile = main_chat-$d.log
+ChatLogPartyFile = party_chat-$d.log
+ChatLogGuildFile = guild_chat-$d.log
+ChatLogWhisperFile = whisper_chat-$d.log
+ChatLogChannelFile = channel_chat-$d.log
+ChatLogRaidFile = raid_chat-$d.log
+ChatLogBattleGroundFile = bg_chat-$d.log
+
+# Chat log screen logging
+ChatLogChatScreen = 0
+ChatLogPartyScreen = 0
+ChatLogGuildScreen = 0
+ChatLogWhisperScreen = 0
+ChatLogChannelScreen = 0
+ChatLogRaidScreen = 0
+ChatLogBattleGroundScreen = 0
+
+# Lexics cutter parameters
+LexicsCutterEnable = 1
+
+LexicsCutterInnormativeCut = 1
+LexicsCutterCutReplacement = &!@^%!^&*!!!
+LexicsCutterLogFile = innormative-$d.log
+LexicsCutterScreenLog = 0
+LexicsCutterAnalogsFile = letter_analogs.txt
+LexicsCutterWordsFile = innormative_words.txt
+
+# Where to cut lexics
+LexicsCutInChat = 1
+LexicsCutInParty = 1
+LexicsCutInGuild = 1
+LexicsCutInWhisper = 1
+LexicsCutInChannel = 1
+LexicsCutInRaid = 1
+LexicsCutInBattleGround = 1
+
+# Ignore word spaces like: W O R D
+LexicsCutterIgnoreSpaces = 1
+
+# Ignore repeats like: WWOOOORRRRRD
+LexicsCutterIgnoreRepeats = 1
+
+# --- Action:
+# ---   0: log only
+# ---   1: sheep
+# ---   2: stun
+# ---   3: kill
+# ---   4: leave 5 health
+# ---   5: disable chat
+# ---   6: stuck (works as stun + 50% health) [by KAPATEJIb]
+# ---   7: resurrection sickness [by Koshei]
+# ---   8: shear [by Koshei]
+LexicsCutterAction = 0
+LexicsCutterActionDuration = 60000
+
+# Do not perform action on GM if this is enabled
+LexicsCutterNoActionOnGM = 1
+
 ###################################################################################################################
 # SERVER SETTINGS
 #
@@ -1079,3 +1151,185 @@ Ra.IP = 0.0.0.0
 Ra.Port = 3443
 Ra.MinLevel = 3
 Ra.Secure = 1
+
+###################################################################################################################
+# AUTO BROADCAST
+#
+#    AutoBroadcast.On
+#        Enable auto broadcast
+#        Default: 0 - off
+#                 1 - on
+#
+#    AutoBroadcast.Center
+#        Display method
+#        Default: 0 - announce
+#                 1 - notify
+#                 2 - both
+#
+#    AutoBroadcast.Timer
+#        Timer for auto broadcast
+#
+###################################################################################################################
+
+AutoBroadcast.On = 0
+AutoBroadcast.Center = 0
+AutoBroadcast.Timer = 60000
+ 
+ ###################################################################################################################
+ # AUCTION HOUSE BOT SETTINGS
+ # 
+ #    Auction House Bot character data
+ #        AuctionHouseBot.Account is the account number (in realmd->account table) of the player you want to run as the auction bot.
+ # 	    AuctionHouseBot.GUID is the GUID (in characters->characters table) of the player you want to run as the auction bot. 
+ #    Default: 0 (Auction House Bot disabled)
+ #
+ #    AuctionHouseBot.NoMail
+ #        This is a flag to disable mail for successfull auctions. 
+ #        A value of 0 will allow mail for successful auctions to be sent, which is the default.
+ #        Non-zero (e.g. AuctionHouseBot.NoMail = 1) will stop successful auction mail.
+ #    Default: 0 (Send auction successful mail)
+ # 
+ #    AuctionHouseBot.AllianceItems
+ #        This is the number of items you want to keep in the Alliance auction house.
+ #    AuctionHouseBot.HordeItems
+ #        This is the number of items you want to keep in the Horde auction house.
+ #    AuctionHouseBot.NeutralItems
+ #        This is the number of items you want to keep in the Neutral auction house.
+ #    Default: 0 (No items generated)
+ #        Note: If you enable AllowTwoSide.Interaction.Trade, ALL auction houses are linked to the neutral auction house.
+ #
+ #    AuctionHouseBot.MinAllianceItems
+ #        This is the minimum number of items you want to keep in the Alliance auction house.
+ #    AuctionHouseBot.MinHordeItems
+ #        This is the minimum number of items you want to keep in the Horde auction house.
+ #    AuctionHouseBot.MinNeutralItems
+ #        This is the minimum number of items you want to keep in the Neutral auction house.
+ #    Default: -1 (minimum will be the same as maximum)
+ # 
+ #    AuctionHouseBot.MinTime
+ #        Sets the minimum number of hours for an auction.
+ #    Default: 8
+ #
+ #    AuctionHouseBot.MaxTime
+ #        Sets the maximum number of hours for an auction.
+ #    Default: 24
+ #
+ #    Item distribution
+ #        Sets the percentage of the auction items that should be trade goods of white quality.
+ #        A value of 0 will disable.
+ #    AuctionHouseBot.PercentWhiteTradeGoods
+ #        Sets the percentage of the White Trade Goods auction items
+ #    Default: 30
+ #    AuctionHouseBot.PercentGreenTradeGoods
+ #        Sets the percentage of the Green Trade Goods auction items
+ #    Default: 13
+ #    AuctionHouseBot.PercentBlueTradeGoods
+ #        Sets the percentage of the Blue Trade Goods auction items
+ #    Default: 9
+ #    AuctionHouseBot.PercentPurpleTradeGoods
+ #        Sets the percentage of the Purple Trade Goods auction items
+ #    Default: 1
+ #        Note: All of the above values (AuctionHouseBot Percent TradeGoods) must add together to make 100 percent.
+ #
+ #    AuctionHouseBot.PercentWhiteItems
+ #        Sets the percentage of the non trade White auction items
+ #    Default: 6
+ #    AuctionHouseBot.PercentGreenItems
+ #        Sets the percentage of the non trade Green auction items
+ #    Default: 30
+ #    AuctionHouseBot.PercentBlueItems
+ #        Sets the percentage of the non trade Blue auction items
+ #    Default: 9
+ #    AuctionHouseBot.PercentPurpleItems
+ #        Sets the percentage of the non trade Purple auction items
+ #    Default: 2
+ #        Note: All of the above values (AuctionHouseBot Percent Items) must add together to make 100 percent.
+ #
+ #    Minimum and maximim price mark-up for items.  Percentage of vendor sale price.
+ #        Example: If a vendor would sell an item for 1g and MinPrice = 150 and MaxPrice = 250,
+ #        then that item would be randomly priced between 1g 50s and 2g 50s.
+ #    AuctionHouseBot.MinPriceWhite
+ #        Minimum price of White items.
+ #    Default: 150
+ #    AuctionHouseBot.MaxPriceWhite
+ #        Maximum price of White items.
+ #    Default: 250
+ #    AuctionHouseBot.MinPriceGreen
+ #        Minimum price of Green items.
+ #    Default: 200
+ #    AuctionHouseBot.MaxPriceGreen
+ #        Maximum price of Green items.
+ #    Default: 300
+ #    AuctionHouseBot.MinPriceBlue
+ #        Minimum price of Blue items.
+ #    Default: 250
+ #    AuctionHouseBot.MaxPriceBlue
+ #        Maximum price of Blue items.
+ #    Default: 350
+ #    AuctionHouseBot.MinPricePurple
+ #        Minimum price of Purple items.
+ #    Default: 300
+ #    AuctionHouseBot.MaxPricePurple
+ #        Maximum price of Purple items.
+ #    Default: 450
+ #
+ #    AuctionHouseBot.BidPrice
+ #    Starting bid price as a percentage of the randomly chosen buyout price
+ #    AuctionHouseBot.BidPriceWhite
+ #    Default: 100 (Bid and buyout price the same)
+ #    AuctionHouseBot.BidPriceGreen
+ #    Default: 100 (Bid and buyout price the same)
+ #    AuctionHouseBot.BidPriceBlue
+ #    Default: 100 (Bid and buyout price the same)
+ #    +AuctionHouseBot.BidPricePurple
+ #    Default: 100 (Bid and buyout price the same)
+ #
+ #    AuctionHouseBot.MaxStack
+ #        Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality,
+ #        which will allow the bot to create items in stack as large as the item allows.
+ #    AuctionHouseBot.MaxStackWhite
+ #    Default: 0
+ #    AuctionHouseBot.MaxStackGreen
+ #    Default: 3
+ #    AuctionHouseBot.MaxStackBlue
+ #    Default: 2
+ #    AuctionHouseBot.MaxStackPurple
+ #    Default: 1
+ #
+ ###################################################################################################################
+ 
+ AuctionHouseBot.Account = 0
+ AuctionHouseBot.GUID = 0
+ AuctionHouseBot.NoMail = 0
+ AuctionHouseBot.AllianceItems = 0
+ AuctionHouseBot.HordeItems = 0
+ AuctionHouseBot.NeutralItems = 0
+ AuctionHouseBot.MinAllianceItems = -1
+ AuctionHouseBot.MinHordeItems = -1
+ AuctionHouseBot.MinNeutralItems = -1
+ AuctionHouseBot.MinTime = 8
+ AuctionHouseBot.MaxTime = 24
+ AuctionHouseBot.PercentWhiteTradeGoods = 30
+ AuctionHouseBot.PercentGreenTradeGoods = 13
+ AuctionHouseBot.PercentBlueTradeGoods = 9
+ AuctionHouseBot.PercentPurpleTradeGoods = 1
+ AuctionHouseBot.PercentWhiteItems = 6
+ AuctionHouseBot.PercentGreenItems = 30
+ AuctionHouseBot.PercentBlueItems = 9
+ AuctionHouseBot.PercentPurpleItems = 2
+ AuctionHouseBot.MinPriceWhite = 150
+ AuctionHouseBot.MaxPriceWhite = 250
+ AuctionHouseBot.MinPriceGreen = 200
+ AuctionHouseBot.MaxPriceGreen = 300
+ AuctionHouseBot.MinPriceBlue = 250
+ AuctionHouseBot.MaxPriceBlue = 350
+ AuctionHouseBot.MinPricePurple = 300
+ AuctionHouseBot.MaxPricePurple = 450
+ AuctionHouseBot.BidPriceWhite = 100
+ AuctionHouseBot.BidPriceGreen = 100
+ AuctionHouseBot.BidPriceBlue = 100
+ AuctionHouseBot.BidPricePurple = 100
+ AuctionHouseBot.MaxStackWhite = 0
+ AuctionHouseBot.MaxStackGreen = 3
+ AuctionHouseBot.MaxStackBlue = 2
+ AuctionHouseBot.MaxStackPurple = 1
diff --git a/src/shared/Database/DatabaseMysql.cpp b/src/shared/Database/DatabaseMysql.cpp
index e8a944f..c08fd4e 100644
--- a/src/shared/Database/DatabaseMysql.cpp
+++ b/src/shared/Database/DatabaseMysql.cpp
@@ -165,6 +165,22 @@ bool DatabaseMysql::Initialize(const char *infoString)
         PExecute("SET NAMES `utf8`");
         PExecute("SET CHARACTER SET `utf8`");
 
+#if MYSQL_VERSION_ID >= 50003
+//  #if MYSQL_VERSIOB_ID >= 50013
+        my_bool my_true = (my_bool)1;
+        if (mysql_options(mMysql, MYSQL_OPT_RECONNECT, &my_true))
+        {
+            sLog.outDetail("Failed to turn on MYSQL_OPT_RECONNECT.");
+        }
+        else
+        {
+            sLog.outDetail("Successfully turned on MYSQL_OPT_RECONNECT.");
+        }
+#else
+        sLog.outDetail("Your mySQL client lib version does not support reconnecting after a timeout.");
+        sLog.outDetail("If this causes you any trouble we advice you to upgrade");
+        sLog.outDetail("your mySQL client libs to at least mySQL 5.0.13 to resolve this problem.");
+#endif
         return true;
     }
     else
diff --git a/win/VC71/game.vcproj b/win/VC71/game.vcproj
index d131d0f..9174dfc 100644
--- a/win/VC71/game.vcproj
+++ b/win/VC71/game.vcproj
@@ -240,6 +240,18 @@
 			<File
 				RelativePath="..\..\src\game\ChatHandler.cpp">
 			</File>
+            <File
+                RelativePath="..\..\src\game\ChatLexicsCutter.cpp">
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLexicsCutter.h">
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLog.cpp">
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLog.h">
+            </File>
 			<File
 				RelativePath="..\..\src\game\CombatHandler.cpp">
 			</File>
@@ -475,6 +487,12 @@
 				RelativePath="..\..\src\game\ArenaTeam.h">
 			</File>
 			<File
+				RelativePath="..\..\src\game\AuctionHouseBot.cpp">
+			</File>
+			<File
+				RelativePath="..\..\src\game\AuctionHouseBot.h">
+			</File>
+			<File
 				RelativePath="..\..\src\game\AuctionHouseObject.h">
 			</File>
 			<File
diff --git a/win/VC80/game.vcproj b/win/VC80/game.vcproj
index 80aa58b..6098468 100644
--- a/win/VC80/game.vcproj
+++ b/win/VC80/game.vcproj
@@ -494,6 +494,22 @@
 				RelativePath="..\..\src\game\ChatHandler.cpp"
 				>
 			</File>
+            <File
+                RelativePath="..\..\src\game\ChatLexicsCutter.cpp"
+                >
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLexicsCutter.h"
+                >
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLog.cpp"
+                >
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLog.h"
+                >
+            </File>
 			<File
 				RelativePath="..\..\src\game\CombatHandler.cpp"
 				>
@@ -807,6 +823,14 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\game\AuctionHouseBot.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\AuctionHouseBot.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\AuctionHouseObject.h"
 				>
 			</File>
diff --git a/win/VC90/game.vcproj b/win/VC90/game.vcproj
index 19b0ae4..4408c4a 100644
--- a/win/VC90/game.vcproj
+++ b/win/VC90/game.vcproj
@@ -496,6 +496,22 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\game\ChatLexicsCutter.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\ChatLexicsCutter.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\ChatLog.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\ChatLog.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\CombatHandler.cpp"
 				>
 			</File>
@@ -808,6 +824,14 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\game\AuctionHouseBot.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\AuctionHouseBot.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\AuctionHouseObject.h"
 				>
 			</File>
