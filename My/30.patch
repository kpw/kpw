diff --git a/src/game/AggressorAI.cpp b/src/game/AggressorAI.cpp
index 637410c..9be41e5 100644
--- a/src/game/AggressorAI.cpp
+++ b/src/game/AggressorAI.cpp
@@ -55,7 +55,7 @@ AggressorAI::MoveInLineOfSight(Unit *u)
         if(i_creature.IsWithinDistInMap(u, attackRadius) && i_creature.IsWithinLOSInMap(u) )
         {
             AttackStart(u);
-            u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
+            //u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
         }
     }
 }
diff --git a/src/game/ArenaTeam.cpp b/src/game/ArenaTeam.cpp
index 06336fe..52e67b8 100644
--- a/src/game/ArenaTeam.cpp
+++ b/src/game/ArenaTeam.cpp
@@ -51,7 +51,7 @@ bool ArenaTeam::create(uint64 captainGuid, uint32 type, std::string ArenaTeamNam
     if(objmgr.GetArenaTeamByName(ArenaTeamName))            // arena team with this name already exist
         return false;
 
-    sLog.outDebug("GUILD: creating arena team %s to leader: %u", ArenaTeamName.c_str(), GUID_LOPART(CaptainGuid));
+    sLog.outDebug("GUILD: creating arena team %s to leader: %u", ArenaTeamName.c_str(), GUID_LOPART(captainGuid));
 
     CaptainGuid = captainGuid;
     Name = ArenaTeamName;
@@ -137,10 +137,8 @@ bool ArenaTeam::AddMember(uint64 PlayerGuid)
     {
         pl->SetInArenaTeam(Id, GetSlot());
         pl->SetArenaTeamIdInvited(0);
-    }
-    else
-    {
-        Player::SetUInt32ValueInDB(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot() * 6), Id, PlayerGuid);
+        // personal rating
+        pl->SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot() * 6) + 5, 1500);
     }
 
     // hide promote/remove buttons
@@ -148,18 +146,39 @@ bool ArenaTeam::AddMember(uint64 PlayerGuid)
     {
         if(pl)
             pl->SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 1 + (GetSlot() * 6), 1);
-        else
-            Player::SetUInt32ValueInDB(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 1 + (GetSlot() * 6), 1, PlayerGuid);
     }
+
+    // setuint32valueindb is asynch, can't be used here
+    Tokens tokens;
+    if(!Player::LoadValuesArrayFromDB(tokens,PlayerGuid))
+        return false;
+
+    // arena team id
+    uint16 index = PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot() * 6);
+    char buf[11];
+    snprintf(buf,11,"%u",Id);
+    tokens[index] = buf;
+    // pers rating
+    index = PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot() * 6) + 5;
+    buf[11];
+    snprintf(buf,11,"%u",1500);
+    tokens[index] = buf;
+    // hide promote/remove buttons
+    if(CaptainGuid != PlayerGuid)
+    {
+        index = PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 1 + (GetSlot() * 6);
+        buf[11];
+        snprintf(buf,11,"%u",1);
+        tokens[index] = buf;
+    }
+
+    Player::SaveValuesArrayInDB(tokens,PlayerGuid);
+
     return true;
 }
 
 bool ArenaTeam::LoadArenaTeamFromDB(uint32 ArenaTeamId)
 {
-    LoadStatsFromDB(ArenaTeamId);
-    LoadMembersFromDB(ArenaTeamId);
-
-    //                                                      0          1    2           3    4               5           6           7           8
     QueryResult *result = CharacterDatabase.PQuery("SELECT arenateamid,name,captainguid,type,BackgroundColor,EmblemStyle,EmblemColor,BorderStyle,BorderColor FROM arena_team WHERE arenateamid = '%u'", ArenaTeamId);
 
     if(!result)
@@ -179,6 +198,22 @@ bool ArenaTeam::LoadArenaTeamFromDB(uint32 ArenaTeamId)
 
     delete result;
 
+    // only load here, so additional checks can be made
+    LoadStatsFromDB(ArenaTeamId);
+    LoadMembersFromDB(ArenaTeamId);
+
+    if(!GetMembersSize())
+    {
+        // arena team is empty, delete from db
+        CharacterDatabase.BeginTransaction();
+        CharacterDatabase.PExecute("DELETE FROM arena_team WHERE arenateamid = '%u'", ArenaTeamId);
+        CharacterDatabase.PExecute("DELETE FROM arena_team_member WHERE arenateamid = '%u'", ArenaTeamId);
+        CharacterDatabase.PExecute("DELETE FROM arena_team_stats WHERE arenateamid = '%u'", ArenaTeamId);
+        CharacterDatabase.CommitTransaction();
+        // return false
+        return false;
+    }
+
     return true;
 }
 
@@ -206,7 +241,7 @@ void ArenaTeam::LoadMembersFromDB(uint32 ArenaTeamId)
 {
     Field *fields;
 
-    QueryResult *result = CharacterDatabase.PQuery("SELECT guid,played_week,wons_week,played_season,wons_season FROM arena_team_member WHERE arenateamid = '%u'", ArenaTeamId);
+    QueryResult *result = CharacterDatabase.PQuery("SELECT guid,played_week,wons_week,played_season,wons_season,points_to_add FROM arena_team_member WHERE arenateamid = '%u'", ArenaTeamId);
     if(!result)
         return;
 
@@ -215,6 +250,14 @@ void ArenaTeam::LoadMembersFromDB(uint32 ArenaTeamId)
         fields = result->Fetch();
         ArenaTeamMember newmember;
         newmember.guid          = MAKE_NEW_GUID(fields[0].GetUInt32(), 0, HIGHGUID_PLAYER);
+        // check if this member is in this arenateam
+        // based on character data field
+        if(Player::GetUInt32ValueFromDB(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot() * 6),newmember.guid) != ArenaTeamId)
+        {
+            // the player's registered arena team for this slot isn't this team, so delete member info from here
+            CharacterDatabase.PExecute("DELETE FROM arena_team_member WHERE guid = '%u' AND arenateamid = '%u'",fields[0].GetUInt32(), ArenaTeamId);
+            continue;
+        }
         LoadPlayerStats(&newmember);
         newmember.played_week   = fields[1].GetUInt32();
         newmember.wons_week     = fields[2].GetUInt32();
@@ -275,17 +318,36 @@ void ArenaTeam::DelMember(uint64 guid)
     }
 
     Player *player = objmgr.GetPlayer(guid);
+    // this will be ugly. because of the asynchronous sql handling, we have to set all the fields of the player at once, and save them at once, or else the save will only modify the last field.
+    // rip off of setuint32valueindb
     if(player)
     {
         player->SetInArenaTeam(0, GetSlot());
         player->GetSession()->SendArenaTeamCommandResult(ERR_ARENA_TEAM_QUIT_S, GetName(), "", 0);
+        // delete all info regarding this team
+        for(int i = 0; i < 6; ++i)
+        {
+            player->SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot() * 6) + i, 0);
+        }
     }
-    else
+
+    // we have to do it this way, setuint32valueindb is asynch, unsafe to use multiple times in a row on the same player
+    Tokens tokens;
+    if(!Player::LoadValuesArrayFromDB(tokens,guid))
+        return;
+
+    for(int i = 0; i < 6; ++i)
     {
-        Player::SetUInt32ValueInDB(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot() * 6), 0, guid);
+        uint16 index = PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot() * 6) + i;
+        char buf[11];
+        snprintf(buf,11,"%u",0);
+        tokens[index] = buf;
     }
 
-    CharacterDatabase.PExecute("DELETE FROM arena_team_member WHERE guid = '%u'", GUID_LOPART(guid));
+    Player::SaveValuesArrayInDB(tokens,guid);
+
+    // only delete from this arena team!
+    CharacterDatabase.PExecute("DELETE FROM arena_team_member WHERE arenateamid = '%u' AND guid = '%u'", GetId(), GUID_LOPART(guid));
 }
 
 void ArenaTeam::Disband(WorldSession *session)
@@ -312,6 +374,7 @@ void ArenaTeam::Disband(WorldSession *session)
 
     CharacterDatabase.BeginTransaction();
     CharacterDatabase.PExecute("DELETE FROM arena_team WHERE arenateamid = '%u'", Id);
+    CharacterDatabase.PExecute("DELETE FROM arena_team_member WHERE arenateamid = '%u'", Id);
     CharacterDatabase.PExecute("DELETE FROM arena_team_stats WHERE arenateamid = '%u'", Id);
     CharacterDatabase.CommitTransaction();
     objmgr.RemoveArenaTeam(this);
@@ -341,7 +404,7 @@ void ArenaTeam::Roster(WorldSession *session)
             data << uint32(itr->wons_week);                 // wins this week
             data << uint32(itr->played_season);             // played this season
             data << uint32(itr->wons_season);               // wins this season
-            data << uint32(0);                              // personal rating?
+            data << uint32(pl->GetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + GetSlot() * 6 + 5));                              // personal rating?
         }
         else
         {
@@ -355,7 +418,7 @@ void ArenaTeam::Roster(WorldSession *session)
             data << uint32(itr->wons_week);                 // wins this week
             data << uint32(itr->played_season);             // played this season
             data << uint32(itr->wons_season);               // wins this season
-            data << uint32(0);                              // personal rating?
+            data << uint32(Player::GetUInt32ValueFromDB(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + GetSlot() * 6 + 5, itr->guid));                              // personal rating?
         }
     }
     session->SendPacket(&data);
@@ -390,6 +453,18 @@ void ArenaTeam::Stats(WorldSession *session)
     session->SendPacket(&data);
 }
 
+void ArenaTeam::NotifyStatsChanged()
+{
+    // this is called after a rated match ended
+    // updates arena team stats for every member of the team (not only the ones who participated!)
+    for(MemberList::iterator itr = members.begin(); itr != members.end(); ++itr)
+    {
+        Player * plr=objmgr.GetPlayer(itr->guid);
+        if(plr)
+            Stats(plr->GetSession());
+    }
+}
+
 void ArenaTeam::InspectStats(WorldSession *session, uint64 guid)
 {
     WorldPacket data(MSG_INSPECT_ARENA_TEAMS, 8+1+4*6);
@@ -397,10 +472,20 @@ void ArenaTeam::InspectStats(WorldSession *session, uint64 guid)
     data << uint8(GetSlot());                               // slot (0...2)
     data << uint32(GetId());                                // arena team id
     data << uint32(stats.rating);                           // rating
-    data << uint32(stats.games);                            // games
-    data << uint32(stats.wins);                             // wins
-    data << uint32(stats.played);                           // played (count of all games, that played...)
-    data << uint32(0);                                      // 2.3.3 personal rating?
+    data << uint32(stats.played);                           // season played
+    data << uint32(stats.wins2);                            // season wins
+    uint32 participated = 0;
+    for(MemberList::iterator itr = members.begin(); itr!= members.end(); ++itr)
+    {
+        if(itr->guid == guid)
+        {
+            participated = itr->played_season;
+            break;
+        }
+    }
+    data << uint32(participated);                            // played (count of all games, that the inspected member participated...)
+    data << uint32(Player::GetUInt32ValueFromDB(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + GetSlot() * 6 + 5, guid));                                       // unk, 2.3.3 (personal rating?)
+
     session->SendPacket(&data);
 }
 
@@ -493,24 +578,211 @@ bool ArenaTeam::HaveMember( uint64 guid ) const
     return false;
 }
 
+uint32 ArenaTeam::GetPoints(uint32 MemberRating)
+{
+    // returns how many points would be awarded with this team type with this rating
+    float points;
+
+    uint32 rating = MemberRating + 150 < stats.rating ? MemberRating : stats.rating;
+
+    if(rating<=1500)
+    {
+        points = (float)rating * 0.22f + 14.0f;
+    }
+    else
+    {
+        points = 1511.26f / (1.0f + 1639.28f * exp(-0.00412f * (float)rating));
+    }
+
+    // type penalties for <5v5 teams
+    if(Type == ARENA_TEAM_2v2)
+        points *= 0.76f;
+    else if(Type == ARENA_TEAM_3v3)
+        points *= 0.88f;
+
+    return (uint32) points;
+}
+
+float ArenaTeam::GetChanceAgainst(uint32 rating)
+{
+    // returns the chance to win against a team with the given rating, used in the rating adjustment calculation
+    // ELO system
+    return 1.0f/(1.0f+exp(log(10.0f)*(float)((float)rating - (float)stats.rating)/400.0f));
+}
+
+int32 ArenaTeam::WonAgainstChance(float chance)
+{
+    // called when the team has won, and had 'chance' calculated chance to beat the opponent
+    // calculate the rating modification (ELO system with k=32)
+    int32 mod = (int32)floor(32.0f * (1.0f - chance));
+    // modify the team stats accordingly
+    stats.rating += mod;
+    stats.games += 1;
+    stats.wins += 1;
+    stats.played += 1;
+    stats.wins2 += 1;
+/*  this should be done in .flusharenapoints; not a breaker though.
+    uint32 higher_rank = 0;
+    QueryResult *result = CharacterDatabase.PQuery("SELECT DISTINCT COUNT(arenateamid) FROM arena_team_stats WHERE rating > '%u' AND arenateamid <> '%u'",stats.rating, Id);
+    if(result)
+    {
+        higher_rank = result->Fetch()->GetUInt32();
+        delete result;
+    }
+    stats.rank = higher_rank + 1;*/
+    // return the rating change, used to display it on the results screen
+    return mod;
+}
+
+int32 ArenaTeam::LostAgainstChance(float chance)
+{
+    // called when the team has lost, and had 'chance' calculated chance to beat the opponent
+    // calculate the rating modification (ELO system with k=32)
+    int32 mod = (int32)ceil(32.0f * (0.0f - chance));
+    // modify the team stats accordingly
+    stats.rating += mod;
+    stats.games += 1;
+    stats.played += 1;
+/*    uint32 higher_rank = 0;
+    QueryResult *result = CharacterDatabase.PQuery("SELECT DISTINCT COUNT (arenateamid) FROM arena_team_stats WHERE rating > '%u' AND arenateamid <> '%u'",stats.rating, Id);
+    if(result)
+    {
+        higher_rank = result->Fetch()->GetUInt32();
+        delete result;
+    }
+    stats.rank = higher_rank + 1;*/
+    // return the rating adjustment for display
+    return mod;
+}
+
+void ArenaTeam::MemberLost(Player * plr, uint32 againstrating)
+{
+    // called for each participant of a match after losing
+    for(MemberList::iterator itr = members.begin(); itr !=  members.end(); ++itr)
+    {
+        if(itr->guid == plr->GetGUID())
+        {
+            // update personal rating
+            int32 personalrating = plr->GetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot()*6) + 5);
+            float chance = 1.0f/(1.0f+exp(log(10.0f)*(float)((float)againstrating - (float)personalrating)/400.0f));
+            int32 mod = (int32)ceil(32.0f * (0.0f - chance));
+            personalrating += mod;
+            if(personalrating < 0)
+                personalrating = 0;
+            plr->SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot()*6) + 5, personalrating);
+            // update personal played stats
+            itr->played_week +=1;
+            itr->played_season +=1;
+            // update the unit fields
+            plr->SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 6 * GetSlot() + 2, itr->played_week);
+            plr->SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 6 * GetSlot() + 3, itr->played_season);
+            return;
+        }
+    }
+}
+
+void ArenaTeam::MemberWon(Player * plr, uint32 againstrating)
+{
+    // called for each participant after winning a match
+    for(MemberList::iterator itr = members.begin(); itr !=  members.end(); ++itr)
+    {
+        if(itr->guid == plr->GetGUID())
+        {
+            // update personal rating
+            int32 personalrating = plr->GetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot()*6) + 5);
+            float chance = 1.0f/(1.0f+exp(log(10.0f)*(float)((float)againstrating - (float)personalrating)/400.0f));
+            int32 mod = (int32)floor(32.0f * (1.0f - chance));
+            personalrating += mod;
+            if(personalrating < 0)
+                personalrating = 0;
+            plr->SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot()*6) + 5, personalrating);
+            // update personal stats
+            itr->played_week +=1;
+            itr->played_season +=1;
+            itr->wons_season += 1;
+            itr->wons_week += 1;
+            // update unit fields
+            plr->SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 6 * GetSlot() + 2, itr->played_week);
+            plr->SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 6 * GetSlot() + 3, itr->played_season);
+            return;
+        }
+    }
+}
+
+void ArenaTeam::UpdateArenaPointsHelper()
+{
+    // called after a match has ended and the stats are already modified
+    // helper function for arena point distribution (this way, when distributing, no actual calculation is required, just a few comparisons)
+    // 10 played games per week is a minimum
+    if(stats.games < 10)
+        return;
+    // to get points, a player has to participate in at least 30% of the matches
+    uint32 min_plays = ceil(stats.games * 0.3);
+    for(MemberList::iterator itr = members.begin(); itr !=  members.end(); ++itr)
+    {
+        // the player participated in enough games, update his points
+        if(itr->played_week >= min_plays)
+        {
+            // do it separately for online and offline players
+            // online players might have modified personal rating in MemberLost/MemberWon, that's not already saved to DB because of asynch queries
+            // offline player cant have a personal rating not matching the db
+            Player * plr = objmgr.GetPlayer(itr->guid);
+            uint32 points_to_add = 0;
+            if(plr)
+                points_to_add = GetPoints(plr->GetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot()*6) + 5));
+            else
+                points_to_add = GetPoints(Player::GetUInt32ValueFromDB(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot()*6) + 5,itr->guid));
+            // it's enough to set the points in memory, the saving is done in separate function
+            CharacterDatabase.PExecute("UPDATE arena_team_member SET points_to_add = '%u' WHERE arenateamid = '%u' AND guid = '%u'", points_to_add, Id, itr->guid);
+        }
+        // the player failed to participate in enough games, so no points for him
+        else
+        {
+            CharacterDatabase.PExecute("UPDATE arena_team_member SET points_to_add = '%u' WHERE arenateamid = '%u' AND guid = '%u'", 0, Id, itr->guid);
+        }
+    }
+}
+
+void ArenaTeam::SaveToDB()
+{
+    // save team and member stats to db
+    // called after a match has ended
+    CharacterDatabase.PExecute("UPDATE arena_team_stats SET rating = '%u',games = '%u',played = '%u',rank = '%u',wins = '%u',wins2 = '%u' WHERE arenateamid = '%u'", stats.rating, stats.games, stats.played, stats.rank, stats.wins, stats.wins2, GetId());
+    for(MemberList::iterator itr = members.begin(); itr !=  members.end(); ++itr)
+    {
+        CharacterDatabase.PExecute("UPDATE arena_team_member SET played_week = '%u', wons_week = '%u', played_season = '%u', wons_season = '%u' WHERE arenateamid = '%u' AND guid = '%u'", itr->played_week, itr->wons_week, itr->played_season, itr->wons_season, Id, itr->guid);
+    }
+}
+
+void ArenaTeam::FinishWeek()
+{
+    stats.games = 0; // played this week
+    stats.wins = 0; // wins this week
+    for(MemberList::iterator itr = members.begin(); itr !=  members.end(); ++itr)
+    {
+        itr->played_week = 0;
+        itr->wons_week = 0;
+    }
+}
+
 /*
 arenateam fields (id from 2.3.3 client):
 1414 - arena team id 2v2
 1415 - 0=captain, 1=member
-1416 - played this season
-1417 - played this week
+1416 - played this week
+1417 - played this season
 1418 - unk
-1419 - unk
+1419 - personal arena rating
 1420 - arena team id 3v3
 1421 - 0=captain, 1=member
-1422 - played this season
-1423 - played this week
+1422 - played this week
+1423 - played this season
 1424 - unk
-1425 - unk
+1425 - personal arena rating
 1426 - arena team id 5v5
 1427 - 0=captain, 1=member
-1428 - played this season
-1429 - played this week
+1428 - played this week
+1429 - played this season
 1430 - unk
-1431 - unk
+1431 - personal arena rating
 */
diff --git a/src/game/ArenaTeam.h b/src/game/ArenaTeam.h
index 0d26b00..73ac7ac 100644
--- a/src/game/ArenaTeam.h
+++ b/src/game/ArenaTeam.h
@@ -149,6 +149,8 @@ class ArenaTeam
         void LoadStatsFromDB(uint32 ArenaTeamId);
         void LoadPlayerStats(ArenaTeamMember* member);
 
+        void SaveToDB();
+
         void BroadcastPacket(WorldPacket *packet);
 
         void Roster(WorldSession *session);
@@ -156,6 +158,19 @@ class ArenaTeam
         void Stats(WorldSession *session);
         void InspectStats(WorldSession *session, uint64 guid);
 
+        uint32 GetPoints(uint32 MemberRating);
+        float GetChanceAgainst(uint32 rating);
+        int32 WonAgainstChance(float chance);
+        void MemberWon(Player * plr, uint32 againstrating);
+        int32 LostAgainstChance(float chance);
+        void MemberLost(Player * plr, uint32 againstrating);
+
+        void UpdateArenaPointsHelper();
+
+        void FinishWeek();
+
+        void NotifyStatsChanged();
+
     protected:
 
         uint32 Id;
diff --git a/src/game/ArenaTeamHandler.cpp b/src/game/ArenaTeamHandler.cpp
index c6b9059..d302703 100644
--- a/src/game/ArenaTeamHandler.cpp
+++ b/src/game/ArenaTeamHandler.cpp
@@ -182,7 +182,7 @@ void WorldSession::HandleArenaTeamInviteAcceptOpcode(WorldPacket & /*recv_data*/
         return;
     }
 
-    if(_player->GetArenaTeamId(at->GetSlot()))
+    if(_player->GetArenaTeamIdFromDB(_player->GetGUIDLow(), at->GetType()))
     {
         // already in arena team that size
         return;
diff --git a/src/game/AuctionHouseBot.cpp b/src/game/AuctionHouseBot.cpp
new file mode 100644
index 0000000..304ea5f
--- /dev/null
+++ b/src/game/AuctionHouseBot.cpp
@@ -0,0 +1,697 @@
+#include "AuctionHouseBot.h"
+#include "Bag.h"
+#include "Config/ConfigEnv.h"
+#include "Database/DatabaseEnv.h"
+#include "Item.h"
+#include "Log.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+#include "World.h"
+#include "WorldSession.h"
+#include <vector>
+
+using namespace std;
+
+//#define NO_VENDOR_ITEMS
+#define ONLY_LOOT_ITEMS
+
+static vector<uint32> whiteTradeGoods;
+static vector<uint32> greenTradeGoods;
+static vector<uint32> blueTradeGoods;
+static vector<uint32> purpleTradeGoods;
+static vector<uint32> whiteItems;
+static vector<uint32> greenItems;
+static vector<uint32> blueItems;
+static vector<uint32> purpleItems;
+
+static uint32 AHBplayerAccount = 0; 
+static uint32 AHBplayerGUID = 0; 
+static uint32 noMail = 0; 
+static uint32 numAllianceItems = 0;
+static uint32 numMinAllianceItems = 0;
+static uint32 numHordeItems = 0;
+static uint32 numMinHordeItems = 0;
+static uint32 numNeutralItems = 0;
+static uint32 numMinNeutralItems = 0;
+static uint32 minTime = 0;
+static uint32 maxTime = 0;
+static uint32 percentWhiteTradeGoods = 0;
+static uint32 percentGreenTradeGoods = 0;
+static uint32 percentBlueTradeGoods = 0;
+static uint32 percentPurpleTradeGoods = 0;
+static uint32 percentWhiteItems = 0;
+static uint32 percentGreenItems = 0;
+static uint32 percentBlueItems = 0;
+static uint32 percentPurpleItems = 0;
+static uint32 minPriceWhite = 0;
+static uint32 maxPriceWhite = 0;
+static uint32 bidPriceWhite = 0;
+static uint32 maxStackWhite = 0;
+static uint32 minPriceGreen = 0;
+static uint32 maxPriceGreen = 0;
+static uint32 bidPriceGreen = 0;
+static uint32 maxStackGreen = 0;
+static uint32 minPriceBlue = 0;
+static uint32 maxPriceBlue = 0;
+static uint32 bidPriceBlue = 0;
+static uint32 maxStackBlue = 0;
+static uint32 minPricePurple = 0;
+static uint32 maxPricePurple = 0;
+static uint32 bidPricePurple = 0;
+static uint32 maxStackPurple = 0;
+
+///////////////////////////////////////////////////////////////////////////////
+//
+///////////////////////////////////////////////////////////////////////////////
+uint32 AuctionHouseBotNoMail()
+{
+   return noMail != 0 ? AHBplayerGUID : 0;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+///////////////////////////////////////////////////////////////////////////////
+static inline uint32 minValue(uint32 a, uint32 b)
+{
+   return a <= b ? a : b;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+///////////////////////////////////////////////////////////////////////////////
+static void deleteOldAuctions(uint32 ahMapID)
+{
+   AuctionHouseObject* auctionHouse = objmgr.GetAuctionsMap(ahMapID);
+
+   AuctionHouseObject::AuctionEntryMap::iterator itr;
+   itr = auctionHouse->GetAuctionsBegin();
+
+   while (itr != auctionHouse->GetAuctionsEnd())
+   {
+      AuctionHouseObject::AuctionEntryMap::iterator tmp = itr;
+      ++itr;
+
+      if (tmp->second->owner != AHBplayerGUID)
+         continue;
+
+      if (tmp->second->bidder != 0)
+         continue;
+
+      if (tmp->second->time > sWorld.GetGameTime())
+         continue;
+
+      // quietly delete the item and auction...
+
+      Item* item = objmgr.GetAItem(tmp->second->item_guidlow);
+      if (item != NULL)
+      {
+         objmgr.RemoveAItem(tmp->second->item_guidlow);
+         item->DeleteFromDB();
+         delete item;
+      }
+      else
+      {
+         sLog.outString("AuctionHouseBot: "
+                        "clearing auction for non-existant item_guidlow (%d)",
+                        tmp->second->item_guidlow);
+      }
+
+	CharacterDatabase.PExecute("DELETE FROM `auctionhouse` WHERE `id` = '%u'",
+                                 tmp->second->Id);
+       AuctionEntry* auctionEntry = tmp->second;
+       auctionHouse->RemoveAuction(auctionEntry->Id);
+       delete auctionEntry;
+   }
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+///////////////////////////////////////////////////////////////////////////////
+static void addNewAuctions(uint32 ahMapID, uint32 maxAuctions, uint32 minAuctions, Player *AHBplayer)
+{
+   AuctionHouseObject* auctionHouse = objmgr.GetAuctionsMap(ahMapID);
+
+   if (auctionHouse->Getcount() > minAuctions)
+      return;
+
+   uint32 whiteTradeGoodsBin = percentWhiteTradeGoods;
+   uint32 greenTradeGoodsBin = percentGreenTradeGoods + whiteTradeGoodsBin;
+   uint32 blueTradeGoodsBin = percentBlueTradeGoods + greenTradeGoodsBin;
+   uint32 purpleTradeGoodsBin = percentPurpleTradeGoods + blueTradeGoodsBin;
+   uint32 whiteItemBin = percentWhiteItems + purpleTradeGoodsBin;
+   uint32 greenItemBin = percentGreenItems + whiteItemBin;
+   uint32 blueItemBin = percentBlueItems + greenItemBin;
+   uint32 purpleItemBin = percentPurpleItems + blueItemBin;
+
+   // only insert 100 at a time, so as not to peg the processor
+   for (uint32 count = 0; 
+        (count < 100) && (auctionHouse->Getcount() < maxAuctions); 
+        count++)
+   {
+      uint32 itemID = purpleItems[urand(0, purpleItems.size() - 1)];
+      uint32 value = urand(1, 100);
+      
+      if (value <= blueItemBin)
+         itemID = blueItems[urand(0, blueItems.size() - 1)];
+
+      if (value <= greenItemBin)
+         itemID = greenItems[urand(0, greenItems.size() - 1)];
+
+      if (value <= whiteItemBin)
+         itemID = whiteItems[urand(0, whiteItems.size() - 1)];
+
+      if (value <= purpleTradeGoodsBin)
+         itemID = purpleTradeGoods[urand(0, purpleTradeGoods.size() - 1)];
+
+      if (value <= blueTradeGoodsBin)
+         itemID = blueTradeGoods[urand(0, blueTradeGoods.size() - 1)];
+
+      if (value <= greenTradeGoodsBin)
+         itemID = greenTradeGoods[urand(0, greenTradeGoods.size() - 1)];
+
+      if (value <= whiteTradeGoodsBin)
+         itemID = whiteTradeGoods[urand(0, whiteTradeGoods.size() - 1)];
+
+      ItemPrototype const* prototype = objmgr.GetItemPrototype(itemID);
+      if (prototype == NULL)
+      {
+         sLog.outString("AuctionHouseBot: Huh?!?! prototype == NULL");
+         continue;
+      }
+
+      Item* item = Item::CreateItem(itemID, 1, AHBplayer);
+	  item->AddToUpdateQueueOf(AHBplayer);
+      if (item == NULL)
+      {
+         sLog.outString("AuctionHouseBot: Item::CreateItem() returned NULL");
+         break;
+      }
+
+      uint32 randomPropertyId = Item::GenerateItemRandomPropertyId(itemID);
+      if (randomPropertyId != 0)
+         item->SetItemRandomProperties(randomPropertyId);
+
+      uint32 buyoutPrice = prototype->BuyPrice * item->GetCount();
+      uint32 bidPrice = 0;
+      uint32 stackCount = urand(1, item->GetMaxStackCount());
+
+      switch (prototype->Quality)
+      {
+         case 1:
+            if (maxStackWhite != 0)
+            {
+               stackCount = urand(1, minValue(item->GetMaxStackCount(), 
+                                              maxStackWhite));
+            }
+
+            buyoutPrice *= urand(minPriceWhite, maxPriceWhite) * stackCount;
+            buyoutPrice /= 100;
+            bidPrice = buyoutPrice * bidPriceWhite;
+            bidPrice /= 100;
+
+            break;
+
+         case 2:
+            if (maxStackGreen != 0)
+            {
+               stackCount = urand(1, minValue(item->GetMaxStackCount(), 
+                                              maxStackGreen));
+            }
+
+            buyoutPrice *= urand(minPriceGreen, maxPriceGreen) * stackCount;
+            buyoutPrice /= 100;
+            bidPrice = buyoutPrice * bidPriceGreen;
+            bidPrice /= 100;
+
+            break;
+
+         case 3:
+            if (maxStackBlue != 0)
+            {
+               stackCount = urand(1, minValue(item->GetMaxStackCount(), 
+                                              maxStackBlue));
+            }
+
+            buyoutPrice *= urand(minPriceBlue, maxPriceBlue) * stackCount;
+            buyoutPrice /= 100;
+            bidPrice = buyoutPrice * bidPriceBlue;
+            bidPrice /= 100;
+
+            break;
+
+         case 4:
+            if (maxStackPurple != 0)
+            {
+               stackCount = urand(1, minValue(item->GetMaxStackCount(), 
+                                              maxStackPurple));
+            }
+
+            buyoutPrice *= urand(minPricePurple, maxPricePurple) * stackCount;
+            buyoutPrice /= 100;
+            bidPrice = buyoutPrice * bidPricePurple;
+            bidPrice /= 100;
+
+            break;
+      }
+
+      item->SetCount(stackCount);
+
+      AuctionEntry* auctionEntry = new AuctionEntry;
+      auctionEntry->Id = objmgr.GenerateAuctionID();
+      auctionEntry->auctioneer = 0;
+      auctionEntry->item_guidlow = item->GetGUIDLow();
+      auctionEntry->item_template = item->GetEntry();
+      auctionEntry->owner = AHBplayer->GetGUIDLow();
+      auctionEntry->startbid = bidPrice;
+      auctionEntry->buyout = buyoutPrice;
+      auctionEntry->bidder = 0;
+      auctionEntry->bid = 0;
+      auctionEntry->deposit = 0;
+      auctionEntry->location = ahMapID;
+      auctionEntry->time = (time_t) (urand(minTime, maxTime) * 60 * 60 + 
+                                     time(NULL));
+      
+      item->SaveToDB();
+      item->RemoveFromUpdateQueueOf(AHBplayer);
+      objmgr.AddAItem(item);
+      auctionHouse->AddAuction(auctionEntry);
+
+      CharacterDatabase.PExecute("INSERT INTO `auctionhouse` (`id`,"
+                                 "`auctioneerguid`,`itemguid`,`item_template`,"
+                                 "`itemowner`,`buyoutprice`,`time`,`buyguid`,"
+                                 "`lastbid`,`startbid`,`deposit`,`location`) "
+                                 "VALUES ('%u', '%u', '%u', '%u', '%u', '%u', "
+                                 "'" I64FMTD "', '%u', '%u', '%u', '%u', '%u')",
+                                 auctionEntry->Id, 
+                                 auctionEntry->auctioneer,
+                                 auctionEntry->item_guidlow, 
+                                 auctionEntry->item_template, 
+                                 auctionEntry->owner, 
+                                 auctionEntry->buyout, 
+                                 (uint64) auctionEntry->time, 
+                                 auctionEntry->bidder, 
+                                 auctionEntry->bid, 
+                                 auctionEntry->startbid, 
+                                 auctionEntry->deposit, 
+                                 auctionEntry->location);
+   }
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+///////////////////////////////////////////////////////////////////////////////
+void AuctionHouseBot()
+{
+   if ((AHBplayerAccount == 0) || (AHBplayerGUID == 0))
+      return;
+
+   WorldSession _session(AHBplayerAccount, NULL, 0, true, 0, LOCALE_enUS);
+   Player _AHBplayer(&_session);
+   _AHBplayer.MinimalLoadFromDB(NULL, AHBplayerGUID);
+   ObjectAccessor::Instance().AddObject(&_AHBplayer);
+
+   deleteOldAuctions(2);
+   deleteOldAuctions(6);
+   deleteOldAuctions(7);
+
+   addNewAuctions(2, numAllianceItems, numMinAllianceItems, &_AHBplayer);
+   addNewAuctions(6, numHordeItems, numMinHordeItems, &_AHBplayer);
+   addNewAuctions(7, numNeutralItems, numMinNeutralItems, &_AHBplayer);
+   
+   ObjectAccessor::Instance().RemoveObject(&_AHBplayer);
+}
+///////////////////////////////////////////////////////////////////////////////
+//
+///////////////////////////////////////////////////////////////////////////////
+void AuctionHouseBotInit()
+{
+   AHBplayerAccount = sConfig.GetIntDefault("AuctionHouseBot.Account", 0);
+   AHBplayerGUID = sConfig.GetIntDefault("AuctionHouseBot.GUID", 0);
+                         
+   if ((AHBplayerAccount == 0) || (AHBplayerGUID == 0))
+   {
+      sLog.outString("AuctionHouseBot disabled");
+      return;            
+   }
+
+   noMail = sConfig.GetIntDefault("AuctionHouseBot.NoMail", 0);
+
+   numAllianceItems = sConfig.GetIntDefault("AuctionHouseBot.AllianceItems", 0);
+   numMinAllianceItems = sConfig.GetIntDefault("AuctionHouseBot.MinAllianceItems", -1);
+   numHordeItems = sConfig.GetIntDefault("AuctionHouseBot.HordeItems", 0);
+   numMinHordeItems = sConfig.GetIntDefault("AuctionHouseBot.MinHordeItems", -1);
+   numNeutralItems = sConfig.GetIntDefault("AuctionHouseBot.NeutralItems", 0);
+   numMinNeutralItems = sConfig.GetIntDefault("AuctionHouseBot.MinNeutralItems", -1);
+
+   if (numMinAllianceItems < 0)
+	   numMinAllianceItems = numAllianceItems;
+
+   if (numMinHordeItems  < 0)
+	   numMinHordeItems = numHordeItems;
+
+   if (numMinNeutralItems  < 0)
+	   numMinNeutralItems = numNeutralItems;
+
+   if (numMinAllianceItems > numAllianceItems)
+	   numMinAllianceItems = numAllianceItems;
+
+   if (numMinHordeItems > numHordeItems)
+	   numMinHordeItems = numHordeItems;
+
+   if (numMinNeutralItems > numNeutralItems)
+	   numMinNeutralItems = numNeutralItems;
+
+   minTime = sConfig.GetIntDefault("AuctionHouseBot.MinTime", 8);
+   maxTime = sConfig.GetIntDefault("AuctionHouseBot.MaxTime", 24);
+
+   if (minTime < 1)
+      minTime = 1;
+
+   if (maxTime > 24)
+      maxTime = 24;
+
+   if (minTime > maxTime)
+      minTime = maxTime;
+
+   percentWhiteTradeGoods = sConfig.GetIntDefault("AuctionHouseBot."
+                                                  "PercentWhiteTradeGoods",
+                                                  27);
+   percentGreenTradeGoods = sConfig.GetIntDefault("AuctionHouseBot."
+                                                  "PercentGreenTradeGoods",
+                                                  12);
+   percentBlueTradeGoods = sConfig.GetIntDefault("AuctionHouseBot."
+                                                  "PercentBlueTradeGoods",
+                                                  10);
+   percentPurpleTradeGoods = sConfig.GetIntDefault("AuctionHouseBot."
+                                                  "PercentPurpleTradeGoods",
+                                                  1);
+   percentWhiteItems = sConfig.GetIntDefault("AuctionHouseBot."
+                                             "PercentWhiteItems",
+                                             10);
+   percentGreenItems = sConfig.GetIntDefault("AuctionHouseBot."
+                                             "PercentGreenItems",
+                                             30);
+   percentBlueItems = sConfig.GetIntDefault("AuctionHouseBot."
+                                            "PercentBlueItems",
+                                            8);
+   percentPurpleItems = sConfig.GetIntDefault("AuctionHouseBot."
+                                              "PercentPurpleItems",
+                                              2);
+
+   uint32 totalPercent = percentWhiteTradeGoods + percentGreenTradeGoods +
+                         percentBlueTradeGoods + percentPurpleTradeGoods +
+                         percentWhiteItems + percentGreenItems + 
+                         percentBlueItems + percentPurpleItems;
+
+   if (totalPercent == 0)
+   {
+      numAllianceItems = 0;
+      numHordeItems = 0;
+      numNeutralItems = 0;
+   }
+   else if (totalPercent != 100)
+   {
+      double scale = (double) 100 / (double) totalPercent;
+
+      percentPurpleItems = (uint32) (scale * (double) percentPurpleItems);
+      percentBlueItems = (uint32) (scale * (double) percentBlueItems);
+      percentGreenItems = (uint32) (scale * (double) percentGreenItems);
+      percentWhiteItems = (uint32) (scale * (double) percentWhiteItems);
+      percentPurpleTradeGoods = (uint32) (scale * 
+                                          (double) percentPurpleTradeGoods);
+      percentBlueTradeGoods = (uint32) (scale * 
+                                        (double) percentBlueTradeGoods);
+      percentGreenTradeGoods = (uint32) (scale * 
+                                         (double) percentGreenTradeGoods);
+      percentWhiteTradeGoods = 100 - 
+                               percentGreenTradeGoods - 
+                               percentBlueTradeGoods -
+                               percentPurpleTradeGoods -
+                               percentWhiteItems -
+                               percentGreenItems -
+                               percentBlueItems -
+                               percentPurpleItems;
+
+      sLog.outString("AuctionHouseBot:");
+      sLog.outString("sum of item percentages not equal to 100, adjusting...");
+      sLog.outString("AuctionHouseBot.PercentWhiteTradeGoods = %d",
+                     percentWhiteTradeGoods);
+      sLog.outString("AuctionHouseBot.PercentGreenTradeGoods = %d",
+                     percentGreenTradeGoods);
+      sLog.outString("AuctionHouseBot.PercentBlueTradeGoods = %d",
+                     percentBlueTradeGoods);
+      sLog.outString("AuctionHouseBot.PercentPurpleTradeGoods = %d",
+                     percentPurpleTradeGoods);
+      sLog.outString("AuctionHouseBot.PercentWhiteItems = %d",
+                     percentWhiteItems);
+      sLog.outString("AuctionHouseBot.PercentGreenItems = %d",
+                     percentGreenItems);
+      sLog.outString("AuctionHouseBot.PercentBlueItems = %d",
+                     percentBlueItems);
+      sLog.outString("AuctionHouseBot.PercentPurpleItems = %d",
+                     percentPurpleItems);
+   }
+
+   minPriceWhite = sConfig.GetIntDefault("AuctionHouseBot.MinPriceWhite",
+                                         150);
+   maxPriceWhite = sConfig.GetIntDefault("AuctionHouseBot.MaxPriceWhite",
+                                         250);
+
+   if (minPriceWhite == 0)
+      minPriceWhite = 1;
+
+   if (maxPriceWhite == 0)
+      maxPriceWhite = 1;
+
+   if (minPriceWhite > maxPriceWhite)
+      minPriceWhite = maxPriceWhite;
+
+   bidPriceWhite = sConfig.GetIntDefault("AuctionHouseBot.BidPriceWhite",
+                                         100);
+   if (bidPriceWhite > 100)
+      bidPriceWhite = 100;
+
+   maxStackWhite = sConfig.GetIntDefault("AuctionHouseBot.MaxStackWhite", 0);
+
+   minPriceGreen = sConfig.GetIntDefault("AuctionHouseBot.MinPriceGreen",
+                                         200);
+   maxPriceGreen = sConfig.GetIntDefault("AuctionHouseBot.MaxPriceGreen",
+                                         300);
+
+   if (minPriceGreen == 0)
+      minPriceGreen = 1;
+
+   if (maxPriceGreen == 0)
+      maxPriceGreen = 1;
+
+   if (minPriceGreen > maxPriceGreen)
+      minPriceGreen = maxPriceGreen;
+
+   bidPriceGreen = sConfig.GetIntDefault("AuctionHouseBot.BidPriceGreen",
+                                         100);
+   if (bidPriceGreen > 100)
+      bidPriceGreen = 100;
+
+   maxStackGreen = sConfig.GetIntDefault("AuctionHouseBot.MaxStackGreen", 0);
+
+   minPriceBlue = sConfig.GetIntDefault("AuctionHouseBot.MinPriceBlue",
+                                        250);
+   maxPriceBlue = sConfig.GetIntDefault("AuctionHouseBot.MaxPriceBlue",
+                                        350);
+
+   if (minPriceBlue == 0)
+      minPriceBlue = 1;
+
+   if (maxPriceBlue == 0)
+      maxPriceBlue = 1;
+
+   if (minPriceBlue > maxPriceBlue)
+      minPriceBlue = maxPriceBlue;
+
+   bidPriceBlue = sConfig.GetIntDefault("AuctionHouseBot.BidPriceBlue",
+                                        100);
+   if (bidPriceBlue > 100)
+      bidPriceBlue = 100;
+
+   maxStackBlue = sConfig.GetIntDefault("AuctionHouseBot.MaxStackBlue", 0);
+
+   minPricePurple = sConfig.GetIntDefault("AuctionHouseBot.MinPricePurple",
+                                          300);
+   maxPricePurple = sConfig.GetIntDefault("AuctionHouseBot.MaxPricePurple",
+                                          450);
+
+   if (minPricePurple == 0)
+      minPricePurple = 1;
+
+   if (maxPricePurple == 0)
+      maxPricePurple = 1;
+
+   if (minPricePurple > maxPricePurple)
+      minPricePurple = maxPricePurple;
+
+   bidPricePurple = sConfig.GetIntDefault("AuctionHouseBot.BidPricePurple",
+                                          100);
+   if (bidPricePurple > 100)
+      bidPricePurple = 100;
+
+   maxStackPurple = sConfig.GetIntDefault("AuctionHouseBot.MaxStackPurple", 0);
+
+   QueryResult* results = (QueryResult*) NULL;
+
+#ifdef NO_VENDOR_ITEMS
+   vector<uint32> npcItems;
+
+   char npcQuery[] = "SELECT `item` FROM `npc_vendor`";
+
+   results = WorldDatabase.PQuery(npcQuery);
+   if (results != NULL)
+   {
+      do
+      {
+         Field* fields = results->Fetch();
+         npcItems.push_back(fields[0].GetUInt32());
+
+      } while (results->NextRow());
+
+      delete results;
+   }
+   else
+   {
+      sLog.outString("AuctionHouseBot: \"%s\" failed", npcQuery);
+   }
+#endif
+
+#ifdef ONLY_LOOT_ITEMS
+   vector<uint32> lootItems;
+
+   char lootQuery[] = "SELECT `item` FROM `creature_loot_template` UNION "
+                      "SELECT `item` FROM `disenchant_loot_template` UNION "
+                      "SELECT `item` FROM `fishing_loot_template` UNION "
+                      "SELECT `item` FROM `gameobject_loot_template` UNION "
+                      "SELECT `item` FROM `item_loot_template` UNION "
+                      "SELECT `item` FROM `pickpocketing_loot_template` UNION "
+                      "SELECT `item` FROM `prospecting_loot_template` UNION "
+                      "SELECT `item` FROM `skinning_loot_template`";
+
+   results = WorldDatabase.PQuery(lootQuery);
+   if (results != NULL)
+   {
+      do
+      {
+         Field* fields = results->Fetch();
+         lootItems.push_back(fields[0].GetUInt32());
+   
+      } while (results->NextRow());
+   
+      delete results;
+   }
+   else
+   {
+      sLog.outString("AuctionHouseBot: \"%s\" failed", lootQuery);
+   }
+#endif
+
+   for (uint32 itemID = 0; itemID < sItemStorage.MaxEntry; itemID++)
+   {
+      ItemPrototype const* prototype = objmgr.GetItemPrototype(itemID);
+
+      if (prototype == NULL)
+         continue;
+
+      if ((prototype->Bonding != NO_BIND) &&
+          (prototype->Bonding != BIND_WHEN_EQUIPED))
+      {
+         continue;
+      }
+
+      if (prototype->BuyPrice == 0)
+         continue;
+         
+      if ((prototype->Quality < 1) || (prototype->Quality > 4))
+         continue;
+
+#ifdef NO_VENDOR_ITEMS
+      bool isVendorItem = false;
+
+      for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorItem); i++)
+      {         
+         if (itemID == npcItems[i])
+            isVendorItem = true;
+      }
+
+      if (isVendorItem)
+         continue;
+#endif
+
+#ifdef ONLY_LOOT_ITEMS
+      bool isLootItem = false;
+
+      for (unsigned int i = 0; (i < lootItems.size()) && (!isLootItem); i++)
+      {         
+         if (itemID == lootItems[i])
+            isLootItem = true;
+      }
+      
+      if (!isLootItem)
+         continue;
+#endif
+
+      switch (prototype->Quality)
+      {
+         case 1:
+            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+               whiteTradeGoods.push_back(itemID);
+            else
+               whiteItems.push_back(itemID);
+            break;
+   
+         case 2:
+            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+               greenTradeGoods.push_back(itemID);
+            else
+               greenItems.push_back(itemID);
+            break;
+   
+         case 3:
+            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+               blueTradeGoods.push_back(itemID);
+            else
+               blueItems.push_back(itemID);
+            break;
+   
+         case 4:
+            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+               purpleTradeGoods.push_back(itemID);
+            else
+               purpleItems.push_back(itemID);
+            break;
+      }
+   }
+   
+   if ((whiteTradeGoods.size() == 0) ||
+       (greenTradeGoods.size() == 0) ||
+       (blueTradeGoods.size() == 0) ||
+       (purpleTradeGoods.size() == 0) ||
+       (whiteItems.size() == 0) ||
+       (greenItems.size() == 0) ||
+       (blueItems.size() == 0) ||
+       (purpleItems.size() == 0))
+   {
+      sLog.outString("AuctionHouseBot: not loaded DB error?");
+      AHBplayerAccount = 0;
+      AHBplayerGUID = 0;
+      return;
+   }
+  
+   sLog.outString("AuctionHouseBot:");
+   sLog.outString("loaded %d white trade goods", whiteTradeGoods.size());
+   sLog.outString("loaded %d green trade goods", greenTradeGoods.size());
+   sLog.outString("loaded %d blue trade goods", blueTradeGoods.size());
+   sLog.outString("loaded %d purple trade goods", purpleTradeGoods.size());
+   sLog.outString("loaded %d white items", whiteItems.size());
+   sLog.outString("loaded %d green items", greenItems.size());
+   sLog.outString("loaded %d blue items", blueItems.size());
+   sLog.outString("loaded %d purple items", purpleItems.size());
+   sLog.outString("AuctionHouseBot v5.8.6691 by |Paradox| (original by ChrisK)  has been loaded.");
+
+}
diff --git a/src/game/AuctionHouseBot.h b/src/game/AuctionHouseBot.h
new file mode 100644
index 0000000..04815b7
--- /dev/null
+++ b/src/game/AuctionHouseBot.h
@@ -0,0 +1,10 @@
+#ifndef AUCTION_HOUSE_BOT_H
+#define AUCTION_HOUSE_BOT_H
+
+#include "Common.h"
+
+uint32 AuctionHouseBotNoMail();
+void AuctionHouseBot();
+void AuctionHouseBotInit();
+
+#endif
diff --git a/src/game/BattleGround.cpp b/src/game/BattleGround.cpp
index 2781ef6..3c335e6 100644
--- a/src/game/BattleGround.cpp
+++ b/src/game/BattleGround.cpp
@@ -24,6 +24,7 @@
 #include "Language.h"
 #include "Chat.h"
 #include "SpellAuras.h"
+#include "ArenaTeam.h"
 #include "World.h"
 #include "Util.h"
 
@@ -47,6 +48,8 @@ BattleGround::BattleGround()
     m_Name              = "";
     m_LevelMin          = 0;
     m_LevelMax          = 0;
+    m_InBGFreeSlotQueue = false;
+    m_SetDeleteThis     = false;
 
     m_MaxPlayersPerTeam = 0;
     m_MaxPlayers        = 0;
@@ -67,21 +70,54 @@ BattleGround::BattleGround()
     m_TeamStartLocO[BG_TEAM_ALLIANCE]   = 0;
     m_TeamStartLocO[BG_TEAM_HORDE]      = 0;
 
+    m_ArenaTeamIds[BG_TEAM_ALLIANCE]   = 0;
+    m_ArenaTeamIds[BG_TEAM_HORDE]      = 0;
+
+    m_ArenaTeamRatingChanges[BG_TEAM_ALLIANCE]   = 0;
+    m_ArenaTeamRatingChanges[BG_TEAM_HORDE]      = 0;
+
     m_BgRaids[BG_TEAM_ALLIANCE]         = NULL;
     m_BgRaids[BG_TEAM_HORDE]            = NULL;
 
     m_PlayersCount[BG_TEAM_ALLIANCE]    = 0;
     m_PlayersCount[BG_TEAM_HORDE]       = 0;
+
+    m_PrematureCountDown = false;
+    m_PrematureCountDown = 0;
 }
 
 BattleGround::~BattleGround()
 {
+    // remove objects and creatures
+    // (this is done automatically in mapmanager update, when the instance is reset after the reset time)    
+    int size = m_BgCreatures.size();
+    for(int i = 0; i < size; ++i)
+    {
+        DelCreature(i);
+    }
+    size = m_BgObjects.size();
+    for(int i = 0; i < size; ++i)
+    {
+        DelObject(i);
+    }
 
+    // delete creature and go respawn times
+    WorldDatabase.PExecute("DELETE FROM creature_respawn WHERE instance = '%u'",GetInstanceID());
+    WorldDatabase.PExecute("DELETE FROM gameobject_respawn WHERE instance = '%u'",GetInstanceID());
+    // delete instance from db
+    CharacterDatabase.PExecute("DELETE FROM instance WHERE id = '%u'",GetInstanceID());
+    // remove from battlegrounds
+    sBattleGroundMgr.RemoveBattleGround(GetInstanceID());
+    // unload map
+    if(Map * map = MapManager::Instance().FindMap(GetMapId(), GetInstanceID()))
+        if(map->IsBattleGroundOrArena())
+            ((BattleGroundMap*)map)->SetUnload();
+    // remove from bg free slot queue
+    this->RemoveFromBGFreeSlotQueue();
 }
 
 void BattleGround::Update(time_t diff)
 {
-
     if(!GetPlayersSize() && !GetRemovedPlayersSize() && !GetReviveQueueSize())
         //BG is empty
         return;
@@ -182,12 +218,56 @@ void BattleGround::Update(time_t diff)
             if(!plr)
                 continue;
             plr->ResurrectPlayer(1.0f);
+
+            //restore player's pet
+            if(plr->GetLastPetNumber() && plr->isAlive())
+            {
+                Pet* NewPet = new Pet();
+
+				if(!NewPet->LoadPetFromDB(plr, 0, plr->GetLastPetNumber(), true))
+                    delete NewPet;
+				//restore pet's Health and Mana
+				else
+				{	
+					NewPet->SetHealth(NewPet->GetMaxHealth());
+					NewPet->SetPower(POWER_MANA,NewPet->GetMaxPower(POWER_MANA));
+                    NewPet->SetPower(POWER_HAPPINESS ,NewPet->GetMaxPower(POWER_HAPPINESS));
+				}
+            }
+
             plr->CastSpell(plr, SPELL_SPIRIT_HEAL_MANA, true);
             ObjectAccessor::Instance().ConvertCorpseForPlayer(*itr);
         }
         m_ResurrectQueue.clear();
     }
 
+    // if less then minimum players are in on one side, then start premature finish timer
+    if(GetStatus() == STATUS_IN_PROGRESS && !isArena() && sBattleGroundMgr.GetPrematureFinishTime() && (GetPlayersCountByTeam(ALLIANCE) < GetMinPlayersPerTeam() || GetPlayersCountByTeam(HORDE) < GetMinPlayersPerTeam()))
+    {
+        if(!m_PrematureCountDown)
+        {
+            m_PrematureCountDown = true;
+            m_PrematureCountDownTimer = sBattleGroundMgr.GetPrematureFinishTime();
+            SendMessageToAll(LANG_BATTLEGROUND_PREMATURE_FINISH_WARNING);
+        }
+        else if(m_PrematureCountDownTimer < diff)
+        {
+            // time's up!
+            EndBattleGround(0); // noone wins
+            m_PrematureCountDown = false;
+        } 
+        else 
+        {
+            uint32 newtime = m_PrematureCountDownTimer - diff;
+            // announce every minute
+            if(m_PrematureCountDownTimer != sBattleGroundMgr.GetPrematureFinishTime() && newtime / 60000 != m_PrematureCountDownTimer / 60000)
+                SendMessageToAll(LANG_BATTLEGROUND_PREMATURE_FINISH_WARNING);
+            m_PrematureCountDownTimer = newtime;
+        }
+    }
+    else if (m_PrematureCountDown)
+        m_PrematureCountDown = false;
+
     if(GetStatus() == STATUS_WAIT_LEAVE)
     {
         // remove all players from battleground after 2 minutes
@@ -239,7 +319,10 @@ void BattleGround::SendPacketToTeam(uint32 TeamID, WorldPacket *packet, Player *
         if(!self && sender == plr)
             continue;
 
-        if(plr->GetTeam() == TeamID)
+        uint32 team = itr->second.Team;//GetPlayerTeam(plr->GetGUID());
+        if(!team) team = plr->GetTeam();
+
+        if(team == TeamID)
             plr->GetSession()->SendPacket(packet);
     }
 }
@@ -265,7 +348,10 @@ void BattleGround::PlaySoundToTeam(uint32 SoundID, uint32 TeamID)
             continue;
         }
 
-        if(plr->GetTeam() == TeamID)
+        uint32 team = itr->second.Team;//GetPlayerTeam(plr->GetGUID());
+        if(!team) team = plr->GetTeam();
+
+        if(team == TeamID)
         {
             sBattleGroundMgr.BuildPlaySoundPacket(&data, SoundID);
             plr->GetSession()->SendPacket(&data);
@@ -285,7 +371,10 @@ void BattleGround::CastSpellOnTeam(uint32 SpellID, uint32 TeamID)
             continue;
         }
 
-        if(plr->GetTeam() == TeamID)
+        uint32 team = itr->second.Team;//GetPlayerTeam(plr->GetGUID());
+        if(!team) team = plr->GetTeam();
+       
+        if(team == TeamID)
             plr->CastSpell(plr, SpellID, true);
     }
 }
@@ -302,7 +391,10 @@ void BattleGround::RewardHonorToTeam(uint32 Honor, uint32 TeamID)
             continue;
         }
 
-        if(plr->GetTeam() == TeamID)
+        uint32 team = itr->second.Team;//GetPlayerTeam(plr->GetGUID());
+        if(!team) team = plr->GetTeam();
+
+        if(team == TeamID)
             UpdatePlayerScore(plr, SCORE_BONUS_HONOR, Honor);
     }
 }
@@ -324,7 +416,10 @@ void BattleGround::RewardReputationToTeam(uint32 faction_id, uint32 Reputation,
             continue;
         }
 
-        if(plr->GetTeam() == TeamID)
+        uint32 team = itr->second.Team;//GetPlayerTeam(plr->GetGUID());
+        if(!team) team = plr->GetTeam();
+
+        if(team == TeamID)
             plr->ModifyFactionReputation(factionEntry, Reputation);
     }
 }
@@ -345,30 +440,86 @@ void BattleGround::UpdateWorldStateForPlayer(uint32 Field, uint32 Value, Player
 
 void BattleGround::EndBattleGround(uint32 winner)
 {
+    this->RemoveFromBGFreeSlotQueue();
+
+    ArenaTeam * winner_arena_team = NULL;
+    ArenaTeam * loser_arena_team = NULL;
+    uint32 loser_rating = 0;
+    uint32 winner_rating = 0;
     WorldPacket data;
     Player *Source = NULL;
     const char *winmsg = "";
 
     if(winner == ALLIANCE)
     {
-        winmsg = GetMangosString(LANG_BG_A_WINS);
+        if(isBattleGround())
+            winmsg = GetMangosString(LANG_BG_A_WINS);
+        else
+            winmsg = GetMangosString(LANG_ARENA_GOLD_WINS);
 
         PlaySoundToAll(SOUND_ALLIANCE_WINS);                // alliance wins sound
 
         SetWinner(WINNER_ALLIANCE);
     }
-    else
+    else if(winner == HORDE)
     {
-        winmsg = GetMangosString(LANG_BG_H_WINS);
+        if(isBattleGround())
+            winmsg = GetMangosString(LANG_BG_H_WINS);
+        else
+            winmsg = GetMangosString(LANG_ARENA_GREEN_WINS);
 
         PlaySoundToAll(SOUND_HORDE_WINS);                   // horde wins sound
 
         SetWinner(WINNER_HORDE);
     }
+    else
+    {
+        SetWinner(3);
+    }
 
     SetStatus(STATUS_WAIT_LEAVE);
     m_EndTime = 0;
 
+    // arena rating calculation
+    if(isArena() && isRated())
+    {
+        if(winner == ALLIANCE)
+        {
+            winner_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(ALLIANCE));
+            loser_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(HORDE));
+        }
+        else if(winner == HORDE)
+        {
+            winner_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(HORDE));
+            loser_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(ALLIANCE));
+        }
+        if(winner_arena_team && loser_arena_team)
+        {
+            loser_rating = loser_arena_team->GetStats().rating;
+            winner_rating = winner_arena_team->GetStats().rating;
+            float winner_chance = winner_arena_team->GetChanceAgainst(loser_rating);
+            float loser_chance = loser_arena_team->GetChanceAgainst(winner_rating);
+            int32 winner_change = winner_arena_team->WonAgainstChance(winner_chance);
+            int32 loser_change = loser_arena_team->LostAgainstChance(loser_chance);
+            sLog.outDebug("--- %u ; %u ; %d ; %d ; %u ; %u ---",winner_rating,loser_rating,winner_chance,loser_chance,winner_change,loser_change);
+            if(winner == ALLIANCE)
+            {
+                SetArenaTeamRatingChangeForTeam(ALLIANCE, winner_change);
+                SetArenaTeamRatingChangeForTeam(HORDE, loser_change);
+            }
+            else
+            {
+                SetArenaTeamRatingChangeForTeam(HORDE, winner_change);
+                SetArenaTeamRatingChangeForTeam(ALLIANCE, loser_change);
+            }
+        }
+        else
+        {
+            SetArenaTeamRatingChangeForTeam(ALLIANCE, 0);
+            SetArenaTeamRatingChangeForTeam(HORDE, 0);
+        }
+    }
+
     for(std::map<uint64, BattleGroundPlayer>::iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
     {
         Player *plr = objmgr.GetPlayer(itr->first);
@@ -378,13 +529,29 @@ void BattleGround::EndBattleGround(uint32 winner)
             continue;
         }
 
+        // should remove spirit of redemption
+        if(plr->HasAuraType(SPELL_AURA_SPIRIT_OF_REDEMPTION))
+            plr->RemoveSpellsCausingAura(SPELL_AURA_MOD_SHAPESHIFT);
+
         if(!plr->isAlive())
         {
             plr->ResurrectPlayer(1.0f);
             plr->SpawnCorpseBones();
         }
 
-        if(plr->GetTeam() == winner)
+        uint32 team = itr->second.Team;//GetPlayerTeam(plr->GetGUID());
+        if(!team) team = plr->GetTeam();
+
+        // per player calculation
+        if(isArena() && isRated() && winner_arena_team && loser_arena_team)
+        {
+            if(team == winner)
+                winner_arena_team->MemberWon(plr,loser_rating);
+            else
+                loser_arena_team->MemberLost(plr,winner_rating);
+        }
+
+        if(team == winner)
         {
             if(!Source)
                 Source = plr;
@@ -404,10 +571,28 @@ void BattleGround::EndBattleGround(uint32 winner)
         sBattleGroundMgr.BuildPvpLogDataPacket(&data, this);
         plr->GetSession()->SendPacket(&data);
 
-        sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, this, plr->GetTeam(), plr->GetBattleGroundQueueIndex(m_TypeID), STATUS_IN_PROGRESS, TIME_TO_AUTOREMOVE, GetStartTime());
+        uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(GetTypeID(), GetArenaType());
+        sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, this, plr->GetTeam(), plr->GetBattleGroundQueueIndex(bgQueueTypeId), STATUS_IN_PROGRESS, TIME_TO_AUTOREMOVE, GetStartTime());
         plr->GetSession()->SendPacket(&data);
     }
 
+    if(isArena() && isRated() && winner_arena_team && loser_arena_team)
+    {
+        // update arena points only after increasing the player's match count!
+        winner_arena_team->UpdateArenaPointsHelper();
+        loser_arena_team->UpdateArenaPointsHelper();
+        // save the stat changes
+        winner_arena_team->SaveToDB();
+        loser_arena_team->SaveToDB();
+        // send updated arena team stats to players
+        // this way all arena team members will get notified, not only the ones who participated in this match
+        winner_arena_team->NotifyStatsChanged();
+        loser_arena_team->NotifyStatsChanged();
+    }
+
+    // inform invited players about the removal
+    sBattleGroundMgr.m_BattleGroundQueues[sBattleGroundMgr.BGQueueTypeId(GetTypeID(), GetArenaType())].BGEndedRemoveInvites(this);
+
     if(Source)
     {
         ChatHandler(Source).FillMessageData(&data, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, Source->GetGUID(), winmsg);
@@ -558,12 +743,16 @@ void BattleGround::BlockMovement(Player *plr)
 
 void BattleGround::RemovePlayerAtLeave(uint64 guid, bool Transport, bool SendPacket)
 {
+    uint32 team = GetPlayerTeam(guid);
+    bool participant = false;
     // Remove from lists/maps
     std::map<uint64, BattleGroundPlayer>::iterator itr = m_Players.find(guid);
     if(itr != m_Players.end())
     {
-        UpdatePlayersCountByTeam(itr->second.Team, true);   // -1 player
+        UpdatePlayersCountByTeam(team, true);   // -1 player
         m_Players.erase(itr);
+        // check if the player was a participant of the match, or only entered through gm command (goname)
+        participant = true;
     }
 
     std::map<uint64, BattleGroundScore*>::iterator itr2 = m_PlayerScores.find(guid);
@@ -577,6 +766,10 @@ void BattleGround::RemovePlayerAtLeave(uint64 guid, bool Transport, bool SendPac
 
     Player *plr = objmgr.GetPlayer(guid);
 
+    // should remove spirit of redemption
+    if(plr && plr->HasAuraType(SPELL_AURA_SPIRIT_OF_REDEMPTION))
+        plr->RemoveSpellsCausingAura(SPELL_AURA_MOD_SHAPESHIFT);
+
     if(plr && !plr->isAlive())                              // resurrect on exit
     {
         plr->ResurrectPlayer(1.0f);
@@ -589,66 +782,106 @@ void BattleGround::RemovePlayerAtLeave(uint64 guid, bool Transport, bool SendPac
     {
         plr->ClearAfkReports();
 
-        if(isArena())
+        if(participant) // if the player was a match participant, remove auras, calc rating, update queue
         {
-            if(!sWorld.IsFFAPvPRealm())
-                plr->RemoveFlag(PLAYER_FLAGS, PLAYER_FLAGS_FFA_PVP);
-        }
+            if(!team) team = plr->GetTeam();
 
-        WorldPacket data;
-        if(SendPacket)
-        {
-            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, this, plr->GetTeam(), plr->GetBattleGroundQueueIndex(m_TypeID), STATUS_NONE, 0, 0);
-            plr->GetSession()->SendPacket(&data);
-        }
+            uint32 bgTypeId = GetTypeID();
+            uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(GetTypeID(), GetArenaType());
+            // if arena, remove the specific arena auras
+            if(isArena())
+            {
+                plr->RemoveArenaAuras(true);    // removes debuffs / dots etc., we don't want the player to die after porting out
+                bgTypeId=BATTLEGROUND_AA;       // set the bg type to all arenas (it will be used for queue refreshing)
 
-        // this call is important, because player, when joins to battleground, this method is not called, so it must be called when leaving bg
-        plr->RemoveBattleGroundQueueId(m_TypeID);
+                // summon old pet if there was one and there isn't a current pet
+                if(!plr->GetPet() && plr->GetTemporaryUnsummonedPetNumber())
+                {
+                    Pet* NewPet = new Pet;
+                    if(!NewPet->LoadPetFromDB(plr, 0, (plr)->GetTemporaryUnsummonedPetNumber(), true))
+                        delete NewPet;
 
-        DecreaseInvitedCount(plr->GetTeam());
-        //we should update battleground queue, but only if bg isn't ending
-        if (GetQueueType() < MAX_BATTLEGROUND_QUEUES)
-            sBattleGroundMgr.m_BattleGroundQueues[GetTypeID()].Update(GetTypeID(), GetQueueType());
+                    (plr)->SetTemporaryUnsummonedPetNumber(0);
+                }
 
-        if(!plr->GetBattleGroundId())
-            return;
+                if(isRated() && GetStatus() == STATUS_IN_PROGRESS)
+                {
+                    //left a rated match while the encounter was in progress, consider as loser
+                    ArenaTeam * winner_arena_team = 0;
+                    ArenaTeam * loser_arena_team = 0;
+                    if(team == HORDE)
+                    {
+                        winner_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(ALLIANCE));
+                        loser_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(HORDE));
+                    }
+                    else
+                    {
+                        winner_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(HORDE));
+                        loser_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(ALLIANCE));
+                    }
+                    if(winner_arena_team && loser_arena_team)
+                    {
+                        loser_arena_team->MemberLost(plr,winner_arena_team->GetRating());
+                    }
+                }
+            }
 
-        Group * group = plr->GetGroup();
+            WorldPacket data;
+            if(SendPacket)
+            {
+                sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, this, team, plr->GetBattleGroundQueueIndex(bgQueueTypeId), STATUS_NONE, 0, 0);
+                plr->GetSession()->SendPacket(&data);
+            }
 
-        // remove from raid group if exist
-        if(group && group == GetBgRaid(plr->GetTeam()))
-        {
-            if(!group->RemoveMember(guid, 0))               // group was disbanded
+            // this call is important, because player, when joins to battleground, this method is not called, so it must be called when leaving bg
+            plr->RemoveBattleGroundQueueId(bgQueueTypeId);
+
+            DecreaseInvitedCount(team);
+            //we should update battleground queue, but only if bg isn't ending
+            if (GetQueueType() < MAX_BATTLEGROUND_QUEUES)
+                sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].Update(bgTypeId, GetQueueType());
+
+            Group * group = plr->GetGroup();
+            // remove from raid group if exist
+            if(group && group == GetBgRaid(team))
             {
-                SetBgRaid(plr->GetTeam(), NULL);
-                delete group;
+                if(!group->RemoveMember(guid, 0))               // group was disbanded
+                {
+                    SetBgRaid(team, NULL);
+                    delete group;
+                }
             }
+
+            // Let others know
+            sBattleGroundMgr.BuildPlayerLeftBattleGroundPacket(&data, plr);
+            SendPacketToTeam(team, &data, plr, false);
         }
 
         // Do next only if found in battleground
         plr->SetBattleGroundId(0);                          // We're not in BG.
-
-        // Let others know
-        sBattleGroundMgr.BuildPlayerLeftBattleGroundPacket(&data, plr);
-        SendPacketToTeam(plr->GetTeam(), &data, plr, false);
+        // reset destination bg team
+        plr->SetBGTeam(0);
 
         if(Transport)
         {
             plr->TeleportTo(plr->GetBattleGroundEntryPointMap(), plr->GetBattleGroundEntryPointX(), plr->GetBattleGroundEntryPointY(), plr->GetBattleGroundEntryPointZ(), plr->GetBattleGroundEntryPointO());
-            //sLog.outDetail("BATTLEGROUND: Sending %s to %f,%f,%f,%f", pl->GetName(), x,y,z,O);
         }
 
         // Log
         sLog.outDetail("BATTLEGROUND: Removed player %s from BattleGround.", plr->GetName());
     }
 
-    /// there will be code which will add battleground to BGFreeSlotQueue , when battleground instance will exist
-    // we always should check if BG is in that queue before adding..
-
-    if(!GetPlayersSize())
+    if(!GetPlayersSize() && !GetInvitedCount(HORDE) && !GetInvitedCount(ALLIANCE))
     {
-        Reset();
+        // if no players left AND no invitees left, set this bg to delete in next update
+        // direct deletion could cause crashes
+        m_SetDeleteThis = true;
+        // return to prevent addition to freeslotqueue
+        return;
     }
+
+    // a player exited the battleground, so there are free slots. add to queue
+    this->AddToBGFreeSlotQueue();
 }
 
 // this method is called when no players remains in battleground
@@ -660,6 +893,8 @@ void BattleGround::Reset()
     SetStartTime(0);
     SetEndTime(0);
     SetLastResurrectTime(0);
+    SetArenaType(0);
+    SetRated(false);
 
     m_Events = 0;
 
@@ -668,6 +903,7 @@ void BattleGround::Reset()
 
     m_InvitedAlliance = 0;
     m_InvitedHorde = 0;
+    m_InBGFreeSlotQueue = false;
 
     m_Players.clear();
     m_PlayerScores.clear();
@@ -704,10 +940,11 @@ void BattleGround::AddPlayer(Player *plr)
     sBattleGroundMgr.BuildPlayerJoinedBattleGroundPacket(&data, plr);
     SendPacketToTeam(team, &data, plr, false);
 
+    // add arena specific auras
     if(isArena())
     {
         plr->RemoveArenaSpellCooldowns();
-        //plr->RemoveArenaAuras();
+        plr->RemoveArenaAuras();
         plr->RemoveAllEnchantments(TEMP_ENCHANTMENT_SLOT);
         if(team == ALLIANCE && plr->GetTeam() == ALLIANCE)
             plr->CastSpell(plr,SPELL_ALLIANCE_GOLD_FLAG,true);
@@ -719,6 +956,19 @@ void BattleGround::AddPlayer(Player *plr)
             plr->CastSpell(plr,SPELL_HORDE_GREEN_FLAG,true);
         plr->DestroyConjuredItems(true);
 
+        Pet* pet = plr->GetPet();
+        if(pet)
+        {
+            if(pet->getPetType() == SUMMON_PET || pet->getPetType() == HUNTER_PET)
+            {
+                (plr)->SetTemporaryUnsummonedPetNumber(pet->GetCharmInfo()->GetPetNumber());
+                (plr)->SetOldPetSpell(pet->GetUInt32Value(UNIT_CREATED_BY_SPELL));
+            }
+            (plr)->RemovePet(NULL,PET_SAVE_NOT_IN_SLOT);
+        }
+    else
+            (plr)->SetTemporaryUnsummonedPetNumber(0);
+
         if(GetStatus() == STATUS_WAIT_JOIN)                 // not started yet
         {
             plr->CastSpell(plr, SPELL_ARENA_PREPARATION, true);
@@ -733,9 +983,6 @@ void BattleGround::AddPlayer(Player *plr)
             plr->CastSpell(plr, SPELL_PREPARATION, true);   // reduces all mana cost of spells.
     }
 
-    if(isArena())
-        plr->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_FFA_PVP);
-
     // Log
     sLog.outDetail("BATTLEGROUND: Player %s joined the battle.", plr->GetName());
 }
@@ -743,13 +990,20 @@ void BattleGround::AddPlayer(Player *plr)
 /* This method should be called only once ... it adds pointer to queue */
 void BattleGround::AddToBGFreeSlotQueue()
 {
-    sBattleGroundMgr.BGFreeSlotQueue[m_TypeID].push_front(this);
+    // make sure to add only once
+    if(!m_InBGFreeSlotQueue)
+    {
+        sBattleGroundMgr.BGFreeSlotQueue[m_TypeID].push_front(this);
+        m_InBGFreeSlotQueue = true;
+    }
 }
 
 /* This method removes this battleground from free queue - it must be called when deleting battleground - not used now*/
 void BattleGround::RemoveFromBGFreeSlotQueue()
 {
-    /* uncomment this code when battlegrounds will work like instances
+    // set to be able to re-add if needed
+    m_InBGFreeSlotQueue = false;
+    // uncomment this code when battlegrounds will work like instances
     for (std::deque<BattleGround*>::iterator itr = sBattleGroundMgr.BGFreeSlotQueue[m_TypeID].begin(); itr != sBattleGroundMgr.BGFreeSlotQueue[m_TypeID].end(); ++itr)
     {
         if ((*itr)->GetInstanceID() == m_InstanceID)
@@ -757,30 +1011,66 @@ void BattleGround::RemoveFromBGFreeSlotQueue()
             sBattleGroundMgr.BGFreeSlotQueue[m_TypeID].erase(itr);
             return;
         }
-    }*/
+    }
 }
 
-/*
-this method should decide, if we can invite new player of certain team to BG, it is based on BATTLEGROUND_STATUS
-*/
-bool BattleGround::HasFreeSlotsForTeam(uint32 Team) const
+// get the number of free slots for team
+// works in similar way that HasFreeSlotsForTeam did, but this is needed for join as group
+uint32 BattleGround::GetFreeSlotsForTeam(uint32 Team) const
 {
     //if BG is starting ... invite anyone:
     if (GetStatus() == STATUS_WAIT_JOIN)
-        return GetInvitedCount(Team) < GetMaxPlayersPerTeam();
+        return (GetInvitedCount(Team) < GetMaxPlayersPerTeam()) ? GetMaxPlayersPerTeam() - GetInvitedCount(Team) : 0;
     //if BG is already started .. do not allow to join too much players of one faction
     uint32 otherTeam;
+    uint32 otherIn;
     if (Team == ALLIANCE)
+    {
         otherTeam = GetInvitedCount(HORDE);
+        otherIn = GetPlayersCountByTeam(HORDE);
+    }
     else
+    {
         otherTeam = GetInvitedCount(ALLIANCE);
+        otherIn = GetPlayersCountByTeam(ALLIANCE);
+    }
     if (GetStatus() == STATUS_IN_PROGRESS)
-        return (GetInvitedCount(Team) <= otherTeam && GetInvitedCount(Team) < GetMaxPlayersPerTeam());
+    {
+        // difference based on ppl invited (not necessarily entered battle)
+        // default: allow 0
+        uint32 diff = 0;
+        // allow join one person if the sides are equal (to fill up bg to minplayersperteam)
+        if (otherTeam == GetInvitedCount(Team)) 
+            diff = 1;
+        // allow join more ppl if the other side has more players
+        else if(otherTeam > GetInvitedCount(Team))
+            diff = otherTeam - GetInvitedCount(Team);
+
+        // difference based on max players per team (don't allow inviting more)
+        uint32 diff2 = (GetInvitedCount(Team) < GetMaxPlayersPerTeam()) ? GetMaxPlayersPerTeam() - GetInvitedCount(Team) : 0;
+
+        // difference based on players who already entered
+        // default: allow 0
+        uint32 diff3 = 0;
+        // allow join one person if the sides are equal (to fill up bg minplayersperteam)
+        if (otherIn == GetPlayersCountByTeam(Team))
+            diff3 = 1;
+        // allow join more ppl if the other side has more players
+        else if (otherIn > GetPlayersCountByTeam(Team))
+            diff3 = otherIn - GetPlayersCountByTeam(Team);
+
+        // return the minimum of the 3 differences
+
+        // min of diff and diff 2
+        diff = diff < diff2 ? diff : diff2;
+
+        // min of diff, diff2 and diff3
+        return diff < diff3 ? diff : diff3 ;
+    }
 
-    return false;
+    return 0;
 }
 
-/* this method isn't called already, it will be useful when more battlegrounds of one type will be available */
 bool BattleGround::HasFreeSlots() const
 {
     return GetPlayersSize() < GetMaxPlayers();
@@ -806,9 +1096,15 @@ void BattleGround::UpdatePlayerScore(Player *Source, uint32 type, uint32 value)
             itr->second->HonorableKills += value;
             break;
         case SCORE_BONUS_HONOR:                             // Honor bonus
-            // reward honor instantly
-            if(Source->RewardHonor(NULL, 1, value))
-                itr->second->BonusHonor += value;
+            // do not add honor in arenas
+            if(isBattleGround())
+            {
+                // reward honor instantly
+                if(Source->RewardHonor(NULL, 1, value))
+                    itr->second->BonusHonor += value;
+            }
+            else
+
             break;
             //used only in EY, but in MSG_PVP_LOG_DATA opcode
         case SCORE_DAMAGE_DONE:                             // Damage Done
@@ -864,15 +1160,26 @@ void BattleGround::RemovePlayerFromResurrectQueue(uint64 player_guid)
 
 bool BattleGround::AddObject(uint32 type, uint32 entry, float x, float y, float z, float o, float rotation0, float rotation1, float rotation2, float rotation3, uint32 respawnTime)
 {
-    GameObjectInfo const* goinfo = objmgr.GetGameObjectInfo(entry);
-    if(!goinfo)
+    Map * map = MapManager::Instance().FindMap(GetMapId(),GetInstanceID());
+    if(!map)
+        return false;
+
+    // must be created this way, adding to godatamap would add it to the base map of the instance
+    // and when loading it (in go::LoadFromDB()), a new guid would be assigned to the object, and a new object would be created
+    // so we must create it specific for this instance
+    GameObject * go = new GameObject;
+    if(!go->Create(objmgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT),entry, map,x,y,z,o,rotation0,rotation1,rotation2,rotation3,100,1))
     {
         sLog.outErrorDb("Gameobject template %u not found in database! BattleGround not created!", entry);
+        sLog.outError("Cannot create gameobject template %u! BattleGround not created!", entry);
+        delete go;
         return false;
     }
+/*
+    uint32 guid = go->GetGUIDLow();
 
-    uint32 guid = objmgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT);
-
+    // without this, UseButtonOrDoor caused the crash, since it tried to get go info from godata
+    // iirc that was changed, so adding to go data map is no longer required if that was the only function using godata from GameObject without checking if it existed
     GameObjectData& data = objmgr.NewGOData(guid);
 
     data.id             = entry;
@@ -886,13 +1193,13 @@ bool BattleGround::AddObject(uint32 type, uint32 entry, float x, float y, float
     data.rotation2      = rotation2;
     data.rotation3      = rotation3;
     data.spawntimesecs  = respawnTime;
+    data.spawnMask      = 1;
     data.animprogress   = 100;
     data.go_state       = 1;
-    data.spawnMask      = 1;
-    objmgr.AddGameobjectToGrid(guid, &data);
-
-    m_BgObjects[type] = MAKE_NEW_GUID(guid, entry, HIGHGUID_GAMEOBJECT);
-
+*/
+    // add to world, so it can be later looked up from HashMapHolder
+    go->AddToWorld();
+    m_BgObjects[type] = go->GetGUID();
     return true;
 }
 
@@ -934,6 +1241,9 @@ void BattleGround::DoorOpen(uint32 type)
 
 void BattleGround::SpawnBGObject(uint32 type, uint32 respawntime)
 {
+    Map * map = MapManager::Instance().FindMap(GetMapId(),GetInstanceID());
+    if(!map)
+        return;
     if( respawntime == 0 )
     {
         GameObject *obj = HashMapHolder<GameObject>::Find(m_BgObjects[type]);
@@ -942,30 +1252,27 @@ void BattleGround::SpawnBGObject(uint32 type, uint32 respawntime)
             //we need to change state from GO_JUST_DEACTIVATED to GO_READY in case battleground is starting again
             if( obj->getLootState() == GO_JUST_DEACTIVATED )
                 obj->SetLootState(GO_READY);
-            obj->Respawn();
+            obj->SetRespawnTime(0);
+            map->Add(obj);
         }
-        else
-            objmgr.SaveGORespawnTime(GUID_LOPART(m_BgObjects[type]), 0, 0);
     }
     else
     {
         GameObject *obj = HashMapHolder<GameObject>::Find(m_BgObjects[type]);
         if(obj)
         {
+            map->Add(obj);
             obj->SetRespawnTime(respawntime);
             obj->SetLootState(GO_JUST_DEACTIVATED);
         }
-        else
-            objmgr.SaveGORespawnTime(GUID_LOPART(m_BgObjects[type]), 0, time(NULL) + respawntime);
     }
 }
 
-Creature* BattleGround::AddCreature(uint32 entry, uint32 type, uint32 teamval, float x, float y, float z, float o)
+Creature* BattleGround::AddCreature(uint32 entry, uint32 type, uint32 teamval, float x, float y, float z, float o, uint32 respawntime)
 {
-    // note: this should normally be FindMap
-    // but it's a hack to allow the battlegrounds to initialize at server startup
-    Map * map = MapManager::Instance().GetMap(GetMapId(), 0);
-    if(!map) return NULL;
+    Map * map = MapManager::Instance().FindMap(GetMapId(),GetInstanceID());
+    if(!map)
+        return NULL;
 
     Creature* pCreature = new Creature;
     if (!pCreature->Create(objmgr.GenerateLowGuid(HIGHGUID_UNIT), map, entry, teamval))
@@ -989,9 +1296,39 @@ Creature* BattleGround::AddCreature(uint32 entry, uint32 type, uint32 teamval, f
 
     map->Add(pCreature);
     m_BgCreatures[type] = pCreature->GetGUID();
+
     return  pCreature;
 }
+/*
+void BattleGround::SpawnBGCreature(uint32 type, uint32 respawntime)
+{
+    Map * map = MapManager::Instance().FindMap(GetMapId(),GetInstanceId());
+    if(!map)
+        return false;
 
+    if(respawntime == 0)
+    {
+        Creature *obj = HashMapHolder<Creature>::Find(m_BgCreatures[type]);
+        if(obj)
+        {
+            //obj->Respawn();                               // bugged
+            obj->SetRespawnTime(0);
+            objmgr.SaveCreatureRespawnTime(obj->GetGUIDLow(), GetInstanceID(), 0);
+            map->Add(obj);
+        }
+    }
+    else
+    {
+        Creature *obj = HashMapHolder<Creature>::Find(m_BgCreatures[type]);
+        if(obj)
+        {
+            obj->setDeathState(DEAD);
+            obj->SetRespawnTime(respawntime);
+            map->Add(obj);
+        }
+    }
+}
+*/
 bool BattleGround::DelCreature(uint32 type)
 {
     Creature *cr = HashMapHolder<Creature>::Find(m_BgCreatures[type]);
@@ -1072,8 +1409,11 @@ void BattleGround::SendMessageToAll(int32 entry)
 
 void BattleGround::EndNow()
 {
+    RemoveFromBGFreeSlotQueue();
     SetStatus(STATUS_WAIT_LEAVE);
     SetEndTime(TIME_TO_AUTOREMOVE);
+    // inform invited players about the removal
+    sBattleGroundMgr.m_BattleGroundQueues[sBattleGroundMgr.BGQueueTypeId(GetTypeID(), GetArenaType())].BGEndedRemoveInvites(this);
 }
 
 // Battleground messages are localized using the dbc lang, they are not client language dependent
@@ -1151,3 +1491,28 @@ void BattleGround::HandleKillPlayer( Player *player, Player *killer )
     // to be able to remove insignia
     player->SetFlag( UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE );
 }
+
+// return the player's team based on battlegroundplayer info
+// used in same faction arena matches mainly
+uint32 BattleGround::GetPlayerTeam(uint64 guid)
+{
+    std::map<uint64, BattleGroundPlayer>::const_iterator itr = m_Players.find(guid);
+    if(itr!=m_Players.end())
+        return itr->second.Team;
+    return 0;
+}
+
+uint32 BattleGround::GetAlivePlayersCountByTeam(uint32 Team) const
+{
+    int count = 0;
+    for(std::map<uint64, BattleGroundPlayer>::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
+    {
+        if(itr->second.Team == Team)
+        {
+            Player * pl = objmgr.GetPlayer(itr->first);
+            if(pl && pl->isAlive())
+                ++count;
+        }
+    }
+    return count;
+}
diff --git a/src/game/BattleGround.h b/src/game/BattleGround.h
index 9e41e66..80a20c1 100644
--- a/src/game/BattleGround.h
+++ b/src/game/BattleGround.h
@@ -18,6 +18,7 @@
 
 #ifndef __BATTLEGROUND_H
 #define __BATTLEGROUND_H
+#define ARENA_PATCH
 
 #include "Common.h"
 #include "WorldPacket.h"
@@ -143,6 +144,18 @@ enum BattleGroundTypeId
     BATTLEGROUND_RL     = 8
 };
 
+// handle the queue types and bg types separately to enable joining queue for different sized arenas at the same time
+enum BattleGroundQueueTypeId
+{
+    BATTLEGROUND_QUEUE_AV     = 1,
+    BATTLEGROUND_QUEUE_WS     = 2,
+    BATTLEGROUND_QUEUE_AB     = 3,
+    BATTLEGROUND_QUEUE_EY     = 4,
+    BATTLEGROUND_QUEUE_2v2     = 5,
+    BATTLEGROUND_QUEUE_3v3     = 6,
+    BATTLEGROUND_QUEUE_5v5     = 7,
+};
+
 enum ScoreType
 {
     SCORE_KILLING_BLOWS         = 1,
@@ -195,6 +208,20 @@ enum BattleGroundTeamId
     BG_TEAM_HORDE           = 1
 };
 
+enum BattleGroundJoinError
+{
+    BG_JOIN_ERR_OK = 0,
+    BG_JOIN_ERR_OFFLINE_MEMBER = 1,
+    BG_JOIN_ERR_GROUP_TOO_MANY = 2,
+    BG_JOIN_ERR_MIXED_FACTION = 3,
+    BG_JOIN_ERR_MIXED_LEVELS = 4,
+    BG_JOIN_ERR_MIXED_ARENATEAM = 5,
+    BG_JOIN_ERR_GROUP_MEMBER_ALREADY_IN_QUEUE = 6,
+    BG_JOIN_ERR_GROUP_DESERTER = 7,
+    BG_JOIN_ERR_ALL_QUEUES_USED = 8,
+    BG_JOIN_ERR_GROUP_NOT_ENOUGH = 9
+};
+
 class BattleGroundScore
 {
     public:
@@ -224,6 +251,7 @@ class BattleGround
     public:
         /* Construction */
         BattleGround();
+        /*BattleGround(const BattleGround& bg);*/
         virtual ~BattleGround();
         virtual void Update(time_t diff);                   // must be implemented in BG subclass of BG specific update code, but must in begginning call parent version
         virtual bool SetupBattleGround()                    // must be implemented in BG subclass
@@ -296,6 +324,7 @@ class BattleGround
         }
         bool HasFreeSlotsForTeam(uint32 Team) const;
         bool HasFreeSlots() const;
+        uint32 GetFreeSlotsForTeam(uint32 Team) const;
 
         bool isArena() const        { return m_IsArena; }
         bool isBattleGround() const { return !m_IsArena; }
@@ -366,6 +395,7 @@ class BattleGround
 
         uint8 GetTeamIndexByTeamId(uint32 Team) const { return Team == ALLIANCE ? BG_TEAM_ALLIANCE : BG_TEAM_HORDE; }
         uint32 GetPlayersCountByTeam(uint32 Team) const { return m_PlayersCount[GetTeamIndexByTeamId(Team)]; }
+        uint32 GetAlivePlayersCountByTeam(uint32 Team) const;   // used in arenas to correctly handle death in spirit of redemption / last stand etc. (killer = killed) cases
         void UpdatePlayersCountByTeam(uint32 Team, bool remove)
         {
             if(remove)
@@ -374,6 +404,12 @@ class BattleGround
                 ++m_PlayersCount[GetTeamIndexByTeamId(Team)];
         }
 
+        // used for rated arena battles
+        void SetArenaTeamIdForTeam(uint32 Team, uint32 ArenaTeamId) { m_ArenaTeamIds[GetTeamIndexByTeamId(Team)] = ArenaTeamId; }
+        uint32 GetArenaTeamIdForTeam(uint32 Team) const { return m_ArenaTeamIds[GetTeamIndexByTeamId(Team)]; }
+        void SetArenaTeamRatingChangeForTeam(uint32 Team, int32 RatingChange) { m_ArenaTeamRatingChanges[GetTeamIndexByTeamId(Team)] = RatingChange; }
+        int32 GetArenaTeamRatingChangeForTeam(uint32 Team) const { return m_ArenaTeamRatingChanges[GetTeamIndexByTeamId(Team)]; }
+
         /* Triggers handle */
         // must be implemented in BG subclass
         virtual void HandleAreaTrigger(Player* /*Source*/, uint32 /*Trigger*/) {}
@@ -390,6 +426,7 @@ class BattleGround
         virtual WorldSafeLocsEntry const* GetClosestGraveYard(float /*x*/, float /*y*/, float /*z*/, uint32 /*team*/)  { return NULL; }
 
         virtual void AddPlayer(Player *plr);                // must be implemented in BG subclass
+
         virtual void RemovePlayerAtLeave(uint64 guid, bool Transport, bool SendPacket);
                                                             // can be extended in in BG subclass
 
@@ -402,7 +439,8 @@ class BattleGround
         BGCreatures m_BgCreatures;
         void SpawnBGObject(uint32 type, uint32 respawntime);
         bool AddObject(uint32 type, uint32 entry, float x, float y, float z, float o, float rotation0, float rotation1, float rotation2, float rotation3, uint32 respawnTime = 0);
-        Creature* AddCreature(uint32 entry, uint32 type, uint32 teamval, float x, float y, float z, float o);
+//        void SpawnBGCreature(uint32 type, uint32 respawntime);
+        Creature* AddCreature(uint32 entry, uint32 type, uint32 teamval, float x, float y, float z, float o, uint32 respawntime = 0);
         bool DelCreature(uint32 type);
         bool DelObject(uint32 type);
         bool AddSpiritGuide(uint32 type, float x, float y, float z, float o, uint32 team);
@@ -411,6 +449,13 @@ class BattleGround
         void DoorClose(uint32 type);
         const char *GetMangosString(int32 entry);
 
+        virtual bool HandlePlayerUnderMap(Player * plr) {return false;}
+
+        // since arenas can be AvA or Hvh, we have to get the "temporary" team of a player
+        uint32 GetPlayerTeam(uint64 guid);
+
+        void SetDeleteThis() {m_SetDeleteThis = true;}
+
     protected:
         //this method is called, when BG cannot spawn its own spirit guide, or something is wrong, It correctly ends BattleGround
         void EndNow();
@@ -443,6 +488,8 @@ class BattleGround
         uint32 m_LastResurrectTime;
         uint32 m_Queue_type;
         uint8  m_ArenaType;                                 // 2=2v2, 3=3v3, 5=5v5
+        bool   m_InBGFreeSlotQueue;                         // used to make sure that BG is only once inserted into the BattleGroundMgr.BGFreeSlotQueue[bgTypeId] deque
+        bool   m_SetDeleteThis;                             // used for safe deletion of the bg after end / all players leave
         // this variable is not used .... it can be found in many other ways... but to store it in BG object instance is useless
         //uint8  m_BattleGroundType;                        // 3=BG, 4=arena
         //instead of uint8 (in previous line) is bool used
@@ -450,6 +497,8 @@ class BattleGround
         uint8  m_Winner;                                    // 0=alliance, 1=horde, 2=none
         int32  m_StartDelayTime;
         bool   m_IsRated;                                   // is this battle rated?
+        bool   m_PrematureCountDown;
+        uint32 m_PrematureCountDownTimer;
         char const *m_Name;
 
         /* Player lists */
@@ -468,6 +517,11 @@ class BattleGround
         /* Players count by team */
         uint32 m_PlayersCount[2];
 
+        /* Arena team ids by team */
+        uint32 m_ArenaTeamIds[2];
+
+        int32 m_ArenaTeamRatingChanges[2];
+
         /* Limits */
         uint32 m_LevelMin;
         uint32 m_LevelMax;
diff --git a/src/game/BattleGroundAB.cpp b/src/game/BattleGroundAB.cpp
index dcf23cc..5200a3f 100644
--- a/src/game/BattleGroundAB.cpp
+++ b/src/game/BattleGroundAB.cpp
@@ -50,6 +50,13 @@ void BattleGroundAB::Update(time_t diff)
         {
             m_Events |= 0x01;
 
+            // setup here, only when at least one player has ported to the map
+            if(!SetupBattleGround())
+            {
+                EndNow();
+                return;
+            }
+
             sLog.outDebug("Arathi Basin: entering state STATUS_WAIT_JOIN ...");
 
             // despawn banners, auras and buffs
@@ -377,6 +384,7 @@ void BattleGroundAB::_NodeOccupied(uint8 node,Team team)
 {
    if( !AddSpiritGuide(node, BG_AB_SpiritGuidePos[node][0], BG_AB_SpiritGuidePos[node][1], BG_AB_SpiritGuidePos[node][2], BG_AB_SpiritGuidePos[node][3], team) )
         sLog.outError("Failed to spawn spirit guide! point: %u, team: %u,", node, team);
+//   SpawnBGCreature(node,RESPAWN_IMMEDIATELY);
 
     uint8 capturedNodes = 0;
     for (uint8 i = 0; i < BG_AB_DYNAMIC_NODES_COUNT; ++i)
diff --git a/src/game/BattleGroundBE.cpp b/src/game/BattleGroundBE.cpp
index 4ad7198..81e47c7 100644
--- a/src/game/BattleGroundBE.cpp
+++ b/src/game/BattleGroundBE.cpp
@@ -47,6 +47,12 @@ void BattleGroundBE::Update(time_t diff)
         if (!(m_Events & 0x01))
         {
             m_Events |= 0x01;
+            // setup here, only when at least one player has ported to the map
+            if(!SetupBattleGround())
+            {
+                EndNow();
+                return;
+            }
             for(uint32 i = BG_BE_OBJECT_DOOR_1; i <= BG_BE_OBJECT_DOOR_4; i++)
                 SpawnBGObject(i, RESPAWN_IMMEDIATELY);
 
@@ -86,6 +92,11 @@ void BattleGroundBE::Update(time_t diff)
             for(BattleGroundPlayerMap::const_iterator itr = GetPlayers().begin(); itr != GetPlayers().end(); ++itr)
                 if(Player *plr = objmgr.GetPlayer(itr->first))
                     plr->RemoveAurasDueToSpell(SPELL_ARENA_PREPARATION);
+
+            if(!GetPlayersCountByTeam(ALLIANCE) && GetPlayersCountByTeam(HORDE))
+                EndBattleGround(HORDE);
+            else if(GetPlayersCountByTeam(ALLIANCE) && !GetPlayersCountByTeam(HORDE))
+                EndBattleGround(ALLIANCE);
         }
     }
 
@@ -102,11 +113,23 @@ void BattleGroundBE::AddPlayer(Player *plr)
     BattleGroundBEScore* sc = new BattleGroundBEScore;
 
     m_PlayerScores[plr->GetGUID()] = sc;
+
+    UpdateWorldState(0x9f1, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0x9f0, GetAlivePlayersCountByTeam(HORDE));
 }
 
 void BattleGroundBE::RemovePlayer(Player* /*plr*/, uint64 /*guid*/)
 {
+    if(GetStatus() == STATUS_WAIT_LEAVE)
+        return;
+
+    UpdateWorldState(0x9f1, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0x9f0, GetAlivePlayersCountByTeam(HORDE));
 
+    if(!GetAlivePlayersCountByTeam(ALLIANCE) && GetPlayersCountByTeam(HORDE))
+        EndBattleGround(HORDE);
+    else if(GetPlayersCountByTeam(ALLIANCE) && !GetAlivePlayersCountByTeam(HORDE))
+        EndBattleGround(ALLIANCE);
 }
 
 void BattleGroundBE::HandleKillPlayer(Player *player, Player *killer)
@@ -120,19 +143,29 @@ void BattleGroundBE::HandleKillPlayer(Player *player, Player *killer)
         return;
     }
 
-    BattleGround::HandleKillPlayer(player, killer);
+    BattleGround::HandleKillPlayer(player,killer);
 
-    uint32 killer_team_index = GetTeamIndexByTeamId(killer->GetTeam());
+    UpdateWorldState(0x9f1, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0x9f0, GetAlivePlayersCountByTeam(HORDE));
 
-    ++m_TeamKills[killer_team_index];                       // add kills to killer's team
-
-    if(m_TeamKills[killer_team_index] >= GetPlayersCountByTeam(player->GetTeam()))
+    if(!GetAlivePlayersCountByTeam(ALLIANCE))
+    {
+        // all opponents killed
+        EndBattleGround(HORDE);
+    }
+    else if(!GetAlivePlayersCountByTeam(HORDE))
     {
         // all opponents killed
-        EndBattleGround(killer->GetTeam());
+        EndBattleGround(ALLIANCE);
     }
 }
 
+bool BattleGroundBE::HandlePlayerUnderMap(Player *player)
+{
+    player->TeleportTo(GetMapId(),6238.930176,262.963470,0.889519,player->GetOrientation(),false);
+    return true;
+}
+
 void BattleGroundBE::HandleAreaTrigger(Player *Source, uint32 Trigger)
 {
     // this is wrong way to implement these things. On official it done by gameobject spell cast.
@@ -159,10 +192,16 @@ void BattleGroundBE::HandleAreaTrigger(Player *Source, uint32 Trigger)
     //    HandleTriggerBuff(buff_guid,Source);
 }
 
+void BattleGroundBE::FillInitialWorldStates(WorldPacket &data)
+{
+    data << uint32(0x9f1) << uint32(GetAlivePlayersCountByTeam(ALLIANCE));           // 7
+    data << uint32(0x9f0) << uint32(GetAlivePlayersCountByTeam(HORDE));           // 8
+    data << uint32(0x9f3) << uint32(1);           // 9
+}
+
 void BattleGroundBE::ResetBGSubclass()
 {
-    m_TeamKills[BG_TEAM_ALLIANCE] = 0;
-    m_TeamKills[BG_TEAM_HORDE]    = 0;
+
 }
 
 bool BattleGroundBE::SetupBattleGround()
diff --git a/src/game/BattleGroundBE.h b/src/game/BattleGroundBE.h
index f74f0a6..df46efb 100644
--- a/src/game/BattleGroundBE.h
+++ b/src/game/BattleGroundBE.h
@@ -64,12 +64,11 @@ class BattleGroundBE : public BattleGround
         void HandleAreaTrigger(Player *Source, uint32 Trigger);
         bool SetupBattleGround();
         void ResetBGSubclass();
+        virtual void FillInitialWorldStates(WorldPacket &d);
         void HandleKillPlayer(Player* player, Player *killer);
+        bool HandlePlayerUnderMap(Player * plr);
 
         /* Scorekeeping */
         void UpdatePlayerScore(Player *Source, uint32 type, uint32 value);
-
-    private:
-        uint32 m_TeamKills[2];                              // count of kills for each team
 };
 #endif
diff --git a/src/game/BattleGroundEY.cpp b/src/game/BattleGroundEY.cpp
index 18d0859..cec2379 100644
--- a/src/game/BattleGroundEY.cpp
+++ b/src/game/BattleGroundEY.cpp
@@ -54,9 +54,18 @@ void BattleGroundEY::Update(time_t diff)
         {
             m_Events |= 0x01;
 
+            // setup here, only when at least one player has ported to the map
+            if(!SetupBattleGround())
+            {
+                EndNow();
+                return;
+            }
+
             SpawnBGObject(BG_EY_OBJECT_DOOR_A, RESPAWN_IMMEDIATELY);
             SpawnBGObject(BG_EY_OBJECT_DOOR_H, RESPAWN_IMMEDIATELY);
 
+//            SpawnBGCreature(EY_SPIRIT_MAIN_ALLIANCE, RESPAWN_IMMEDIATELY);
+//            SpawnBGCreature(EY_SPIRIT_MAIN_HORDE, RESPAWN_IMMEDIATELY);
             for(uint32 i = BG_EY_OBJECT_A_BANNER_FEL_REALVER_CENTER; i < BG_EY_OBJECT_MAX; ++i)
                 SpawnBGObject(i, RESPAWN_ONE_DAY);
 
@@ -572,7 +581,17 @@ void BattleGroundEY::HandleKillPlayer(Player *player, Player *killer)
 
 void BattleGroundEY::EventPlayerDroppedFlag(Player *Source)
 {
-    // Drop allowed in any BG state
+    if(GetStatus() != STATUS_IN_PROGRESS)
+    {
+        // if not running, do not cast things at the dropper player, neither send unnecessary messages
+        // just take off the aura
+        if(IsFlagPickedup() && GetFlagPickerGUID() == Source->GetGUID())
+        {
+            SetFlagPicker(0);
+            Source->RemoveAurasDueToSpell(BG_EY_NETHERSTORM_FLAG_SPELL);
+        }
+        return;
+    }
 
     if(!IsFlagPickedup())
         return;
@@ -744,6 +763,8 @@ void BattleGroundEY::EventTeamCapturedPoint(Player *Source, uint32 Point)
         sLog.outError("BatteGroundEY: Failed to spawn spirit guide! point: %u, team: %u, graveyard_id: %u",
             Point, Team, m_CapturingPointTypes[Point].GraveYardId);
 
+//    SpawnBGCreature(Point,RESPAWN_IMMEDIATELY);
+
     UpdatePointsIcons(Team, Point);
     UpdatePointsCount(Team);
 }
diff --git a/src/game/BattleGroundHandler.cpp b/src/game/BattleGroundHandler.cpp
index 3b744f0..f699d3e 100644
--- a/src/game/BattleGroundHandler.cpp
+++ b/src/game/BattleGroundHandler.cpp
@@ -26,9 +26,11 @@
 #include "MapManager.h"
 #include "ObjectAccessor.h"
 #include "Object.h"
+#include "Chat.h"
 #include "BattleGroundMgr.h"
 #include "BattleGroundWS.h"
 #include "BattleGround.h"
+#include "ArenaTeam.h"
 #include "Language.h"
 
 void WorldSession::HandleBattleGroundHelloOpcode( WorldPacket & recv_data )
@@ -76,16 +78,23 @@ void WorldSession::HandleBattleGroundJoinOpcode( WorldPacket & recv_data )
     uint32 bgTypeId;
     uint32 instanceId;
     uint8 joinAsGroup;
+    Group * grp;
 
     recv_data >> guid;                                      // battlemaster guid
     recv_data >> bgTypeId;                                  // battleground type id (DBC id)
     recv_data >> instanceId;                                // instance id, 0 if First Available selected
     recv_data >> joinAsGroup;                               // join as group
 
-    sLog.outDebug( "WORLD: Recvd CMSG_BATTLEMASTER_JOIN Message from: " I64FMT " for BG (Type: %u)", guid, bgTypeId);
-
-    if(bgTypeId >= MAX_BATTLEGROUND_TYPES)                  // cheating?
+    if(bgTypeId >= MAX_BATTLEGROUND_TYPES)
+    {
+        sLog.outError("Battleground: invalid bgtype received. possible cheater? player guid %u",_player->GetGUIDLow());
         return;
+    }
+
+    sLog.outDebug( "WORLD: Recvd CMSG_BATTLEMASTER_JOIN Message from: " I64FMT, guid);
+
+    // can do this, since it's battleground, not arena
+    uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bgTypeId, 0);
 
     // ignore if we already in BG or BG queue
     if(_player->InBattleGround())
@@ -98,74 +107,150 @@ void WorldSession::HandleBattleGroundJoinOpcode( WorldPacket & recv_data )
     if(!unit->isBattleMaster())                             // it's not battlemaster
         return;
 
-    // check Deserter debuff
-    if( !_player->CanJoinToBattleground() )
+    // get bg instance or bg template if instance not found
+    BattleGround * bg = 0;
+    if(instanceId)
+        BattleGround *bg = sBattleGroundMgr.GetBattleGround(instanceId);
+
+    if(!bg && !(bg = sBattleGroundMgr.GetBattleGroundTemplate(bgTypeId)))
     {
-        WorldPacket data(SMSG_GROUP_JOINED_BATTLEGROUND, 4);
-        data << (uint32) 0xFFFFFFFE;
-        _player->GetSession()->SendPacket(&data);
+        sLog.outError("Battleground: no available bg / template found");
         return;
     }
 
-    // check existence
-    BattleGround *bg = sBattleGroundMgr.GetBattleGround(bgTypeId);
-    if(!bg)
-        return;
-
-    if(joinAsGroup && _player->GetGroup())
+    // check queueing conditions
+    if(!joinAsGroup)
     {
-        Group *grp = _player->GetGroup();
-        for(GroupReference *itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
+        // check Deserter debuff
+        if( !_player->CanJoinToBattleground() )
         {
-            Player *member = itr->getSource();
-            if(!member) continue;
-
-            if( !member->CanJoinToBattleground() )
+            WorldPacket data(SMSG_GROUP_JOINED_BATTLEGROUND, 4);
+            data << (uint32) 0xFFFFFFFE;
+            _player->GetSession()->SendPacket(&data);
+            return;
+        }
+        // check if already in queue
+        if (_player->GetBattleGroundQueueIndex(bgQueueTypeId) < PLAYER_MAX_BATTLEGROUND_QUEUES)
+            //player is already in this queue
+            return;
+        // check if has free queue slots
+        if(!_player->HasFreeBattleGroundQueueId())
+            return;
+    }
+    else
+    {
+        grp = _player->GetGroup();
+        // no group found, error
+        if(!grp)
+            return;
+        uint32 err = grp->CanJoinBattleGroundQueue(bgTypeId, bgQueueTypeId, 0, bg->GetMaxPlayersPerTeam(), false, 0);
+        switch(err)
+        {
+            // TODO: add error-based feedback to players in all cases
+        case BG_JOIN_ERR_GROUP_TOO_MANY:
             {
-                WorldPacket data(SMSG_GROUP_JOINED_BATTLEGROUND, 4);
-                data << (uint32) 0xFFFFFFFE;
-                _player->GetSession()->SendPacket(&data);
-                continue;
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_TOO_LARGE), NULL);
+            SendPacket(&data);
             }
-            if (member->InBattleGroundQueueForBattleGroundType(bgTypeId))
-                //player is already in this queue
-                continue;
-
+            return;
+            break;
+        case BG_JOIN_ERR_OFFLINE_MEMBER:
+            {
             WorldPacket data;
-                                                            // add to queue
-            uint32 queueSlot = member->AddBattleGroundQueueId(bgTypeId);
-            if (queueSlot == PLAYER_MAX_BATTLEGROUND_QUEUES)
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_OFFLINE_MEMBER), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_MIXED_FACTION:
             {
-                // fill data packet
-                //member->GetSession()->SendPacket(data);
-                continue;
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_MIXED_FACTION), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_MIXED_LEVELS:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_MIXED_LEVELS), NULL);
+            SendPacket(&data);
             }
+            return;
+            break;
+        case BG_JOIN_ERR_GROUP_MEMBER_ALREADY_IN_QUEUE:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_MEMBER_ALREADY_IN_QUEUE), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_GROUP_DESERTER:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_MEMBER_DESERTER), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_ALL_QUEUES_USED:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_MEMBER_NO_FREE_QUEUE_SLOTS), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+            // all ok, can join
+        case BG_JOIN_ERR_OK:
+            break;
+            // these aren't possible outcomes in bgs 
+        case BG_JOIN_ERR_GROUP_NOT_ENOUGH:
+        case BG_JOIN_ERR_MIXED_ARENATEAM:
+            return;
+            break;
+            // not the above? shouldn't happen, don't let join
+        default:
+            return;
+            break;
+        };
+    }
+
+    // if we're here, then the conditions to join a bg are met. We can proceed in joining.
+
+    // _player->GetGroup() was already checked, grp is already initialized
+    if(joinAsGroup /* && _player->GetGroup()*/)
+    {
+        sLog.outDebug("Battleground: the following players are joining as group:");
+        GroupQueueInfo * ginfo = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddGroup(_player, bgTypeId, 0, false, 0);
+        for(GroupReference *itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player *member = itr->getSource();
+            if(!member) continue;   // this should never happen
+
+            uint32 queueSlot = member->AddBattleGroundQueueId(bgQueueTypeId);           // add to queue
 
             // store entry point coords (same as leader entry point)
             member->SetBattleGroundEntryPoint(_player->GetMapId(),_player->GetPositionX(),_player->GetPositionY(),_player->GetPositionZ(),_player->GetOrientation());
 
+            WorldPacket data;
                                                             // send status packet (in queue)
             sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, member->GetTeam(), queueSlot, STATUS_WAIT_QUEUE, 0, 0);
             member->GetSession()->SendPacket(&data);
             sBattleGroundMgr.BuildGroupJoinedBattlegroundPacket(&data, bgTypeId);
             member->GetSession()->SendPacket(&data);
-            sBattleGroundMgr.m_BattleGroundQueues[bgTypeId].AddPlayer(member, bgTypeId);
+            sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddPlayer(member, ginfo);
+            sLog.outDebug("Battleground: player joined queue for bg queue type %u bg type %u: GUID %u, NAME %s",bgQueueTypeId,bgTypeId,member->GetGUIDLow(), member->GetName());
         }
+        sLog.outDebug("Battleground: group end");
+        sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].Update(bgTypeId, _player->GetBattleGroundQueueIdFromLevel());
     }
     else
     {
-        if (_player->InBattleGroundQueueForBattleGroundType(bgTypeId))
-            //player is already in this queue
-            return;
-        uint32 queueSlot = _player->AddBattleGroundQueueId(bgTypeId);
-        if (queueSlot == PLAYER_MAX_BATTLEGROUND_QUEUES)
-        {
-            WorldPacket data;
-            // fill data packet
-            //SendPacket(data);
-            return;
-        }
-
+        // already checked if queueSlot is valid, now just get it
+        uint32 queueSlot = _player->AddBattleGroundQueueId(bgQueueTypeId);
         // store entry point coords
         _player->SetBattleGroundEntryPoint(_player->GetMapId(),_player->GetPositionX(),_player->GetPositionY(),_player->GetPositionZ(),_player->GetOrientation());
 
@@ -173,7 +258,11 @@ void WorldSession::HandleBattleGroundJoinOpcode( WorldPacket & recv_data )
                                                             // send status packet (in queue)
         sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), queueSlot, STATUS_WAIT_QUEUE, 0, 0);
         SendPacket(&data);
-        sBattleGroundMgr.m_BattleGroundQueues[bgTypeId].AddPlayer(_player, bgTypeId);
+
+        GroupQueueInfo * ginfo = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddGroup(_player, bgTypeId, 0, false, 0);
+        sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddPlayer(_player, ginfo);
+        sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].Update(bgTypeId, _player->GetBattleGroundQueueIdFromLevel());
+        sLog.outDebug("Battleground: player joined queue for bg queue type %u bg type %u: GUID %u, NAME %s",bgQueueTypeId,bgTypeId,_player->GetGUIDLow(), _player->GetName());
     }
 }
 
@@ -247,12 +336,11 @@ void WorldSession::HandleBattleGroundListOpcode( WorldPacket &recv_data )
     uint32 bgTypeId;
     recv_data >> bgTypeId;                                  // id from DBC
 
-    if(bgTypeId >= MAX_BATTLEGROUND_TYPES)                  // cheating?
-        return;
-
-    // can't be received if player not in BG queue
-    if(!_player->InBattleGroundQueueForBattleGroundType(bgTypeId))
+    if(bgTypeId >= MAX_BATTLEGROUND_TYPES)
+    {
+        sLog.outError("Battleground: invalid bgtype received.");
         return;
+    }
 
     BattlemasterListEntry const* bl = sBattlemasterListStore.LookupEntry(bgTypeId);
 
@@ -270,80 +358,186 @@ void WorldSession::HandleBattleGroundPlayerPortOpcode( WorldPacket &recv_data )
 
     sLog.outDebug( "WORLD: Recvd CMSG_BATTLEFIELD_PORT Message");
 
-    uint8 unk1;
+    uint8 type;                                             // arenatype if arena
     uint8 unk2;                                             // unk, can be 0x0 (may be if was invited?) and 0x1
+    uint32 instanceId;                                      
     uint32 bgTypeId;                                        // type id from dbc
     uint16 unk;                                             // 0x1F90 constant?
     uint8 action;                                           // enter battle 0x1, leave queue 0x0
 
-    recv_data >> unk1 >> unk2 >> bgTypeId >> unk >> action;
+    recv_data >> type >> unk2 >> bgTypeId >> unk >> action;
 
-    if(bgTypeId >= MAX_BATTLEGROUND_TYPES)                  // cheating?
-        return;
+    if(bgTypeId >= MAX_BATTLEGROUND_TYPES)
+    {
+        sLog.outError("Battleground: invalid bgtype received.");
+        // update battleground slots for the player to fix his UI and sent data.
+        // this is a HACK, I don't know why the client starts sending invalid packets in the first place.
+        // it usually happens with extremely high latency (if debugging / stepping in the code for example)
+        if(_player->InBattleGroundQueue())
+        {
+            // update all queues, send invitation info if player is invited, queue info if queued
+            for (uint32 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
+            {
+                uint32 queue_id = _player->GetBattleGroundQueueId(i);
+                if(!queue_id)
+                    continue;
+                BattleGroundQueue::QueuedPlayersMap::iterator itrPlayerStatus = sBattleGroundMgr.m_BattleGroundQueues[queue_id].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].find(_player->GetGUID());
+                // if the player is not in queue, contine
+                if(itrPlayerStatus == sBattleGroundMgr.m_BattleGroundQueues[queue_id].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].end())
+                    continue;
 
-    if(!_player->InBattleGroundQueueForBattleGroundType(bgTypeId))
-        return;
+                // no group information, this should never happen
+                if(!itrPlayerStatus->second.GroupInfo)
+                    continue;
 
-    BattleGround *bg = sBattleGroundMgr.GetBattleGround(bgTypeId);
-    if(!bg)
-        return;
+                BattleGround * bg = NULL;
 
-    uint32 queueSlot = 0;
-    WorldPacket data;
-    switch(action)
-    {
-        case 1:                                             // port to battleground
-            // cheating?
-            if(!_player->IsInvitedForBattleGroundType(bgTypeId))
-                return;
+                // get possibly needed data from groupinfo
+                bgTypeId = itrPlayerStatus->second.GroupInfo->BgTypeId;
+                uint8 arenatype = itrPlayerStatus->second.GroupInfo->ArenaType;
+                uint8 israted = itrPlayerStatus->second.GroupInfo->IsRated;
+                uint8 status = 0;
 
-            // check if player is not deserter
-            if( !_player->CanJoinToBattleground() )
-            {
-                WorldPacket data2;
-                data2.Initialize(SMSG_GROUP_JOINED_BATTLEGROUND, 4);
-                data2 << (uint32) 0xFFFFFFFE;
-                SendPacket(&data2);
-                return;
-            }
+                
+                if(!itrPlayerStatus->second.GroupInfo->IsInvitedToBGInstanceGUID)
+                {
+                    // not invited to bg, get template
+                    bg = sBattleGroundMgr.GetBattleGroundTemplate(bgTypeId);
+                    status = STATUS_WAIT_QUEUE;
+                }
+                else
+                {
+                    // get the bg we're invited to
+                    BattleGround * bg = sBattleGroundMgr.GetBattleGround(itrPlayerStatus->second.GroupInfo->IsInvitedToBGInstanceGUID);
+                    status = STATUS_WAIT_JOIN;
+                }
 
-            // if the player is dead, resurrect him before teleport
-            if(!_player->isAlive())
-            {
-                _player->ResurrectPlayer(1.0f);
-                _player->SpawnCorpseBones();
+                // if bg not found, then continue
+                if(!bg)
+                    continue;
+
+                // don't invite if already in the instance
+                if(_player->InBattleGround() && _player->GetBattleGround() && _player->GetBattleGround()->GetInstanceID() == bg->GetInstanceID())
+                    continue;
+
+                // re - invite player with proper data
+                WorldPacket data;
+                sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, itrPlayerStatus->second.GroupInfo->Team?itrPlayerStatus->second.GroupInfo->Team:_player->GetTeam(), i, status, INVITE_ACCEPT_WAIT_TIME, 0, arenatype, israted);
+                SendPacket(&data);
             }
+        }
+        return;
+    }
 
-            // leave current group
-            _player->RemoveFromGroup();
+    uint32 bgQueueTypeId = 0;
+    // get the bg what we were invited to 
+    BattleGroundQueue::QueuedPlayersMap::iterator itrPlayerStatus;
+    bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bgTypeId,type);
+    itrPlayerStatus = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].find(_player->GetGUID());
 
-            // packet to player about BG status
-            queueSlot = _player->GetBattleGroundQueueIndex(bgTypeId);
-            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), queueSlot, STATUS_IN_PROGRESS, 0, bg->GetStartTime());
-            _player->GetSession()->SendPacket(&data);
+    if(itrPlayerStatus == sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].end())
+    {
+        sLog.outError("Battleground: itrplayerstatus not found.");
+        return;
+    }
+    instanceId = itrPlayerStatus->second.GroupInfo->IsInvitedToBGInstanceGUID;
 
-            // remove battleground queue status from BGmgr
-            sBattleGroundMgr.m_BattleGroundQueues[bgTypeId].RemovePlayer(_player->GetGUID(), false);
+    // if action == 1, then instanceId is _required_
+    if(!instanceId && action == 1)
+    {
+        sLog.outError("Battleground: instance not found.");
+        return;
+    }
 
-            // this is still needed here if battleground "jumping" shouldn't add deserter debuff
-            // also this required to prevent stuck at old battleground after SetBattleGroundId set to new
-            if (BattleGround *currentBg = _player->GetBattleGround())
-                currentBg->RemovePlayerAtLeave(_player->GetGUID(), false, true);
+    BattleGround *bg = sBattleGroundMgr.GetBattleGround(instanceId);
 
-            _player->SetBattleGroundId(bg->GetTypeID());
-            sBattleGroundMgr.SendToBattleGround(_player, bgTypeId);
-            bg->AddPlayer(_player);
-            break;
-        case 0:                                             // leave queue
-            queueSlot = _player->GetBattleGroundQueueIndex(bgTypeId);
-            _player->RemoveBattleGroundQueueId(bgTypeId);   // must be called this way, because if you move this call to queue->removeplayer, it causes bugs
-            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), queueSlot, STATUS_NONE, 0, 0);
-            sBattleGroundMgr.m_BattleGroundQueues[bgTypeId].RemovePlayer(_player->GetGUID(), true);
-            SendPacket(&data);
-            break;
-        default:
-            sLog.outError("Battleground port: unknown action %u", action);
-            break;
+    // bg template might and must be used in case of leaving queue, when instance is not created yet
+    if(!bg && action == 0)
+        bg = sBattleGroundMgr.GetBattleGroundTemplate(bgTypeId);
+
+    if(!bg)
+    {
+        sLog.outError("Battleground: bg not found.");
+        return;
+    }
+
+    bgTypeId = bg->GetTypeID();
+
+    if(_player->InBattleGroundQueue())
+    {
+        uint32 queueSlot = 0;
+        uint32 team = 0;
+        uint32 arenatype = 0;
+        uint32 israted = 0;
+        uint32 rating = 0;
+        // get the team info from the queue
+        BattleGroundQueue::QueuedPlayersMap::iterator pitr = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].find(_player->GetGUID());
+        if(pitr !=sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].end()
+            && pitr->second.GroupInfo )
+        {
+            team = pitr->second.GroupInfo->Team;
+            arenatype = pitr->second.GroupInfo->ArenaType;
+            israted = pitr->second.GroupInfo->IsRated;
+            rating = pitr->second.GroupInfo->ArenaTeamRating;
+        }
+        else
+        {
+            sLog.outError("Battleground: Invalid player queue info!");
+            return;
+        }
+        WorldPacket data;
+        switch(action)
+        {
+            case 1:                                     // port to battleground
+                if(!_player->IsInvitedForBattleGroundQueueType(bgQueueTypeId))
+                    return;                                     // cheating?
+                // resurrect the player
+                if(!_player->isAlive())
+                {
+                    _player->ResurrectPlayer(1.0f);
+                    _player->SpawnCorpseBones();
+                }
+                // stop taxi flight at port
+                if(_player->isInFlight())
+                {
+                    _player->GetMotionMaster()->MovementExpired();
+                    _player->m_taxi.ClearTaxiDestinations();
+                }
+                _player->RemoveFromGroup();
+                queueSlot = _player->GetBattleGroundQueueIndex(bgQueueTypeId);
+                sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), queueSlot, STATUS_IN_PROGRESS, 0, bg->GetStartTime());
+                _player->GetSession()->SendPacket(&data);
+                // remove battleground queue status from BGmgr
+                sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].RemovePlayer(_player->GetGUID(), false);
+                // this is still needed here if battleground "jumping" shouldn't add deserter debuff
+                // also this required to prevent stuck at old battleground after SetBattleGroundId set to new
+                if( BattleGround *currentBg = _player->GetBattleGround() )
+                    currentBg->RemovePlayerAtLeave(_player->GetGUID(), false, true);
+
+                // set the destination instance id
+                _player->SetBattleGroundId(bg->GetInstanceID());
+                // set the destination team
+                _player->SetBGTeam(team);
+                // bg->HandleBeforeTeleportToBattleGround(_player);
+                sBattleGroundMgr.SendToBattleGround(_player, instanceId);
+                // add only in HandleMoveWorldPortAck()
+                // bg->AddPlayer(_player,team);
+                sLog.outDebug("Battleground: player %s (%u) joined battle for bg %u, bgtype %u, queue type %u.",_player->GetName(),_player->GetGUIDLow(),bg->GetInstanceID(),bg->GetTypeID(),bgQueueTypeId);
+                break;
+            case 0:                                     // leave queue
+                queueSlot = _player->GetBattleGroundQueueIndex(bgQueueTypeId);
+                _player->RemoveBattleGroundQueueId(bgQueueTypeId); // must be called this way, because if you move this call to queue->removeplayer, it causes bugs
+                sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), queueSlot, STATUS_NONE, 0, 0);
+                sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].RemovePlayer(_player->GetGUID(), true);
+                // player left queue, we should update it, maybe now his group fits in
+                sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].Update(bgTypeId,_player->GetBattleGroundQueueIdFromLevel(),arenatype,israted,rating);
+                SendPacket(&data);
+                sLog.outDebug("Battleground: player %s (%u) left queue for bgtype %u, queue type %u.",_player->GetName(),_player->GetGUIDLow(),bg->GetTypeID(),bgQueueTypeId);
+                break;
+            default:
+                sLog.outError("Battleground port: unknown action %u", action);
+                break;
+        }
     }
 }
 
@@ -384,7 +578,8 @@ void WorldSession::HandleBattlefieldStatusOpcode( WorldPacket & /*recv_data*/ )
         BattleGround *bg = _player->GetBattleGround();
         if(bg)
         {
-            uint32 queueSlot = _player->GetBattleGroundQueueIndex(bg->GetTypeID());
+            uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bg->GetTypeID(), bg->GetArenaType());
+            uint32 queueSlot = _player->GetBattleGroundQueueIndex(bgQueueTypeId);
             if((bg->GetStatus() <= STATUS_IN_PROGRESS))
             {
                 sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), queueSlot, STATUS_IN_PROGRESS, 0, bg->GetStartTime());
@@ -392,15 +587,25 @@ void WorldSession::HandleBattlefieldStatusOpcode( WorldPacket & /*recv_data*/ )
             }
             for (uint32 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
             {
-                uint32 queue_id = _player->GetBattleGroundQueueId(i);
-                if (i == queueSlot || !queue_id)
+                uint32 queue_id = _player->GetBattleGroundQueueId(i);       // battlegroundqueueid stores the type id, not the instance id, so this is definitely wrong
+                uint8 arenatype = sBattleGroundMgr.BGArenaType(queue_id);
+                uint8 isRated = 0;
+                if (i == queueSlot || !queue_id)                            // we need to get the instance ids
+                    continue;
+                BattleGroundQueue::QueuedPlayersMap::iterator itrPlayerStatus = sBattleGroundMgr.m_BattleGroundQueues[queue_id].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].find(_player->GetGUID());
+                if(itrPlayerStatus == sBattleGroundMgr.m_BattleGroundQueues[queue_id].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].end())
                     continue;
-                BattleGround *bg2 = sBattleGroundMgr.GetBattleGround(queue_id);
+                if(itrPlayerStatus->second.GroupInfo)
+                {
+                    arenatype = itrPlayerStatus->second.GroupInfo->ArenaType;
+                    isRated = itrPlayerStatus->second.GroupInfo->IsRated;
+                }
+                BattleGround *bg2 = sBattleGroundMgr.GetBattleGroundTemplate(sBattleGroundMgr.BGTemplateId(queue_id)); //  try this
                 if(bg2)
                 {
                     //in this call is small bug, this call should be filled by player's waiting time in queue
                     //this call nulls all timers for client :
-                    sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg2, _player->GetTeam(), i, STATUS_WAIT_QUEUE, 0, 0);
+                    sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg2, _player->GetTeam(), i, STATUS_WAIT_QUEUE, 0, 0,arenatype,isRated);
                     SendPacket(&data);
                 }
             }
@@ -411,16 +616,36 @@ void WorldSession::HandleBattlefieldStatusOpcode( WorldPacket & /*recv_data*/ )
         // we should update all queues? .. i'm not sure if this code is correct
         for (uint32 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
         {
-            if(uint32 queue_id = _player->GetBattleGroundQueueId(i))
+            uint32 queue_id = _player->GetBattleGroundQueueId(i);
+            if(!queue_id)
+                continue;
+            uint32 bgTypeId = sBattleGroundMgr.BGTemplateId(queue_id);
+            uint8 arenatype = sBattleGroundMgr.BGArenaType(queue_id);
+            uint8 isRated = 0;
+            BattleGround *bg = sBattleGroundMgr.GetBattleGroundTemplate(bgTypeId);
+            BattleGroundQueue::QueuedPlayersMap::iterator itrPlayerStatus = sBattleGroundMgr.m_BattleGroundQueues[queue_id].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].find(_player->GetGUID());
+            if(itrPlayerStatus == sBattleGroundMgr.m_BattleGroundQueues[queue_id].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].end())
+                continue;
+            if(itrPlayerStatus->second.GroupInfo)
             {
-                if(BattleGround *bg = sBattleGroundMgr.GetBattleGround(queue_id))
-                {
-                    sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), i, STATUS_WAIT_QUEUE, 0, 0);
-                    SendPacket(&data);
-                }
+                arenatype = itrPlayerStatus->second.GroupInfo->ArenaType;
+                isRated = itrPlayerStatus->second.GroupInfo->IsRated;
+            }
+            if(bg && queue_id)
+            {
+                sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), i, STATUS_WAIT_QUEUE, 0, 0, arenatype, isRated);
+                SendPacket(&data);
             }
         }
     }
+/*    else              // not sure if it needed...
+    {
+        for (uint32 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
+        {
+            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, NULL, _player->GetTeam(),i , STATUS_NONE, 0, 0);
+            SendPacket(&data);
+        }
+    }*/
 }
 
 void WorldSession::HandleAreaSpiritHealerQueryOpcode( WorldPacket & recv_data )
@@ -480,16 +705,12 @@ void WorldSession::HandleBattleGroundArenaJoin( WorldPacket & recv_data )
     if(_player->InBattleGround())
         return;
 
-    for(int qId = 0; qId < PLAYER_MAX_BATTLEGROUND_QUEUES; ++qId)
-    {
-        if(_player->GetBattleGroundQueueId(qId) != 0)
-            return;
-    }
-
     uint64 guid;                                            // arena Battlemaster guid
     uint8 type;                                             // 2v2, 3v3 or 5v5
     uint8 asGroup;                                          // asGroup
     uint8 isRated;                                          // isRated
+    Group * grp;
+
     recv_data >> guid >> type >> asGroup >> isRated;
 
     Creature *unit = ObjectAccessor::GetCreature(*_player, guid);
@@ -500,6 +721,7 @@ void WorldSession::HandleBattleGroundArenaJoin( WorldPacket & recv_data )
         return;
 
     uint8 arenatype = 0;
+    uint32 arenaRating = 0;
 
     switch(type)
     {
@@ -517,88 +739,196 @@ void WorldSession::HandleBattleGroundArenaJoin( WorldPacket & recv_data )
             return;
     }
 
-    if(isRated && !_player->GetArenaTeamId(type))           // player not in arena team of that size
+    //check existance
+    BattleGround* bg = NULL;
+    if( !(bg = sBattleGroundMgr.GetBattleGroundTemplate(BATTLEGROUND_AA)) )
     {
-        _player->GetSession()->SendNotInArenaTeamPacket(arenatype);
+        sLog.outError("Battleground: template bg (all arenas) not found");     
         return;
     }
 
-    if(asGroup && !_player->GetGroup())                     // player not in group
-        return;
+    uint8 bgTypeId = bg->GetTypeID();
+    uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bgTypeId, arenatype);
 
-    // check existence
-    BattleGround *bg = sBattleGroundMgr.GetBattleGround(BATTLEGROUND_AA);
-    if(!bg)
-        return;
+    // check queueing conditions
+    if(!asGroup)
+    {
+        // check if already in queue
+        if (_player->GetBattleGroundQueueIndex(bgQueueTypeId) < PLAYER_MAX_BATTLEGROUND_QUEUES)
+            //player is already in this queue
+            return;
+        // check if has free queue slots
+        if(!_player->HasFreeBattleGroundQueueId())
+            return;
+    }
+    else
+    {
+        grp = _player->GetGroup();
+        // no group found, error
+        if(!grp)
+            return;
+        uint32 err = grp->CanJoinBattleGroundQueue(bgTypeId, bgQueueTypeId, arenatype, arenatype, (bool)isRated, type);
+        switch(err)
+        {
+            // TODO: add error-based feedback to players in all cases
+        case BG_JOIN_ERR_GROUP_TOO_MANY:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_ARENA_GROUP_TOO_LARGE), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_GROUP_NOT_ENOUGH:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_ARENA_NOT_ENOUGH_PLAYERS), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_MIXED_ARENATEAM:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_ARENA_YOUR_TEAM_ONLY), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_OFFLINE_MEMBER:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_OFFLINE_MEMBER), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_MIXED_FACTION:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_MIXED_FACTION), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_MIXED_LEVELS:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_MIXED_LEVELS), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_GROUP_MEMBER_ALREADY_IN_QUEUE:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_MEMBER_ALREADY_IN_QUEUE), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_GROUP_DESERTER:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_MEMBER_DESERTER), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_ALL_QUEUES_USED:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_MEMBER_NO_FREE_QUEUE_SLOTS), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+            // all ok, can join
+        case BG_JOIN_ERR_OK:
+            break;
+            // not the above? shouldn't happen, don't let join
+        default:
+            return;
+            break;
+        };
+    }
 
-    bg->SetArenaType(arenatype);
-    bg->SetRated(isRated);
+    uint32 ateamId = 0;
 
-    if(asGroup && _player->GetGroup())
+    if(isRated)           
     {
-        Group *grp = _player->GetGroup();
+        ateamId = _player->GetArenaTeamId(type);
+        // check real arenateam existence only here (if it was moved to group->CanJoin .. () then we would ahve to get it twice)
+        ArenaTeam * at = objmgr.GetArenaTeamById(ateamId);
+        if(!at)
+        {
+            _player->GetSession()->SendNotInArenaTeamPacket(arenatype);
+            return;
+        }
+        // get the team rating for queueing
+        arenaRating = at->GetRating();
+        // the arenateam id must match for everyone in the group
+        // get the personal ratings for queueing
+        uint32 avg_pers_rating = 0;
         for(GroupReference *itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
         {
             Player *member = itr->getSource();
-            if(!member) continue;
 
-            /*if (!member->CanJoinToBattleground())
-                //player has deserter aura .. do nothing
-            */
+            // calc avg personal rating
+            avg_pers_rating += member->GetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (type*6) + 5);
+        }
 
-            if (member->InBattleGroundQueueForBattleGroundType(BATTLEGROUND_AA))
-                //player is already in this queue
-                continue;
+        if( arenatype )
+            avg_pers_rating /= arenatype;
 
-                                                            // add to queue
-            uint32 queueSlot = member->AddBattleGroundQueueId(BATTLEGROUND_AA);
-            if (queueSlot == PLAYER_MAX_BATTLEGROUND_QUEUES)
-            {
-                WorldPacket data;
-                //fill data
-                //member->GetSession()->SendPacket(data);
-                continue;
-            }
+        // if avg personal rating is more than 150 points below the teams rating, the team will be queued against an opponent matching or similar to the average personal rating 
+        if(avg_pers_rating + 150 < arenaRating)
+            arenaRating = avg_pers_rating;
+    }
+
+    if(asGroup)
+    {
+        GroupQueueInfo * ginfo = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddGroup(_player, bgTypeId, arenatype, isRated, arenaRating, ateamId);
+        sLog.outDebug("Battleground: arena join as group start");
+        if(isRated)
+            sLog.outDebug("Battleground: arena team id %u, leader %s queued with rating %u for type %u",_player->GetArenaTeamId(type),_player->GetName(),arenaRating,arenatype);
+        for(GroupReference *itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player *member = itr->getSource();
+            if(!member) continue;
+
+            uint32 queueSlot = member->AddBattleGroundQueueId(bgQueueTypeId);// add to queue
 
             // store entry point coords (same as leader entry point)
             member->SetBattleGroundEntryPoint(_player->GetMapId(),_player->GetPositionX(),_player->GetPositionY(),_player->GetPositionZ(),_player->GetOrientation());
 
             WorldPacket data;
             // send status packet (in queue)
-            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, member->GetTeam(), queueSlot, STATUS_WAIT_QUEUE, 0, 0);
+            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, member->GetTeam(), queueSlot, STATUS_WAIT_QUEUE, 0, 0, arenatype, isRated);
             member->GetSession()->SendPacket(&data);
-            sBattleGroundMgr.BuildGroupJoinedBattlegroundPacket(&data, BATTLEGROUND_AA);
+            sBattleGroundMgr.BuildGroupJoinedBattlegroundPacket(&data, bgTypeId);
             member->GetSession()->SendPacket(&data);
-            sBattleGroundMgr.m_BattleGroundQueues[BATTLEGROUND_AA].AddPlayer(member, BATTLEGROUND_AA);
+            sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddPlayer(member, ginfo);
+            sLog.outDebug("Battleground: player joined queue for arena as group bg queue type %u bg type %u: GUID %u, NAME %s",bgQueueTypeId,bgTypeId,member->GetGUIDLow(), member->GetName());
         }
+        sLog.outDebug("Battleground: arena join as group end");
+        sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].Update(bgTypeId, _player->GetBattleGroundQueueIdFromLevel(), arenatype, isRated, arenaRating);
     }
     else
     {
-        /*if (!member->CanJoinToBattleground())
-            //player has deserter aura .. do nothing
-        */
-
-        if (_player->InBattleGroundQueueForBattleGroundType(BATTLEGROUND_AA))
-            //player is already in this queue
-            return;
-
-        uint32 queueSlot = _player->AddBattleGroundQueueId(BATTLEGROUND_AA);
-        if (queueSlot == PLAYER_MAX_BATTLEGROUND_QUEUES)
-        {
-            WorldPacket data;
-            //fill data (player is in 3 queues already)
-            //SendPacket(data);
-            return;
-        }
+        uint32 queueSlot = _player->AddBattleGroundQueueId(bgQueueTypeId);
 
         // store entry point coords
         _player->SetBattleGroundEntryPoint(_player->GetMapId(),_player->GetPositionX(),_player->GetPositionY(),_player->GetPositionZ(),_player->GetOrientation());
 
         WorldPacket data;
         // send status packet (in queue)
-        sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), queueSlot, STATUS_WAIT_QUEUE, 0, 0);
+        sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), queueSlot, STATUS_WAIT_QUEUE, 0, 0, arenatype, isRated);
         SendPacket(&data);
-        sBattleGroundMgr.m_BattleGroundQueues[BATTLEGROUND_AA].AddPlayer(_player, BATTLEGROUND_AA);
+        GroupQueueInfo * ginfo = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddGroup(_player, bgTypeId, arenatype, isRated, arenaRating);
+        sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddPlayer(_player, ginfo);
+        sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].Update(bgTypeId, _player->GetBattleGroundQueueIdFromLevel(), arenatype, isRated, arenaRating);
+        sLog.outDebug("Battleground: player joined queue for arena, skirmish, bg queue type %u bg type %u: GUID %u, NAME %s",bgQueueTypeId,bgTypeId,_player->GetGUIDLow(), _player->GetName());
     }
 }
 
diff --git a/src/game/BattleGroundMgr.cpp b/src/game/BattleGroundMgr.cpp
index 5cee001..420404d 100644
--- a/src/game/BattleGroundMgr.cpp
+++ b/src/game/BattleGroundMgr.cpp
@@ -30,10 +30,13 @@
 #include "SharedDefines.h"
 #include "Policies/SingletonImp.h"
 #include "MapManager.h"
+#include "Map.h"
+#include "MapInstanced.h"
 #include "ObjectMgr.h"
 #include "ProgressBar.h"
 #include "World.h"
 #include "Chat.h"
+#include "ArenaTeam.h"
 
 INSTANTIATE_SINGLETON_1( BattleGroundMgr );
 
@@ -44,12 +47,12 @@ INSTANTIATE_SINGLETON_1( BattleGroundMgr );
 BattleGroundQueue::BattleGroundQueue()
 {
     //queues are empty, we don't have to call clear()
-    for (int i = 0; i < MAX_BATTLEGROUND_QUEUES; i++)
+/*    for (int i = 0; i < MAX_BATTLEGROUND_QUEUES; i++)
     {
-        m_QueuedPlayers[i].Horde = 0;
-        m_QueuedPlayers[i].Alliance = 0;
+        //m_QueuedPlayers[i].Horde = 0;
+        //m_QueuedPlayers[i].Alliance = 0;
         //m_QueuedPlayers[i].AverageTime = 0;
-    }
+    }*/
 }
 
 BattleGroundQueue::~BattleGroundQueue()
@@ -57,31 +60,191 @@ BattleGroundQueue::~BattleGroundQueue()
     for (int i = 0; i < MAX_BATTLEGROUND_QUEUES; i++)
     {
         m_QueuedPlayers[i].clear();
+        for(QueuedGroupsList::iterator itr = m_QueuedGroups[i].begin(); itr!= m_QueuedGroups[i].end(); ++itr)
+        {
+            delete (*itr);
+        }
+        m_QueuedGroups[i].clear();
+    }
+}
+
+// initialize eligible groups from the given source matching the given specifications
+void BattleGroundQueue::EligibleGroups::Init(BattleGroundQueue::QueuedGroupsList *source, uint32 BgTypeId, uint32 side, uint32 MaxPlayers, uint8 ArenaType, bool IsRated, uint32 MinRating, uint32 MaxRating, uint32 DisregardTime, uint32 excludeTeam)
+{
+    // clear from prev initialization
+    clear();
+    BattleGroundQueue::QueuedGroupsList::iterator itr, next;
+    // iterate through the source
+    for(itr = source->begin(); itr!= source->end(); itr = next)
+    {
+        next = itr;
+        ++next;
+        if( (*itr)->BgTypeId == BgTypeId &&     // bg type must match
+            (*itr)->ArenaType == ArenaType &&   // arena type must match
+            (*itr)->IsRated == IsRated &&       // israted must match
+            (*itr)->IsInvitedToBGInstanceGUID == 0 && // leave out already invited groups
+            (*itr)->Team == side &&             // match side
+            (*itr)->Players.size() <= MaxPlayers &&   // the group must fit in the bg
+            ( !excludeTeam || (*itr)->ArenaTeamId != excludeTeam ) && // if excludeTeam is specified, leave out those arena team ids
+            ( !IsRated || (*itr)->Players.size() == MaxPlayers ) &&   // if rated, then pass only if the player count is exact NEEDS TESTING! (but now this should never happen)
+            (  (*itr)->JoinTime <= DisregardTime              // pass if disregard time is greater than join time
+               || (*itr)->ArenaTeamRating == 0                 // pass if no rating info
+               || ( (*itr)->ArenaTeamRating >= MinRating       // pass if matches the rating range
+                     && (*itr)->ArenaTeamRating <= MaxRating ) ) )   
+        {
+            // the group matches the conditions
+            // insert it in order of groupsize, and join time
+            uint32 size = (*itr)->Players.size();
+            uint32 jointime = (*itr)->JoinTime;
+            bool inserted = false;
+
+            for(std::list<GroupQueueInfo *>::iterator elig_itr = begin(); elig_itr != end(); ++elig_itr)
+            {
+                // if the next one's size is smaller, then insert
+                // also insert if the next one's size is equal, but it joined the queue later
+                if( ((*elig_itr)->Players.size()<size) ||
+                    ((*elig_itr)->Players.size() == size && (*elig_itr)->JoinTime > jointime) )
+                {
+                    insert(elig_itr,(*itr));
+                    inserted = true;
+                    break;
+                }
+            }
+            // if not inserted -> this is the smallest group -> push_back
+            if(!inserted)
+            {
+                push_back((*itr));
+            }
+        }
+    }
+}
+
+// remove group from eligible groups
+// used when building selection pools
+void BattleGroundQueue::EligibleGroups::RemoveGroup(GroupQueueInfo * ginfo)
+{
+    for(std::list<GroupQueueInfo *>::iterator itr = begin(); itr != end(); ++itr)
+    {
+        if((*itr)==ginfo)
+        {
+            erase(itr);
+            return;
+        }
+    }
+}
+
+// selection pool initialization, used to clean up from prev selection
+void BattleGroundQueue::SelectionPool::Init()
+{
+    SelectedGroups.clear();
+    MaxGroup = 0;
+    PlayerCount = 0;
+}
+
+// get the maximal group from the selection pool
+// used when building the pool, and have to remove the largest
+GroupQueueInfo * BattleGroundQueue::SelectionPool::GetMaximalGroup()
+{
+    if(SelectedGroups.empty())
+    {
+        sLog.outError("Getting max group when selection pool is empty, this should never happen.");
+        MaxGroup = NULL;
+        return 0;
     }
+    // actually select the max group if it's not set
+    if(MaxGroup==0 && !SelectedGroups.empty())
+    {
+        uint32 max_size = 0;
+        for(std::list<GroupQueueInfo *>::iterator itr = SelectedGroups.begin(); itr != SelectedGroups.end(); ++itr)
+        {
+            if(max_size<(*itr)->Players.size())
+            {
+                MaxGroup =(*itr);
+                max_size = MaxGroup->Players.size();
+            }
+        }
+    }
+    return MaxGroup;
 }
 
-void BattleGroundQueue::AddPlayer(Player *plr, uint32 bgTypeId)
+// remove group info from selection pool
+// used when building selection pools and have to remove maximal group
+void BattleGroundQueue::SelectionPool::RemoveGroup(GroupQueueInfo *ginfo)
+{
+    // uninitiate max group info if needed
+    if(MaxGroup == ginfo)
+        MaxGroup = 0;
+    // find what to remove
+    for(std::list<GroupQueueInfo *>::iterator itr = SelectedGroups.begin(); itr != SelectedGroups.end(); ++itr)
+    {
+        if((*itr)==ginfo)
+        {
+            SelectedGroups.erase(itr);
+            // decrease selected players count
+            PlayerCount -= ginfo->Players.size();
+            return;
+        }
+    }
+}
+
+// add group to selection
+// used when building selection pools
+void BattleGroundQueue::SelectionPool::AddGroup(GroupQueueInfo * ginfo)
+{
+    SelectedGroups.push_back(ginfo);
+    // increase selected players count
+    PlayerCount+=ginfo->Players.size();
+    if(!MaxGroup || ginfo->Players.size() > MaxGroup->Players.size())
+    {
+        // update max group info if needed
+        MaxGroup = ginfo;
+    }
+}
+
+// add group to bg queue with the given leader and bg specifications
+GroupQueueInfo * BattleGroundQueue::AddGroup(Player *leader, uint32 BgTypeId, uint8 ArenaType, bool isRated, uint32 arenaRating, uint32 arenateamid)
+{
+    uint32 queue_id = leader->GetBattleGroundQueueIdFromLevel();
+
+    // create new ginfo
+    // cannot use the method like in addplayer, because that could modify an in-queue group's stats
+    // (e.g. leader leaving queue then joining as individual again)
+    GroupQueueInfo* ginfo = new GroupQueueInfo;
+    ginfo->BgTypeId                  = BgTypeId;
+    ginfo->ArenaType                 = ArenaType;
+    ginfo->ArenaTeamId               = arenateamid;
+    ginfo->IsRated                   = isRated;
+    ginfo->IsInvitedToBGInstanceGUID = 0;                       // maybe this should be modifiable by function arguments to enable selection of running instances?
+    ginfo->JoinTime                  = getMSTime();
+    ginfo->Team                      = leader->GetTeam();
+
+    if(sBattleGroundMgr.GetMaxRatingDifference())               // if max difference is set, then store rating info for queue
+        ginfo->ArenaTeamRating       = arenaRating;
+    else
+        ginfo->ArenaTeamRating       = 0;                       // don't if it doesn't matter
+
+    ginfo->Players.clear();
+
+    m_QueuedGroups[queue_id].push_back(ginfo);
+
+    // return ginfo, because it is needed to add players to this group info
+    return ginfo;
+}
+
+void BattleGroundQueue::AddPlayer(Player *plr, GroupQueueInfo *ginfo)
 {
     uint32 queue_id = plr->GetBattleGroundQueueIdFromLevel();
 
     //if player isn't in queue, he is added, if already is, then values are overwritten, no memory leak
     PlayerQueueInfo& info = m_QueuedPlayers[queue_id][plr->GetGUID()];
     info.InviteTime                 = 0;
-    info.IsInvitedToBGInstanceGUID  = 0;
     info.LastInviteTime             = 0;
     info.LastOnlineTime             = getMSTime();
-    info.Team                       = plr->GetTeam();
-
-    //add player to waiting order queue
-    m_PlayersSortedByWaitTime[queue_id].push_back(plr->GetGUID());
-
-    if(plr->GetTeam() == ALLIANCE)
-        ++m_QueuedPlayers[queue_id].Alliance;
-    else
-        ++m_QueuedPlayers[queue_id].Horde;
-
-    Update(bgTypeId, queue_id);
+    info.GroupInfo                  = ginfo;
 
+    // add the pinfo to ginfo's list
+    ginfo->Players[plr->GetGUID()]  = &info;
+/*
     if( sWorld.getConfig(CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_ENABLE) )
     {
         BattleGround* bg = sBattleGroundMgr.GetBattleGround(bgTypeId);
@@ -111,7 +274,8 @@ void BattleGroundQueue::AddPlayer(Player *plr, uint32 bgTypeId)
             sWorld.SendWorldText(LANG_BG_QUEUE_ANNOUNCE_WORLD,
                 bgName, q_min_level, q_max_level, qAlliance, MinPlayers - qAlliance, qHorde, MinPlayers - qHorde);
         }
-    }
+
+    }*/
 }
 
 void BattleGroundQueue::RemovePlayer(uint64 guid, bool decreaseInvitedCount)
@@ -120,11 +284,22 @@ void BattleGroundQueue::RemovePlayer(uint64 guid, bool decreaseInvitedCount)
 
     uint32 queue_id = 0;
     QueuedPlayersMap::iterator itr;
+    GroupQueueInfo * group;
+    QueuedGroupsList::iterator group_itr;
     bool IsSet = false;
-    if(!plr)
-    {                                                       //player is offline, we need to find him somewhere in queues
-        /// there is something wrong if this code is run, because we have in queue only online players!
-        sLog.outError("Battleground: removing offline player from BG queue - this might not happen, but it should not cause crash");
+    if(plr)
+    {
+        queue_id = plr->GetBattleGroundQueueIdFromLevel();
+
+        itr = m_QueuedPlayers[queue_id].find(guid);
+        if(itr != m_QueuedPlayers[queue_id].end())
+            IsSet = true;
+    }
+
+    if(!IsSet)
+    {                                                       
+        // either player is offline, or he levelled up to another queue category
+        // sLog.outError("Battleground: removing offline player from BG queue - this might not happen, but it should not cause crash");
         for (uint32 i = 0; i < MAX_BATTLEGROUND_QUEUES; i++)
         {
             itr = m_QueuedPlayers[i].find(guid);
@@ -136,44 +311,248 @@ void BattleGroundQueue::RemovePlayer(uint64 guid, bool decreaseInvitedCount)
             }
         }
     }
-    else
-    {                                                       //player is online, we have his level, so we can find exact queue from his level
-        queue_id = plr->GetBattleGroundQueueIdFromLevel();
-        itr = m_QueuedPlayers[queue_id].find(guid);
-        IsSet = true;
+
+    // couldn't find the player in bg queue, return
+    if(!IsSet)
+    {
+        sLog.outError("Battleground: couldn't find player to remove.");
+        return;
     }
 
-    //all variables are set, so remove player
-    //remove player from time queue
-    m_PlayersSortedByWaitTime[queue_id].remove(guid);
+    group = itr->second.GroupInfo;
 
-    if (IsSet && itr != m_QueuedPlayers[queue_id].end())
+    for(group_itr=m_QueuedGroups[queue_id].begin(); group_itr != m_QueuedGroups[queue_id].end(); ++group_itr)
     {
-        if (!itr->second.IsInvitedToBGInstanceGUID)
-        {
-            if(itr->second.Team == ALLIANCE)
-                --m_QueuedPlayers[queue_id].Alliance;
-            else
-                --m_QueuedPlayers[queue_id].Horde;
-        }
-        else
+        if(group == (GroupQueueInfo*)(*group_itr))
+            break;
+    }
+
+    // variables are set (what about leveling up when in queue????)
+    // remove player from group
+    // if only player there, remove group
+
+    // remove player queue info from group queue info
+    std::map<uint64, PlayerQueueInfo*>::iterator pitr = group->Players.find(guid);
+
+    if(pitr != group->Players.end())
+        group->Players.erase(pitr);
+
+    // check for iterator correctness
+    if (group_itr != m_QueuedGroups[queue_id].end() && itr != m_QueuedPlayers[queue_id].end())
+    {
+        // used when player left the queue, NOT used when porting to bg
+        if (decreaseInvitedCount)
         {
-            if (decreaseInvitedCount)
+            // if invited to bg, and should decrease invited count, then do it
+            if(group->IsInvitedToBGInstanceGUID)
             {
-                BattleGround* bg = sBattleGroundMgr.GetBattleGround(itr->second.IsInvitedToBGInstanceGUID);
+                BattleGround* bg = sBattleGroundMgr.GetBattleGround(group->IsInvitedToBGInstanceGUID);
                 if (bg)
-                    bg->DecreaseInvitedCount(itr->second.Team);
+                    bg->DecreaseInvitedCount(group->Team);
+                if (bg && !bg->GetPlayersSize() && !bg->GetInvitedCount(ALLIANCE) && !bg->GetInvitedCount(HORDE))
+                {
+                    // no more players on battleground, set delete it
+                    bg->SetDeleteThis();
+                }
             }
+            // update the join queue, maybe now the player's group fits in a queue!
+            // not yet implemented (should store bgTypeId in group queue info?)
         }
+        // remove player queue info
         m_QueuedPlayers[queue_id].erase(itr);
+        // remove group queue info if needed
+        if(group->Players.empty())
+        {
+            m_QueuedGroups[queue_id].erase(group_itr);
+            delete group;
+        }
+        // NEEDS TESTING!
+        // group wasn't empty, so it wasn't deleted, and player have left a rated queue -> everyone from the group should leave too
+        // don't remove recursively if already invited to bg!
+        else if(!group->IsInvitedToBGInstanceGUID && decreaseInvitedCount && group->IsRated)
+        {
+            // remove next player, this is recursive
+            // first send removal information
+            if(Player *plr2 = objmgr.GetPlayer(group->Players.begin()->first))
+            {
+                BattleGround * bg = sBattleGroundMgr.GetBattleGroundTemplate(group->BgTypeId);
+                uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(group->BgTypeId,group->ArenaType);
+                uint32 queueSlot = plr2->GetBattleGroundQueueIndex(bgQueueTypeId);
+                plr2->RemoveBattleGroundQueueId(bgQueueTypeId); // must be called this way, because if you move this call to queue->removeplayer, it causes bugs
+                WorldPacket data;
+                sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, plr2->GetTeam(), queueSlot, STATUS_NONE, 0, 0);
+                plr2->GetSession()->SendPacket(&data);
+            }
+            // then actually delete, this may delete the group as well!
+            RemovePlayer(group->Players.begin()->first,decreaseInvitedCount);
+        }
+    }
+}
+
+bool BattleGroundQueue::InviteGroupToBG(GroupQueueInfo * ginfo, BattleGround * bg, uint32 side)
+{
+    // set side if needed
+    if(side)
+        ginfo->Team = side;
+
+    if(!ginfo->IsInvitedToBGInstanceGUID)
+    {
+        // not yet invited
+        // set invitation
+        ginfo->IsInvitedToBGInstanceGUID = bg->GetInstanceID();
+        uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bg->GetTypeID(), bg->GetArenaType());
+        // loop through the players
+        for(std::map<uint64,PlayerQueueInfo*>::iterator itr = ginfo->Players.begin(); itr != ginfo->Players.end(); ++itr)
+        {
+            // set status
+            itr->second->InviteTime = getMSTime();
+            itr->second->LastInviteTime = getMSTime();
+
+            // get the player
+            Player* plr = objmgr.GetPlayer(itr->first);
+            // if offline, skip him
+            if(!plr)
+                continue;
+
+            // invite the player
+            sBattleGroundMgr.InvitePlayer(plr, bg->GetInstanceID(),ginfo->Team);
+
+            WorldPacket data;
+
+            uint32 queueSlot = plr->GetBattleGroundQueueIndex(bgQueueTypeId);
+
+            sLog.outDebug("Battleground: invited plr %s (%u) to BG instance %u queueindex %u bgtype %u, I can't help it if they don't press the enter battle button.",plr->GetName(),plr->GetGUIDLow(),bg->GetInstanceID(),queueSlot,bg->GetTypeID());
+
+            // send status packet
+            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, side?side:plr->GetTeam(), queueSlot, STATUS_WAIT_JOIN, INVITE_ACCEPT_WAIT_TIME, 0);
+            plr->GetSession()->SendPacket(&data);
+        }
+        return true;
+    }
+
+    return false;
+}
+
+// this function is responsible for the selection of queued groups when trying to create new battlegrounds
+bool BattleGroundQueue::BuildSelectionPool(uint32 bgTypeId, uint32 queue_id, uint32 MinPlayers, uint32 MaxPlayers,  SelectionPoolBuildMode mode, uint8 ArenaType, bool isRated, uint32 MinRating, uint32 MaxRating, uint32 DisregardTime, uint32 excludeTeam)
+{
+    uint32 side;
+    switch(mode)
+    {
+    case NORMAL_ALLIANCE:
+    case ONESIDE_ALLIANCE_TEAM1:
+    case ONESIDE_ALLIANCE_TEAM2:
+        side = ALLIANCE;
+        break;
+    case NORMAL_HORDE:
+    case ONESIDE_HORDE_TEAM1:
+    case ONESIDE_HORDE_TEAM2:
+        side = HORDE;
+        break;
+    default:
+        //unknown mode, return false
+        sLog.outDebug("Battleground: unknown selection pool build mode, returning...");
+        return false;
+        break;
+    }
+
+    // inititate the groups eligible to create the bg
+    m_EligibleGroups.Init(&(m_QueuedGroups[queue_id]), bgTypeId, side, MaxPlayers, ArenaType, isRated, MinRating, MaxRating, DisregardTime, excludeTeam);
+    // init the selected groups (clear)
+    m_SelectionPools[mode].Init();
+    while(!(m_EligibleGroups.empty()))
+    {
+        sLog.outDebug("m_EligibleGroups is not empty, continue building selection pool");
+        // in decreasing group size, add groups to join if they fit in the MaxPlayersPerTeam players
+        for(EligibleGroups::iterator itr= m_EligibleGroups.begin(); itr!=m_EligibleGroups.end(); ++itr)
+        {
+            // get the maximal not yet checked group
+            GroupQueueInfo * MaxGroup = (*itr);
+            // if it fits in the maxplayer size, add it
+            if( (m_SelectionPools[mode].GetPlayerCount() + MaxGroup->Players.size()) <= MaxPlayers )
+            {
+                m_SelectionPools[mode].AddGroup(MaxGroup);
+            }
+        }
+        if(m_SelectionPools[mode].GetPlayerCount()>=MinPlayers)
+        {
+            // the selection pool is set, return
+            sLog.outDebug("pool build succeeded, return true");
+            return true;
+        }
+        // if the selection pool's not set, then remove the group with the highest player count, and try again with the rest.
+        GroupQueueInfo * MaxGroup = m_SelectionPools[mode].GetMaximalGroup();
+        m_EligibleGroups.RemoveGroup(MaxGroup);
+        m_SelectionPools[mode].RemoveGroup(MaxGroup);
+    }
+    // failed to build a selection pool matching the given values
+    return false;
+}
+
+// used to remove the Enter Battle window if the battle has already, but someone still has it
+// (this can happen in arenas mainly, since the preparation is shorter than the timer for the bgqueueremove event
+void BattleGroundQueue::BGEndedRemoveInvites(BattleGround *bg)
+{
+    uint32 queue_id = bg->GetQueueType();
+    uint32 bgInstanceId = bg->GetInstanceID();
+    uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bg->GetTypeID(), bg->GetArenaType());
+    QueuedGroupsList::iterator itr, next;
+    for(itr = m_QueuedGroups[queue_id].begin(); itr != m_QueuedGroups[queue_id].end(); itr = next)
+    {
+        // must do this way, because the groupinfo will be deleted when all playerinfos are removed
+        GroupQueueInfo * ginfo = (*itr);
+        next = itr;
+        ++next;
+        // if group was invited to this bg instance, then remove all references
+        if(ginfo->IsInvitedToBGInstanceGUID == bgInstanceId)
+        {
+            // after removing this much playerinfos, the ginfo will be deleted, so we'll use a for loop
+            uint32 to_remove = ginfo->Players.size();
+            uint32 team = ginfo->Team;
+            for(int i = 0; i < to_remove; ++i)
+            {
+                // always remove the first one in the group
+                std::map<uint64, PlayerQueueInfo * >::iterator itr2 = ginfo->Players.begin();
+                if(itr2 == ginfo->Players.end())
+                {
+                    sLog.outError("Empty Players in ginfo, this should never happen!");
+                    return;
+                }
+
+                // get the player
+                Player * plr = objmgr.GetPlayer(itr2->first);
+                if(!plr)
+                {
+                    sLog.outError("Player offline when trying to remove from GroupQueueInfo, this should never happen.");
+                    continue;
+                }
+
+                // get the queueslot
+                uint32 queueSlot = plr->GetBattleGroundQueueIndex(bgQueueTypeId);
+                if (queueSlot < PLAYER_MAX_BATTLEGROUND_QUEUES) // player is in queue
+                {
+                    plr->RemoveBattleGroundQueueId(bgQueueTypeId);
+                    // remove player from queue, this might delete the ginfo as well! don't use that pointer after this!
+                    RemovePlayer(itr2->first, true);
+                    // this is probably unneeded, since this player was already invited -> does not fit when initing eligible groups
+                    // but updateing the queue can't hurt
+                    Update(bgQueueTypeId, bg->GetQueueType());
+                    // send info to client
+                    WorldPacket data;
+                    sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, team, queueSlot, STATUS_NONE, 0, 0);
+                    plr->GetSession()->SendPacket(&data);
+                }
+            }
+        }
     }
 }
 
 /*
-this method is called when player is inserted, or removed from BG Queue - there is only one player's status changed, so we don't use while(true) cycles to invite whole queue
-add method calls this by itself, the remove method could works in other way, so you have to call this method from other code after calling remove method
+this method is called when group is inserted, or player / group is removed from BG Queue - there is only one player's status changed, so we don't use while(true) cycles to invite whole queue
+it must be called after fully adding the members of a group to ensure group joining
+should be called after removeplayer functions in some cases
 */
-void BattleGroundQueue::Update(uint32 bgTypeId, uint32 queue_id)
+void BattleGroundQueue::Update(uint32 bgTypeId, uint32 queue_id, uint8 arenatype, bool isRated, uint32 arenaRating)
 {
     if (queue_id >= MAX_BATTLEGROUND_QUEUES)
     {
@@ -183,157 +562,333 @@ void BattleGroundQueue::Update(uint32 bgTypeId, uint32 queue_id)
     }
 
     //if no players in queue ... do nothing
-    if (m_QueuedPlayers[queue_id].Alliance == 0 && m_QueuedPlayers[queue_id].Horde == 0)
+    if (m_QueuedGroups[queue_id].size() == 0)
         return;
 
+    uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bgTypeId, arenatype);
+
     //battleground with free slot for player should be always the last in this queue
-    for (BGFreeSlotQueueType::iterator itr = sBattleGroundMgr.BGFreeSlotQueue[bgTypeId].begin(); itr != sBattleGroundMgr.BGFreeSlotQueue[bgTypeId].end(); ++itr)
+    BGFreeSlotQueueType::iterator itr, next;
+    for (itr = sBattleGroundMgr.BGFreeSlotQueue[bgTypeId].begin(); itr != sBattleGroundMgr.BGFreeSlotQueue[bgTypeId].end(); itr = next)
     {
+        next = itr;
+        ++next;
         // battleground is running, so if:
         // DO NOT allow queue manager to invite new player to running arena
-        if ((*itr)->isBattleGround() && (*itr)->GetQueueType() == queue_id && (*itr)->GetStatus() > STATUS_WAIT_QUEUE && (*itr)->GetStatus() < STATUS_WAIT_LEAVE)
+        if ((*itr)->isBattleGround() && (*itr)->GetTypeID() == bgTypeId && (*itr)->GetQueueType() == queue_id && (*itr)->GetStatus() > STATUS_WAIT_QUEUE && (*itr)->GetStatus() < STATUS_WAIT_LEAVE)
         {
             //we must check both teams
             BattleGround* bg = *itr; //we have to store battleground pointer here, because when battleground is full, it is removed from free queue (not yet implemented!!)
             // and iterator is invalid
 
-            //check if there are some players in queue
-            if (m_QueuedPlayers[queue_id].Alliance > 0 || m_QueuedPlayers[queue_id].Horde > 0)
+            for(QueuedGroupsList::iterator itr = m_QueuedGroups[queue_id].begin(); itr != m_QueuedGroups[queue_id].end(); ++itr)
             {
-                for (PlayerGuidsSortedByTimeQueue::iterator itr2 = m_PlayersSortedByWaitTime[queue_id].begin(); itr2 != m_PlayersSortedByWaitTime[queue_id].end();)
+                // did the group join for this bg type?
+                if((*itr)->BgTypeId != bgTypeId)
+                    continue;
+                // if so, check if fits in
+                if(bg->GetFreeSlotsForTeam((*itr)->Team) >= (*itr)->Players.size())
                 {
-                    Player* plr = objmgr.GetPlayer(*itr2);
-                    if (!plr)
-                    {
-                        //something is wrong!, kick player from queue
-                        sLog.outError("BATTLEGROUND: problem with inviting offline player to Battleground queue .... pls report bug");
-                        uint64 oldval = *itr2;
-                        itr2 = m_PlayersSortedByWaitTime[queue_id].erase(itr2);
-                        RemovePlayer(oldval, true);
-                        continue;
-                    }
-
-                    // player will be invited, if in bg there is a free slot for him
-                    if (bg->HasFreeSlotsForTeam(plr->GetTeam()))
-                    {
-                        // iterator to player's queue status
-                        QueuedPlayersMap::iterator itrPlayerStatus = m_QueuedPlayers[queue_id].find(*itr2);
-
-                        // remove him from time queue
-                        itr2 = m_PlayersSortedByWaitTime[queue_id].erase(itr2);
-
-                        // only check to be sure ... but this condition shouldn't be true (if it is true, then there is a bug somewhere and pls report it)
-                        if (itrPlayerStatus == m_QueuedPlayers[queue_id].end())
-                            continue;
-
-                        // check if player is not already invited
-                        if (!itrPlayerStatus->second.IsInvitedToBGInstanceGUID)
-                        {
-                            itrPlayerStatus->second.IsInvitedToBGInstanceGUID = bg->GetInstanceID();
-                            itrPlayerStatus->second.InviteTime = getMSTime();
-                            itrPlayerStatus->second.LastInviteTime = getMSTime();
-                            if(itrPlayerStatus->second.Team == ALLIANCE)
-                                --m_QueuedPlayers[queue_id].Alliance;
-                            else
-                                --m_QueuedPlayers[queue_id].Horde;
-                            sBattleGroundMgr.InvitePlayer(plr, bg->GetInstanceID());
-
-                            WorldPacket data;
-                            uint32 queueSlot = plr->GetBattleGroundQueueIndex(bgTypeId);
-                            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, plr->GetTeam(), queueSlot, STATUS_WAIT_JOIN, INVITE_ACCEPT_WAIT_TIME, 0);
-                            plr->GetSession()->SendPacket(&data);
-                        }
-                    }
-                    else
-                        ++itr2;
-
-                    //if battleground is FULL, then it is removed from free slot queue - not yet implemented!
-                    if (!bg->HasFreeSlots())
-                    {
-                        //if bg is full, there is no need to invite other players, so break
-                        break;
-                        //remove BG from BGFreeSlotQueue - not used now, in this system we don't remove BGs from free queue
-                        //bg->RemoveFromBGFreeSlotQueue() --- do not uncomment this - not yet implemented
-                    }
+                    // if group fits in, invite it
+                    InviteGroupToBG((*itr),bg,(*itr)->Team);
                 }
             }
+
+            if (!bg->HasFreeSlots())
+            {
+                //remove BG from BGFreeSlotQueue
+                bg->RemoveFromBGFreeSlotQueue();
+            }
         }
     }
 
-    /* THIS IS A CASE THAT IN QUEUE THERE IS ENOUGHT PLAYERS TO START NEW BG */
-    //itr->end is the last BG - template, which is not already started!
+    // finished iterating through the bgs with free slots, maybe we need to create a new bg
 
-    /* here will be a most of change, when we create battlegrounds instantiated */
-    /* if (there is enough players to start new BG)
-        Battleground* newbg = sBattleGroundMgr.CreateNewBattleGround(bgTypeId)
-        - that function will use the COPY constructor on BattleGround class ( in bg manager we should have one battleground as a template
-            (battleground template will be used only to create new BGs, it will be an instance of BG class, but it won't ever start) */
-
-    /* following code is working with current Battleground system and it should be removed, when BGs will work like instances */
-    BattleGround* bg2 = sBattleGroundMgr.GetBattleGround(bgTypeId);
-    if (bg2->GetQueueType() != MAX_BATTLEGROUND_QUEUES || bg2->GetStatus() != STATUS_WAIT_QUEUE)
+    BattleGround * bg_template = sBattleGroundMgr.GetBattleGroundTemplate(bgTypeId);
+    if(!bg_template)
+    {
+        sLog.outError("Battleground: Update: bg template not found for %u", bgTypeId);
         return;
-    if (m_QueuedPlayers[queue_id].Alliance >= bg2->GetMinPlayersPerTeam() && m_QueuedPlayers[queue_id].Horde >= bg2->GetMinPlayersPerTeam())
+    }
+
+    // get the min. players per team, properly for larger arenas as well. (must have full teams for arena matches!)
+    uint32 MinPlayersPerTeam = bg_template->GetMinPlayersPerTeam();
+    uint32 MaxPlayersPerTeam = bg_template->GetMaxPlayersPerTeam();
+    if(bg_template->isArena())
     {
-        bg2->SetStatus(STATUS_WAIT_JOIN);
-        bg2->SetQueueType(queue_id);
+        if(sBattleGroundMgr.isArenaTesting())
+        {
+            MaxPlayersPerTeam = 1;
+            MinPlayersPerTeam = 1;
+        }
+        else
+        {
+            switch(arenatype)
+            {
+            case ARENA_TYPE_2v2:
+                MaxPlayersPerTeam = 2;
+                MinPlayersPerTeam = 2;
+                break;
+            case ARENA_TYPE_3v3:
+                MaxPlayersPerTeam = 3;
+                MinPlayersPerTeam = 3;
+                break;
+            case ARENA_TYPE_5v5:
+                MaxPlayersPerTeam = 5;
+                MinPlayersPerTeam = 5;
+                break;
+            }
+        }
+    }
+
+    // found out the minimum and maximum ratings the newly added team should battle against
+    // arenaRating is the rating of the latest joined team
+    uint32 arenaMinRating = (arenaRating <= sBattleGroundMgr.GetMaxRatingDifference()) ? 0 : arenaRating - sBattleGroundMgr.GetMaxRatingDifference();
+    // if no rating is specified, set maxrating to 0
+    uint32 arenaMaxRating = (arenaRating == 0)? 0 : arenaRating + sBattleGroundMgr.GetMaxRatingDifference();
+    uint32 discardTime = 0;
+    // if max rating difference is set and the time past since server startup is greater than the rating discard time
+    // (after what time the ratings aren't taken into account when making teams) then 
+    // the discard time is current_time - time_to_discard, teams that joined after that, will have their ratings taken into account
+    // else leave the discard time on 0, this way all ratings will be discarded
+    if(sBattleGroundMgr.GetMaxRatingDifference() && getMSTime() >= sBattleGroundMgr.GetRatingDiscardTimer())
+        discardTime = getMSTime() - sBattleGroundMgr.GetRatingDiscardTimer();
+
+    // try to build the selection pools
+    bool bAllyOK = BuildSelectionPool(bgTypeId, queue_id, MinPlayersPerTeam, MaxPlayersPerTeam, NORMAL_ALLIANCE, arenatype, isRated, arenaMinRating, arenaMaxRating, discardTime);
+    if(bAllyOK)
+        sLog.outDebug("Battleground: ally pool succesfully build");
+    else
+        sLog.outDebug("Battleground: ally pool wasn't created");
+    bool bHordeOK = BuildSelectionPool(bgTypeId, queue_id, MinPlayersPerTeam, MaxPlayersPerTeam, NORMAL_HORDE, arenatype, isRated, arenaMinRating, arenaMaxRating, discardTime);
+    if(bHordeOK)
+        sLog.outDebug("Battleground: horde pool succesfully built");
+    else
+        sLog.outDebug("Battleground: horde pool wasn't created");
 
-        for (PlayerGuidsSortedByTimeQueue::iterator itr2 = m_PlayersSortedByWaitTime[queue_id].begin(); itr2 != m_PlayersSortedByWaitTime[queue_id].end();)
+    // if selection pools are ready, create the new bg
+    if (bAllyOK && bHordeOK)
+    {
+        BattleGround * bg2 = 0;
+        // special handling for arenas
+        if(bg_template->isArena())
         {
-            Player* plr = objmgr.GetPlayer(*itr2);
-            if (!plr)
+            // Find a random arena, that can be created
+            uint8 arenas[] = {BATTLEGROUND_NA, BATTLEGROUND_BE, BATTLEGROUND_RL};
+            uint32 arena_num = urand(0,2);
+            if( !(bg2 = sBattleGroundMgr.CreateNewBattleGround(arenas[arena_num%3])) &&
+                !(bg2 = sBattleGroundMgr.CreateNewBattleGround(arenas[(arena_num+1)%3])) &&
+                !(bg2 = sBattleGroundMgr.CreateNewBattleGround(arenas[(arena_num+2)%3])) )
             {
-                //something is wrong!, kick player from queue
-                sLog.outError("BATTLEGROUND: problem with inviting offline player to Battleground queue .... pls report bug");
-                uint64 oldval = *itr2;
-                itr2 = m_PlayersSortedByWaitTime[queue_id].erase(itr2);
-                RemovePlayer(oldval, true);
-                continue;
+                sLog.outError("Battleground: couldn't create arena");
+                return;
             }
 
-            /* TODO: (i'm not sure this code will be useful:
-            here should be some condition like if (bg2->isArena() && bg2->isRated())
+            // set the MaxPlayersPerTeam values based on arenatype
+            // setting the min player values isn't needed, since we won't be using that value later on.
+            if(sBattleGroundMgr.isArenaTesting())
             {
-                invite players from 1 certain group on each faction to play arena match
-            } else if ....and existing code
-            */
-            // player will be invited, if in bg there is a free slot for him
-            if (bg2->HasFreeSlotsForTeam(plr->GetTeam()))
+                bg2->SetMaxPlayersPerTeam(1);
+                bg2->SetMaxPlayers(2);
+            }
+            else
             {
-                // iterator to player's queue status
-                QueuedPlayersMap::iterator itrPlayerStatus = m_QueuedPlayers[queue_id].find(*itr2);
+                switch(arenatype)
+                {
+                case ARENA_TYPE_2v2:
+                    bg2->SetMaxPlayersPerTeam(2);
+                    bg2->SetMaxPlayers(4);
+                    break;
+                case ARENA_TYPE_3v3:
+                    bg2->SetMaxPlayersPerTeam(3);
+                    bg2->SetMaxPlayers(6);
+                    break;
+                case ARENA_TYPE_5v5:
+                    bg2->SetMaxPlayersPerTeam(5);
+                    bg2->SetMaxPlayers(10);
+                    break;
+                default:
+                    break;
+                }
+            }
+        }
+        else
+        {
+            // create new battleground
+            bg2 = sBattleGroundMgr.CreateNewBattleGround(bgTypeId);
+        }
 
-                // remove him from time queue
-                itr2 = m_PlayersSortedByWaitTime[queue_id].erase(itr2);
+        if(!bg2)
+        {
+            sLog.outError("Battleground: couldn't create bg %u",bgTypeId);
+            return;
+        }
 
-                // only check to be sure ... but this condition shouldn't be true (if it is true, then there is a bug somewhere and report it)
-                if (itrPlayerStatus == m_QueuedPlayers[queue_id].end())
-                    continue;
+        // start the joining of the bg
+        bg2->SetStatus(STATUS_WAIT_JOIN);
+        bg2->SetQueueType(queue_id);
+        // initialize arena / rating info
+        bg2->SetArenaType(arenatype);
+        // set rating
+        bg2->SetRated(isRated);
 
-                //check if player is not already invited
-                if (!itrPlayerStatus->second.IsInvitedToBGInstanceGUID)
-                {
-                    itrPlayerStatus->second.IsInvitedToBGInstanceGUID = bg2->GetInstanceID();
-                    itrPlayerStatus->second.InviteTime = getMSTime();
-                    itrPlayerStatus->second.LastInviteTime = getMSTime();
+        std::list<GroupQueueInfo* >::iterator itr;
 
-                    if(itrPlayerStatus->second.Team == ALLIANCE)
-                        --m_QueuedPlayers[queue_id].Alliance;
-                    else
-                        --m_QueuedPlayers[queue_id].Horde;
+        // invite groups from horde selection pool
+        for(itr = m_SelectionPools[NORMAL_HORDE].SelectedGroups.begin(); itr != m_SelectionPools[NORMAL_HORDE].SelectedGroups.end(); ++itr)
+        {
+            InviteGroupToBG((*itr),bg2,HORDE);
+        }
 
-                    sBattleGroundMgr.InvitePlayer(plr, bg2->GetInstanceID());
+        // invite groups from ally selection pools
+        for(itr = m_SelectionPools[NORMAL_ALLIANCE].SelectedGroups.begin(); itr != m_SelectionPools[NORMAL_ALLIANCE].SelectedGroups.end(); ++itr)
+        {
+            InviteGroupToBG((*itr),bg2,ALLIANCE);
+        }
 
-                    WorldPacket data;
-                    uint32 queueSlot = plr->GetBattleGroundQueueIndex(bgTypeId);
-                    sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg2, plr->GetTeam(), queueSlot, STATUS_WAIT_JOIN, INVITE_ACCEPT_WAIT_TIME, 0);
-                    plr->GetSession()->SendPacket(&data);
+        // start the battleground
+        bg2->StartBattleGround();
+    }
+
+    // there weren't enough players for a "normal" match
+    // if arena, enable horde versus horde or alliance versus alliance teams here
+
+    else if(bg_template->isArena())
+    {
+        bool bOneSideHordeTeam1 = false, bOneSideHordeTeam2 = false;
+        bool bOneSideAllyTeam1 = false, bOneSideAllyTeam2 = false;
+        bOneSideHordeTeam1 = BuildSelectionPool(bgTypeId, queue_id,MaxPlayersPerTeam,MaxPlayersPerTeam,ONESIDE_HORDE_TEAM1,arenatype, isRated, arenaMinRating, arenaMaxRating, discardTime);
+        if(bOneSideHordeTeam1)
+        {
+            // one team has been selected, find out if other can be selected too
+            std::list<GroupQueueInfo* >::iterator itr;
+            // temporarily change the team side to enable building the next pool excluding the already selected groups
+            for(itr = m_SelectionPools[ONESIDE_HORDE_TEAM1].SelectedGroups.begin(); itr != m_SelectionPools[ONESIDE_HORDE_TEAM1].SelectedGroups.end(); ++itr)
+                (*itr)->Team=ALLIANCE;
+
+            bOneSideHordeTeam2 = BuildSelectionPool(bgTypeId, queue_id,MaxPlayersPerTeam,MaxPlayersPerTeam,ONESIDE_HORDE_TEAM2,arenatype, isRated, arenaMinRating, arenaMaxRating, discardTime, (*(m_SelectionPools[ONESIDE_HORDE_TEAM1].SelectedGroups.begin()))->ArenaTeamId);
+
+            // change back the team to horde
+            for(itr = m_SelectionPools[ONESIDE_HORDE_TEAM1].SelectedGroups.begin(); itr != m_SelectionPools[ONESIDE_HORDE_TEAM1].SelectedGroups.end(); ++itr)
+                (*itr)->Team=HORDE;
+
+            if(!bOneSideHordeTeam2)
+                bOneSideHordeTeam1 = false;
+        }
+        if(!bOneSideHordeTeam1)
+        {
+            // check for one sided ally
+            bOneSideAllyTeam1 = BuildSelectionPool(bgTypeId, queue_id,MaxPlayersPerTeam,MaxPlayersPerTeam,ONESIDE_ALLIANCE_TEAM1,arenatype, isRated, arenaMinRating, arenaMaxRating, discardTime);
+            if(bOneSideAllyTeam1)
+            {
+                // one team has been selected, find out if other can be selected too
+                std::list<GroupQueueInfo* >::iterator itr;
+                // temporarily change the team side to enable building the next pool excluding the already selected groups
+                for(itr = m_SelectionPools[ONESIDE_ALLIANCE_TEAM1].SelectedGroups.begin(); itr != m_SelectionPools[ONESIDE_ALLIANCE_TEAM1].SelectedGroups.end(); ++itr)
+                    (*itr)->Team=HORDE;
+
+                bOneSideAllyTeam2 = BuildSelectionPool(bgTypeId, queue_id,MaxPlayersPerTeam,MaxPlayersPerTeam,ONESIDE_ALLIANCE_TEAM2,arenatype, isRated, arenaMinRating, arenaMaxRating, discardTime,(*(m_SelectionPools[ONESIDE_ALLIANCE_TEAM1].SelectedGroups.begin()))->ArenaTeamId);
+
+                // change back the team to ally
+                for(itr = m_SelectionPools[ONESIDE_ALLIANCE_TEAM1].SelectedGroups.begin(); itr != m_SelectionPools[ONESIDE_ALLIANCE_TEAM1].SelectedGroups.end(); ++itr)
+                    (*itr)->Team=ALLIANCE;
+            }
+
+            if(!bOneSideAllyTeam2)
+                bOneSideAllyTeam1 = false;
+        }
+        // 1-sided BuildSelectionPool() will work, because the MinPlayersPerTeam == MaxPlayersPerTeam in every arena!!!!
+        if( (bOneSideHordeTeam1 && bOneSideHordeTeam2) ||
+            (bOneSideAllyTeam1 && bOneSideAllyTeam2) )
+        {
+            // which side has enough players?
+            uint32 side = 0;
+            SelectionPoolBuildMode mode1, mode2;
+            // find out what pools are we using
+            if(bOneSideAllyTeam1 && bOneSideAllyTeam2)
+            {
+                side = ALLIANCE;
+                mode1 = ONESIDE_ALLIANCE_TEAM1;
+                mode2 = ONESIDE_ALLIANCE_TEAM2;
+            }
+            else
+            {
+                side = HORDE;
+                mode1 = ONESIDE_HORDE_TEAM1;
+                mode2 = ONESIDE_HORDE_TEAM2;
+            }
+
+            // create random arena
+            uint8 arenas[] = {BATTLEGROUND_NA, BATTLEGROUND_BE, BATTLEGROUND_RL};
+            uint32 arena_num = urand(0,2);
+            BattleGround* bg2 = NULL;
+            if( !(bg2 = sBattleGroundMgr.CreateNewBattleGround(arenas[arena_num%3])) &&
+                !(bg2 = sBattleGroundMgr.CreateNewBattleGround(arenas[(arena_num+1)%3])) &&
+                !(bg2 = sBattleGroundMgr.CreateNewBattleGround(arenas[(arena_num+2)%3])) )
+            {
+                sLog.outError("Could not create arena.");
+                return;
+            }
+
+            sLog.outDebug("Battleground: One-faction arena created.");
+            // init stats
+            if(sBattleGroundMgr.isArenaTesting())
+            {
+                bg2->SetMaxPlayersPerTeam(1);
+                bg2->SetMaxPlayers(2);
+            }
+            else
+            {
+                switch(arenatype)
+                {
+                case ARENA_TYPE_2v2:
+                    bg2->SetMaxPlayersPerTeam(2);
+                    bg2->SetMaxPlayers(4);
+                    break;
+                case ARENA_TYPE_3v3:
+                    bg2->SetMaxPlayersPerTeam(3);
+                    bg2->SetMaxPlayers(6);
+                    break;
+                case ARENA_TYPE_5v5:
+                    bg2->SetMaxPlayersPerTeam(5);
+                    bg2->SetMaxPlayers(10);
+                    break;
+                default:
+                    break;
                 }
             }
+
+            bg2->SetRated(isRated);
+
+            // assigned team of the other group
+            uint32 other_side;
+            if(side == ALLIANCE)
+                other_side = HORDE;
             else
-                ++itr2;
+                other_side = ALLIANCE;
+
+            // start the joining of the bg
+            bg2->SetStatus(STATUS_WAIT_JOIN);
+            bg2->SetQueueType(queue_id);
+            // initialize arena / rating info
+            bg2->SetArenaType(arenatype);
+
+            std::list<GroupQueueInfo* >::iterator itr;
+
+            // invite players from the first group as horde players (actually green team)
+            for(itr = m_SelectionPools[mode1].SelectedGroups.begin(); itr != m_SelectionPools[mode1].SelectedGroups.end(); ++itr)
+            {
+                InviteGroupToBG((*itr),bg2,HORDE);
+            }
+
+            // invite players from the second group as ally players (actually gold team)
+            for(itr = m_SelectionPools[mode2].SelectedGroups.begin(); itr != m_SelectionPools[mode2].SelectedGroups.end(); ++itr)
+            {
+                InviteGroupToBG((*itr),bg2,ALLIANCE);
+            }
+
+            bg2->StartBattleGround();
         }
-        bg2->StartBattleGround();
     }
 }
 
@@ -361,14 +916,19 @@ bool BGQueueInviteEvent::Execute(uint64 /*e_time*/, uint32 /*p_time*/)
     uint32 queueSlot = plr->GetBattleGroundQueueIndex(bg->GetTypeID());
     if (queueSlot < PLAYER_MAX_BATTLEGROUND_QUEUES)         // player is in queue
     {
-        // check if player is invited to this bg ... this check must be here, because when player leaves queue and joins another, it would cause a problems
-        BattleGroundQueue::QueuedPlayersMap const& qpMap = sBattleGroundMgr.m_BattleGroundQueues[bg->GetTypeID()].m_QueuedPlayers[plr->GetBattleGroundQueueIdFromLevel()];
-        BattleGroundQueue::QueuedPlayersMap::const_iterator qItr = qpMap.find(m_PlayerGuid);
-        if (qItr != qpMap.end() && qItr->second.IsInvitedToBGInstanceGUID == m_BgInstanceGUID)
+        uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bg->GetTypeID(), bg->GetArenaType());
+        uint32 queueSlot = plr->GetBattleGroundQueueIndex(bgQueueTypeId);
+        if (queueSlot < PLAYER_MAX_BATTLEGROUND_QUEUES) // player is in queue
         {
-            WorldPacket data;
-            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, plr->GetTeam(), queueSlot, STATUS_WAIT_JOIN, INVITE_ACCEPT_WAIT_TIME/2, 0);
-            plr->GetSession()->SendPacket(&data);
+            // check if player is invited to this bg ... this check must be here, because when player leaves queue and joins another, it would cause a problems
+            BattleGroundQueue::QueuedPlayersMap const& qpMap = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].m_QueuedPlayers[plr->GetBattleGroundQueueIdFromLevel()];
+            BattleGroundQueue::QueuedPlayersMap::const_iterator qItr = qpMap.find(m_PlayerGuid);
+            if (qItr != qpMap.end() && qItr->second.GroupInfo->IsInvitedToBGInstanceGUID == m_BgInstanceGUID)
+            {
+                WorldPacket data;
+                sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, qItr->second.GroupInfo->Team, queueSlot, STATUS_WAIT_JOIN, INVITE_ACCEPT_WAIT_TIME/2, 0);
+                plr->GetSession()->SendPacket(&data);
+            }
         }
     }
     return true;                                            //event will be deleted
@@ -396,23 +956,26 @@ bool BGQueueRemoveEvent::Execute(uint64 /*e_time*/, uint32 /*p_time*/)
     if (!bg)
         return true;
 
-    uint32 queueSlot = plr->GetBattleGroundQueueIndex(bg->GetTypeID());
-    if (queueSlot < PLAYER_MAX_BATTLEGROUND_QUEUES)         // player is in queue (base at player data
+    sLog.outDebug("Battleground: removing player %u from bg queue for instance %u because of not pressing enter battle in time.",plr->GetGUIDLow(),m_BgInstanceGUID);
+
+    uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bg->GetTypeID(), bg->GetArenaType());
+    uint32 queueSlot = plr->GetBattleGroundQueueIndex(bgQueueTypeId);
+    if (queueSlot < PLAYER_MAX_BATTLEGROUND_QUEUES) // player is in queue
     {
         // check if player is invited to this bg ... this check must be here, because when player leaves queue and joins another, it would cause a problems
-        BattleGroundQueue::QueuedPlayersMap const& qpMap = sBattleGroundMgr.m_BattleGroundQueues[bg->GetTypeID()].m_QueuedPlayers[plr->GetBattleGroundQueueIdFromLevel()];
-        BattleGroundQueue::QueuedPlayersMap::const_iterator qItr = qpMap.find(m_PlayerGuid);
-        if (qItr!=qpMap.end() && qItr->second.IsInvitedToBGInstanceGUID == m_BgInstanceGUID)
+        BattleGroundQueue::QueuedPlayersMap::iterator qMapItr = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].m_QueuedPlayers[plr->GetBattleGroundQueueIdFromLevel()].find(m_PlayerGuid);
+        if (qMapItr != sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].m_QueuedPlayers[plr->GetBattleGroundQueueIdFromLevel()].end() && qMapItr->second.GroupInfo && qMapItr->second.GroupInfo->IsInvitedToBGInstanceGUID == m_BgInstanceGUID)
         {
-            plr->RemoveBattleGroundQueueId(bg->GetTypeID());
-            sBattleGroundMgr.m_BattleGroundQueues[bg->GetTypeID()].RemovePlayer(m_PlayerGuid, true);
-            sBattleGroundMgr.m_BattleGroundQueues[bg->GetTypeID()].Update(bg->GetTypeID(), bg->GetQueueType());
-
+            plr->RemoveBattleGroundQueueId(bgQueueTypeId);
+            sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].RemovePlayer(m_PlayerGuid, true);
+            sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].Update(bgQueueTypeId, bg->GetQueueType());
             WorldPacket data;
-            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, plr->GetTeam(), queueSlot, STATUS_NONE, 0, 0);
+            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, m_PlayersTeam, queueSlot, STATUS_NONE, 0, 0);
             plr->GetSession()->SendPacket(&data);
         }
     }
+    else
+        sLog.outDebug("Battleground: Player was already removed from queue");
 
     //event will be deleted
     return true;
@@ -431,22 +994,80 @@ void BGQueueRemoveEvent::Abort(uint64 /*e_time*/)
 BattleGroundMgr::BattleGroundMgr()
 {
     m_BattleGrounds.clear();
+    m_AutoDistributePoints = (bool)sWorld.getConfig(CONFIG_ARENA_AUTO_DISTRIBUTE_POINTS);
+    m_MaxRatingDifference = sWorld.getConfig(CONFIG_ARENA_MAX_RATING_DIFFERENCE);
+    m_RatingDiscardTimer = sWorld.getConfig(CONFIG_ARENA_RATING_DISCARD_TIMER);
+    m_PrematureFinishTimer = sWorld.getConfig(CONFIG_BATTLEGROUND_PREMATURE_FINISH_TIMER);
+    m_NextRatingDiscardUpdate = m_RatingDiscardTimer;
+    m_AutoDistributionTimeChecker = 0;
+    m_ArenaTesting = false;
 }
 
 BattleGroundMgr::~BattleGroundMgr()
 {
-    for(std::map<uint32, BattleGround*>::iterator itr = m_BattleGrounds.begin(); itr != m_BattleGrounds.end(); ++itr)
-        delete itr->second;
+    BattleGroundSet::iterator itr, next;
+    for(itr = m_BattleGrounds.begin(); itr != m_BattleGrounds.end(); itr = next)
+    {
+        next = itr;
+        ++next;
+        BattleGround * bg = itr->second;
+        m_BattleGrounds.erase(itr);
+        delete bg;
+    }
     m_BattleGrounds.clear();
 }
 
+// used to update running battlegrounds, and delete finished ones
 void BattleGroundMgr::Update(time_t diff)
 {
-    for(BattleGroundSet::iterator itr = m_BattleGrounds.begin(); itr != m_BattleGrounds.end(); ++itr)
+    BattleGroundSet::iterator itr, next;
+    for(itr = m_BattleGrounds.begin(); itr != m_BattleGrounds.end(); itr = next)
+    {
+        next = itr;
+        ++next;
         itr->second->Update(diff);
+        // use the SetDeleteThis variable
+        // direct deletion caused crashes
+        if(itr->second->m_SetDeleteThis)
+        {
+            BattleGround * bg = itr->second;
+            m_BattleGrounds.erase(itr);
+            delete bg;
+        }
+    }
+    // if rating difference counts, maybe force-update queues
+    if(m_MaxRatingDifference)
+    {
+        // it's time to force update
+        if(m_NextRatingDiscardUpdate < diff)
+        {
+            // forced update for level 70 rated arenas
+            m_BattleGroundQueues[BATTLEGROUND_QUEUE_2v2].Update(BATTLEGROUND_AA,6,ARENA_TYPE_2v2,true,0);
+            m_BattleGroundQueues[BATTLEGROUND_QUEUE_3v3].Update(BATTLEGROUND_AA,6,ARENA_TYPE_3v3,true,0);
+            m_BattleGroundQueues[BATTLEGROUND_QUEUE_5v5].Update(BATTLEGROUND_AA,6,ARENA_TYPE_5v5,true,0);
+            m_NextRatingDiscardUpdate = m_RatingDiscardTimer;
+        } 
+        else 
+            m_NextRatingDiscardUpdate -= diff;
+    }
+    if(m_AutoDistributePoints)
+    {
+        if(m_AutoDistributionTimeChecker < diff)
+        {
+            if(time(NULL) > m_NextAutoDistributionTime)
+            {
+                DistributeArenaPoints();
+                m_NextAutoDistributionTime = time(NULL) + BATTLEGROUND_ARENA_POINT_DISTRIBUTION_DAY * sWorld.getConfig(CONFIG_ARENA_AUTO_DISTRIBUTE_INTERVAL_DAYS);
+                CharacterDatabase.PExecute("UPDATE saved_variables SET NextArenaPointDistributionTime = FROM_UNIXTIME('"I64FMTD"')",(uint64)m_NextAutoDistributionTime);
+            }
+            m_AutoDistributionTimeChecker = 600000; // check 10 minutes
+        }
+        else
+            m_AutoDistributionTimeChecker -= diff;
+    }
 }
 
-void BattleGroundMgr::BuildBattleGroundStatusPacket(WorldPacket *data, BattleGround *bg, uint32 team, uint8 QueueSlot, uint8 StatusID, uint32 Time1, uint32 Time2)
+void BattleGroundMgr::BuildBattleGroundStatusPacket(WorldPacket *data, BattleGround *bg, uint32 team, uint8 QueueSlot, uint8 StatusID, uint32 Time1, uint32 Time2, uint32 arenatype, uint8 israted)
 {
     // we can be in 3 queues in same time...
     if(StatusID == 0)
@@ -460,10 +1081,55 @@ void BattleGroundMgr::BuildBattleGroundStatusPacket(WorldPacket *data, BattleGro
     data->Initialize(SMSG_BATTLEFIELD_STATUS, (4+1+1+4+2+4+1+4+4+4));
     *data << uint32(QueueSlot);                             // queue id (0...2) - player can be in 3 queues in time
     // uint64 in client
-    *data << uint64( uint64(bg->GetArenaType()) | (uint64(0x0D) << 8) | (uint64(bg->GetTypeID()) << 16) | (uint64(0x1F90) << 48) );
+    *data << uint64( uint64(arenatype ? arenatype : bg->GetArenaType()) | (uint64(0x0D) << 8) | (uint64(bg->GetTypeID()) << 16) | (uint64(0x1F90) << 48) );
     *data << uint32(0);                                     // unknown
     // alliance/horde for BG and skirmish/rated for Arenas
-    *data << uint8(bg->isArena() ? (bg->isRated() ? 1 : 0) : bg->GetTeamIndexByTeamId(team));
+    *data << uint8(bg->isArena() ? ( israted ? israted : bg->isRated() ) : bg->GetTeamIndexByTeamId(team));
+/*    *data << uint8(arenatype ? arenatype : bg->GetArenaType());                     // team type (0=BG, 2=2x2, 3=3x3, 5=5x5), for arenas    // NOT PROPER VALUE IF ARENA ISN'T RUNNING YET!!!!
+    switch(bg->GetTypeID())                                 // value depends on bg id
+    {
+        case BATTLEGROUND_AV:
+            *data << uint8(1);
+            break;
+        case BATTLEGROUND_WS:
+            *data << uint8(2);
+            break;
+        case BATTLEGROUND_AB:
+            *data << uint8(3);
+            break;
+        case BATTLEGROUND_NA:
+            *data << uint8(4);
+            break;
+        case BATTLEGROUND_BE:
+            *data << uint8(5);
+            break;
+        case BATTLEGROUND_AA:
+            *data << uint8(6);
+            break;
+        case BATTLEGROUND_EY:
+            *data << uint8(7);
+            break;
+        case BATTLEGROUND_RL:
+            *data << uint8(8);
+            break;
+        default:                                            // unknown
+            *data << uint8(0);
+            break;
+    }
+
+    if(bg->isArena() && (StatusID == STATUS_WAIT_QUEUE))
+        *data << uint32(BATTLEGROUND_AA);                   // all arenas   I don't think so.
+    else
+    *data << uint32(bg->GetTypeID());                   // BG id from DBC
+
+    *data << uint16(0x1F90);                                // unk value 8080
+    *data << uint32(bg->GetInstanceID());                   // instance id
+
+    if(bg->isBattleGround())
+        *data << uint8(bg->GetTeamIndexByTeamId(team));     // team
+    else
+        *data << uint8(israted?israted:bg->isRated());                      // is rated battle
+*/
     *data << uint32(StatusID);                              // status
     switch(StatusID)
     {
@@ -493,13 +1159,24 @@ void BattleGroundMgr::BuildPvpLogDataPacket(WorldPacket *data, BattleGround *bg)
                                                             // last check on 2.4.1
     data->Initialize(MSG_PVP_LOG_DATA, (1+1+4+40*bg->GetPlayerScoresSize()));
     *data << uint8(type);                                   // seems to be type (battleground=0/arena=1)
+
     if(type)                                                // arena
     {
-        for(uint8 i = 0; i < 2; i++)
+        // it seems this must be according to BG_WINNER_A/H and _NOT_ BG_TEAM_A/H
+        for(int i = 1; i >= 0; --i)
         {
-            *data << uint32(3000+1+i);                      // rating change: showed value - 3000
-            *data << uint32(0);                             // 2.4.0, has some to do with rating change...
-            *data << uint8(0);                              // some unknown string
+            *data << uint32(3000-bg->m_ArenaTeamRatingChanges[i]);                      // rating change: showed value - 3000
+            *data << uint32(3999);  // huge thanks for TOM_RUS for this!
+            sLog.outDebug("rating change: %d", bg->m_ArenaTeamRatingChanges[i]);
+        }
+        for(int i = 1; i >= 0; --i)
+        {
+            uint32 at_id = bg->m_ArenaTeamIds[i];
+            ArenaTeam * at = objmgr.GetArenaTeamById(at_id);
+            if(at)
+                *data << at->GetName();
+            else//*/
+                *data << (uint8)0;
         }
     }
 
@@ -519,32 +1196,35 @@ void BattleGroundMgr::BuildPvpLogDataPacket(WorldPacket *data, BattleGround *bg)
     {
         *data << (uint64)itr->first;
         *data << (int32)itr->second->KillingBlows;
-        if(type)
+        Player *plr = objmgr.GetPlayer(itr->first);
+        uint32 team = bg->GetPlayerTeam(itr->first);
+        if(!team && plr) team = plr->GetTeam();
+        if(type == 0)
+        {
+            *data << (int32)itr->second->HonorableKills;
+            *data << (int32)itr->second->Deaths;
+            *data << (int32)(itr->second->BonusHonor);
+        }
+        else
         {
-            // this value is team (green/gold)?
             // that part probably wrong
-            Player *plr = objmgr.GetPlayer(itr->first);
             if(plr)
             {
-                if(plr->GetTeam() == HORDE)
+                if(team == HORDE)
                     *data << uint8(0);
-                else if(plr->GetTeam() == ALLIANCE)
+                else if(team == ALLIANCE)
+                {
                     *data << uint8(1);
+                }
                 else
                     *data << uint8(0);
             }
             else
                 *data << uint8(0);
         }
-        else
-        {
-            *data << (int32)itr->second->HonorableKills;
-            *data << (int32)itr->second->Deaths;
-            *data << (int32)itr->second->BonusHonor;        // bonus honor
-        }
-        *data << (int32)itr->second->DamageDone;            // damage done
-        *data << (int32)itr->second->HealingDone;           // healing done
-        switch(bg->GetTypeID())                             // battleground specific things
+        *data << (int32)itr->second->DamageDone;             // damage done
+        *data << (int32)itr->second->HealingDone;            // healing done
+        switch(bg->GetTypeID())                              // battleground specific things
         {
             case BATTLEGROUND_AV:
                 *data << (uint32)0x00000005;                // count of next fields
@@ -622,23 +1302,120 @@ void BattleGroundMgr::BuildPlayerJoinedBattleGroundPacket(WorldPacket *data, Pla
     *data << uint64(plr->GetGUID());
 }
 
-void BattleGroundMgr::InvitePlayer(Player* plr, uint32 bgInstanceGUID)
+void BattleGroundMgr::InvitePlayer(Player* plr, uint32 bgInstanceGUID, uint32 team)
 {
     // set invited player counters:
     BattleGround* bg = GetBattleGround(bgInstanceGUID);
     if(!bg)
         return;
+    bg->IncreaseInvitedCount(team);
+    
+    plr->SetInviteForBattleGroundQueueType(BGQueueTypeId(bg->GetTypeID(),bg->GetArenaType()), bgInstanceGUID);
+
+    // set the arena teams for rated matches
+    if(bg->isArena() && bg->isRated())
+    {
+        switch(bg->GetArenaType())
+        {
+        case ARENA_TYPE_2v2:
+            bg->SetArenaTeamIdForTeam(team, plr->GetArenaTeamId(0));
+            break;
+        case ARENA_TYPE_3v3:
+            bg->SetArenaTeamIdForTeam(team, plr->GetArenaTeamId(1));
+            break;
+        case ARENA_TYPE_5v5:
+            bg->SetArenaTeamIdForTeam(team, plr->GetArenaTeamId(2));
+            break;
+        default:
+            break;
+        }
+    }
 
-    bg->IncreaseInvitedCount(plr->GetTeam());
-    plr->SetInviteForBattleGroundType(bg->GetTypeID());
     // create invite events:
     //add events to player's counters ---- this is not good way - there should be something like global event processor, where we should add those events
     BGQueueInviteEvent* inviteEvent = new BGQueueInviteEvent(plr->GetGUID(), bgInstanceGUID);
     plr->m_Events.AddEvent(inviteEvent, plr->m_Events.CalculateTime(INVITE_ACCEPT_WAIT_TIME/2));
-    BGQueueRemoveEvent* removeEvent = new BGQueueRemoveEvent(plr->GetGUID(), bgInstanceGUID, plr->GetTeam());
+    BGQueueRemoveEvent* removeEvent = new BGQueueRemoveEvent(plr->GetGUID(), bgInstanceGUID, team);
     plr->m_Events.AddEvent(removeEvent, plr->m_Events.CalculateTime(INVITE_ACCEPT_WAIT_TIME));
 }
 
+BattleGround * BattleGroundMgr::GetBattleGroundTemplate(uint32 bgTypeId)
+{
+    return BGFreeSlotQueue[bgTypeId].empty() ? NULL : BGFreeSlotQueue[bgTypeId].back();
+}
+
+// create a new battleground that will really be used to play
+BattleGround * BattleGroundMgr::CreateNewBattleGround(uint32 bgTypeId)
+{
+    BattleGround *bg = NULL;
+
+    // get the template BG
+    BattleGround *bg_template = GetBattleGroundTemplate(bgTypeId);
+
+    if(!bg_template)
+    {
+        sLog.outError("BattleGround: CreateNewBattleGround - bg template not found for %u", bgTypeId);
+        return 0;
+    }
+    
+    // create a copy of the BG template
+    switch(bgTypeId)
+    {
+        case BATTLEGROUND_AV: 
+            bg = new BattleGroundAV(*(BattleGroundAV*)bg_template); 
+            break;
+        case BATTLEGROUND_WS: 
+            bg = new BattleGroundWS(*(BattleGroundWS*)bg_template); 
+            break;
+        case BATTLEGROUND_AB: 
+            bg = new BattleGroundAB(*(BattleGroundAB*)bg_template); 
+            break;
+        case BATTLEGROUND_NA: 
+            bg = new BattleGroundNA(*(BattleGroundNA*)bg_template); 
+            break;
+        case BATTLEGROUND_BE: 
+            bg = new BattleGroundBE(*(BattleGroundBE*)bg_template); 
+            break;
+        case BATTLEGROUND_AA: 
+            bg = new BattleGroundAA(*(BattleGroundAA*)bg_template); 
+            break;
+        case BATTLEGROUND_EY: 
+            bg = new BattleGroundEY(*(BattleGroundEY*)bg_template); 
+            break;
+        case BATTLEGROUND_RL: 
+            bg = new BattleGroundRL(*(BattleGroundRL*)bg_template); 
+            break;
+        default:
+            //bg = new BattleGround;   
+            return 0;
+            break;             // placeholder for non implemented BG
+    }
+
+    // generate a new instance id
+    bg->SetInstanceID(MapManager::Instance().GenerateInstanceId()); // set instance id
+
+    // reset the new bg (set status to status_wait_queue from status_none)
+    bg->Reset();
+
+    /*   will be setup in BG::Update() when the first player is ported in
+    if(!(bg->SetupBattleGround()))
+    {
+        sLog.outError("BattleGround: CreateNewBattleGround: SetupBattleGround failed for bg %u", bgTypeId);
+        delete bg;
+        return 0;
+    }
+    */
+
+    // add BG to free slot queue
+    bg->AddToBGFreeSlotQueue();
+
+    // add bg to update list
+    AddBattleGround(bg->GetInstanceID(), bg);
+
+    return bg;
+}
+
+// used to create the BG templates
 uint32 BattleGroundMgr::CreateBattleGround(uint32 bgTypeId, uint32 MinPlayersPerTeam, uint32 MaxPlayersPerTeam, uint32 LevelMin, uint32 LevelMax, char* BattleGroundName, uint32 MapID, float Team1StartLocX, float Team1StartLocY, float Team1StartLocZ, float Team1StartLocO, float Team2StartLocX, float Team2StartLocY, float Team2StartLocZ, float Team2StartLocO)
 {
     // Create the BG
@@ -658,12 +1435,8 @@ uint32 BattleGroundMgr::CreateBattleGround(uint32 bgTypeId, uint32 MinPlayersPer
     }
 
     bg->SetMapId(MapID);
+
     bg->Reset();
-    if(!bg->SetupBattleGround())
-    {
-        delete bg;
-        return 0;
-    }
 
     BattlemasterListEntry const *bl = sBattlemasterListStore.LookupEntry(bgTypeId);
     //in previous method is checked if exists entry in sBattlemasterListStore, so no check needed
@@ -673,7 +1446,7 @@ uint32 BattleGroundMgr::CreateBattleGround(uint32 bgTypeId, uint32 MinPlayersPer
     }
 
     bg->SetTypeID(bgTypeId);
-    bg->SetInstanceID(bgTypeId);                            // temporary
+    bg->SetInstanceID(0);                               // template bg, instance id is 0
     bg->SetMinPlayersPerTeam(MinPlayersPerTeam);
     bg->SetMaxPlayersPerTeam(MaxPlayersPerTeam);
     bg->SetMinPlayers(MinPlayersPerTeam*2);
@@ -682,12 +1455,14 @@ uint32 BattleGroundMgr::CreateBattleGround(uint32 bgTypeId, uint32 MinPlayersPer
     bg->SetTeamStartLoc(ALLIANCE, Team1StartLocX, Team1StartLocY, Team1StartLocZ, Team1StartLocO);
     bg->SetTeamStartLoc(HORDE,    Team2StartLocX, Team2StartLocY, Team2StartLocZ, Team2StartLocO);
     bg->SetLevelRange(LevelMin, LevelMax);
-    //add BaggleGround instance to FreeSlotQueue
+
+    //add BattleGround instance to FreeSlotQueue (.back() will return the template!)
     bg->AddToBGFreeSlotQueue();
 
-    AddBattleGround(bg->GetInstanceID(), bg);
-    //sLog.outDetail("BattleGroundMgr: Created new battleground: %u %s (Map %u, %u players per team, Levels %u-%u)", bg_TypeID, bg->m_Name, bg->m_MapId, bg->m_MaxPlayersPerTeam, bg->m_LevelMin, bg->m_LevelMax);
-    return bg->GetInstanceID();
+    // do NOT add to update list, since this is a template battleground!
+
+    // return some not-null value, bgTypeId is good enough for me
+    return bgTypeId; 
 }
 
 void BattleGroundMgr::CreateInitialBattleGrounds()
@@ -807,6 +1582,90 @@ void BattleGroundMgr::CreateInitialBattleGrounds()
     sLog.outString( ">> Loaded %u battlegrounds", count );
 }
 
+void BattleGroundMgr::InitAutomaticArenaPointDistribution()
+{
+    if(m_AutoDistributePoints)
+    {
+        sLog.outDebug("Initializing Automatic Arena Point Distribution");
+        QueryResult * result = CharacterDatabase.Query("SELECT UNIX_TIMESTAMP(NextArenaPointDistributionTime) FROM saved_variables");
+        if(!result)
+        {
+            sLog.outDebug("Battleground: Next arena point distribution time not found in SavedVariables, reseting it now."); 
+            m_NextAutoDistributionTime = time(NULL) + BATTLEGROUND_ARENA_POINT_DISTRIBUTION_DAY * sWorld.getConfig(CONFIG_ARENA_AUTO_DISTRIBUTE_INTERVAL_DAYS);
+            CharacterDatabase.PExecute("INSERT INTO saved_variables (NextArenaPointDistributionTime) VALUES ( FROM_UNIXTIME('"I64FMTD"') )",(uint64)m_NextAutoDistributionTime);
+        }
+        else
+        {
+            m_NextAutoDistributionTime = (*result)[0].GetUInt64();
+            delete result;
+        }
+        sLog.outDebug("Automatic Arena Point Distribution initialized.");
+    }
+}
+
+void BattleGroundMgr::DistributeArenaPoints()
+{
+    // used to distribute arena points based on last week's stats
+    sWorld.SendGlobalText("Flushing Arena points based on team ratings, this may take a few minutes. Please stand by...", NULL);
+
+    sWorld.SendGlobalText("Distributing arena points to players...", NULL);
+
+    CharacterDatabase.BeginTransaction();
+    // direct execute, because of the later GetUInt32ValueFromDB() calls
+                                                                                                                                        // 1                                                                                               2                                                          3                                                 4                                                                                                                                      5                                                                              6                                                         7                                                 8                                                                                                                                  9                                                                                    10                                                 1                           2                              3                        4                                        5                                      6                        7                              8                       9                                             10
+    CharacterDatabase.DirectPExecute("UPDATE characters b, arena_team_member a SET b.data = CONCAT( SUBSTRING_INDEX(b.data, ' ', '%u'),' ', CAST( IF ( ((CAST( SUBSTRING( b.data FROM (CHAR_LENGTH(SUBSTRING_INDEX(b.data,' ','%u')) + 2) FOR (CHAR_LENGTH(SUBSTRING_INDEX(b.data,' ','%u')) - CHAR_LENGTH(SUBSTRING_INDEX(b.data,' ','%u')) - 1) ) AS UNSIGNED) + (SELECT MAX(c.points_to_add) FROM arena_team_member c WHERE c.guid = b.guid GROUP BY c.guid) ) < '%u'), CAST(SUBSTRING(b.data FROM (CHAR_LENGTH(SUBSTRING_INDEX(b.data,' ','%u')) + 2) FOR (CHAR_LENGTH(SUBSTRING_INDEX(b.data,' ','%u')) - CHAR_LENGTH(SUBSTRING_INDEX(b.data,' ','%u')) - 1) ) AS UNSIGNED) + (SELECT MAX(d.points_to_add) FROM arena_team_member d WHERE d.guid = b.guid GROUP BY d.guid), '%u') AS CHAR),' ',SUBSTRING(b.data FROM (CHAR_LENGTH(SUBSTRING_INDEX(b.data,' ','%u')) + 2))) WHERE b.guid = a.guid",PLAYER_FIELD_ARENA_CURRENCY, PLAYER_FIELD_ARENA_CURRENCY, PLAYER_FIELD_ARENA_CURRENCY+1, PLAYER_FIELD_ARENA_CURRENCY, sWorld.getConfig(CONFIG_MAX_ARENA_POINTS),PLAYER_FIELD_ARENA_CURRENCY, PLAYER_FIELD_ARENA_CURRENCY+1, PLAYER_FIELD_ARENA_CURRENCY, sWorld.getConfig(CONFIG_MAX_ARENA_POINTS), PLAYER_FIELD_ARENA_CURRENCY+1);
+    for(int i=0; i<3; ++i)
+    {
+        // reset weekly played matches
+        uint32 position = PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 6 * i + 2;
+        CharacterDatabase.DirectPExecute("UPDATE characters SET data = CONCAT( SUBSTRING_INDEX(data,' ','%u'),' ','0',' ',SUBSTRING(data FROM (CHAR_LENGTH(SUBSTRING_INDEX(data,' ','%u')) + 2)))",position, position + 1);
+    }
+    CharacterDatabase.DirectExecute("UPDATE arena_team_member SET points_to_add = '0', played_week = '0', wons_week = '0'");
+    CharacterDatabase.DirectExecute("UPDATE arena_team_stats SET games = '0', wins = '0'");
+    CharacterDatabase.CommitTransaction();
+
+    sWorld.SendGlobalText("Finished distributing arena points to players. Now set the new points in online players' data blob, this will send them update packets as well...", NULL);
+
+    QueryResult *result = CharacterDatabase.PQuery("SELECT guid, data FROM characters WHERE online = '1'");
+    if( result )
+    {
+        do
+        {
+            Field *fields = result->Fetch();
+
+            uint32 guid = fields[0].GetUInt32();
+            if(Player * pl = objmgr.GetPlayer(MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER)))
+            {
+                Tokens data = StrSplit(fields[1].GetCppString(), " ");
+                // update arena currency
+                pl->SetUInt32Value(PLAYER_FIELD_ARENA_CURRENCY, Player::GetUInt32ValueFromArray(data, PLAYER_FIELD_ARENA_CURRENCY));
+                // reset played this week count for all teams
+                for(int i= 0; i < 3; ++i)
+                    pl->SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 6 * i + 2, 0);
+            }
+
+        } while (result->NextRow());
+
+        delete result;
+    }
+
+    sWorld.SendGlobalText("Finished setting arena points for online players.", NULL);
+
+    sWorld.SendGlobalText("Modifying played count, arena points etc. for loaded arena teams, sending updated stats to online players...", NULL);
+    for(ObjectMgr::ArenaTeamSet::iterator titr = objmgr.GetArenaTeamSetBegin(); titr != objmgr.GetArenaTeamSetEnd(); ++titr)
+    {
+        if(ArenaTeam * at = (*titr))
+        {
+            at->FinishWeek();   // set played this week etc values to 0 in memory, too
+            // at->SaveToDB(); // no need, the modified values are already saved above
+            at->NotifyStatsChanged();  // notify the players of the changes
+        }
+    }
+    sWorld.SendGlobalText("Modification done.", NULL);
+
+    sWorld.SendGlobalText("Done flushing Arena points.", NULL);
+}
+
 void BattleGroundMgr::BuildBattleGroundListPacket(WorldPacket *data, uint64 guid, Player* plr, uint32 bgTypeId)
 {
     uint32 PlayerLevel = 10;
@@ -842,18 +1701,25 @@ void BattleGroundMgr::BuildBattleGroundListPacket(WorldPacket *data, uint64 guid
     }
 }
 
-void BattleGroundMgr::SendToBattleGround(Player *pl, uint32 bgTypeId)
+void BattleGroundMgr::SendToBattleGround(Player *pl, uint32 instanceId)
 {
-    BattleGround *bg = GetBattleGround(bgTypeId);
+    BattleGround *bg = GetBattleGround(instanceId);
     if(bg)
     {
         uint32 mapid = bg->GetMapId();
         float x, y, z, O;
-        bg->GetTeamStartLoc(pl->GetTeam(), x, y, z, O);
+        uint32 team = pl->GetBGTeam();
+        if(team==0)
+            team = pl->GetTeam();
+        bg->GetTeamStartLoc(team, x, y, z, O);
 
         sLog.outDetail("BATTLEGROUND: Sending %s to map %u, X %f, Y %f, Z %f, O %f", pl->GetName(), mapid, x, y, z, O);
         pl->TeleportTo(mapid, x, y, z, O);
     }
+    else
+    {
+        sLog.outError("player %u trying to port to non-existent bg instance %u",pl->GetGUIDLow(), instanceId);
+    }
 }
 
 void BattleGroundMgr::SendAreaSpiritHealerQueryOpcode(Player *pl, BattleGround *bg, uint64 guid)
@@ -865,3 +1731,100 @@ void BattleGroundMgr::SendAreaSpiritHealerQueryOpcode(Player *pl, BattleGround *
     data << guid << time_;
     pl->GetSession()->SendPacket(&data);
 }
+
+void BattleGroundMgr::RemoveBattleGround(uint32 instanceID)
+{
+    BattleGroundSet::iterator itr = m_BattleGrounds.find(instanceID);
+    if(itr!=m_BattleGrounds.end())
+        m_BattleGrounds.erase(itr);
+}
+
+bool BattleGroundMgr::IsArenaType(uint32 bgTypeId) const
+{
+    return ( bgTypeId == BATTLEGROUND_AA ||
+        bgTypeId == BATTLEGROUND_BE ||
+        bgTypeId == BATTLEGROUND_NA ||
+        bgTypeId == BATTLEGROUND_RL );
+}
+
+bool BattleGroundMgr::IsBattleGroundType(uint32 bgTypeId) const
+{
+    return !IsArenaType(bgTypeId);
+}
+
+uint32 BattleGroundMgr::BGQueueTypeId(uint32 bgTypeId, uint8 arenaType) const
+{
+    switch(bgTypeId)
+    {
+    case BATTLEGROUND_WS:
+        return BATTLEGROUND_QUEUE_WS;
+    case BATTLEGROUND_AB:
+        return BATTLEGROUND_QUEUE_AB;
+    case BATTLEGROUND_AV:
+        return BATTLEGROUND_QUEUE_AV;
+    case BATTLEGROUND_EY:
+        return BATTLEGROUND_QUEUE_EY;
+    case BATTLEGROUND_AA:
+    case BATTLEGROUND_NA:
+    case BATTLEGROUND_RL:
+    case BATTLEGROUND_BE:
+        switch(arenaType)
+        {
+        case ARENA_TYPE_2v2:
+            return BATTLEGROUND_QUEUE_2v2;
+        case ARENA_TYPE_3v3:
+            return BATTLEGROUND_QUEUE_3v3;
+        case ARENA_TYPE_5v5:
+            return BATTLEGROUND_QUEUE_5v5;
+        default:
+            return 0;
+        }
+    default:
+        return 0;
+    }
+}
+
+uint32 BattleGroundMgr::BGTemplateId(uint32 bgQueueTypeId) const
+{
+    switch(bgQueueTypeId)
+    {
+    case BATTLEGROUND_QUEUE_WS:
+        return BATTLEGROUND_WS;
+    case BATTLEGROUND_QUEUE_AB:
+        return BATTLEGROUND_AB;
+    case BATTLEGROUND_QUEUE_AV:
+        return BATTLEGROUND_AV;
+    case BATTLEGROUND_QUEUE_EY:
+        return BATTLEGROUND_EY;
+    case BATTLEGROUND_QUEUE_2v2:
+    case BATTLEGROUND_QUEUE_3v3:
+    case BATTLEGROUND_QUEUE_5v5:
+        return BATTLEGROUND_AA;
+    default:
+        return 0;
+    }
+}
+
+uint8 BattleGroundMgr::BGArenaType(uint32 bgQueueTypeId) const
+{
+    switch(bgQueueTypeId)
+    {
+    case BATTLEGROUND_QUEUE_2v2:
+        return ARENA_TYPE_2v2;
+    case BATTLEGROUND_QUEUE_3v3:
+        return ARENA_TYPE_3v3;
+    case BATTLEGROUND_QUEUE_5v5:
+        return ARENA_TYPE_5v5;
+    default:
+        return 0;
+    }
+}
+
+void BattleGroundMgr::ToggleArenaTesting()
+{
+    m_ArenaTesting = !m_ArenaTesting;
+    if(m_ArenaTesting)
+        sWorld.SendGlobalText("Arenas are set to 1v1 for debugging. So, don't join as group.", NULL);
+    else
+        sWorld.SendGlobalText("Arenas are set to normal playercount.", NULL);
+}
diff --git a/src/game/BattleGroundMgr.h b/src/game/BattleGroundMgr.h
index 193e5f4..63510ce 100644
--- a/src/game/BattleGroundMgr.h
+++ b/src/game/BattleGroundMgr.h
@@ -34,51 +34,98 @@ typedef std::deque<BattleGround*> BGFreeSlotQueueType;
 
 #define MAX_BATTLEGROUND_TYPES 9                            // each BG type will be in array
 
-struct PlayerQueueInfo
+#define MAX_BATTLEGROUND_QUEUE_TYPES 8
+
+#define BATTLEGROUND_ARENA_POINT_DISTRIBUTION_DAY    86400     // seconds in a day
+
+struct GroupQueueInfo;                                      // type predefinition
+struct PlayerQueueInfo                                      // stores information for players in queue
 {
     uint32  InviteTime;                                     // first invite time
     uint32  LastInviteTime;                                 // last invite time
-    uint32  IsInvitedToBGInstanceGUID;                      // was invited to certain BG
     uint32  LastOnlineTime;                                 // for tracking and removing offline players from queue after 5 minutes
-    uint32  Team;                                           // Player team (ALLIANCE/HORDE)
-    bool IsRated;
-    bool AsGroup;                                           // uint32 GroupId;
-    uint8 ArenaType;
+    GroupQueueInfo * GroupInfo;                             // pointer to the associated groupqueueinfo
 };
 
-struct PlayersCount
+struct GroupQueueInfo                                       // stores information about the group in queue (also used when joined as solo!)
 {
-    uint32 Alliance;
-    uint32 Horde;
-};
-
-template<class _Kty, class _Ty> class bgqueue: public std::map<_Kty, _Ty>
-{
-    public:
-        uint32 Alliance;
-        uint32 Horde;
-        //bool   Ready; // not used now
-        //uint32 AverageTime; //not already implemented (it should be average time in queue for last 10 players)
+    std::map<uint64, PlayerQueueInfo*> Players;             // player queue info map
+    uint32  Team;                                           // Player team (ALLIANCE/HORDE)
+    bool    IsRated;                                        // rated
+    uint32  BgTypeId;                                       // battleground type id
+    uint8   ArenaType;                                      // 2v2, 3v3, 5v5 or 0 when BG
+    uint32  ArenaTeamId;                                    // team id if rated match
+    uint32  JoinTime;                                       // time when group was added
+    uint32  IsInvitedToBGInstanceGUID;                      // was invited to certain BG
+    uint32  ArenaTeamRating;                                // if rated match, inited to the rating of the team
 };
 
+class BattleGround;
 class BattleGroundQueue
 {
     public:
         BattleGroundQueue();
         ~BattleGroundQueue();
-/*
-        uint32 GetType();
-        void SetType(uint32 type);*/
 
-        void Update(uint32 bgTypeId, uint32 queue_id);
+        void Update(uint32 bgTypeId, uint32 queue_id, uint8 arenatype = 0, bool isRated = false, uint32 minRating = 0);
 
-        void AddPlayer(Player *plr, uint32 bgTypeId);
+        GroupQueueInfo * AddGroup(Player * leader, uint32 BgTypeId, uint8 ArenaType, bool isRated, uint32 ArenaRating, uint32 ArenaTeamId = 0);
+        void AddPlayer(Player *plr, GroupQueueInfo *ginfo);
         void RemovePlayer(uint64 guid, bool decreaseInvitedCount);
+        void DecreaseGroupLength(uint32 queueId, uint32 AsGroup);
+        void BGEndedRemoveInvites(BattleGround * bg);
 
-        typedef bgqueue<uint64, PlayerQueueInfo> QueuedPlayersMap;
+        typedef std::map<uint64, PlayerQueueInfo> QueuedPlayersMap;
         QueuedPlayersMap m_QueuedPlayers[MAX_BATTLEGROUND_QUEUES];
-        typedef std::list<uint64> PlayerGuidsSortedByTimeQueue;
-        PlayerGuidsSortedByTimeQueue m_PlayersSortedByWaitTime[MAX_BATTLEGROUND_QUEUES];
+
+        typedef std::list<GroupQueueInfo*> QueuedGroupsList;
+        QueuedGroupsList m_QueuedGroups[MAX_BATTLEGROUND_QUEUES];
+
+        // class to hold pointers to the groups eligible for a specific selection pool building mode
+        class EligibleGroups : public std::list<GroupQueueInfo *>
+        {
+        public:
+            void Init(QueuedGroupsList * source, uint32 BgTypeId, uint32 side, uint32 MaxPlayers, uint8 ArenaType = 0, bool IsRated = false, uint32 MinRating = 0, uint32 MaxRating = 0, uint32 DisregardTime = 0, uint32 excludeTeam = 0);
+            void RemoveGroup(GroupQueueInfo * ginfo);
+        };
+
+        EligibleGroups m_EligibleGroups;
+
+        // class to select and invite groups to bg
+        class SelectionPool
+        {
+        public:
+            void Init();
+            void AddGroup(GroupQueueInfo * group);
+            GroupQueueInfo * GetMaximalGroup();
+            void RemoveGroup(GroupQueueInfo * group);
+            uint32 GetPlayerCount() const {return PlayerCount;}
+        public:
+            std::list<GroupQueueInfo *> SelectedGroups;
+        private:
+            uint32 PlayerCount;
+            GroupQueueInfo * MaxGroup;
+        };
+
+        enum SelectionPoolBuildMode
+        {
+            NORMAL_ALLIANCE,
+            NORMAL_HORDE,
+            ONESIDE_ALLIANCE_TEAM1,
+            ONESIDE_ALLIANCE_TEAM2,
+            ONESIDE_HORDE_TEAM1,
+            ONESIDE_HORDE_TEAM2,
+
+            NUM_SELECTION_POOL_TYPES
+        };
+
+        SelectionPool m_SelectionPools[NUM_SELECTION_POOL_TYPES];
+
+        bool BuildSelectionPool(uint32 bgTypeId, uint32 queue_id, uint32 MinPlayers, uint32 MaxPlayers, SelectionPoolBuildMode mode, uint8 ArenaType = 0, bool isRated = false, uint32 MinRating = 0, uint32 MaxRating = 0, uint32 DisregardTime = 0, uint32 excludeTeam = 0);
+
+    private:
+
+        bool InviteGroupToBG(GroupQueueInfo * ginfo, BattleGround * bg, uint32 side);
 };
 
 /*
@@ -96,7 +143,6 @@ class BGQueueInviteEvent : public BasicEvent
     private:
         uint64 m_PlayerGuid;
         uint32 m_BgInstanceGUID;
-
 };
 
 /*
@@ -116,7 +162,6 @@ class BGQueueRemoveEvent : public BasicEvent
         uint32 m_PlayersTeam;
 };
 
-
 class BattleGroundMgr
 {
     public:
@@ -132,18 +177,18 @@ class BattleGroundMgr
         void BuildGroupJoinedBattlegroundPacket(WorldPacket *data, uint32 bgTypeId);
         void BuildUpdateWorldStatePacket(WorldPacket *data, uint32 field, uint32 value);
         void BuildPvpLogDataPacket(WorldPacket *data, BattleGround *bg);
-        void BuildBattleGroundStatusPacket(WorldPacket *data, BattleGround *bg, uint32 team, uint8 QueueSlot, uint8 StatusID, uint32 Time1, uint32 Time2);
+        void BuildBattleGroundStatusPacket(WorldPacket *data, BattleGround *bg, uint32 team, uint8 QueueSlot, uint8 StatusID, uint32 Time1, uint32 Time2, uint32 arenatype = 0, uint8 israted = 0);
         void BuildPlaySoundPacket(WorldPacket *data, uint32 soundid);
 
         /* Player invitation */
         // called from Queue update, or from Addplayer to queue
-        void InvitePlayer(Player* plr, uint32 bgInstanceGUID);
+        void InvitePlayer(Player* plr, uint32 bgInstanceGUID, uint32 team);
 
         /* Battlegrounds */
         BattleGroundSet::iterator GetBattleGroundsBegin() { return m_BattleGrounds.begin(); };
         BattleGroundSet::iterator GetBattleGroundsEnd() { return m_BattleGrounds.end(); };
 
-        BattleGround* GetBattleGround(uint8 ID)
+        BattleGround* GetBattleGround(uint32 ID)
         {
             BattleGroundSet::iterator i = m_BattleGrounds.find(ID);
             if(i != m_BattleGrounds.end())
@@ -152,9 +197,13 @@ class BattleGroundMgr
                 return NULL;
         };
 
+        BattleGround * GetBattleGroundTemplate(uint32 bgTypeId);
+        BattleGround * CreateNewBattleGround(uint32 bgTypeId);
+
         uint32 CreateBattleGround(uint32 bgTypeId, uint32 MinPlayersPerTeam, uint32 MaxPlayersPerTeam, uint32 LevelMin, uint32 LevelMax, char* BattleGroundName, uint32 MapID, float Team1StartLocX, float Team1StartLocY, float Team1StartLocZ, float Team1StartLocO, float Team2StartLocX, float Team2StartLocY, float Team2StartLocZ, float Team2StartLocO);
 
         inline void AddBattleGround(uint32 ID, BattleGround* BG) { m_BattleGrounds[ID] = BG; };
+        void RemoveBattleGround(uint32 instanceID);
 
         void CreateInitialBattleGrounds();
 
@@ -162,16 +211,39 @@ class BattleGroundMgr
 
         /* Battleground queues */
         //these queues are instantiated when creating BattlegroundMrg
-        BattleGroundQueue m_BattleGroundQueues[MAX_BATTLEGROUND_TYPES]; // public, because we need to access them in BG handler code
+        BattleGroundQueue m_BattleGroundQueues[MAX_BATTLEGROUND_QUEUE_TYPES]; // public, because we need to access them in BG handler code
 
         BGFreeSlotQueueType BGFreeSlotQueue[MAX_BATTLEGROUND_TYPES];
 
         void SendAreaSpiritHealerQueryOpcode(Player *pl, BattleGround *bg, uint64 guid);
 
+        bool IsArenaType(uint32 bgTypeId) const;
+        bool IsBattleGroundType(uint32 bgTypeId) const;
+        uint32 BGQueueTypeId(uint32 bgTypeId, uint8 arenaType) const;
+        uint32 BGTemplateId(uint32 bgQueueTypeId) const;
+        uint8 BGArenaType(uint32 bgQueueTypeId) const;
+
+        uint32 GetMaxRatingDifference() const {return m_MaxRatingDifference;}
+        uint32 GetRatingDiscardTimer() const {return m_RatingDiscardTimer;}
+
+        void InitAutomaticArenaPointDistribution();
+        void DistributeArenaPoints();
+        uint32 GetPrematureFinishTime() const {return m_PrematureFinishTimer;}
+        void ToggleArenaTesting();
+        const bool isArenaTesting() const { return m_ArenaTesting; }
+
     private:
 
         /* Battlegrounds */
         BattleGroundSet m_BattleGrounds;
+        uint32 m_MaxRatingDifference;
+        uint32 m_RatingDiscardTimer;
+        uint32 m_NextRatingDiscardUpdate;
+        bool   m_AutoDistributePoints;
+        uint64 m_NextAutoDistributionTime;
+        uint32 m_AutoDistributionTimeChecker;
+        uint32 m_PrematureFinishTimer;
+        bool   m_ArenaTesting;
 };
 
 #define sBattleGroundMgr MaNGOS::Singleton<BattleGroundMgr>::Instance()
diff --git a/src/game/BattleGroundNA.cpp b/src/game/BattleGroundNA.cpp
index ac4705f..385de12 100644
--- a/src/game/BattleGroundNA.cpp
+++ b/src/game/BattleGroundNA.cpp
@@ -47,6 +47,12 @@ void BattleGroundNA::Update(time_t diff)
         if (!(m_Events & 0x01))
         {
             m_Events |= 0x01;
+            // setup here, only when at least one player has ported to the map
+            if(!SetupBattleGround())
+            {
+                EndNow();
+                return;
+            }
             for(uint32 i = BG_NA_OBJECT_DOOR_1; i <= BG_NA_OBJECT_DOOR_4; i++)
                 SpawnBGObject(i, RESPAWN_IMMEDIATELY);
 
@@ -73,6 +79,9 @@ void BattleGroundNA::Update(time_t diff)
             for(uint32 i = BG_NA_OBJECT_DOOR_1; i <= BG_NA_OBJECT_DOOR_2; i++)
                 DoorOpen(i);
 
+            for(uint32 i = BG_NA_OBJECT_BUFF_1; i <= BG_NA_OBJECT_BUFF_2; i++)
+                SpawnBGObject(i, 60);
+
             SendMessageToAll(LANG_ARENA_BEGUN);
             SetStatus(STATUS_IN_PROGRESS);
             SetStartDelayTime(0);
@@ -80,6 +89,11 @@ void BattleGroundNA::Update(time_t diff)
             for(BattleGroundPlayerMap::const_iterator itr = GetPlayers().begin(); itr != GetPlayers().end(); ++itr)
                 if(Player *plr = objmgr.GetPlayer(itr->first))
                     plr->RemoveAurasDueToSpell(SPELL_ARENA_PREPARATION);
+
+            if(!GetPlayersCountByTeam(ALLIANCE) && GetPlayersCountByTeam(HORDE))
+                EndBattleGround(HORDE);
+            else if(GetPlayersCountByTeam(ALLIANCE) && !GetPlayersCountByTeam(HORDE))
+                EndBattleGround(ALLIANCE);
         }
     }
 
@@ -96,11 +110,23 @@ void BattleGroundNA::AddPlayer(Player *plr)
     BattleGroundNAScore* sc = new BattleGroundNAScore;
 
     m_PlayerScores[plr->GetGUID()] = sc;
+
+    UpdateWorldState(0xa0f, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0xa10, GetAlivePlayersCountByTeam(HORDE));
 }
 
 void BattleGroundNA::RemovePlayer(Player* /*plr*/, uint64 /*guid*/)
 {
+    if(GetStatus() == STATUS_WAIT_LEAVE)
+        return;
+
+    UpdateWorldState(0xa0f, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0xa10, GetAlivePlayersCountByTeam(HORDE));
 
+    if(!GetAlivePlayersCountByTeam(ALLIANCE) && GetPlayersCountByTeam(HORDE))
+        EndBattleGround(HORDE);
+    else if(GetPlayersCountByTeam(ALLIANCE) && !GetAlivePlayersCountByTeam(HORDE))
+        EndBattleGround(ALLIANCE);
 }
 
 void BattleGroundNA::HandleKillPlayer(Player *player, Player *killer)
@@ -114,19 +140,29 @@ void BattleGroundNA::HandleKillPlayer(Player *player, Player *killer)
         return;
     }
 
-    BattleGround::HandleKillPlayer(player, killer);
+    BattleGround::HandleKillPlayer(player,killer);
 
-    uint32 killer_team_index = GetTeamIndexByTeamId(killer->GetTeam());
+    UpdateWorldState(0xa0f, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0xa10, GetAlivePlayersCountByTeam(HORDE));
 
-    ++m_TeamKills[killer_team_index];                       // add kills to killer's team
-
-    if(m_TeamKills[killer_team_index] >= GetPlayersCountByTeam(player->GetTeam()))
+    if(!GetAlivePlayersCountByTeam(ALLIANCE))
+    {
+        // all opponents killed
+        EndBattleGround(HORDE);
+    }
+    else if(!GetAlivePlayersCountByTeam(HORDE))
     {
         // all opponents killed
-        EndBattleGround(killer->GetTeam());
+        EndBattleGround(ALLIANCE);
     }
 }
 
+bool BattleGroundNA::HandlePlayerUnderMap(Player *player)
+{
+    player->TeleportTo(GetMapId(),4055.504395,2919.660645,13.611241,player->GetOrientation(),false);
+    return true;
+}
+
 void BattleGroundNA::HandleAreaTrigger(Player *Source, uint32 Trigger)
 {
     if(GetStatus() != STATUS_IN_PROGRESS)
@@ -149,19 +185,28 @@ void BattleGroundNA::HandleAreaTrigger(Player *Source, uint32 Trigger)
     //    HandleTriggerBuff(buff_guid,Source);
 }
 
+void BattleGroundNA::FillInitialWorldStates(WorldPacket &data)
+{
+    data << uint32(0xa0f) << uint32(GetAlivePlayersCountByTeam(ALLIANCE));           // 7
+    data << uint32(0xa10) << uint32(GetAlivePlayersCountByTeam(HORDE));           // 8
+    data << uint32(0xa11) << uint32(1);           // 9
+}
+
 void BattleGroundNA::ResetBGSubclass()
 {
-    m_TeamKills[BG_TEAM_ALLIANCE] = 0;
-    m_TeamKills[BG_TEAM_HORDE]    = 0;
+
 }
 
 bool BattleGroundNA::SetupBattleGround()
 {
     // gates
-    if(    !AddObject(BG_NA_OBJECT_DOOR_1, BG_NA_OBJECT_TYPE_DOOR_1, 4031.854f, 2966.833f, 12.6462f, -2.648788f, 0, 0, 0.9697962f, -0.2439165f, RESPAWN_IMMEDIATELY)
-        || !AddObject(BG_NA_OBJECT_DOOR_2, BG_NA_OBJECT_TYPE_DOOR_2, 4081.179f, 2874.97f, 12.39171f, 0.4928045f, 0, 0, 0.2439165f, 0.9697962f, RESPAWN_IMMEDIATELY)
-        || !AddObject(BG_NA_OBJECT_DOOR_3, BG_NA_OBJECT_TYPE_DOOR_3, 4023.709f, 2981.777f, 10.70117f, -2.648788f, 0, 0, 0.9697962f, -0.2439165f, RESPAWN_IMMEDIATELY)
-        || !AddObject(BG_NA_OBJECT_DOOR_4, BG_NA_OBJECT_TYPE_DOOR_4, 4090.064f, 2858.438f, 10.23631f, 0.4928045f, 0, 0, 0.2439165f, 0.9697962f, RESPAWN_IMMEDIATELY))
+    if(    !AddObject(BG_NA_OBJECT_DOOR_1, BG_NA_OBJECT_TYPE_DOOR_1, 4031.854, 2966.833, 12.6462, -2.648788, 0, 0, 0.9697962, -0.2439165, RESPAWN_IMMEDIATELY)
+        || !AddObject(BG_NA_OBJECT_DOOR_2, BG_NA_OBJECT_TYPE_DOOR_2, 4081.179, 2874.97, 12.39171, 0.4928045, 0, 0, 0.2439165, 0.9697962, RESPAWN_IMMEDIATELY)
+        || !AddObject(BG_NA_OBJECT_DOOR_3, BG_NA_OBJECT_TYPE_DOOR_3, 4023.709, 2981.777, 10.70117, -2.648788, 0, 0, 0.9697962, -0.2439165, RESPAWN_IMMEDIATELY)
+        || !AddObject(BG_NA_OBJECT_DOOR_4, BG_NA_OBJECT_TYPE_DOOR_4, 4090.064, 2858.438, 10.23631, 0.4928045, 0, 0, 0.2439165, 0.9697962, RESPAWN_IMMEDIATELY)
+    // buffs
+        || !AddObject(BG_NA_OBJECT_BUFF_1, BG_NA_OBJECT_TYPE_BUFF_1, 4009.189941, 2895.250000, 13.052700, -1.448624, 0, 0, 0.6626201, -0.7489557, 120)
+        || !AddObject(BG_NA_OBJECT_BUFF_2, BG_NA_OBJECT_TYPE_BUFF_2, 4103.330078, 2946.350098, 13.051300, -0.06981307, 0, 0, 0.03489945, -0.9993908, 120))
     {
         sLog.outErrorDb("BatteGroundNA: Failed to spawn some object!");
         return false;
diff --git a/src/game/BattleGroundNA.h b/src/game/BattleGroundNA.h
index 723e5b0..a444609 100644
--- a/src/game/BattleGroundNA.h
+++ b/src/game/BattleGroundNA.h
@@ -26,7 +26,9 @@ enum BattleGroundNAObjectTypes
     BG_NA_OBJECT_DOOR_2         = 1,
     BG_NA_OBJECT_DOOR_3         = 2,
     BG_NA_OBJECT_DOOR_4         = 3,
-    BG_NA_OBJECT_MAX            = 4
+    BG_NA_OBJECT_BUFF_1         = 4,
+    BG_NA_OBJECT_BUFF_2         = 5,
+    BG_NA_OBJECT_MAX            = 6
 };
 
 enum BattleGroundNAObjects
@@ -34,7 +36,9 @@ enum BattleGroundNAObjects
     BG_NA_OBJECT_TYPE_DOOR_1    = 183978,
     BG_NA_OBJECT_TYPE_DOOR_2    = 183980,
     BG_NA_OBJECT_TYPE_DOOR_3    = 183977,
-    BG_NA_OBJECT_TYPE_DOOR_4    = 183979
+    BG_NA_OBJECT_TYPE_DOOR_4    = 183979,
+    BG_NA_OBJECT_TYPE_BUFF_1    = 184663,
+    BG_NA_OBJECT_TYPE_BUFF_2    = 184664
 };
 
 class BattleGroundNAScore : public BattleGroundScore
@@ -61,9 +65,8 @@ class BattleGroundNA : public BattleGround
         void HandleAreaTrigger(Player *Source, uint32 Trigger);
         bool SetupBattleGround();
         virtual void ResetBGSubclass();
+        virtual void FillInitialWorldStates(WorldPacket &d);
         void HandleKillPlayer(Player* player, Player *killer);
-
-    private:
-        uint32 m_TeamKills[2];                              // count of kills for each team
+        bool HandlePlayerUnderMap(Player * plr);
 };
 #endif
diff --git a/src/game/BattleGroundRL.cpp b/src/game/BattleGroundRL.cpp
index 4be135c..bf3b5b0 100644
--- a/src/game/BattleGroundRL.cpp
+++ b/src/game/BattleGroundRL.cpp
@@ -47,6 +47,13 @@ void BattleGroundRL::Update(time_t diff)
         {
             m_Events |= 0x01;
 
+            // setup here, only when at least one player has ported to the map
+            if(!SetupBattleGround())
+            {
+                EndNow();
+                return;
+            }
+
             for(uint32 i = BG_RL_OBJECT_DOOR_1; i <= BG_RL_OBJECT_DOOR_2; i++)
                 SpawnBGObject(i, RESPAWN_IMMEDIATELY);
 
@@ -73,6 +80,9 @@ void BattleGroundRL::Update(time_t diff)
             for(uint32 i = BG_RL_OBJECT_DOOR_1; i <= BG_RL_OBJECT_DOOR_2; i++)
                 DoorOpen(i);
 
+            for(uint32 i = BG_RL_OBJECT_BUFF_1; i <= BG_RL_OBJECT_BUFF_2; i++)
+                SpawnBGObject(i, 60);
+
             SendMessageToAll(LANG_ARENA_BEGUN);
             SetStatus(STATUS_IN_PROGRESS);
             SetStartDelayTime(0);
@@ -80,6 +90,11 @@ void BattleGroundRL::Update(time_t diff)
             for(BattleGroundPlayerMap::const_iterator itr = GetPlayers().begin(); itr != GetPlayers().end(); ++itr)
                 if(Player *plr = objmgr.GetPlayer(itr->first))
                     plr->RemoveAurasDueToSpell(SPELL_ARENA_PREPARATION);
+
+            if(!GetPlayersCountByTeam(ALLIANCE) && GetPlayersCountByTeam(HORDE))
+                EndBattleGround(HORDE);
+            else if(GetPlayersCountByTeam(ALLIANCE) && !GetPlayersCountByTeam(HORDE))
+                EndBattleGround(ALLIANCE);
         }
     }
 
@@ -96,11 +111,23 @@ void BattleGroundRL::AddPlayer(Player *plr)
     BattleGroundRLScore* sc = new BattleGroundRLScore;
 
     m_PlayerScores[plr->GetGUID()] = sc;
+
+    UpdateWorldState(0xbb8, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0xbb9, GetAlivePlayersCountByTeam(HORDE));
 }
 
 void BattleGroundRL::RemovePlayer(Player* /*plr*/, uint64 /*guid*/)
 {
+    if(GetStatus() == STATUS_WAIT_LEAVE)
+        return;
 
+    UpdateWorldState(0xbb8, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0xbb9, GetAlivePlayersCountByTeam(HORDE));
+
+    if(!GetAlivePlayersCountByTeam(ALLIANCE) && GetPlayersCountByTeam(HORDE))
+        EndBattleGround(HORDE);
+    else if(GetPlayersCountByTeam(ALLIANCE) && !GetAlivePlayersCountByTeam(HORDE))
+        EndBattleGround(ALLIANCE);
 }
 
 void BattleGroundRL::HandleKillPlayer(Player *player, Player *killer)
@@ -114,19 +141,29 @@ void BattleGroundRL::HandleKillPlayer(Player *player, Player *killer)
         return;
     }
 
-    BattleGround::HandleKillPlayer(player, killer);
-
-    uint32 killer_team_index = GetTeamIndexByTeamId(killer->GetTeam());
+    BattleGround::HandleKillPlayer(player,killer);
 
-    ++m_TeamKills[killer_team_index];                       // add kills to killer's team
+    UpdateWorldState(0xbb8, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0xbb9, GetAlivePlayersCountByTeam(HORDE));
 
-    if(m_TeamKills[killer_team_index] >= GetPlayersCountByTeam(player->GetTeam()))
+    if(!GetAlivePlayersCountByTeam(ALLIANCE))
+    {
+        // all opponents killed
+        EndBattleGround(HORDE);
+    }
+    else if(!GetAlivePlayersCountByTeam(HORDE))
     {
         // all opponents killed
-        EndBattleGround(killer->GetTeam());
+        EndBattleGround(ALLIANCE);
     }
 }
 
+bool BattleGroundRL::HandlePlayerUnderMap(Player *player)
+{
+    player->TeleportTo(GetMapId(),1285.810547,1667.896851,39.957642,player->GetOrientation(),false);
+    return true;
+}
+
 void BattleGroundRL::HandleAreaTrigger(Player *Source, uint32 Trigger)
 {
     // this is wrong way to implement these things. On official it done by gameobject spell cast.
@@ -150,17 +187,26 @@ void BattleGroundRL::HandleAreaTrigger(Player *Source, uint32 Trigger)
     //    HandleTriggerBuff(buff_guid,Source);
 }
 
+void BattleGroundRL::FillInitialWorldStates(WorldPacket &data)
+{
+    data << uint32(0xbb8) << uint32(GetAlivePlayersCountByTeam(ALLIANCE));           // 7
+    data << uint32(0xbb9) << uint32(GetAlivePlayersCountByTeam(HORDE));           // 8
+    data << uint32(0xbba) << uint32(1);           // 9
+}
+
 void BattleGroundRL::ResetBGSubclass()
 {
-    m_TeamKills[BG_TEAM_ALLIANCE] = 0;
-    m_TeamKills[BG_TEAM_HORDE]    = 0;
+
 }
 
 bool BattleGroundRL::SetupBattleGround()
 {
     // gates
-    if(    !AddObject(BG_RL_OBJECT_DOOR_1, BG_RL_OBJECT_TYPE_DOOR_1, 1293.561f, 1601.938f, 31.60557f, -1.457349f, 0, 0, -0.6658813f, 0.7460576f, RESPAWN_IMMEDIATELY)
-        || !AddObject(BG_RL_OBJECT_DOOR_2, BG_RL_OBJECT_TYPE_DOOR_2, 1278.648f, 1730.557f, 31.60557f, 1.684245f, 0, 0, 0.7460582f, 0.6658807f, RESPAWN_IMMEDIATELY))
+    if(    !AddObject(BG_RL_OBJECT_DOOR_1, BG_RL_OBJECT_TYPE_DOOR_1, 1293.561, 1601.938, 31.60557, -1.457349, 0, 0, -0.6658813, 0.7460576, RESPAWN_IMMEDIATELY)
+        || !AddObject(BG_RL_OBJECT_DOOR_2, BG_RL_OBJECT_TYPE_DOOR_2, 1278.648, 1730.557, 31.60557, 1.684245, 0, 0, 0.7460582, 0.6658807, RESPAWN_IMMEDIATELY)
+    // buffs
+        || !AddObject(BG_RL_OBJECT_BUFF_1, BG_RL_OBJECT_TYPE_BUFF_1, 1328.719971, 1632.719971, 36.730400, -1.448624, 0, 0, 0.6626201, -0.7489557, 120)
+        || !AddObject(BG_RL_OBJECT_BUFF_2, BG_RL_OBJECT_TYPE_BUFF_2, 1243.300049, 1699.170044, 34.872601, -0.06981307, 0, 0, 0.03489945, -0.9993908, 120))
     {
         sLog.outErrorDb("BatteGroundRL: Failed to spawn some object!");
         return false;
diff --git a/src/game/BattleGroundRL.h b/src/game/BattleGroundRL.h
index 0e9a38b..dd000ce 100644
--- a/src/game/BattleGroundRL.h
+++ b/src/game/BattleGroundRL.h
@@ -24,13 +24,17 @@ enum BattleGroundRLObjectTypes
 {
     BG_RL_OBJECT_DOOR_1         = 0,
     BG_RL_OBJECT_DOOR_2         = 1,
-    BG_RL_OBJECT_MAX            = 2
+    BG_RL_OBJECT_BUFF_1         = 2,
+    BG_RL_OBJECT_BUFF_2         = 3,
+    BG_RL_OBJECT_MAX            = 4
 };
 
 enum BattleGroundRLObjects
 {
     BG_RL_OBJECT_TYPE_DOOR_1    = 185918,
-    BG_RL_OBJECT_TYPE_DOOR_2    = 185917
+    BG_RL_OBJECT_TYPE_DOOR_2    = 185917,
+    BG_RL_OBJECT_TYPE_BUFF_1    = 184663,
+    BG_RL_OBJECT_TYPE_BUFF_2    = 184664
 };
 
 class BattleGroundRLScore : public BattleGroundScore
@@ -57,9 +61,8 @@ class BattleGroundRL : public BattleGround
         void HandleAreaTrigger(Player *Source, uint32 Trigger);
         bool SetupBattleGround();
         virtual void ResetBGSubclass();
+        virtual void FillInitialWorldStates(WorldPacket &d);
         void HandleKillPlayer(Player* player, Player *killer);
-
-    private:
-        uint32 m_TeamKills[2];                              // count of kills for each team
+        bool HandlePlayerUnderMap(Player * plr);
 };
 #endif
diff --git a/src/game/BattleGroundWS.cpp b/src/game/BattleGroundWS.cpp
index 23c90a7..53c67c1 100644
--- a/src/game/BattleGroundWS.cpp
+++ b/src/game/BattleGroundWS.cpp
@@ -49,6 +49,16 @@ void BattleGroundWS::Update(time_t diff)
         {
             m_Events |= 0x01;
 
+            // setup here, only when at least one player has ported to the map
+            if(!SetupBattleGround())
+            {
+                EndNow();
+                return;
+            }
+
+//            for(uint32 i = WS_SPIRIT_MAIN_ALLIANCE; i <= WS_SPIRIT_MAIN_HORDE; i++)
+//                SpawnBGCreature(i, RESPAWN_IMMEDIATELY);
+
             for(uint32 i = BG_WS_OBJECT_DOOR_A_1; i <= BG_WS_OBJECT_DOOR_H_4; i++)
             {
                 SpawnBGObject(i, RESPAWN_IMMEDIATELY);
@@ -285,7 +295,32 @@ void BattleGroundWS::EventPlayerCapturedFlag(Player *Source)
 
 void BattleGroundWS::EventPlayerDroppedFlag(Player *Source)
 {
-    // Drop allowed in any BG state
+    if(GetStatus() != STATUS_IN_PROGRESS)
+    {
+        // if not running, do not cast things at the dropper player (prevent spawning the "dropped" flag), neither send unnecessary messages
+        // just take off the aura
+        if(Source->GetTeam() == ALLIANCE)
+        {
+            if(!this->IsHordeFlagPickedup())
+                return;
+            if(GetHordeFlagPickerGUID() == Source->GetGUID())
+            {
+                SetHordeFlagPicker(0);
+                Source->RemoveAurasDueToSpell(BG_WS_SPELL_WARSONG_FLAG);
+            }
+        }
+        else
+        {
+            if(!this->IsAllianceFlagPickedup())
+                return;
+            if(GetAllianceFlagPickerGUID() == Source->GetGUID())
+            {
+                SetAllianceFlagPicker(0);
+                Source->RemoveAurasDueToSpell(BG_WS_SPELL_SILVERWING_FLAG);
+            }
+        }
+        return;
+    }
 
     const char *message = "";
     uint8 type = 0;
diff --git a/src/game/CharacterHandler.cpp b/src/game/CharacterHandler.cpp
index 0d55aa0..d7a1c87 100644
--- a/src/game/CharacterHandler.cpp
+++ b/src/game/CharacterHandler.cpp
@@ -36,6 +36,7 @@
 #include "PlayerDump.h"
 #include "SocialMgr.h"
 #include "Util.h"
+#include "ArenaTeam.h"
 #include "Language.h"
 
 class LoginQueryHolder : public SqlQueryHolder
diff --git a/src/game/Chat.cpp b/src/game/Chat.cpp
index 068476c..3fdf712 100644
--- a/src/game/Chat.cpp
+++ b/src/game/Chat.cpp
@@ -169,6 +169,7 @@ ChatCommand * ChatHandler::getCommandTable()
         { "Mod32Value",     SEC_ADMINISTRATOR,  false, &ChatHandler::HandleMod32Value,                 "", NULL },
         { "anim",           SEC_GAMEMASTER,     false, &ChatHandler::HandleAnimCommand,                "", NULL },
         { "lootrecipient",  SEC_GAMEMASTER,     false, &ChatHandler::HandleGetLootRecipient,           "", NULL },
+        { "arena",          SEC_ADMINISTRATOR,  false, &ChatHandler::HandleDebugArenaCommand,          "", NULL },
         { NULL,             0,                  false, NULL,                                           "", NULL }
     };
 
@@ -485,6 +486,8 @@ ChatCommand * ChatHandler::getCommandTable()
         { "gps",            SEC_MODERATOR,      false, &ChatHandler::HandleGPSCommand,                 "", NULL },
         { "guid",           SEC_GAMEMASTER,     false, &ChatHandler::HandleGUIDCommand,                "", NULL },
         { "help",           SEC_PLAYER,         true,  &ChatHandler::HandleHelpCommand,                "", NULL },
+        { "ahexpire",       SEC_ADMINISTRATOR,  false, &ChatHandler::HandleAHExpireCommand,            "", NULL },
+        { "ahdelete",       SEC_ADMINISTRATOR,  false, &ChatHandler::HandleAHDeleteCommand,            "", NULL },
         { "itemmove",       SEC_GAMEMASTER,     false, &ChatHandler::HandleItemMoveCommand,            "", NULL },
         { "cooldown",       SEC_ADMINISTRATOR,  false, &ChatHandler::HandleCooldownCommand,            "", NULL },
         { "unlearn",        SEC_ADMINISTRATOR,  false, &ChatHandler::HandleUnLearnCommand,             "", NULL },
@@ -533,6 +536,7 @@ ChatCommand * ChatHandler::getCommandTable()
         { "damage",         SEC_ADMINISTRATOR,  false, &ChatHandler::HandleDamageCommand,              "", NULL },
         { "combatstop",     SEC_GAMEMASTER,     false, &ChatHandler::HandleCombatStopCommand,          "", NULL },
         { "chardelete",     SEC_CONSOLE,        true,  &ChatHandler::HandleCharacterDeleteCommand,     "", NULL },
+        { "flusharenapoints",    SEC_ADMINISTRATOR, false, &ChatHandler::HandleFlushArenaPointsCommand,         "",   NULL },
         { "sendmessage",    SEC_ADMINISTRATOR,  true,  &ChatHandler::HandleSendMessageCommand,         "", NULL },
         { "repairitems",    SEC_GAMEMASTER,     false, &ChatHandler::HandleRepairitemsCommand,         "", NULL },
         { "waterwalk",      SEC_GAMEMASTER,     false, &ChatHandler::HandleWaterwalkCommand,           "", NULL },
diff --git a/src/game/Chat.h b/src/game/Chat.h
index 77a9d51..7dbf7ff 100644
--- a/src/game/Chat.h
+++ b/src/game/Chat.h
@@ -151,6 +151,8 @@ class ChatHandler
         bool HandleLookupSkillCommand(const char* args);
         bool HandleLookupSpellCommand(const char* args);
         bool HandleLookupTeleCommand(const char * args);
+        bool HandleAHExpireCommand(const char * args);
+        bool HandleAHDeleteCommand(const char * args);
 
         bool HandleModifyKnownTitlesCommand(const char* args);
         bool HandleModifyHPCommand(const char* args);
@@ -414,6 +416,7 @@ class ChatHandler
         bool HandleComeToMeCommand(const char *args);
         bool HandleCombatStopCommand(const char *args);
         bool HandleSendMessageCommand(const char * args);
+        bool HandleFlushArenaPointsCommand(const char *args);
         bool HandleRepairitemsCommand(const char* args);
         bool HandleWaterwalkCommand(const char* args);
 
@@ -428,6 +431,7 @@ class ChatHandler
         bool HandleSaveAllCommand(const char* args);
         bool HandleGetItemState(const char * args);
         bool HandleGetLootRecipient(const char * args);
+        bool HandleDebugArenaCommand(const char * args);
 
         Player*   getSelectedPlayer();
         Creature* getSelectedCreature();
diff --git a/src/game/ChatHandler.cpp b/src/game/ChatHandler.cpp
index a6e05aa..9bef693 100644
--- a/src/game/ChatHandler.cpp
+++ b/src/game/ChatHandler.cpp
@@ -18,6 +18,7 @@
 
 #include "Common.h"
 #include "Log.h"
+#include "ChatLog.h"
 #include "WorldPacket.h"
 #include "WorldSession.h"
 #include "World.h"
@@ -159,11 +160,23 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
                 break;
 
             if(type == CHAT_MSG_SAY)
+            {
+                sChatLog.ChatMsg(GetPlayer(), msg, type);
+
                 GetPlayer()->Say(msg, lang);
+            }
             else if(type == CHAT_MSG_EMOTE)
+            {
+                sChatLog.ChatMsg(GetPlayer(), msg, type);
+
                 GetPlayer()->TextEmote(msg);
+            }
             else if(type == CHAT_MSG_YELL)
+            {
+                sChatLog.ChatMsg(GetPlayer(), msg, type);
+
                 GetPlayer()->Yell(msg, lang);
+            }
         } break;
 
         case CHAT_MSG_WHISPER:
@@ -180,6 +193,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.WhisperMsg(GetPlayer(), to, msg);
+
             if(!normalizePlayerName(to))
             {
                 WorldPacket data(SMSG_CHAT_PLAYER_NOT_FOUND, (to.size()+1));
@@ -233,6 +248,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.PartyMsg(GetPlayer(), msg);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group)
                 return;
@@ -260,6 +277,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.GuildMsg(GetPlayer(), msg, false);
+
             if (GetPlayer()->GetGuildId())
             {
                 Guild *guild = objmgr.GetGuildById(GetPlayer()->GetGuildId());
@@ -287,6 +306,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.GuildMsg(GetPlayer(), msg, true);
+
             if (GetPlayer()->GetGuildId())
             {
                 Guild *guild = objmgr.GetGuildById(GetPlayer()->GetGuildId());
@@ -313,6 +334,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.RaidMsg(GetPlayer(), msg, type);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isRaidGroup())
                 return;
@@ -339,6 +362,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.RaidMsg(GetPlayer(), msg, type);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isRaidGroup() || !group->IsLeader(GetPlayer()->GetGUID()))
                 return;
@@ -359,6 +384,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.RaidMsg(GetPlayer(), msg, type);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isRaidGroup() || !(group->IsLeader(GetPlayer()->GetGUID()) || group->IsAssistant(GetPlayer()->GetGUID())))
                 return;
@@ -380,6 +407,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.BattleGroundMsg(GetPlayer(), msg, type);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isRaidGroup())
                 return;
@@ -401,6 +430,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.BattleGroundMsg(GetPlayer(), msg, type);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isRaidGroup() || !group->IsLeader(GetPlayer()->GetGUID()))
                 return;
@@ -427,6 +458,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.ChannelMsg(GetPlayer(), channel, msg);
+
             if(ChannelMgr* cMgr = channelMgr(_player->GetTeam()))
             {
                 if(Channel *chn = cMgr->GetChannel(channel,_player))
diff --git a/src/game/ChatLexicsCutter.cpp b/src/game/ChatLexicsCutter.cpp
new file mode 100644
index 0000000..1c1d555
--- /dev/null
+++ b/src/game/ChatLexicsCutter.cpp
@@ -0,0 +1,274 @@
+/* 
+ * Copyright (C) 2005,2006,2007 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "Common.h"
+#include "ChatLexicsCutter.h"
+
+LexicsCutter::LexicsCutter()
+{
+    InvalidChars = "~`!@#$%^&*()-_+=[{]}|\\;:'\",<.>/?";
+}
+
+bool LexicsCutter::ReadUTF8(std::string& in, std::string& out, unsigned int& pos)
+{
+    if (pos >= in.length()) return false;
+    
+    out = "";
+    unsigned char c = in[pos++];
+    out += c;
+    int toread = trailingBytesForUTF8[(int) c];
+    while ((pos < in.length()) && (toread > 0))
+    {
+        out += in[pos++];
+        toread--;
+    }
+    
+    return true;
+}
+
+std::string LexicsCutter::trim(std::string& s, const std::string& drop)
+{
+    std::string r = s.erase(s.find_last_not_of(drop) + 1);
+    return r.erase(0, r.find_first_not_of(drop));
+}
+
+bool LexicsCutter::Read_Letter_Analogs(std::string& FileName)
+{
+    FILE *ma_file;
+    char line[1024];
+    unsigned int pos;
+    std::string line_s;
+    std::string lchar;
+    std::string lanalog;
+    
+    ma_file = fopen(FileName.c_str(), "rb");
+    
+    while (!feof(ma_file))
+    {
+        line[0] = 0x0;
+        fgets(line, 1020, ma_file);
+
+        // check for UTF8 prefix and comments
+        if (strlen(line) >= 3)
+        {
+            if (line[0] == '\xEF' && line[1] == '\xBB' && line[2] == '\xBF')
+            {
+                strncpy(&line[0], &line[3], strlen(line) - 3);
+            }
+        }
+
+        if (strlen(line) >= 2)
+        {
+            if (line[0] == '/' && line[1] == '/') continue;
+        }
+
+        // check for empty string
+        line_s = line; 
+        line_s = trim(line_s, "\x0A\x0D\x20");
+        if (line_s == "") continue;
+
+        // process line without CR/LF
+        line_s = line; 
+        line_s = trim(line_s, "\x0A\x0D");
+    
+        pos = 0;
+        if (ReadUTF8(line_s, lchar, pos))
+        {
+            // create analogs vector
+            LC_AnalogVector av;
+            while (ReadUTF8(line_s, lanalog, pos))
+            {
+                av.push_back(lanalog);
+            }
+        
+            // store vector in hash map
+            AnalogMap[lchar] = av;
+        }
+    }
+    
+    fclose(ma_file);
+    
+    return true;
+}
+
+bool LexicsCutter::Read_Innormative_Words(std::string& FileName)
+{
+    FILE *ma_file;
+    char line[1024];
+    unsigned int pos;
+    std::string line_s;
+    std::string lchar;
+    
+    ma_file = fopen(FileName.c_str(), "rb");
+    
+    while (!feof(ma_file))
+    {
+        line[0] = 0x0;
+        fgets(line, 1020, ma_file);
+
+        // check for UTF8 prefix and comment
+        if (strlen(line) >= 3)
+        {
+            if (line[0] == '\xEF' && line[1] == '\xBB' && line[2] == '\xBF')
+            {
+                strncpy(&line[0], &line[3], strlen(line) - 3);
+            }
+        }
+
+        if (strlen(line) >= 2)
+        {
+            if (line[0] == '/' && line[1] == '/') continue;
+        }
+
+        // check for empty string
+        line_s = line; 
+        line_s = trim(line_s, "\x0A\x0D\x20");
+        if (line_s == "") continue;
+
+        // process line without CR/LF
+        line_s = line; 
+        line_s = trim(line_s, "\x0A\x0D");
+    
+        // create word vector of vectors
+        LC_WordVector vw;
+        pos = 0;
+        while (ReadUTF8(line_s, lchar, pos))
+        {
+            // create letter set
+            LC_LetterSet vl;
+        
+            // initialize letter set with letter read
+            vl.insert(lchar);
+        
+            // find letter analogs and push them onto the vector
+            LC_AnalogMap::iterator itr = AnalogMap.find(lchar);
+            if (itr != AnalogMap.end())
+            {
+                // analogs present, iterate
+                for (LC_AnalogVector::iterator itr2 = itr->second.begin(); itr2 != itr->second.end(); itr2++)
+                {
+                    vl.insert(*itr2);
+                }
+            }
+        
+            // add letter vector to word vector
+            vw.push_back(vl);
+        }
+
+        // push new word to words list
+        WordList.push_back(vw);
+    }
+    
+    fclose(ma_file);
+    
+    return true;
+}
+
+void LexicsCutter::Map_Innormative_Words()
+{
+    // process all the words in the vector
+    for (unsigned int i = 0; i < WordList.size(); i++)
+    {
+        // parse all analogs in the first word letter
+        for (LC_LetterSet::iterator itr = (*WordList[i].begin()).begin(); itr != (*WordList[i].begin()).end(); itr++)
+        {
+            // map the word to its first letter variants
+            WordMap.insert(std::pair< std::string, unsigned int >(*itr, i));
+        }
+    }
+}
+
+bool LexicsCutter::Compare_Word(std::string& str, unsigned int pos, LC_WordVector word)
+{
+   std::string lchar_prev;
+    std::string lchar;
+
+   // read first letter of the word into lchar_prev
+   ReadUTF8(str, lchar, pos);    
+
+    // okay, here we go, comparing word
+    // first letter is already okay, we do begin from second and go on
+    LC_WordVector::iterator i = word.begin();
+    i++;
+    while (i != word.end())
+    {
+        // get letter from word, return false if the string is shorter
+        if (!ReadUTF8(str, lchar, pos)) return(false);
+        // check, if the letter is in the set
+        LC_LetterSet ls = *i;
+        if (ls.count(lchar) == 0)
+       {
+           // letter is not in set, but we must check, if it is not space or repeat
+           if ( (!(IgnoreMiddleSpaces && (lchar == " "))) &&
+               (!(IgnoreLetterRepeat && (lchar == lchar_prev))) )
+           {
+               // no checks viable
+               return(false);
+           }
+       }
+       else
+       {
+           // next word letter
+           i++;
+       }
+       // set previous string letter to compare if needed (this check can really conserve time)
+       if (IgnoreLetterRepeat) lchar_prev = lchar;
+   }
+    
+    return(true);
+}
+
+bool LexicsCutter::Check_Lexics(std::string& Phrase)
+{
+    std::string lchar;
+    LC_WordMap::iterator i;
+    std::pair< LC_WordMap::iterator, LC_WordMap::iterator > ii;
+
+    if (Phrase.size() == 0) return(false);
+    
+    // first, convert the string, adding spaces and removing invalid characters
+    // also create fast position vector for the new positions
+    std::string str = " ";
+    unsigned int pos = 0;
+    while (ReadUTF8(Phrase, lchar, pos))
+    {
+        if (InvalidChars.find(lchar) == std::string::npos)
+        {
+            str.append(lchar);
+        }
+    }
+    
+    // string prepared, now parse it and scan for all the words
+   unsigned int pos_prev = 0;
+    pos = 0;
+    while (ReadUTF8(str, lchar, pos))
+    {
+        // got character, now try to find wordmap for it
+        ii = WordMap.equal_range(lchar);
+        // iterate over all found words
+        for (i = ii.first; i != ii.second; i++)
+        {
+            // compare word at initial position
+            if (Compare_Word(str, pos_prev, WordList[i->second])) return(true);
+        }
+       // set initial position to the current position
+       pos_prev = pos;
+    }
+    
+    return(false);
+}
diff --git a/src/game/ChatLexicsCutter.h b/src/game/ChatLexicsCutter.h
new file mode 100644
index 0000000..38d636c
--- /dev/null
+++ b/src/game/ChatLexicsCutter.h
@@ -0,0 +1,67 @@
+/* 
+ * Copyright (C) 2005,2006,2007 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef MANGOSSERVER_CHATLEXICSCUTTER_H
+#define MANGOSSERVER_CHATLEXICSCUTTER_H
+
+typedef std::vector< std::string > LC_AnalogVector;
+typedef std::map< std::string, LC_AnalogVector > LC_AnalogMap;
+typedef std::set< std::string > LC_LetterSet;
+typedef std::vector< LC_LetterSet > LC_WordVector;
+typedef std::vector< LC_WordVector > LC_WordList;
+typedef std::multimap< std::string, unsigned int > LC_WordMap;
+
+static int trailingBytesForUTF8[256] = {
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5
+};
+
+class LexicsCutter
+{
+    protected:
+        LC_AnalogMap AnalogMap;
+        LC_WordList WordList;
+        LC_WordMap WordMap;
+
+        std::string InvalidChars;
+
+    public:
+        LexicsCutter();
+
+        static bool ReadUTF8(std::string& in, std::string& out, unsigned int& pos);
+
+        std::string trim(std::string& s, const std::string& drop = " ");
+        bool Read_Letter_Analogs(std::string& FileName);
+        bool Read_Innormative_Words(std::string& FileName);
+        void Map_Innormative_Words();
+        bool Compare_Word(std::string& str, unsigned int pos, LC_WordVector word);
+        bool Check_Lexics(std::string& Phrase);
+        
+        std::vector< std::pair< unsigned int, unsigned int > > Found;
+        bool IgnoreMiddleSpaces;
+        bool IgnoreLetterRepeat;
+};
+
+#endif
+
diff --git a/src/game/ChatLog.cpp b/src/game/ChatLog.cpp
new file mode 100644
index 0000000..ef5e203
--- /dev/null
+++ b/src/game/ChatLog.cpp
@@ -0,0 +1,855 @@
+/* 
+ * Copyright (C) 2005,2006,2007 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "Common.h"
+#include "ChatLexicsCutter.h"
+#include "ChatLog.h"
+#include "Chat.h"
+#include "Group.h"
+#include "Guild.h"
+#include "ObjectMgr.h"
+#include "SpellAuras.h"
+#include "Policies/SingletonImp.h"
+#include "Config/ConfigEnv.h"
+
+INSTANTIATE_SINGLETON_1( ChatLog );
+
+ChatLog::ChatLog()
+{
+    for (int i = 0; i <= CHATLOG_CHAT_TYPES_COUNT - 1; i++)
+    {
+        names[i] = "";
+        files[i] = NULL;
+    }
+    
+    Lexics = NULL;
+    fn_innormative = "";
+    f_innormative = NULL;
+    
+    Initialize();
+}
+
+ChatLog::~ChatLog()
+{
+    // close all files (avoiding double-close)
+    CloseAllFiles();
+
+    if (Lexics)
+    {
+        delete Lexics;
+        Lexics = NULL;
+    }
+}
+
+void ChatLog::Initialize()
+{
+    // determine, if the chat logs are enabled
+    ChatLogEnable = sConfig.GetBoolDefault("ChatLogEnable", false);
+    ChatLogDateSplit = sConfig.GetBoolDefault("ChatLogDateSplit", false);
+    ChatLogUTFHeader = sConfig.GetBoolDefault("ChatLogUTFHeader", false);
+    ChatLogIgnoreUnprintable = sConfig.GetBoolDefault("ChatLogIgnoreUnprintable", false);
+    
+    if (ChatLogEnable)
+    {
+        // read chat log file names
+        names[CHAT_LOG_CHAT] = sConfig.GetStringDefault("ChatLogChatFile", "");
+        names[CHAT_LOG_PARTY] = sConfig.GetStringDefault("ChatLogPartyFile", "");
+        names[CHAT_LOG_GUILD] = sConfig.GetStringDefault("ChatLogGuildFile", "");
+        names[CHAT_LOG_WHISPER] = sConfig.GetStringDefault("ChatLogWhisperFile", "");
+        names[CHAT_LOG_CHANNEL] = sConfig.GetStringDefault("ChatLogChannelFile", "");
+        names[CHAT_LOG_RAID] = sConfig.GetStringDefault("ChatLogRaidFile", "");
+        names[CHAT_LOG_BATTLEGROUND] = sConfig.GetStringDefault("ChatLogBattleGroundFile", "");
+
+        // read screen log flags
+        screenflag[CHAT_LOG_CHAT] = sConfig.GetBoolDefault("ChatLogChatScreen", false);
+        screenflag[CHAT_LOG_PARTY] = sConfig.GetBoolDefault("ChatLogPartyScreen", false);
+        screenflag[CHAT_LOG_GUILD] = sConfig.GetBoolDefault("ChatLogGuildScreen", false);
+        screenflag[CHAT_LOG_WHISPER] = sConfig.GetBoolDefault("ChatLogWhisperScreen", false);
+        screenflag[CHAT_LOG_CHANNEL] = sConfig.GetBoolDefault("ChatLogChannelScreen", false);
+        screenflag[CHAT_LOG_RAID] = sConfig.GetBoolDefault("ChatLogRaidScreen", false);
+        screenflag[CHAT_LOG_BATTLEGROUND] = sConfig.GetBoolDefault("ChatLogBattleGroundScreen", false);
+    }
+
+    // lexics cutter
+    LexicsCutterEnable = sConfig.GetBoolDefault("LexicsCutterEnable", false);
+
+    if (LexicsCutterEnable)
+    {
+        // initialize lexics cutter parameters
+        LexicsCutterInnormativeCut = sConfig.GetBoolDefault("LexicsCutterInnormativeCut", true);
+        LexicsCutterNoActionOnGM = sConfig.GetBoolDefault("LexicsCutterNoActionOnGM", true);
+        LexicsCutterScreenLog = sConfig.GetBoolDefault("LexicsCutterScreenLog", false);
+        LexicsCutterCutReplacement = sConfig.GetStringDefault("LexicsCutterCutReplacement", "&!@^%!^&*!!! [gibberish]");
+        LexicsCutterAction = sConfig.GetIntDefault("LexicsCutterAction", 0);
+        LexicsCutterActionDuration = sConfig.GetIntDefault("LexicsCutterActionDuration", 60000);
+        std::string fn_analogsfile = sConfig.GetStringDefault("LexicsCutterAnalogsFile", "");
+        std::string fn_wordsfile = sConfig.GetStringDefault("LexicsCutterWordsFile", "");
+
+        // read lexics cutter flags
+        cutflag[CHAT_LOG_CHAT] = sConfig.GetBoolDefault("LexicsCutInChat", true);
+        cutflag[CHAT_LOG_PARTY] = sConfig.GetBoolDefault("LexicsCutInParty", true);
+        cutflag[CHAT_LOG_GUILD] = sConfig.GetBoolDefault("LexicsCutInGuild", true);
+        cutflag[CHAT_LOG_WHISPER] = sConfig.GetBoolDefault("LexicsCutInWhisper", true);
+        cutflag[CHAT_LOG_CHANNEL] = sConfig.GetBoolDefault("LexicsCutInChannel", true);
+        cutflag[CHAT_LOG_RAID] = sConfig.GetBoolDefault("LexicsCutInRaid", true);
+        cutflag[CHAT_LOG_BATTLEGROUND] = sConfig.GetBoolDefault("LexicsCutInBattleGround", true);
+
+        if (fn_analogsfile == "" || fn_wordsfile == "")
+        {
+            LexicsCutterEnable = false;
+        }
+        else
+        {
+            // initialize lexics cutter
+            Lexics = new LexicsCutter;
+            if (Lexics) Lexics->Read_Letter_Analogs(fn_analogsfile);
+            if (Lexics) Lexics->Read_Innormative_Words(fn_wordsfile);
+            if (Lexics) Lexics->Map_Innormative_Words();
+
+            // read additional parameters
+            Lexics->IgnoreLetterRepeat = sConfig.GetBoolDefault("LexicsCutterIgnoreRepeats", true);
+            Lexics->IgnoreMiddleSpaces = sConfig.GetBoolDefault("LexicsCutterIgnoreSpaces", true);
+            fn_innormative = sConfig.GetStringDefault("LexicsCutterLogFile", "");
+        }
+    }
+
+    // open all files (with aliasing)
+    OpenAllFiles();
+
+    // write timestamps (init)
+    WriteInitStamps();
+}
+
+bool ChatLog::_ChatCommon(int ChatType, Player *player, std::string &msg)
+{
+    if (LexicsCutterEnable && Lexics && cutflag[ChatType] && Lexics->Check_Lexics(msg)) ChatBadLexicsAction(player, msg);
+
+    if (!ChatLogEnable) return(false);
+
+    if (ChatLogIgnoreUnprintable)
+    {
+        // have to ignore unprintables, verify string by UTF8 here
+        unsigned int pos = 0;
+        std::string lchar;
+        while (LexicsCutter::ReadUTF8(msg, lchar, pos))
+        {
+            if (lchar.size() == 1)
+            {
+                if (lchar[0] < ' ') return(false); // unprintable detected
+            }
+        }
+    }
+
+    return(true);
+}
+        
+void ChatLog::ChatMsg(Player *player, std::string &msg, uint32 type)
+{
+    if (!_ChatCommon(CHAT_LOG_CHAT, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    switch (type)
+    {
+        case CHAT_MSG_EMOTE:
+        log_str.append("{EMOTE} ");
+        break;
+
+        case CHAT_MSG_YELL:
+        log_str.append("{YELL} ");
+        break;
+    }
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("] ");
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_CHAT]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_CHAT])
+    {
+        OutTimestamp(files[CHAT_LOG_CHAT]);
+        fprintf(files[CHAT_LOG_CHAT], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_CHAT]);
+    }
+}
+
+void ChatLog::PartyMsg(Player *player, std::string &msg)
+{
+    if (!_ChatCommon(CHAT_LOG_PARTY, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("]->GROUP:");
+    
+    Group *group = player->GetGroup();
+    if (!group)
+    {
+        log_str.append("[unknown group] ");
+    }
+    else
+    {
+        // obtain group information
+        log_str.append("[");
+
+        uint8 gm_count = group->GetMembersCount();
+        uint8 gm_count_m1 = gm_count - 1;
+        uint64 gm_leader_GUID = group->GetLeaderGUID();
+        Player *gm_member;
+
+        gm_member = objmgr.GetPlayer(gm_leader_GUID);
+        if (gm_member)
+        {
+            log_str.append(gm_member->GetName());
+            log_str.append(",");
+        }
+
+        Group::MemberSlotList g_members = group->GetMemberSlots();
+        
+        for (Group::member_citerator itr = g_members.begin(); itr != g_members.end(); itr++)
+        {
+            if (itr->guid == gm_leader_GUID) continue;
+
+            gm_member = objmgr.GetPlayer(itr->guid);
+            if (gm_member)
+            {
+                log_str.append(itr->name);
+                log_str.append(",");
+            }
+        }
+
+        log_str.erase(log_str.length() - 1);
+        log_str.append("] ");
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+    
+    if (screenflag[CHAT_LOG_PARTY]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_PARTY])
+    {
+        OutTimestamp(files[CHAT_LOG_PARTY]);
+        fprintf(files[CHAT_LOG_PARTY], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_PARTY]);
+    }
+}
+
+void ChatLog::GuildMsg(Player *player, std::string &msg, bool officer)
+{
+    if (!_ChatCommon(CHAT_LOG_GUILD, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append((officer ? "]->GUILD_OFF:" : "]->GUILD:"));
+    
+    if (!player->GetGuildId())
+    {
+        log_str.append("[unknown guild] ");
+    }
+    else
+    {
+        Guild *guild = objmgr.GetGuildById(player->GetGuildId());
+        if (!guild)
+        {
+            log_str.append("[unknown guild] ");
+        }
+        else
+        {
+            // obtain guild information
+            log_str.append("(");
+            log_str.append(guild->GetName());
+            log_str.append(") ");
+        }
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+    
+    if (screenflag[CHAT_LOG_GUILD]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_GUILD])
+    {
+        OutTimestamp(files[CHAT_LOG_GUILD]);
+        fprintf(files[CHAT_LOG_GUILD], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_GUILD]);
+    }
+}
+
+void ChatLog::WhisperMsg(Player *player, std::string &to, std::string &msg)
+{
+    if (!_ChatCommon(CHAT_LOG_WHISPER, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("]->");
+    
+    if (to.size() == 0)
+    {
+        log_str.append("[???] ");
+    }
+    else
+    {
+        normalizePlayerName(to);
+        log_str.append("[");
+        log_str.append(to);
+        log_str.append("] ");
+    }
+    
+    log_str.append(msg);
+
+    log_str.append("\n");
+    
+    if (screenflag[CHAT_LOG_WHISPER]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_WHISPER])
+    {
+        OutTimestamp(files[CHAT_LOG_WHISPER]);
+        fprintf(files[CHAT_LOG_WHISPER], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_WHISPER]);
+    }
+}
+
+void ChatLog::ChannelMsg(Player *player, std::string &channel, std::string &msg)
+{
+    if (!_ChatCommon(CHAT_LOG_CHANNEL, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("]->CHANNEL:");
+    
+    if (channel.size() == 0)
+    {
+        log_str.append("[unknown channel] ");
+    }
+    else
+    {
+        log_str.append("[");
+        log_str.append(channel);
+        log_str.append("] ");
+    }
+    
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_CHANNEL]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_CHANNEL])
+    {
+        OutTimestamp(files[CHAT_LOG_CHANNEL]);
+        fprintf(files[CHAT_LOG_CHANNEL], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_CHANNEL]);
+    }
+}
+
+void ChatLog::RaidMsg(Player *player, std::string &msg, uint32 type)
+{
+    if (!_ChatCommon(CHAT_LOG_RAID, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+
+    switch (type)
+    {
+        case CHAT_MSG_RAID:
+        log_str.append("]->RAID:");
+        break;
+
+        case CHAT_MSG_RAID_LEADER:
+        log_str.append("]->RAID_LEADER:");
+        break;
+
+        case CHAT_MSG_RAID_WARNING:
+        log_str.append("]->RAID_WARN:");
+        break;
+
+        default:
+        log_str.append("]->RAID_UNKNOWN:");
+    }
+    
+    Group *group = player->GetGroup();
+    if (!group)
+    {
+        log_str.append("[unknown raid] ");
+    }
+    else
+    {
+        // obtain group information
+        log_str.append("[");
+
+        uint8 gm_count = group->GetMembersCount();
+        uint8 gm_count_m1 = gm_count - 1;
+        uint64 gm_leader_GUID = group->GetLeaderGUID();
+        Player *gm_member;
+
+        gm_member = objmgr.GetPlayer(gm_leader_GUID);
+        if (gm_member)
+        {
+            log_str.append(gm_member->GetName());
+            log_str.append(",");
+        }
+
+        Group::MemberSlotList g_members = group->GetMemberSlots();
+    
+        for (Group::member_citerator itr = g_members.begin(); itr != g_members.end(); itr++)
+        {
+            if (itr->guid == gm_leader_GUID) continue;
+
+            gm_member = objmgr.GetPlayer(itr->guid);
+            if (gm_member)
+            {
+                log_str.append(itr->name);
+                log_str.append(",");
+            }
+        }
+    
+        log_str.erase(log_str.length() - 1);
+        log_str.append("] ");
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_RAID]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_RAID])
+    {
+        OutTimestamp(files[CHAT_LOG_RAID]);
+        fprintf(files[CHAT_LOG_RAID], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_RAID]);
+    }
+}
+
+void ChatLog::BattleGroundMsg(Player *player, std::string &msg, uint32 type)
+{
+    if (!_ChatCommon(CHAT_LOG_BATTLEGROUND, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+
+    switch (type)
+    {
+        case CHAT_MSG_BATTLEGROUND:
+        log_str.append("]->BG:");
+        break;
+
+        case CHAT_MSG_BATTLEGROUND_LEADER:
+        log_str.append("]->BG_LEADER:");
+        break;
+
+        default:
+        log_str.append("]->BG_UNKNOWN:");
+    }
+    
+    Group *group = player->GetGroup();
+    if (!group)
+    {
+        log_str.append("[unknown group] ");
+    }
+    else
+    {
+        // obtain group information
+        log_str.append("[");
+
+        uint8 gm_count = group->GetMembersCount();
+        uint8 gm_count_m1 = gm_count - 1;
+        uint64 gm_leader_GUID = group->GetLeaderGUID();
+        Player *gm_member;
+
+        gm_member = objmgr.GetPlayer(gm_leader_GUID);
+        if (gm_member)
+        {
+            log_str.append(gm_member->GetName());
+            log_str.append(",");
+        }
+
+        Group::MemberSlotList g_members = group->GetMemberSlots();
+    
+        for (Group::member_citerator itr = g_members.begin(); itr != g_members.end(); itr++)
+        {
+            if (itr->guid == gm_leader_GUID) continue;
+
+            gm_member = objmgr.GetPlayer(itr->guid);
+            if (gm_member)
+            {
+                log_str.append(itr->name);
+                log_str.append(",");
+            }
+        }
+    
+        log_str.erase(log_str.length() - 1);
+        log_str.append("] ");
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_BATTLEGROUND]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_BATTLEGROUND])
+    {
+        OutTimestamp(files[CHAT_LOG_BATTLEGROUND]);
+        fprintf(files[CHAT_LOG_BATTLEGROUND], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_BATTLEGROUND]);
+    }
+}
+
+void ChatLog::OpenAllFiles()
+{
+    std::string tempname;
+    char dstr[12];
+
+    if (ChatLogDateSplit)
+    {
+        time_t t = time(NULL);
+        tm* aTm = localtime(&t);
+        sprintf(dstr, "%-4d-%02d-%02d", aTm->tm_year + 1900, aTm->tm_mon + 1, aTm->tm_mday);
+    }
+
+    if (ChatLogEnable)
+    {
+        for (int i = 0; i <= CHATLOG_CHAT_TYPES_COUNT - 1; i++)
+        {
+            if (names[i] != "")
+            {
+                for (int j = i - 1; j >= 0; j--)
+                {
+                    if (names[i] == names[j])
+                    {
+                        files[i] = files[j];
+                        break;
+                    }
+                }
+                if (!files[i])
+                {
+                    tempname = names[i];
+                    if (ChatLogDateSplit)
+                    {
+                        // append date instead of $d if applicable
+                        int dpos = tempname.find("$d");
+                        if (dpos != tempname.npos)
+                        {
+                            tempname.replace(dpos, 2, &dstr[0], 10);
+                        }
+                    }
+                    files[i] = fopen(tempname.c_str(), "a+b");
+                    if (ChatLogUTFHeader && (ftell(files[i]) == 0)) fputs("\xEF\xBB\xBF", files[i]);
+                }
+            }
+        }
+    }
+
+    // initialize innormative log
+    if (LexicsCutterEnable)
+    {
+        if (fn_innormative != "")
+        {
+            tempname = fn_innormative;
+            if (ChatLogDateSplit)
+            {
+                // append date instead of $d if applicable
+                int dpos = tempname.find("$d");
+                if (dpos != tempname.npos)
+                {
+                    tempname.replace(dpos, 2, &dstr[0], 10);
+                }
+            }
+            f_innormative = fopen(tempname.c_str(), "a+b");
+            if (ChatLogUTFHeader && (ftell(f_innormative) == 0)) fputs("\xEF\xBB\xBF", f_innormative);
+        }
+    }
+}
+
+void ChatLog::CloseAllFiles()
+{
+    for (int i = 0; i <= CHATLOG_CHAT_TYPES_COUNT - 1; i++)
+    {
+        if (files[i])
+        {
+            for (int j = i + 1; j <= CHATLOG_CHAT_TYPES_COUNT - 1; j++)
+            {
+                if (files[j] == files[i]) files[j] = NULL;
+            }
+        
+            fclose(files[i]);
+            files[i] = NULL;
+        }
+    }
+
+    if (f_innormative)
+    {
+        fclose(f_innormative);
+        f_innormative = NULL;
+    }
+}
+
+void ChatLog::CheckDateSwitch()
+{
+    if (ChatLogDateSplit)
+    {
+        time_t t = time(NULL);
+        tm* aTm = localtime(&t);
+        if (lastday != aTm->tm_mday)
+        {
+            // date switched
+            CloseAllFiles();
+            OpenAllFiles();
+            WriteInitStamps();
+        }
+    }
+}
+
+void ChatLog::WriteInitStamps()
+{
+    // remember date
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    lastday = aTm->tm_mday;
+
+    if (files[CHAT_LOG_CHAT])
+    {
+        OutTimestamp(files[CHAT_LOG_CHAT]);
+        fprintf(files[CHAT_LOG_CHAT], "%s", "[SYSTEM] Chat Log Initialized\n");
+    }
+    if (files[CHAT_LOG_PARTY])
+    {
+        OutTimestamp(files[CHAT_LOG_PARTY]);
+        fprintf(files[CHAT_LOG_PARTY], "%s", "[SYSTEM] Party Chat Log Initialized\n");
+    }
+    if (files[CHAT_LOG_GUILD])
+    {
+        OutTimestamp(files[CHAT_LOG_GUILD]);
+        fprintf(files[CHAT_LOG_GUILD], "%s", "[SYSTEM] Guild Chat Log Initialized\n");
+    }
+    if (files[CHAT_LOG_WHISPER])
+    {
+        OutTimestamp(files[CHAT_LOG_WHISPER]);
+        fprintf(files[CHAT_LOG_WHISPER], "%s", "[SYSTEM] Whisper Log Initialized\n");
+    }
+    if (files[CHAT_LOG_CHANNEL])
+    {
+        OutTimestamp(files[CHAT_LOG_CHANNEL]);
+        fprintf(files[CHAT_LOG_CHANNEL], "%s", "[SYSTEM] Chat Channels Log Initialized\n");
+    }
+    if (files[CHAT_LOG_RAID])
+    {
+        OutTimestamp(files[CHAT_LOG_RAID]);
+        fprintf(files[CHAT_LOG_RAID], "%s", "[SYSTEM] Raid Party Chat Log Initialized\n");
+    }
+
+    if (f_innormative)
+    {
+        OutTimestamp(f_innormative);
+        fprintf(f_innormative, "%s", "[SYSTEM] Innormative Lexics Log Initialized\n");
+    }
+}
+
+void ChatLog::OutTimestamp(FILE* file)
+{
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    fprintf(file, "%-4d-%02d-%02d %02d:%02d:%02d ", aTm->tm_year + 1900, aTm->tm_mon + 1, aTm->tm_mday, aTm->tm_hour, aTm->tm_min, aTm->tm_sec);
+}
+
+void ChatLog::ChatBadLexicsAction(Player* player, std::string& msg)
+{
+    // logging
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("] ");
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (LexicsCutterScreenLog) printf("<INNORMATIVE!> %s", log_str.c_str());
+    if (f_innormative)
+    {
+        OutTimestamp(f_innormative);
+        fprintf(f_innormative, "%s", log_str.c_str());
+        fflush(f_innormative);
+    }
+
+    // cutting innormative lexics
+    if (LexicsCutterInnormativeCut)
+    {
+        msg = LexicsCutterCutReplacement;
+    }
+
+    if (!player || !player->GetSession()) return;
+
+    if (LexicsCutterNoActionOnGM && player->GetSession()->GetSecurity()) return;
+
+    // special action
+    const SpellEntry* sl;
+
+    switch (LexicsCutterAction)
+    {
+        case LEXICS_ACTION_SHEEP:
+        {
+            // sheep me, yeah, yeah, sheep me
+            sl = sSpellStore.LookupEntry(118);
+            if (sl)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    Aura* Aur = CreateAura(sl, i, NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        case LEXICS_ACTION_STUN:
+        {
+            // stunned surprised
+            sl = sSpellStore.LookupEntry(13005);
+            if (sl)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    Aura* Aur = CreateAura(sl, i, NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        case LEXICS_ACTION_DIE:
+        {
+            // oops, kicked the bucket
+            player->DealDamage(player, player->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }
+        break;
+
+        case LEXICS_ACTION_DRAIN:
+        {
+            // living corpse :)
+            player->DealDamage(player, player->GetHealth() - 5, NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }
+        break;
+
+
+        case LEXICS_ACTION_SILENCE:
+        {
+            // glue the mouth
+            time_t mutetime = time(NULL) + (int) (LexicsCutterActionDuration / 1000);
+            player->GetSession()->m_muteTime = mutetime;
+        }
+        break;
+
+        case LEXICS_ACTION_STUCK:
+        {
+            // yo, the Matrix has had you :) [by KAPATEJIb]
+            sl = sSpellStore.LookupEntry(23312);
+            if (sl)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    Aura* Aur = CreateAura(sl, i, NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        case LEXICS_ACTION_SICKNESS:
+        {
+            // for absence of censorship, there is punishment [by Koshei]
+            sl = sSpellStore.LookupEntry(15007);
+            if (sl)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    Aura* Aur = CreateAura(sl, i, NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        case LEXICS_ACTION_SHEAR:
+        {
+            // Lord Illidan to watch you [by Koshei]
+            sl = sSpellStore.LookupEntry(41032);
+            if (sl)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    Aura* Aur = CreateAura(sl, i, NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        default:
+        // no action except logging
+        break;
+    }
+}
diff --git a/src/game/ChatLog.h b/src/game/ChatLog.h
new file mode 100644
index 0000000..7460b92
--- /dev/null
+++ b/src/game/ChatLog.h
@@ -0,0 +1,107 @@
+/* 
+ * Copyright (C) 2005,2006,2007 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef MANGOSSERVER_CHATLOG_H
+#define MANGOSSERVER_CHATLOG_H
+
+#include "SharedDefines.h"
+#include "ChatLexicsCutter.h"
+#include "ObjectMgr.h"
+#include "Policies/Singleton.h"
+
+#define CHATLOG_CHAT_TYPES_COUNT 7
+
+enum ChatLogFiles
+{
+    CHAT_LOG_CHAT = 0,
+    CHAT_LOG_PARTY = 1,
+    CHAT_LOG_GUILD = 2,
+    CHAT_LOG_WHISPER = 3,
+    CHAT_LOG_CHANNEL = 4,
+    CHAT_LOG_RAID = 5,
+    CHAT_LOG_BATTLEGROUND = 6,
+};
+
+enum LexicsActions
+{
+    LEXICS_ACTION_LOG = 0,
+    LEXICS_ACTION_SHEEP = 1,
+    LEXICS_ACTION_STUN = 2,
+    LEXICS_ACTION_DIE = 3,
+    LEXICS_ACTION_DRAIN = 4,
+    LEXICS_ACTION_SILENCE = 5,
+    LEXICS_ACTION_STUCK = 6,
+    LEXICS_ACTION_SICKNESS = 7,
+    LEXICS_ACTION_SHEAR = 8,
+};
+
+class ChatLog : public MaNGOS::Singleton<ChatLog, MaNGOS::ClassLevelLockable<ChatLog, ZThread::FastMutex> >
+{
+    public:
+        ChatLog();
+        ~ChatLog();
+
+        void Initialize();
+        
+        void ChatMsg(Player *player, std::string &msg, uint32 type);
+        void PartyMsg(Player *player, std::string &msg);
+        void GuildMsg(Player *player, std::string &msg, bool officer);
+        void WhisperMsg(Player *player, std::string &to, std::string &msg);
+        void ChannelMsg(Player *player, std::string &channel, std::string &msg);
+        void RaidMsg(Player *player, std::string &msg, uint32 type);
+        void BattleGroundMsg(Player *player, std::string &msg, uint32 type);
+        
+        void ChatBadLexicsAction(Player *player, std::string &msg);
+        
+    private:
+        bool _ChatCommon(int ChatType, Player *player, std::string &msg);
+
+        bool ChatLogEnable;
+        bool ChatLogDateSplit;
+        bool ChatLogUTFHeader;
+        bool ChatLogIgnoreUnprintable;
+
+        int lastday;
+   
+        FILE* files[CHATLOG_CHAT_TYPES_COUNT];
+        std::string names[CHATLOG_CHAT_TYPES_COUNT];
+        bool screenflag[CHATLOG_CHAT_TYPES_COUNT];
+   
+        LexicsCutter* Lexics;
+        bool cutflag[CHATLOG_CHAT_TYPES_COUNT];
+
+        bool LexicsCutterEnable;
+        bool LexicsCutterInnormativeCut;
+        bool LexicsCutterNoActionOnGM;
+        bool LexicsCutterScreenLog;
+        std::string LexicsCutterCutReplacement;
+        int LexicsCutterAction;
+        int LexicsCutterActionDuration;
+        std::string fn_innormative;
+        FILE* f_innormative;
+
+        void OpenAllFiles();
+        void CloseAllFiles();
+        void CheckDateSwitch();
+
+        void WriteInitStamps();
+        void OutTimestamp(FILE *file);
+};
+
+#define sChatLog MaNGOS::Singleton<ChatLog>::Instance()
+#endif
diff --git a/src/game/Group.cpp b/src/game/Group.cpp
index cb03eda..ebf4916 100644
--- a/src/game/Group.cpp
+++ b/src/game/Group.cpp
@@ -1298,6 +1298,54 @@ void Group::UpdateLooterGuid( Creature* creature, bool ifneed )
     SendUpdate();
 }
 
+uint32 Group::CanJoinBattleGroundQueue(uint32 bgTypeId, uint32 bgQueueType, uint32 MinPlayerCount, uint32 MaxPlayerCount, bool isRated, uint32 arenaSlot)
+{
+    // check for min / max count
+    uint32 memberscount = GetMembersCount();
+    if(memberscount < MinPlayerCount)
+        return BG_JOIN_ERR_GROUP_NOT_ENOUGH;
+    if(memberscount > MaxPlayerCount)
+        return BG_JOIN_ERR_GROUP_TOO_MANY;
+
+    // get a player as reference, to compare other players' stats to (arena team id, queue id based on level, etc.)
+    Player * reference = GetFirstMember()->getSource();
+    // no reference found, can't join this way
+    if(!reference)
+        return BG_JOIN_ERR_OFFLINE_MEMBER;
+
+    uint32 bgQueueId = reference->GetBattleGroundQueueIdFromLevel();
+    uint32 arenaTeamId = reference->GetArenaTeamId(arenaSlot);
+    uint32 team = reference->GetTeam();
+
+    // check every member of the group to be able to join
+    for(GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player *member = itr->getSource();
+        // offline member? don't let join
+        if(!member)
+            return BG_JOIN_ERR_OFFLINE_MEMBER;
+        // don't allow cross-faction join as group
+        if(member->GetTeam() != team)
+            return BG_JOIN_ERR_MIXED_FACTION;
+        // not in the same battleground level braket, don't let join
+        if(member->GetBattleGroundQueueIdFromLevel() != bgQueueId)
+            return BG_JOIN_ERR_MIXED_LEVELS;
+        // don't let join rated matches if the arena team id doesn't match
+        if(isRated && member->GetArenaTeamId(arenaSlot) != arenaTeamId)
+            return BG_JOIN_ERR_MIXED_ARENATEAM;
+        // don't let join if someone from the group is already in that bg queue
+        if(member->InBattleGroundQueueForBattleGroundQueueType(bgQueueType))
+            return BG_JOIN_ERR_GROUP_MEMBER_ALREADY_IN_QUEUE;
+        // check for deserter debuff in case not arena queue
+        if(bgTypeId != BATTLEGROUND_AA && !member->CanJoinToBattleground())
+            return BG_JOIN_ERR_GROUP_DESERTER;
+        // check if member can join any more battleground queues
+        if(!member->HasFreeBattleGroundQueueId())
+            return BG_JOIN_ERR_ALL_QUEUES_USED;
+    }
+    return BG_JOIN_ERR_OK;
+}
+
 //===================================================
 //============== Roll ===============================
 //===================================================
diff --git a/src/game/Group.h b/src/game/Group.h
index 6160fd0..52a1188 100644
--- a/src/game/Group.h
+++ b/src/game/Group.h
@@ -234,6 +234,7 @@ class MANGOS_DLL_SPEC Group
         void ConvertToRaid();
 
         void SetBattlegroundGroup(BattleGround *bg) { m_bgGroup = bg; }
+        uint32 CanJoinBattleGroundQueue(uint32 bgTypeId, uint32 bgQueueType, uint32 MinPlayerCount, uint32 MaxPlayerCount, bool isRated, uint32 arenaSlot);
 
         void ChangeMembersGroup(const uint64 &guid, const uint8 &group);
         void ChangeMembersGroup(Player *player, const uint8 &group);
diff --git a/src/game/GuardAI.cpp b/src/game/GuardAI.cpp
index 5672f14..b07146d 100644
--- a/src/game/GuardAI.cpp
+++ b/src/game/GuardAI.cpp
@@ -50,7 +50,7 @@ void GuardAI::MoveInLineOfSight(Unit *u)
         {
             //Need add code to let guard support player
             AttackStart(u);
-            u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
+            //u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
         }
     }
 }
diff --git a/src/game/Language.h b/src/game/Language.h
index ad5a2b4..ad8a0f1 100644
--- a/src/game/Language.h
+++ b/src/game/Language.h
@@ -21,6 +21,8 @@
 
 enum MangosStrings
 {
+	LANG_AUTO_BROADCAST                 = 2001,
+
     // for chat commands
     LANG_SELECT_CHAR_OR_CREATURE        = 1,
     LANG_SELECT_CREATURE                = 2,
@@ -641,11 +643,30 @@ enum MangosStrings
     LANG_BG_QUEUE_ANNOUNCE_SELF         = 711,
     LANG_BG_QUEUE_ANNOUNCE_WORLD        = 712,
 
+
     LANG_YOUR_ARENA_LEVEL_REQ_ERROR     = 713,
     LANG_HIS_ARENA_LEVEL_REQ_ERROR      = 714,
     LANG_YOUR_BG_LEVEL_REQ_ERROR        = 715,
     LANG_YOUR_ARENA_TEAM_FULL           = 716,
-    // Room for BG/ARENA                  717-799 not used
+
+    LANG_BG_GROUP_TOO_LARGE             = 7007, // "Your group is too large for this battleground. Please regroup to join."
+    LANG_ARENA_GROUP_TOO_LARGE          = 7008, // "Your group is too large for this arena. Please regroup to join."
+    LANG_ARENA_YOUR_TEAM_ONLY           = 7009, // "Your group has members not in your arena team. Please regroup to join."
+    LANG_ARENA_NOT_ENOUGH_PLAYERS       = 7010, // "Your group does not have enough players to join this match."
+    LANG_ARENA_GOLD_WINS                = 7011, // "The Gold Team wins!"
+    LANG_ARENA_GREEN_WINS               = 7012, // "The Green Team wins!"
+    LANG_BATTLEGROUND_PREMATURE_FINISH_WARNING = 7013,   // The battleground will end soon, because there aren't enough players. Get more ppl or win already!
+    LANG_BG_GROUP_OFFLINE_MEMBER        = 7014, // "Your group has an offline member. Please remove him before joining."
+    LANG_BG_GROUP_MIXED_FACTION         = 7015, // "Your group has players from the opposing faction. You can't join the battleground as a group."
+    LANG_BG_GROUP_MIXED_LEVELS          = 7016, // "Your group has players from different battleground brakets. You can't join as group."
+    LANG_BG_GROUP_MEMBER_ALREADY_IN_QUEUE = 7017, // "Someone in your party is already in this battleground queue. (S)he must leave it before joining as group."
+    LANG_BG_GROUP_MEMBER_DESERTER       = 7018, // "Someone in your party is Deserter. You can't join as group."
+    LANG_BG_GROUP_MEMBER_NO_FREE_QUEUE_SLOTS = 7019, // "Someone in your party is already in three battleground queues. You cannot join as group."
+
+    LANG_CANNOT_TELE_TO_BG              = 7020, // "You cannot teleport to a battleground or arena map."
+    LANG_CANNOT_SUMMON_TO_BG            = 7021, // "You cannot summon players to a battleground or arena map."
+    LANG_CANNOT_GO_TO_BG_GM             = 7022, // "You must be in GM mode to teleport to a player in a battleground."
+    LANG_CANNOT_GO_TO_BG_FROM_BG        = 7023, // "You cannot teleport to a battleground from another battleground. Please leave the current battleground first."
 
     // in game strings
     //                                  = 800, not used
diff --git a/src/game/Level1.cpp b/src/game/Level1.cpp
index 3bb2475..49cea90 100644
--- a/src/game/Level1.cpp
+++ b/src/game/Level1.cpp
@@ -351,7 +351,14 @@ bool ChatHandler::HandleNamegoCommand(const char* args)
 
         Map* pMap = MapManager::Instance().GetMap(m_session->GetPlayer()->GetMapId(),m_session->GetPlayer());
 
-        if(pMap->Instanceable())
+        if(pMap->IsBattleGroundOrArena())
+        {
+            // cannot summon to bg
+            PSendSysMessage(LANG_CANNOT_SUMMON_TO_BG,chr->GetName());
+            SetSentErrorMessage(true);
+            return false;
+        }
+        else if(pMap->IsDungeon())
         {
             Map* cMap = MapManager::Instance().GetMap(chr->GetMapId(),chr);
             if( cMap->Instanceable() && cMap->GetInstanceId() != pMap->GetInstanceId() )
@@ -436,7 +443,27 @@ bool ChatHandler::HandleGonameCommand(const char* args)
     if (chr)
     {
         Map* cMap = MapManager::Instance().GetMap(chr->GetMapId(),chr);
-        if(cMap->Instanceable())
+        if(cMap->IsBattleGroundOrArena())
+        {
+            // only allow if gm mode is on
+            if (!_player->isGameMaster())
+            {
+                PSendSysMessage(LANG_CANNOT_GO_TO_BG_GM,chr->GetName());
+                SetSentErrorMessage(true);
+                return false;
+            }
+            // if already in a bg, don't let port to other
+            else if (_player->GetBattleGroundId())
+            {
+                PSendSysMessage(LANG_CANNOT_GO_TO_BG_FROM_BG,chr->GetName());
+                SetSentErrorMessage(true);
+                return false;
+            }
+            // all's well, set bg id
+            // when porting out from the bg, it will be reset to 0
+            _player->SetBattleGroundId(chr->GetBattleGroundId());
+        }
+        else if(cMap->IsDungeon())
         {
             // we have to go to instance, and can go to player only if:
             //   1) we are in his group (either as leader or as member)
@@ -1188,7 +1215,7 @@ bool ChatHandler::HandleModifyScaleCommand(const char* args)
         return false;
 
     float Scale = (float)atof((char*)args);
-    if (Scale > 3.0f || Scale <= 0.0f)
+    if (Scale > 15.0f || Scale <= 0.0f)
     {
         SendSysMessage(LANG_BAD_VALUE);
         SetSentErrorMessage(true);
diff --git a/src/game/Level3.cpp b/src/game/Level3.cpp
index 8d7e412..7a1a03f 100644
--- a/src/game/Level3.cpp
+++ b/src/game/Level3.cpp
@@ -47,6 +47,7 @@
 #include "Config/ConfigEnv.h"
 #include "Util.h"
 #include "ItemEnchantmentMgr.h"
+#include "BattleGroundMgr.h"
 #include "InstanceSaveMgr.h"
 #include "InstanceData.h"
 
@@ -4855,6 +4856,92 @@ bool ChatHandler::HandleCompleteQuest(const char* args)
     return true;
 }
 
+bool ChatHandler::HandleAHExpireCommand(const char* args)
+{
+   if (args == NULL)
+      return false;
+
+   char* ahMapIdStr = strtok((char*) args, " ");
+   char* playerGuidStr = strtok(NULL, " ");
+
+   if ((ahMapIdStr == NULL) || (playerGuidStr == NULL))
+      return false;
+
+   uint32 ahMapID = (uint32) strtoul(ahMapIdStr, NULL, 0);
+   uint32 playerGUID = (uint32) strtoul(playerGuidStr, NULL, 0);
+
+   AuctionHouseObject* auctionHouse = objmgr.GetAuctionsMap(ahMapID);
+
+   if (auctionHouse == NULL)
+      return false;
+
+   AuctionHouseObject::AuctionEntryMap::iterator itr;
+   itr = auctionHouse->GetAuctionsBegin();
+
+   while (itr != auctionHouse->GetAuctionsEnd())
+   {
+      if (itr->second->owner == playerGUID)
+         itr->second->time = sWorld.GetGameTime();
+
+      ++itr;
+   }
+
+   return true;
+}
+
+bool ChatHandler::HandleAHDeleteCommand(const char* args)
+{
+   if (args == NULL)
+      return false;
+
+   char* ahMapIdStr = strtok((char*) args, " ");
+   char* playerGuidStr = strtok(NULL, " ");
+
+   if ((ahMapIdStr == NULL) || (playerGuidStr == NULL))
+      return false;
+
+   uint32 ahMapID = (uint32) strtoul(ahMapIdStr, NULL, 0);
+   uint32 playerGUID = (uint32) strtoul(playerGuidStr, NULL, 0);
+
+   AuctionHouseObject* auctionHouse = objmgr.GetAuctionsMap(ahMapID);
+
+   if (auctionHouse == NULL)
+      return false;
+
+   AuctionHouseObject::AuctionEntryMap::iterator itr;
+   itr = auctionHouse->GetAuctionsBegin();
+
+   while (itr != auctionHouse->GetAuctionsEnd())
+   {
+      AuctionHouseObject::AuctionEntryMap::iterator tmp = itr;
+      ++itr;
+
+      if (tmp->second->owner != playerGUID)
+         continue;
+
+      Item* item = objmgr.GetAItem(tmp->second->item_guidlow);
+      if (item != NULL)
+      {
+         objmgr.RemoveAItem(tmp->second->item_guidlow);
+         item->DeleteFromDB();
+         delete item;
+      }
+      else
+      {
+         sLog.outString("ahdelete: "
+                        "clearing auction for non-existant item_guidlow (%d)",
+                        tmp->second->item_guidlow);
+      }
+
+      CharacterDatabase.PExecute("DELETE FROM `auctionhouse` WHERE `id` = '%u'",
+                                 tmp->second->Id);
+      auctionHouse->RemoveAuction(tmp->second->Id);
+      delete tmp->second;
+   }
+
+   return true;
+}
+
 bool ChatHandler::HandleBanAccountCommand(const char* args)
 {
     return HandleBanHelper(BAN_ACCOUNT,args);
@@ -6407,6 +6494,12 @@ bool ChatHandler::HandleSendMessageCommand(const char* args)
     return true;
 }
 
+bool ChatHandler::HandleFlushArenaPointsCommand(const char * /*args*/)
+{
+    sBattleGroundMgr.DistributeArenaPoints();
+    return true;
+}
+
 bool ChatHandler::HandleModifyGenderCommand(const char *args)
 {
     if(!*args)
diff --git a/src/game/Makefile.am b/src/game/Makefile.am
index 03dbeef..51cfdd1 100644
--- a/src/game/Makefile.am
+++ b/src/game/Makefile.am
@@ -38,6 +38,8 @@ libmangosgame_a_SOURCES = \
     ArenaTeam.cpp \
     ArenaTeam.h \
     ArenaTeamHandler.cpp \
+    AuctionHouseBot.cpp \
+    AuctionHouseBot.h \
     AuctionHouse.cpp \
     AuctionHouseObject.h \
     Bag.cpp \
@@ -73,6 +75,10 @@ libmangosgame_a_SOURCES = \
     Chat.cpp \
     Chat.h \
     ChatHandler.cpp \
+    ChatLexicsCutter.cpp \
+    ChatLexicsCutter.h \
+    ChatLog.cpp \
+    ChatLog.h \
     CombatHandler.cpp \
     ConfusedMovementGenerator.cpp \
     ConfusedMovementGenerator.h \
diff --git a/src/game/MapInstanced.cpp b/src/game/MapInstanced.cpp
index 79a8b88..ce4be94 100644
--- a/src/game/MapInstanced.cpp
+++ b/src/game/MapInstanced.cpp
@@ -141,7 +141,17 @@ Map* MapInstanced::GetInstance(const WorldObject* obj)
             uint32 NewInstanceId = 0;                       // instanceId of the resulting map
             Player* player = (Player*)obj;
 
-            // TODO: battlegrounds and arenas
+            if(IsBattleGroundOrArena())
+            {
+                // instantiate or find existing bg map for player
+                // the instance id is set in battlegroundid
+                NewInstanceId = player->GetBattleGroundId();
+                assert(NewInstanceId);
+                map = _FindMap(NewInstanceId);
+                if(!map)
+                    map = CreateBattleGround(NewInstanceId);
+                return map;
+            }
 
             InstancePlayerBind *pBind = player->GetBoundInstance(GetId(), player->GetDifficulty());
             InstanceSave *pSave = pBind ? pBind->save : NULL;
diff --git a/src/game/MapManager.cpp b/src/game/MapManager.cpp
index e044b10..ede8e49 100644
--- a/src/game/MapManager.cpp
+++ b/src/game/MapManager.cpp
@@ -107,7 +107,7 @@ MapManager::_GetBaseMap(uint32 id)
         Guard guard(*this);
 
         const MapEntry* entry = sMapStore.LookupEntry(id);
-        if (entry && entry->IsDungeon())
+        if (entry && entry->Instanceable())
         {
             m = new MapInstanced(id, i_gridCleanUpDelay);
         }
diff --git a/src/game/MiscHandler.cpp b/src/game/MiscHandler.cpp
index 5c40964..7c3cf98 100644
--- a/src/game/MiscHandler.cpp
+++ b/src/game/MiscHandler.cpp
@@ -661,6 +661,10 @@ void WorldSession::HandleCorpseReclaimOpcode(WorldPacket &recv_data)
     if (GetPlayer()->isAlive())
         return;
 
+    if (BattleGround * bg = _player->GetBattleGround())
+        if(bg->isArena())
+            return;
+
     // body not released yet
     if(!GetPlayer()->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
         return;
diff --git a/src/game/MovementHandler.cpp b/src/game/MovementHandler.cpp
index a171e7b..e516115 100644
--- a/src/game/MovementHandler.cpp
+++ b/src/game/MovementHandler.cpp
@@ -30,6 +30,9 @@
 #include "WaypointMovementGenerator.h"
 #include "InstanceSaveMgr.h"
 
+/*Movement anticheat DEBUG defines */
+//#define MOVEMENT_ANTICHEAT_DEBUG true
+/*end Movement anticheate defines*/
 void WorldSession::HandleMoveWorldportAckOpcode( WorldPacket & /*recv_data*/ )
 {
     sLog.outDebug( "WORLD: got MSG_MOVE_WORLDPORT_ACK." );
@@ -47,7 +50,8 @@ void WorldSession::HandleMoveWorldportAckOpcode()
         LogoutPlayer(false);
         return;
     }
-
+    //reset falltimer at teleport
+    GetPlayer()->m_anti_justteleported = 1;
     // get the destination map entry, not the current one, this will fix homebind and reset greeting
     MapEntry const* mEntry = sMapStore.LookupEntry(loc.mapid);
     InstanceTemplate const* mInstance = objmgr.GetInstanceTemplate(loc.mapid);
@@ -130,22 +134,28 @@ void WorldSession::HandleMoveWorldportAckOpcode()
         _player->RemoveSpellsCausingAura(SPELL_AURA_MOUNTED);
 
     // battleground state prepare
-    if(_player->InBattleGround())
+    // only add to bg group and object, if the player was invited (else he entered through command)
+    if(_player->InBattleGround() && _player->IsInvitedForBattleGroundInstance(_player->GetBattleGroundId()))
     {
         BattleGround *bg = _player->GetBattleGround();
         if(bg)
         {
+            bg->AddPlayer(_player);
             if(bg->GetMapId() == _player->GetMapId())       // we teleported to bg
             {
-                if(!bg->GetBgRaid(_player->GetTeam()))      // first player joined
+                // get the team this way, because arenas might 'override' the teams.
+                uint32 team = bg->GetPlayerTeam(_player->GetGUID());
+                if(!team)
+                    team = _player->GetTeam();
+                if(!bg->GetBgRaid(team))      // first player joined
                 {
                     Group *group = new Group;
-                    bg->SetBgRaid(_player->GetTeam(), group);
+                    bg->SetBgRaid(team, group);
                     group->Create(_player->GetGUIDLow(), _player->GetName());
                 }
                 else                                        // raid already exist
                 {
-                    bg->GetBgRaid(_player->GetTeam())->AddMember(_player->GetGUID(), _player->GetName());
+                    bg->GetBgRaid(team)->AddMember(_player->GetGUID(), _player->GetName());
                 }
             }
         }
@@ -172,8 +182,13 @@ void WorldSession::HandleMovementOpcodes( WorldPacket & recv_data )
 {
     CHECK_PACKET_SIZE(recv_data, 4+1+4+4+4+4+4);
 
-    if(GetPlayer()->GetDontMove())
+    if(GetPlayer()->GetDontMove()){
+        GetPlayer()->m_anti_justteleported = 1;
         return;
+    }
+
+    //get opcode
+    uint16 opcode = recv_data.GetOpcode();
 
     /* extract packet */
     MovementInfo movementInfo;
@@ -251,47 +266,77 @@ void WorldSession::HandleMovementOpcodes( WorldPacket & recv_data )
     {
         // transports size limited
         // (also received at zeppelin leave by some reason with t_* as absolute in continent coordinates, can be safely skipped)
-        if( movementInfo.t_x > 50 || movementInfo.t_y > 50 || movementInfo.t_z > 50 )
+        if( movementInfo.t_x > 60 || movementInfo.t_y > 60 || movementInfo.t_z > 60 )
             return;
 
         if( !MaNGOS::IsValidMapCoord(movementInfo.x+movementInfo.t_x, movementInfo.y+movementInfo.t_y,
             movementInfo.z+movementInfo.t_z, movementInfo.o+movementInfo.t_o) )
             return;
-
-        // if we boarded a transport, add us to it
-        if (!GetPlayer()->m_transport)
+        if ((GetPlayer()->m_anti_transportGUID == 0) && (movementInfo.t_guid !=0))
         {
-            // elevators also cause the client to send MOVEMENTFLAG_ONTRANSPORT - just unmount if the guid can be found in the transport list
-            for (MapManager::TransportSet::iterator iter = MapManager::Instance().m_Transports.begin(); iter != MapManager::Instance().m_Transports.end(); ++iter)
+            // if we boarded a transport, add us to it
+            if (!GetPlayer()->m_transport)
             {
-                if ((*iter)->GetGUID() == movementInfo.t_guid)
+                // elevators also cause the client to send MOVEMENTFLAG_ONTRANSPORT - just unmount if the guid can be found in the transport list
+                for (MapManager::TransportSet::iterator iter = MapManager::Instance().m_Transports.begin(); iter != MapManager::Instance().m_Transports.end(); ++iter)
                 {
-                    // unmount before boarding
-                    _player->RemoveSpellsCausingAura(SPELL_AURA_MOUNTED);
-
-                    GetPlayer()->m_transport = (*iter);
-                    (*iter)->AddPassenger(GetPlayer());
-                    break;
+                    if ((*iter)->GetGUID() == movementInfo.t_guid)
+                    {
+                        // unmount before boarding
+                        _player->RemoveSpellsCausingAura(SPELL_AURA_MOUNTED);
+
+                        GetPlayer()->m_transport = (*iter);
+                        (*iter)->AddPassenger(GetPlayer());
+                        break;
+                    }
                 }
             }
+            ///GetPlayer()->m_anti_transportGUID = GUID_LOPART(movementInfo.t_guid);
+            //Correct finding GO guid in DB (thanks to GriffonHeart)
+            GameObject *obj = HashMapHolder<GameObject>::Find(movementInfo.t_guid);
+            if(obj)
+                GetPlayer()->m_anti_transportGUID = obj->GetDBTableGUIDLow();
+            else
+                GetPlayer()->m_anti_transportGUID = GUID_LOPART(movementInfo.t_guid);
         }
     }
-    else if (GetPlayer()->m_transport)                      // if we were on a transport, leave
+    else if (GetPlayer()->m_anti_transportGUID != 0)
     {
-        GetPlayer()->m_transport->RemovePassenger(GetPlayer());
-        GetPlayer()->m_transport = NULL;
+        if (GetPlayer()->m_transport)                      // if we were on a transport, leave
+        {
+            GetPlayer()->m_transport->RemovePassenger(GetPlayer());
+            GetPlayer()->m_transport = NULL;
+        }
         movementInfo.t_x = 0.0f;
         movementInfo.t_y = 0.0f;
         movementInfo.t_z = 0.0f;
         movementInfo.t_o = 0.0f;
         movementInfo.t_time = 0;
+        GetPlayer()->m_anti_transportGUID = 0;
     }
 
     // fall damage generation (ignore in flight case that can be triggered also at lags in moment teleportation to another map).
     if (recv_data.GetOpcode() == MSG_MOVE_FALL_LAND && !GetPlayer()->isInFlight())
     {
         Player *target = GetPlayer();
-
+        //movement anticheat "No Fall Damage"
+        if (target->m_anti_beginfalltime != 0)
+        {
+            #ifdef MOVEMENT_ANTICHEAT_DEBUG
+            sLog.outDebug("Movement anticheat: alternate FallTime %d | client falltime %d | m_anti_justteleported = %d",movementInfo.time - GetPlayer()->m_anti_beginfalltime, movementInfo.fallTime, GetPlayer()->m_anti_justteleported );
+            #endif
+            if (target->m_anti_justteleported != 1){
+                uint32 alt_falltime = movementInfo.time - target->m_anti_beginfalltime;
+                movementInfo.fallTime = (alt_falltime < movementInfo.fallTime) ? movementInfo.fallTime : alt_falltime;
+            } else {
+                target->m_anti_justteleported = 0;
+            }
+            target->m_anti_beginfalltime = 0;
+        }
+        #ifdef MOVEMENT_ANTICHEAT_DEBUG
+        sLog.outError("Movement anticheat: FallTime %d", movementInfo.fallTime);
+        #endif
+        //end movement anticheate
         //Players with Feather Fall or low fall time, or physical immunity (charges used) are ignored
         if (movementInfo.fallTime > 1100 && !target->isDead() && !target->isGameMaster() &&
             !target->HasAuraType(SPELL_AURA_HOVER) && !target->HasAuraType(SPELL_AURA_FEATHER_FALL) &&
@@ -348,37 +393,243 @@ void WorldSession::HandleMovementOpcodes( WorldPacket & recv_data )
         GetPlayer()->SetInWater( !GetPlayer()->IsInWater() || GetPlayer()->GetBaseMap()->IsUnderWater(movementInfo.x, movementInfo.y, movementInfo.z) );
     }
 
+    #ifdef MOVEMENT_ANTICHEAT_DEBUG
+    sLog.outBasic("%s newcoord: tm:%d ftm:%d | %f,%f,%fo(%f) [%X][%s]| transport: %f,%f,%fo(%f)",GetPlayer()->GetName(),movementInfo.time,movementInfo.fallTime,movementInfo.x,movementInfo.y,movementInfo.z,movementInfo.o,MovementFlags, LookupOpcodeName(opcode),movementInfo.t_x,movementInfo.t_y,movementInfo.t_z,movementInfo.t_o);
+    sLog.outBasic("Transport: %d |  tguid: %d - %d", GetPlayer()->m_anti_transportGUID, GUID_LOPART(movementInfo.t_guid), GUID_HIPART(movementInfo.t_guid));
+    #endif
     /*----------------------*/
+    //---- anti-cheat features -->>>
+    bool check_passed = true;
+    uint32 curDest = GetPlayer()->m_taxi.GetTaxiDestination(); //check taxi flight
+    if ((GetPlayer()->m_anti_transportGUID == 0) && World::GetEnableMvAnticheat() && !curDest)
+    {
+        UnitMoveType move_type;
+
+        if (MovementFlags & MOVEMENTFLAG_FLYING) move_type = MovementFlags & MOVEMENTFLAG_BACKWARD ? MOVE_FLYBACK : MOVE_FLY;
+        else if (MovementFlags & MOVEMENTFLAG_SWIMMING) move_type = MovementFlags & MOVEMENTFLAG_BACKWARD ? MOVE_SWIMBACK : MOVE_SWIM;
+        else if (MovementFlags & MOVEMENTFLAG_WALK_MODE) move_type = MOVE_WALK;
+        //hmm... in first time after login player has MOVE_SWIMBACK instead MOVE_WALKBACK
+        else move_type = MovementFlags & MOVEMENTFLAG_BACKWARD ? MOVE_SWIMBACK : MOVE_RUN;
+
+        float allowed_delta= 0;
+        float current_speed = GetPlayer()->GetSpeed(move_type);
+        float delta_x = GetPlayer()->GetPositionX() - movementInfo.x;
+        float delta_y = GetPlayer()->GetPositionY() - movementInfo.y;
+        float delta_z = GetPlayer()->GetPositionZ() - movementInfo.z;
+        float real_delta = delta_x * delta_x + delta_y * delta_y;
+        float tg_z = -99999; //tangens
+        float time_delta = movementInfo.time - GetPlayer()->m_anti_lastmovetime;
+        if (time_delta > 0) {
+            GetPlayer()->m_anti_lastmovetime = movementInfo.time;
+        } else {time_delta = 0;}
+        time_delta = (time_delta < 1500) ? time_delta/1000 : 1.5f; //normalize time - 1.5 second allowed for heavy loaded server
+
+        if (!(MovementFlags & (MOVEMENTFLAG_FLYING | MOVEMENTFLAG_SWIMMING)))
+          tg_z = (real_delta !=0) ? (delta_z*delta_z / real_delta) : -99999;
+
+        //antiOFF fall-damage, MOVEMENTFLAG_UNK4 seted by client if player try movement when falling and unset in this case the MOVEMENTFLAG_FALLING flag.
+        if (MovementFlags & (MOVEMENTFLAG_FALLING | MOVEMENTFLAG_UNK4 | MOVEMENTFLAG_JUMPING))
+        {
+            if (GetPlayer()->m_anti_beginfalltime == 0)
+            {
+                GetPlayer()->m_anti_beginfalltime = movementInfo.time;
+                #ifdef MOVEMENT_ANTICHEAT_DEBUG
+                sLog.outDebug("Movement anticheat: begin fall-time %d",GetPlayer()->m_anti_beginfalltime);
+                #endif
+            }
+        } else {
+            if (GetPlayer()->m_anti_beginfalltime != 0)
+            {
+                GetPlayer()->m_anti_beginfalltime = 0; // reset timer if we landed without MSG_MOVE_FALL_LAND opcode
+                #ifdef MOVEMENT_ANTICHEAT_DEBUG
+                sLog.outDebug("Movement anticheat: end fall-time %d",GetPlayer()->m_anti_beginfalltime);
+                #endif
+            }
+        }
+        if (current_speed < GetPlayer()->m_anti_last_hspeed)
+        {
+            allowed_delta = GetPlayer()->m_anti_last_hspeed;
+            if (GetPlayer()->m_anti_lastspeed_changetime == 0 )
+                GetPlayer()->m_anti_lastspeed_changetime = movementInfo.time + (uint32)floor(((GetPlayer()->m_anti_last_hspeed / current_speed) * 1000)) + 100; //100ms above for random fluctuating =)))
+        } else allowed_delta = current_speed;
+        allowed_delta = allowed_delta * time_delta;
+        allowed_delta = allowed_delta * allowed_delta + 2;
+
+       // static char const* move_type_name[MAX_MOVE_TYPE] = {  "Walk", "Run", "Walkback", "Swim", "Swimback", "Turn", "Fly", "Flyback" };
+       // sLog.outBasic("%s newcoord: tm:%d ftm:%d | %f,%f,%fo(%f) [%X][%s]$%s",GetPlayer()->GetName(),movementInfo.time,movementInfo.fallTime,movementInfo.x,movementInfo.y,movementInfo.z,movementInfo.o,MovementFlags, LookupOpcodeName(opcode),move_type_name[move_type]);
+       // sLog.outBasic("%f",tg_z);
+
+        if ((real_delta > allowed_delta)) //&& (delta_z < 1)
+        {
+            #ifdef MOVEMENT_ANTICHEAT_DEBUG
+            sLog.outDebug("Movement anticheat: %s is speed exception. {real_delta=%f allowed_delta=%f | current_speed=%f preview_speed=%f time=%f}(%f %f %f %d)[%s]",GetPlayer()->GetName(),real_delta, allowed_delta, current_speed, GetPlayer()->m_anti_last_hspeed,time_delta,GetPlayer()->GetPositionX(),GetPlayer()->GetPositionY(),GetPlayer()->GetPositionZ(), GetPlayer()->GetMapId(),LookupOpcodeName(opcode));
+            #endif
+            check_passed = false;
+        }
+        if ((real_delta>4900.0f) && !(real_delta < allowed_delta))
+        {
+            #ifdef MOVEMENT_ANTICHEAT_DEBUG
+            sLog.outDebug("Movement anticheat: %s is teleport exception. {real_delta=%f allowed_delta=%f | current_speed=%f preview_speed=%f time=%f}(%f %f %f %d)",GetPlayer()->GetName(),real_delta, allowed_delta, current_speed, GetPlayer()->m_anti_last_hspeed,time_delta,GetPlayer()->GetPositionX(),GetPlayer()->GetPositionY(),GetPlayer()->GetPositionZ(), GetPlayer()->GetMapId());
+            #endif
+            check_passed = false;
+        }
+        if (movementInfo.time>GetPlayer()->m_anti_lastspeed_changetime)
+        {
+            GetPlayer()->m_anti_last_hspeed = current_speed; // store current speed
+            GetPlayer()->m_anti_last_vspeed = -3.2f;
+            if (GetPlayer()->m_anti_lastspeed_changetime != 0) GetPlayer()->m_anti_lastspeed_changetime = 0;
+        }
 
+        if ((tg_z > 1.56f) && (delta_z < GetPlayer()->m_anti_last_vspeed))
+        {
+            #ifdef MOVEMENT_ANTICHEAT_DEBUG
+            sLog.outDebug("Movement anticheat: %s is mountain exception. {tg_z=%f} (%f %f %f %d)",GetPlayer()->GetName(),tg_z, GetPlayer()->GetPositionX(),GetPlayer()->GetPositionY(),GetPlayer()->GetPositionZ(), GetPlayer()->GetMapId());
+            #endif
+            check_passed = false;
+        }
+        if (((MovementFlags & (MOVEMENTFLAG_CAN_FLY | MOVEMENTFLAG_FLYING | MOVEMENTFLAG_FLYING2)) != 0) && !GetPlayer()->isGameMaster() && !(GetPlayer()->HasAuraType(SPELL_AURA_FLY) || GetPlayer()->HasAuraType(SPELL_AURA_MOD_INCREASE_FLIGHT_SPEED)))
+        {
+            #ifdef MOVEMENT_ANTICHEAT_DEBUG
+            sLog.outDebug("Movement anticheat: %s is fly cheater. {SPELL_AURA_FLY=[%X]} {SPELL_AURA_MOD_INCREASE_FLIGHT_SPEED=[%X]} {SPELL_AURA_MOD_SPEED_FLIGHT=[%X]} {SPELL_AURA_MOD_FLIGHT_SPEED_ALWAYS=[%X]} {SPELL_AURA_MOD_FLIGHT_SPEED_NOT_STACK=[%X]}",
+               GetPlayer()->GetName(),
+               GetPlayer()->HasAuraType(SPELL_AURA_FLY), GetPlayer()->HasAuraType(SPELL_AURA_MOD_INCREASE_FLIGHT_SPEED),
+               GetPlayer()->HasAuraType(SPELL_AURA_MOD_SPEED_FLIGHT), GetPlayer()->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_ALWAYS),
+               GetPlayer()->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_NOT_STACK));
+            #endif
+            check_passed = false;
+        }
+        if (((MovementFlags & MOVEMENTFLAG_WATERWALKING) != 0) && !GetPlayer()->isGameMaster() && !(GetPlayer()->HasAuraType(SPELL_AURA_WATER_WALK) | GetPlayer()->HasAuraType(SPELL_AURA_GHOST)))
+        {
+            #ifdef MOVEMENT_ANTICHEAT_DEBUG
+            sLog.outDebug("Movement anticheat: %s is water-walk exception. [%X]{SPELL_AURA_WATER_WALK=[%X]}", GetPlayer()->GetName(), MovementFlags, GetPlayer()->HasAuraType(SPELL_AURA_WATER_WALK));
+            #endif
+            check_passed = false;
+        }
+        if(movementInfo.z < 0.0001f && movementInfo.z > -0.0001f && ((MovementFlags & (MOVEMENTFLAG_SWIMMING | MOVEMENTFLAG_CAN_FLY | MOVEMENTFLAG_FLYING | MOVEMENTFLAG_FLYING2)) == 0) && !GetPlayer()->isGameMaster() )
+        {
+            // Prevent using TeleportToPlan.
+            Map *map = GetPlayer()->GetMap();
+            if (map){
+                float plane_z = map->GetHeight(movementInfo.x, movementInfo.y, MAX_HEIGHT) - movementInfo.z;
+                plane_z = (plane_z < -500.0f) ? 0 : plane_z; //check holes in heigth map
+                if(plane_z > 0.1f || plane_z < -0.1f)
+                {
+                    GetPlayer()->m_anti_teletoplane_count++;
+                    check_passed = false;
+                    #ifdef MOVEMENT_ANTICHEAT_DEBUG
+                    sLog.outDebug("Movement anticheat: %s is teleport to plan exception. plane_z: %f ", GetPlayer()->GetName(), plane_z);
+                    #endif
+                    if (GetPlayer()->m_anti_teletoplane_count > World::GetTeleportToPlaneAlarms())
+                    {
+                        GetPlayer()->GetSession()->KickPlayer();
+                        sLog.outError("Movement anticheat: %s is teleport to plan exception. Exception count: %d ", GetPlayer()->GetName(), GetPlayer()->m_anti_teletoplane_count);
+                    }
+                }
+            }
+        } else {
+            if (GetPlayer()->m_anti_teletoplane_count !=0)
+                GetPlayer()->m_anti_teletoplane_count = 0;
+        }
+    } else if (MovementFlags & MOVEMENTFLAG_ONTRANSPORT) {
+            //antiwrap =)
+        if (GetPlayer()->m_transport)
+        {
+            float trans_rad = movementInfo.t_x*movementInfo.t_x + movementInfo.t_y*movementInfo.t_y + movementInfo.t_z*movementInfo.t_z;
+            if (trans_rad > 3600.0f)
+                check_passed = false;
+        } else {
+            if (GameObjectData const* go_data = objmgr.GetGOData(GetPlayer()->m_anti_transportGUID))
+            {
+                float delta_gox = go_data->posX - movementInfo.x;
+                float delta_goy = go_data->posY - movementInfo.y;
+                float delta_goz = go_data->posZ - movementInfo.z;
+                int mapid = go_data->mapid;
+                #ifdef MOVEMENT_ANTICHEAT_DEBUG
+                sLog.outDebug("Movement anticheat: %s on some transport. xyzo: %f,%f,%f", GetPlayer()->GetName(), go_data->posX,go_data->posY,go_data->posZ);
+                #endif
+                if (GetPlayer()->GetMapId() != mapid){
+                    check_passed = false;
+                } else if (mapid !=369) {
+                    float delta_go = delta_gox*delta_gox + delta_goy*delta_goy;
+                    if (delta_go > 3600.0f)
+                        check_passed = false;
+                }
+
+            } else {
+                #ifdef MOVEMENT_ANTICHEAT_DEBUG
+                sLog.outDebug("Movement anticheat: %s on undefined transport.", GetPlayer()->GetName());
+                #endif
+                check_passed = false;
+            }
+        }
+        if (!check_passed){
+            if (GetPlayer()->m_transport)
+                {
+                    GetPlayer()->m_transport->RemovePassenger(GetPlayer());
+                    GetPlayer()->m_transport = NULL;
+                }
+                movementInfo.t_x = 0.0f;
+                movementInfo.t_y = 0.0f;
+                movementInfo.t_z = 0.0f;
+                movementInfo.t_o = 0.0f;
+                movementInfo.t_time = 0;
+                GetPlayer()->m_anti_transportGUID = 0;
+        }
+    }
     /* process position-change */
-    recv_data.put<uint32>(5, getMSTime());                  // offset flags(4) + unk(1)
-    WorldPacket data(recv_data.GetOpcode(), (GetPlayer()->GetPackGUID().size()+recv_data.size()));
-    data.append(GetPlayer()->GetPackGUID());
-    data.append(recv_data.contents(), recv_data.size());
-    GetPlayer()->SendMessageToSet(&data, false);
+    if (check_passed)
+    {
+        recv_data.put<uint32>(5, getMSTime());                  // offset flags(4) + unk(1)
+        WorldPacket data(recv_data.GetOpcode(), (GetPlayer()->GetPackGUID().size()+recv_data.size()));
+        data.append(GetPlayer()->GetPackGUID());
+        data.append(recv_data.contents(), recv_data.size());
+        GetPlayer()->SendMessageToSet(&data, false);
 
-    GetPlayer()->SetPosition(movementInfo.x, movementInfo.y, movementInfo.z, movementInfo.o);
-    GetPlayer()->m_movementInfo = movementInfo;
+        GetPlayer()->SetPosition(movementInfo.x, movementInfo.y, movementInfo.z, movementInfo.o);
+        GetPlayer()->m_movementInfo = movementInfo;
 
-    if(GetPlayer()->isMovingOrTurning())
-        GetPlayer()->RemoveSpellsCausingAura(SPELL_AURA_FEIGN_DEATH);
+        if(GetPlayer()->isMovingOrTurning())
+            GetPlayer()->RemoveSpellsCausingAura(SPELL_AURA_FEIGN_DEATH);
 
     if(movementInfo.z < -500.0f)
     {
-        // NOTE: this is actually called many times while falling
-        // even after the player has been teleported away
-        // TODO: discard movement packets after the player is rooted
-        if(GetPlayer()->isAlive())
+        if(GetPlayer()->InBattleGround() 
+            && GetPlayer()->GetBattleGround() 
+            && GetPlayer()->GetBattleGround()->HandlePlayerUnderMap(_player))
         {
-            GetPlayer()->EnvironmentalDamage(GetPlayer()->GetGUID(),DAMAGE_FALL_TO_VOID, GetPlayer()->GetMaxHealth());
-            // change the death state to CORPSE to prevent the death timer from
-            // starting in the next player update
-            GetPlayer()->KillPlayer();
-            GetPlayer()->BuildPlayerRepop();
+            // do nothing, the handle already did if returned true
         }
+        else
+        {
+            // NOTE: this is actually called many times while falling
+            // even after the player has been teleported away
+            // TODO: discard movement packets after the player is rooted
+            if(GetPlayer()->isAlive())
+            {
+                GetPlayer()->EnvironmentalDamage(GetPlayer()->GetGUID(),DAMAGE_FALL_TO_VOID, GetPlayer()->GetMaxHealth());
+                // change the death state to CORPSE to prevent the death timer from
+                // starting in the next player update
+                GetPlayer()->KillPlayer();
+                GetPlayer()->BuildPlayerRepop();
+            }
 
-        // cancel the death timer here if started
-        GetPlayer()->RepopAtGraveyard();
+            // cancel the death timer here if started
+            GetPlayer()->RepopAtGraveyard();
+        }
+    }
+
+        if (GetPlayer()->m_anti_alarmcount > 0){
+            sLog.outError("Movement anticheat: %s produce %d anticheat alarms",GetPlayer()->GetName(),GetPlayer()->m_anti_alarmcount);
+            GetPlayer()->m_anti_alarmcount = 0;
+        }
+    } else {
+        GetPlayer()->m_anti_alarmcount++;
+        WorldPacket data;
+        GetPlayer()->SetUnitMovementFlags(0);
+        GetPlayer()->BuildTeleportAckMsg(&data, GetPlayer()->GetPositionX(), GetPlayer()->GetPositionY(), GetPlayer()->GetPositionZ(), GetPlayer()->GetOrientation());
+        GetPlayer()->GetSession()->SendPacket(&data);
+        GetPlayer()->BuildHeartBeatMsg(&data);
+        GetPlayer()->SendMessageToSet(&data, true);
     }
 }
 
@@ -529,34 +780,60 @@ void WorldSession::HandleMountSpecialAnimOpcode(WorldPacket& /*recvdata*/)
     GetPlayer()->SendMessageToSet(&data, false);
 }
 
-void WorldSession::HandleMoveKnockBackAck( WorldPacket & /*recv_data*/ )
+void WorldSession::HandleMoveKnockBackAck( WorldPacket & recv_data )
 {
     // CHECK_PACKET_SIZE(recv_data,?);
     sLog.outDebug("CMSG_MOVE_KNOCK_BACK_ACK");
     // Currently not used but maybe use later for recheck final player position
     // (must be at call same as into "recv_data >> x >> y >> z >> orientation;"
 
-    /*
-    uint32 flags, time;
-    float x, y, z, orientation;
+    CHECK_PACKET_SIZE(recv_data, 8+4+4+1+4+4+4+4+4);
+    MovementInfo movementInfo;
+
     uint64 guid;
     uint32 sequence;
+    uint32 MovementFlags;
     uint32 ukn1;
     float xdirection,ydirection,hspeed,vspeed;
 
-    recv_data >> guid;
-    recv_data >> sequence;
-    recv_data >> flags >> time;
-    recv_data >> x >> y >> z >> orientation;
-    recv_data >> ukn1; //unknown
-    recv_data >> vspeed >> xdirection >> ydirection >> hspeed;
+    recv_data >> guid;          //8
+    recv_data >> sequence;      //4
+    recv_data >> MovementFlags >> movementInfo.unk1 >> movementInfo.time; //4+1+4
+    recv_data >> movementInfo.x >> movementInfo.y >> movementInfo.z >> movementInfo.o; //4+4+4+4
+
+    //Save movement flags
+    _player->SetUnitMovementFlags(MovementFlags);
+
+    if(MovementFlags & MOVEMENTFLAG_ONTRANSPORT)
+    {
+        // recheck
+        CHECK_PACKET_SIZE(recv_data, recv_data.rpos()+8+4+4+4+4+4);
+
+        recv_data >> movementInfo.t_guid;
+        recv_data >> movementInfo.t_x;
+        recv_data >> movementInfo.t_y;
+        recv_data >> movementInfo.t_z;
+        recv_data >> movementInfo.t_o;
+        recv_data >> movementInfo.t_time;
+    }
+
+    CHECK_PACKET_SIZE(recv_data, recv_data.rpos()+4+4+4+4+4);
+    recv_data >> ukn1; //unknown //4
+    recv_data >> vspeed >> xdirection >> ydirection >> hspeed; //4+4+4+4
+
+    #ifdef MOVEMENT_ANTICHEAT_DEBUG
+    sLog.outDebug("%s CMSG_MOVE_KNOCK_BACK_ACK: tm:%d ftm:%d | %f,%f,%fo(%f) [%X]",GetPlayer()->GetName(),movementInfo.time,movementInfo.fallTime,movementInfo.x,movementInfo.y,movementInfo.z,movementInfo.o,MovementFlags);
+    sLog.outDebug("%s CMSG_MOVE_KNOCK_BACK_ACK additional: vspeed:%f, hspeed:%f, xdir:%f ydir:%f",GetPlayer()->GetName(), vspeed, hspeed, xdirection, ydirection);
+    #endif
 
     // skip not personal message;
     if(GetPlayer()->GetGUID()!=guid)
         return;
 
-    // check code
-    */
+    GetPlayer()->m_movementInfo = movementInfo;
+    GetPlayer()->m_anti_last_hspeed = hspeed;
+    GetPlayer()->m_anti_last_vspeed = vspeed < 3.2f ? vspeed - 1.0f : 3.2f;
+    GetPlayer()->m_anti_lastspeed_changetime = movementInfo.time + 1750;
 }
 
 void WorldSession::HandleMoveHoverAck( WorldPacket& /*recv_data*/ )
diff --git a/src/game/Object.cpp b/src/game/Object.cpp
index 24ce65d..9536aaa 100644
--- a/src/game/Object.cpp
+++ b/src/game/Object.cpp
@@ -1125,7 +1125,7 @@ void WorldObject::UpdateGroundPositionZ(float x, float y, float &z) const
 {
     float new_z = MapManager::Instance().GetBaseMap(GetMapId())->GetHeight(x,y,z,true);
     if(new_z > INVALID_HEIGHT)
-        z = new_z+ 0.05f;                                   // just to be sure that we are not a few pixel under the surface
+        z = new_z; //+ 0.05f;                                   // just to be sure that we are not a few pixel under the surface
 }
 
 bool WorldObject::IsPositionValid() const
@@ -1557,7 +1557,7 @@ void WorldObject::GetNearPoint(WorldObject const* searcher, float &x, float &y,
     }
 
     float angle;                                            // candidate of angle for free pos
-
+    
     // special case when one from list empty and then empty side preferred
     if(selector.FirstAngle(angle))
     {
@@ -1571,7 +1571,12 @@ void WorldObject::GetNearPoint(WorldObject const* searcher, float &x, float &y,
 
     // set first used pos in lists
     selector.InitializeAngle();
-
+    
+    // Debugging LoS problem when angle == 0.00, set some vars
+    bool localDebug = false;
+    uint32 localCounter = 0;
+    uint32 localCounter2 = 0;
+    
     // select in positions after current nodes (selection one by one)
     while(selector.NextAngle(angle))                        // angle for free pos
     {
@@ -1581,51 +1586,92 @@ void WorldObject::GetNearPoint(WorldObject const* searcher, float &x, float &y,
 
         if(IsWithinLOS(x,y,z))
             return;
+
+        // Start outputting debug when angle == 0.00
+        if(!angle && !localCounter) {
+                sLog.outError("WorldObject::GetNearPoint: DEBUG START (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
+                localDebug = true;
+        }
+        
+        if(++localCounter > 100) {
+            sLog.outError("WorldObject::GetNearPoint: FIRST WHILE LOOP more then 100 iterations, BREAK (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
+            break;
+        }
     }
 
     // BAD NEWS: not free pos (or used or have LOS problems)
     // Attempt find _used_ pos without LOS problem
+    
+    if(localDebug) sLog.outError("WorldObject::GetNearPoint: CHECKPOINT 1 (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
 
     if(!first_los_conflict)
     {
+        if(localDebug) sLog.outError("WorldObject::GetNearPoint: CHECKPOINT 1A (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
+        
         x = first_x;
         y = first_y;
 
         UpdateGroundPositionZ(x,y,z);                       // update to LOS height if available
+        
+        if(localDebug) sLog.outError("WorldObject::GetNearPoint: RETURN POINT 1 (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
         return;
     }
+    
+    if(localDebug) sLog.outError("WorldObject::GetNearPoint: CHECKPOINT 2 (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
 
     // special case when one from list empty and then empty side preferred
     if( selector.IsNonBalanced() )
     {
+        if(localDebug) sLog.outError("WorldObject::GetNearPoint: CHECKPOINT 2A (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
+        
         if(!selector.FirstAngle(angle))                     // _used_ pos
         {
+            if(localDebug) sLog.outError("WorldObject::GetNearPoint: CHECKPOINT 2B (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
+            
             GetNearPoint2D(x,y,distance2d,absAngle+angle);
             z = GetPositionZ();
             UpdateGroundPositionZ(x,y,z);                   // update to LOS height if available
 
-            if(IsWithinLOS(x,y,z))
+            if(IsWithinLOS(x,y,z)) {
+                if(localDebug) sLog.outError("WorldObject::GetNearPoint: RETURN POINT 2 (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
                 return;
+            }
         }
     }
+    
+    if(localDebug) sLog.outError("WorldObject::GetNearPoint: CHECKPOINT 3 (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
 
     // set first used pos in lists
     selector.InitializeAngle();
+    
+    if(localDebug) sLog.outError("WorldObject::GetNearPoint: CHECKPOINT 4 (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
 
     // select in positions after current nodes (selection one by one)
     while(selector.NextUsedAngle(angle))                    // angle for used pos but maybe without LOS problem
     {
+        if(localDebug) sLog.outError("WorldObject::GetNearPoint: CHECKPOINT 4A (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
+        
         GetNearPoint2D(x,y,distance2d,absAngle+angle);
         z = GetPositionZ();
         UpdateGroundPositionZ(x,y,z);                       // update to LOS height if available
 
-        if(IsWithinLOS(x,y,z))
+        if(IsWithinLOS(x,y,z)) {
+            if(localDebug) sLog.outError("WorldObject::GetNearPoint: RETURN POINT 3 (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
             return;
+        }
+        
+        if(++localCounter2 > 100) {
+            sLog.outError("WorldObject::GetNearPoint: SECOND WHILE LOOP more then 100 iterations, BREAK (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
+            break;
+        }
     }
+    
+    if(localDebug) sLog.outError("WorldObject::GetNearPoint: CHECKPOINT 5 (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
 
     // BAD BAD NEWS: all found pos (free and used) have LOS problem :(
     x = first_x;
     y = first_y;
 
     UpdateGroundPositionZ(x,y,z);                           // update to LOS height if available
+    if(localDebug) sLog.outError("WorldObject::GetNearPoint: RETURN POINT 4 (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
 }
diff --git a/src/game/ObjectMgr.cpp b/src/game/ObjectMgr.cpp
index f49f0a1..6462dec 100644
--- a/src/game/ObjectMgr.cpp
+++ b/src/game/ObjectMgr.cpp
@@ -20,6 +20,7 @@
 #include "Database/DatabaseEnv.h"
 #include "Database/SQLStorage.h"
 
+#include "AuctionHouseBot.h"
 #include "Log.h"
 #include "MapManager.h"
 #include "ObjectMgr.h"
@@ -415,6 +416,9 @@ void ObjectMgr::SendAuctionSalePendingMail( AuctionEntry * auction )
 //call this method to send mail to auction owner, when auction is successful, it does not clear ram
 void ObjectMgr::SendAuctionSuccessfulMail( AuctionEntry * auction )
 {
+    if (auction->owner == AuctionHouseBotNoMail())
+        return;
+
     uint64 owner_guid = MAKE_NEW_GUID(auction->owner, 0, HIGHGUID_PLAYER);
     Player *owner = GetPlayer(owner_guid);
 
diff --git a/src/game/ObjectMgr.h b/src/game/ObjectMgr.h
index 4c5a1c4..7a5ee92 100644
--- a/src/game/ObjectMgr.h
+++ b/src/game/ObjectMgr.h
@@ -320,6 +320,8 @@ class ObjectMgr
         ArenaTeam* GetArenaTeamByCapitan(uint64 const& guid) const;
         void AddArenaTeam(ArenaTeam* arenateam) { mArenaTeamSet.insert( arenateam ); }
         void RemoveArenaTeam(ArenaTeam* arenateam) { mArenaTeamSet.erase( arenateam ); }
+        ArenaTeamSet::iterator GetArenaTeamSetBegin() { return mArenaTeamSet.begin(); }
+        ArenaTeamSet::iterator GetArenaTeamSetEnd() { return mArenaTeamSet.end(); }
 
         static CreatureInfo const *GetCreatureTemplate( uint32 id );
         CreatureModelInfo const *GetCreatureModelInfo( uint32 modelid );
diff --git a/src/game/ObjectPosSelector.cpp b/src/game/ObjectPosSelector.cpp
index 6855e21..f682c2e 100644
--- a/src/game/ObjectPosSelector.cpp
+++ b/src/game/ObjectPosSelector.cpp
@@ -17,6 +17,7 @@
  */
 
 #include "ObjectPosSelector.h"
+#include "Log.h"
 
 ObjectPosSelector::ObjectPosSelector(float x,float y,float size,float dist)
 : m_center_x(x),m_center_y(y),m_size(size),m_dist(dist)
@@ -99,14 +100,32 @@ bool ObjectPosSelector::NextAngle(float& angle)
 
 bool ObjectPosSelector::NextUsedAngle(float& angle)
 {
+    // Debugging LoS problem when angle == 0.00, set some vars
+    bool localDebug = false;
+    uint32 localCounter = 0;
+    
+    // Start outputting debug when angle == 0.00
+    if(!angle) {
+        sLog.outError("ObjectPosSelector::NextUsedAngle: DEBUG START (angle = %f)", angle);
+        localDebug = true;
+    }
+    
     while(m_nextUsedPos[USED_POS_PLUS]!=m_UsedPosLists[USED_POS_PLUS].end() ||
         m_nextUsedPos[USED_POS_MINUS]!=m_UsedPosLists[USED_POS_MINUS].end() )
     {
         // calculate next possible angle
-        if(!NextPosibleAngle(angle))
+        if(!NextPosibleAngle(angle)) {
+            if(localDebug) sLog.outError("ObjectPosSelector::NextUsedAngle: RETURN POINT 1 (angle = %f)", angle);
             return true;
+        }
+            
+        if(++localCounter > 100) {
+            sLog.outError("ObjectPosSelector::NextUsedAngle: WHILE LOOP more then 100 iterations, BREAK (angle = %f)", angle);
+            break;
+        }
     }
 
+    if(localDebug) sLog.outError("ObjectPosSelector::NextUsedAngle: RETURN POINT 2 (angle = %f)", angle);
     return false;
 }
 
diff --git a/src/game/Pet.cpp b/src/game/Pet.cpp
index e72e29e..63d6c2b 100644
--- a/src/game/Pet.cpp
+++ b/src/game/Pet.cpp
@@ -367,6 +367,10 @@ bool Pet::LoadPetFromDB( Unit* owner, uint32 petentry, uint32 petnumber, bool cu
         }
     }
 
+	//set last used pet number (for use in BG's)
+    if(owner->GetTypeId() == TYPEID_PLAYER && isControlled() && !isTemporarySummoned() && (getPetType() == SUMMON_PET || getPetType() == HUNTER_PET))
+		((Player*)owner)->SetLastPetNumber(pet_number);
+
     return true;
 }
 
@@ -619,7 +623,7 @@ void Pet::RegenerateFocus()
     AuraList const& ModPowerRegenPCTAuras = GetAurasByType(SPELL_AURA_MOD_POWER_REGEN_PERCENT);
     for(AuraList::const_iterator i = ModPowerRegenPCTAuras.begin(); i != ModPowerRegenPCTAuras.end(); ++i)
         if ((*i)->GetModifier()->m_miscvalue == POWER_FOCUS)
-            addvalue *= ((*i)->GetModifier()->m_amount + 100) / 100.0f;
+            addvalue *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount + 100) / 100.0f;
 
     ModifyPower(POWER_FOCUS, (int32)addvalue);
 }
diff --git a/src/game/PetAI.cpp b/src/game/PetAI.cpp
index 144b2d7..b16877a 100644
--- a/src/game/PetAI.cpp
+++ b/src/game/PetAI.cpp
@@ -55,7 +55,7 @@ void PetAI::MoveInLineOfSight(Unit *u)
             if(i_pet.IsWithinLOSInMap(u))
             {
                 AttackStart(u);
-                u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
+                //u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
             }
         }
     }
diff --git a/src/game/Player.cpp b/src/game/Player.cpp
index 8d80991..4a9ed98 100644
--- a/src/game/Player.cpp
+++ b/src/game/Player.cpp
@@ -346,8 +346,8 @@ Player::Player (WorldSession *session): Unit()
     m_bgBattleGroundID = 0;
     for (int j=0; j < PLAYER_MAX_BATTLEGROUND_QUEUES; j++)
     {
-        m_bgBattleGroundQueueID[j].bgType  = 0;
-        m_bgBattleGroundQueueID[j].invited = false;
+        m_bgBattleGroundQueueID[j].bgQueueType  = 0;
+        m_bgBattleGroundQueueID[j].invitedToInstance = 0;
     }
     m_bgTeam = 0;
 
@@ -366,6 +366,8 @@ Player::Player (WorldSession *session): Unit()
     //when dying/logging out
     m_oldpetspell = 0;
 
+    m_lastpetnumber = 0;
+
     ////////////////////Rest System/////////////////////
     time_inn_enter=0;
     inn_pos_mapid=0;
@@ -375,7 +377,18 @@ Player::Player (WorldSession *session): Unit()
     m_rest_bonus=0;
     rest_type=REST_TYPE_NO;
     ////////////////////Rest System/////////////////////
-
+    //movement anticheat
+    m_anti_lastmovetime = 0;     //last movement time
+    m_anti_transportGUID = 0;    //current transport GUID
+    m_anti_last_hspeed = 7.0f;   //horizontal speed, default RUN speed
+    m_anti_lastspeed_changetime = 0; //last speed change time
+    m_anti_last_vspeed = -2.0f;  //vertical speed, default max jump height
+    m_anti_beginfalltime = 0;    //alternative falling begin time
+    m_anti_justteleported = 0;   //seted when player was teleported
+    m_anti_teletoplane_count = 0;//Teleport To Plane alarm counter
+
+    m_anti_alarmcount = 0;       //alarm counter
+    /////////////////////////////////
     m_mailsLoaded = false;
     m_mailsUpdated = false;
     unReadMails = 0;
@@ -766,7 +779,7 @@ void Player::HandleDrowning()
 
     AuraList const& mModWaterBreathing = GetAurasByType(SPELL_AURA_MOD_WATER_BREATHING);
     for(AuraList::const_iterator i = mModWaterBreathing.begin(); i != mModWaterBreathing.end(); ++i)
-        UnderWaterTime = uint32(UnderWaterTime * (100.0f + (*i)->GetModifier()->m_amount) / 100.0f);
+        UnderWaterTime = uint32(UnderWaterTime * (100.0f + (*i)->GetModifier()->m_amount * (*i)->m_stackAmount) / 100.0f);
 
     if ((m_isunderwater & 0x01) && !(m_isunderwater & 0x80) && isAlive())
     {
@@ -1432,14 +1445,16 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
         sLog.outError("TeleportTo: invalid map %d or absent instance template.", mapid);
         return false;
     }
-
+    //reset falltimer at teleport
+    m_anti_justteleported = 1;
     // preparing unsummon pet if lost (we must get pet before teleportation or will not find it later)
     Pet* pet = GetPet();
 
     MapEntry const* mEntry = sMapStore.LookupEntry(mapid);
 
     // don't let enter battlegrounds without assigned battleground id (for example through areatrigger)...
-    if(!InBattleGround() && mEntry->IsBattleGround() && !GetSession()->GetSecurity())
+    // don't let gm level > 1 either
+    if(!InBattleGround() && mEntry->IsBattleGroundOrArena())
         return false;
 
     // client without expansion support
@@ -1554,7 +1569,7 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
     else
     {
         // far teleport to another map
-        Map* oldmap = IsInWorld() ? MapManager::Instance().GetMap(GetMapId(), this) : NULL;
+        Map* oldmap = IsInWorld() ? MapManager::Instance().FindMap(GetMapId(), GetInstanceId()) : NULL;
         // check if we can enter before stopping combat / removing pet / totems / interrupting spells
 
         // Check enter rights before map getting to avoid creating instance copy for player
@@ -1796,7 +1811,7 @@ void Player::Regenerate(Powers power)
         AuraList const& ModPowerRegenPCTAuras = GetAurasByType(SPELL_AURA_MOD_POWER_REGEN_PERCENT);
         for(AuraList::const_iterator i = ModPowerRegenPCTAuras.begin(); i != ModPowerRegenPCTAuras.end(); ++i)
             if ((*i)->GetModifier()->m_miscvalue == power)
-                addvalue *= ((*i)->GetModifier()->m_amount + 100) / 100.0f;
+                addvalue *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount + 100) / 100.0f;
     }
 
     if (power != POWER_RAGE)
@@ -1837,7 +1852,7 @@ void Player::RegenerateHealth()
         {
             AuraList const& mModHealthRegenPct = GetAurasByType(SPELL_AURA_MOD_HEALTH_REGEN_PERCENT);
             for(AuraList::const_iterator i = mModHealthRegenPct.begin(); i != mModHealthRegenPct.end(); ++i)
-                addvalue *= (100.0f + (*i)->GetModifier()->m_amount) / 100.0f;
+                addvalue *= (100.0f + (*i)->GetModifier()->m_amount * (*i)->m_stackAmount) / 100.0f;
         }
         else if(HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT))
             addvalue *= GetTotalAuraModifier(SPELL_AURA_MOD_REGEN_DURING_COMBAT) / 100.0f;
@@ -2034,7 +2049,7 @@ void Player::GiveXP(uint32 xp, Unit* victim)
     // handle SPELL_AURA_MOD_XP_PCT auras
     Unit::AuraList const& ModXPPctAuras = GetAurasByType(SPELL_AURA_MOD_XP_PCT);
     for(Unit::AuraList::const_iterator i = ModXPPctAuras.begin();i != ModXPPctAuras.end(); ++i)
-        xp = uint32(xp*(1.0f + (*i)->GetModifier()->m_amount / 100.0f));
+        xp = uint32(xp*(1.0f + (*i)->GetModifier()->m_amount * (*i)->m_stackAmount / 100.0f));
 
     // XP resting bonus for kill
     uint32 rested_bonus_xp = victim ? GetXPRestBonus(xp) : 0;
@@ -3429,6 +3444,29 @@ void Player::DeleteFromDB(uint64 playerguid, uint32 accountId, bool updateRealmC
             guild->DelMember(guid);
     }
 
+    // remove from arena teams
+    uint32 at_id = GetArenaTeamIdFromDB(playerguid,ARENA_TEAM_2v2);
+    if(at_id != 0)
+    {
+        ArenaTeam * at = objmgr.GetArenaTeamById(at_id);
+        if(at)
+            at->DelMember(playerguid);
+    }
+    at_id = GetArenaTeamIdFromDB(playerguid,ARENA_TEAM_3v3);
+    if(at_id != 0)
+    {
+        ArenaTeam * at = objmgr.GetArenaTeamById(at_id);
+        if(at)
+            at->DelMember(playerguid);
+    }
+    at_id = GetArenaTeamIdFromDB(playerguid,ARENA_TEAM_5v5);
+    if(at_id != 0)
+    {
+        ArenaTeam * at = objmgr.GetArenaTeamById(at_id);
+        if(at)
+            at->DelMember(playerguid);
+    }
+
     // the player was uninvited already on logout so just remove from group
     QueryResult *resultGroup = CharacterDatabase.PQuery("SELECT leaderGuid FROM group_member WHERE memberGuid='%u'", guid);
     if(resultGroup)
@@ -5851,6 +5889,10 @@ bool Player::RewardHonor(Unit *uVictim, uint32 groupsize, float honor)
     // need call before fields update to have chance move yesterday data to appropriate fields before today data change.
     UpdateHonorFields();
 
+    // do not reward honor in arenas, but return true to enable onkill spellproc
+    if(InBattleGround() && GetBattleGround() && GetBattleGround()->isArena())
+        return true;
+
     if(honor <= 0)
     {
         if(!uVictim || uVictim == this || uVictim->HasAuraType(SPELL_AURA_NO_PVP_CREDIT))
@@ -5922,7 +5964,7 @@ bool Player::RewardHonor(Unit *uVictim, uint32 groupsize, float honor)
             if (!cVictim->isRacialLeader())
                 return false;
 
-            honor = 100;                                    // ??? need more info
+            honor = 2000;                                    // ??? need more info
             victim_rank = 19;                               // HK: Leader
         }
     }
@@ -6583,7 +6625,7 @@ void Player::_ApplyWeaponDependentAuraCritMod(Item *item, WeaponAttackType attac
 
     if (item->IsFitToSpellRequirements(aura->GetSpellProto()))
     {
-        HandleBaseModValue(mod, FLAT_MOD, float (aura->GetModifier()->m_amount), apply);
+        HandleBaseModValue(mod, FLAT_MOD, float (aura->GetModifier()->m_amount * aura->m_stackAmount), apply);
     }
 }
 
@@ -6617,7 +6659,7 @@ void Player::_ApplyWeaponDependentAuraDamageMod(Item *item, WeaponAttackType att
 
     if (item->IsFitToSpellRequirements(aura->GetSpellProto()))
     {
-        HandleStatModifier(unitMod, unitModType, float(modifier->m_amount),apply);
+        HandleStatModifier(unitMod, unitModType, float(modifier->m_amount * aura->m_stackAmount),apply);
     }
 }
 
@@ -7658,19 +7700,34 @@ void Player::SendInitWorldStates()
             data << uint32(0xa5f) << uint32(0x0);           // 35
             break;
         case 3698:                                          // Nagrand Arena
-            data << uint32(0xa0f) << uint32(0x0);           // 7
-            data << uint32(0xa10) << uint32(0x0);           // 8
-            data << uint32(0xa11) << uint32(0x0);           // 9
+            if (bg && bg->GetTypeID() == BATTLEGROUND_NA)
+                bg->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(0xa0f) << uint32(0x0);           // 7
+                data << uint32(0xa10) << uint32(0x0);           // 8
+                data << uint32(0xa11) << uint32(0x0);           // 9 show
+            }
             break;
         case 3702:                                          // Blade's Edge Arena
-            data << uint32(0x9f0) << uint32(0x0);           // 7
-            data << uint32(0x9f1) << uint32(0x0);           // 8
-            data << uint32(0x9f3) << uint32(0x0);           // 9
+            if (bg && bg->GetTypeID() == BATTLEGROUND_BE)
+                bg->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(0x9f0) << uint32(0x0);           // 7 gold
+                data << uint32(0x9f1) << uint32(0x0);           // 8 green
+                data << uint32(0x9f3) << uint32(0x0);           // 9 show
+            }
             break;
         case 3968:                                          // Ruins of Lordaeron
-            data << uint32(0xbb8) << uint32(0x0);           // 7
-            data << uint32(0xbb9) << uint32(0x0);           // 8
-            data << uint32(0xbba) << uint32(0x0);           // 9
+            if (bg && bg->GetTypeID() == BATTLEGROUND_RL)
+                bg->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(0xbb8) << uint32(0x0);           // 7 gold 
+                data << uint32(0xbb9) << uint32(0x0);           // 8 green
+                data << uint32(0xbba) << uint32(0x0);           // 9 show
+            }
             break;
         case 3703:                                          // Shattrath City
             break;
@@ -14729,8 +14786,10 @@ void Player::SaveToDB()
     // first save/honor gain after midnight will also update the player's honor fields
     UpdateHonorFields();
 
-    // Must saved before enter into BattleGround
-    if(InBattleGround())
+    // players aren't saved on battleground maps
+    uint32 mapid = IsBeingTeleported() ? GetTeleportDest().mapid : GetMapId();
+    const MapEntry * me = sMapStore.LookupEntry(mapid);
+    if(!me || me->IsBattleGroundOrArena())
         return;
 
     int is_save_resting = HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING) ? 1 : 0;
@@ -15528,7 +15587,7 @@ void Player::RemovePet(Pet* pet, PetSaveMode mode, bool returnreagent)
     if(!pet)
         pet = GetPet();
 
-    if(returnreagent && (pet || m_temporaryUnsummonedPetNumber))
+    if(returnreagent && (pet || m_temporaryUnsummonedPetNumber) && !InBattleGround())
     {
         //returning of reagents only for players, so best done here
         uint32 spellId = pet ? pet->GetUInt32Value(UNIT_CREATED_BY_SPELL) : m_oldpetspell;
@@ -17509,7 +17568,8 @@ bool Player::InArena() const
 
 bool Player::GetBGAccessByLevel(uint32 bgTypeId) const
 {
-    BattleGround *bg = sBattleGroundMgr.GetBattleGround(bgTypeId);
+    // get a template bg instead of running one
+    BattleGround *bg = sBattleGroundMgr.GetBattleGroundTemplate(bgTypeId);
     if(!bg)
         return false;
 
diff --git a/src/game/Player.h b/src/game/Player.h
index 3308c08..51990b0 100644
--- a/src/game/Player.h
+++ b/src/game/Player.h
@@ -1801,24 +1801,32 @@ class MANGOS_DLL_SPEC Player : public Unit
         static uint32 GetMaxLevelForBattleGroundQueueId(uint32 queue_id);
         uint32 GetBattleGroundQueueIdFromLevel() const;
 
-        uint32 GetBattleGroundQueueId(uint32 index) const { return m_bgBattleGroundQueueID[index].bgType; }
-        uint32 GetBattleGroundQueueIndex(uint32 bgType) const
+        bool InBattleGroundQueue() const 	 
+	    { 	 
+	        for (int i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++) 	 
+                if (m_bgBattleGroundQueueID[i].bgQueueType != 0) 	 
+	                return true; 	 
+	        return false; 	 
+	    }
+
+        uint32 GetBattleGroundQueueId(uint32 index) const { return m_bgBattleGroundQueueID[index].bgQueueType; }
+        uint32 GetBattleGroundQueueIndex(uint32 bgQueueType) const
         {
             for (int i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
-                if (m_bgBattleGroundQueueID[i].bgType == bgType)
+                if (m_bgBattleGroundQueueID[i].bgQueueType == bgQueueType)
                     return i;
             return PLAYER_MAX_BATTLEGROUND_QUEUES;
         }
-        bool IsInvitedForBattleGroundType(uint32 bgType) const
+        bool IsInvitedForBattleGroundQueueType(uint32 bgQueueType) const
         {
             for (int i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
-                if (m_bgBattleGroundQueueID[i].bgType == bgType)
-                    return m_bgBattleGroundQueueID[i].invited;
+                if (m_bgBattleGroundQueueID[i].bgQueueType == bgQueueType)
+                    return m_bgBattleGroundQueueID[i].invitedToInstance != 0;
             return PLAYER_MAX_BATTLEGROUND_QUEUES;
         }
-        bool InBattleGroundQueueForBattleGroundType(uint32 bgType) const
+        bool InBattleGroundQueueForBattleGroundQueueType(uint32 bgQueueType) const
         {
-            return GetBattleGroundQueueIndex(bgType) < PLAYER_MAX_BATTLEGROUND_QUEUES;
+            return GetBattleGroundQueueIndex(bgQueueType) < PLAYER_MAX_BATTLEGROUND_QUEUES;
         }
 
         void SetBattleGroundId(uint32 val)  { m_bgBattleGroundID = val; }
@@ -1826,34 +1834,47 @@ class MANGOS_DLL_SPEC Player : public Unit
         {
             for (int i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
             {
-                if (m_bgBattleGroundQueueID[i].bgType == 0 || m_bgBattleGroundQueueID[i].bgType == val)
+                if (m_bgBattleGroundQueueID[i].bgQueueType == 0 || m_bgBattleGroundQueueID[i].bgQueueType == val)
                 {
-                    m_bgBattleGroundQueueID[i].bgType = val;
-                    m_bgBattleGroundQueueID[i].invited = false;
+                    m_bgBattleGroundQueueID[i].bgQueueType = val;
+                    m_bgBattleGroundQueueID[i].invitedToInstance = 0;
                     return i;
                 }
             }
             return PLAYER_MAX_BATTLEGROUND_QUEUES;
         }
+        bool HasFreeBattleGroundQueueId()
+        {
+            for (int i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
+                if (m_bgBattleGroundQueueID[i].bgQueueType == 0)
+                    return true;
+            return false;
+        }
         void RemoveBattleGroundQueueId(uint32 val)
         {
             for (int i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
             {
-                if (m_bgBattleGroundQueueID[i].bgType == val)
+                if (m_bgBattleGroundQueueID[i].bgQueueType == val)
                 {
-                    m_bgBattleGroundQueueID[i].bgType = 0;
-                    m_bgBattleGroundQueueID[i].invited = false;
+                    m_bgBattleGroundQueueID[i].bgQueueType = 0;
+                    m_bgBattleGroundQueueID[i].invitedToInstance = 0;
                     return;
                 }
             }
         }
-        void SetInviteForBattleGroundType(uint32 bgType)
+        void SetInviteForBattleGroundQueueType(uint32 bgQueueType, uint32 instanceId)
         {
             for (int i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
-                if (m_bgBattleGroundQueueID[i].bgType == bgType)
-                    m_bgBattleGroundQueueID[i].invited = true;
+                if (m_bgBattleGroundQueueID[i].bgQueueType == bgQueueType)
+                    m_bgBattleGroundQueueID[i].invitedToInstance = instanceId;
+        }
+        bool IsInvitedForBattleGroundInstance(uint32 instanceId) const
+        {
+            for (int i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
+                if (m_bgBattleGroundQueueID[i].invitedToInstance == instanceId)
+                    return true;
+            return false;
         }
-
         uint32 GetBattleGroundEntryPointMap() const { return m_bgEntryPointMap; }
         float GetBattleGroundEntryPointX() const { return m_bgEntryPointX; }
         float GetBattleGroundEntryPointY() const { return m_bgEntryPointY; }
@@ -1976,6 +1997,10 @@ class MANGOS_DLL_SPEC Player : public Unit
         uint32 GetOldPetSpell() const { return m_oldpetspell; }
         void SetOldPetSpell(uint32 petspell) { m_oldpetspell = petspell; }
 
+		// last used pet number (for BG's)
+        uint32 GetLastPetNumber() const { return m_lastpetnumber; }
+        void SetLastPetNumber(uint32 petnumber) { m_lastpetnumber = petnumber; }
+
         /*********************************************************/
         /***                 INSTANCE SYSTEM                   ***/
         /*********************************************************/
@@ -2034,8 +2059,8 @@ class MANGOS_DLL_SPEC Player : public Unit
         */
         struct BgBattleGroundQueueID_Rec
         {
-            uint32 bgType;
-            bool   invited;
+            uint32 bgQueueType;
+            uint32 invitedToInstance;
         };
         BgBattleGroundQueueID_Rec m_bgBattleGroundQueueID[PLAYER_MAX_BATTLEGROUND_QUEUES];
         uint32 m_bgEntryPointMap;
@@ -2216,7 +2241,17 @@ class MANGOS_DLL_SPEC Player : public Unit
         float m_rest_bonus;
         RestType rest_type;
         ////////////////////Rest System/////////////////////
-
+        //movement anticheat
+        uint32 m_anti_lastmovetime;     //last movement time
+        uint64 m_anti_transportGUID;    //current transport GUID
+        float  m_anti_last_hspeed;      //horizontal speed, default RUN speed
+        uint32 m_anti_lastspeed_changetime;  //last speed change time
+        float  m_anti_last_vspeed;      //vertical speed, default max jump height
+        uint32 m_anti_beginfalltime;    //alternative falling begin time
+        uint32 m_anti_justteleported;   //seted when player was teleported
+        uint32 m_anti_teletoplane_count;//Teleport To Plane alarm counter
+
+        uint64 m_anti_alarmcount;       //alarm counter
         // Transports
         Transport * m_transport;
 
@@ -2237,9 +2272,12 @@ class MANGOS_DLL_SPEC Player : public Unit
         uint32 m_temporaryUnsummonedPetNumber;
         uint32 m_oldpetspell;
 
-        uint64 m_miniPet;
+		// last used pet number (for BG's)
+		uint32 m_lastpetnumber;
         GuardianPetList m_guardianPets;
 
+		uint64 m_miniPet;
+
         // Player summoning
         time_t m_summon_expire;
         uint32 m_summon_mapid;
diff --git a/src/game/SharedDefines.h b/src/game/SharedDefines.h
index 907cceb..ca2ce17 100644
--- a/src/game/SharedDefines.h
+++ b/src/game/SharedDefines.h
@@ -798,14 +798,16 @@ enum Targets
     TARGET_AREAEFFECT_PARTY            = 37,
     TARGET_SCRIPT                      = 38,
     TARGET_SELF_FISHING                = 39,
-    TARGET_TOTEM_EARTH                 = 41,
-    TARGET_TOTEM_WATER                 = 42,
-    TARGET_TOTEM_AIR                   = 43,
-    TARGET_TOTEM_FIRE                  = 44,
+    TARGET_LOCATION_FRONT_LEFT         = 41,
+    TARGET_LOCATION_BACK_LEFT          = 42,
+    TARGET_LOCATION_BACK_RIGHT         = 43,
+    TARGET_LOCATION_FRONT_RIGHT        = 44,
     TARGET_CHAIN_HEAL                  = 45,
     TARGET_SCRIPT_COORDINATES          = 46,
-    TARGET_DYNAMIC_OBJECT              = 47,
-    TARGET_SUMMON                      = 48,
+    TARGET_LOCATION_FRONT              = 47,
+    TARGET_LOCATION_BACK               = 48,
+    TARGET_LOCATION_LEFT               = 49,
+    TARGET_LOCATION_RIGHT              = 50,
     TARGET_AREAEFFECT_CUSTOM_2         = 52,
     TARGET_CURRENT_ENEMY_COORDINATES   = 53,                // set unit coordinates as dest, only 16 target B imlemented
     TARGET_RANDOM_RAID_MEMBER          = 56,
@@ -813,8 +815,12 @@ enum Targets
     TARGET_AREAEFFECT_PARTY_AND_CLASS  = 61,
     TARGET_DUELVSPLAYER_COORDINATES    = 63,
     TARGET_BEHIND_VICTIM               = 65,                // uses in teleport behind spells
+    TARGET_LOCATION_RANDOM_AROUND_CASTER    = 72,
+    TARGET_LOCATION_RADIUS_AROUND_CASTER    = 73,
+    TARGET_LOCATION_RANDOM_IN_AREA     = 74,
     TARGET_SINGLE_ENEMY                = 77,
-    TARGET_SELF2                       = 87,
+    TARGET_LOCATION_AROUND_DEST        = 86,
+    TARGET_LOCATION_AT_DEST            = 87,
     TARGET_NONCOMBAT_PET               = 90,
 };
 
diff --git a/src/game/Spell.cpp b/src/game/Spell.cpp
index b42c59e..96ba4b6 100644
--- a/src/game/Spell.cpp
+++ b/src/game/Spell.cpp
@@ -946,6 +946,9 @@ void Spell::DoAllEffectOnTarget(TargetInfo *target)
 
 void Spell::DoSpellHitOnUnit(Unit *unit, const uint32 effectMask)
 {
+    if (m_caster->hasUnitState(UNIT_STAT_DIED)) 
+        return;
+
     if(!unit || !effectMask)
         return;
 
@@ -969,10 +972,7 @@ void Spell::DoSpellHitOnUnit(Unit *unit, const uint32 effectMask)
                 return;
             }
 
-            // exclude Arcane Missiles Dummy Aura aura for now (attack on hit)
-            // TODO: find way to not need this?
-            if(!(m_spellInfo->SpellFamilyName == SPELLFAMILY_MAGE &&
-                m_spellInfo->SpellFamilyFlags & 0x800LL))
+            if(!IsPositiveSpell(m_spellInfo->Id))
             {
                 unit->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
 
@@ -1173,16 +1173,99 @@ void Spell::SetTargetMap(uint32 i,uint32 cur,std::list<Unit*> &TagUnitMap)
     uint32 unMaxTargets = m_spellInfo->MaxAffectedTargets;
     switch(cur)
     {
-        case TARGET_TOTEM_EARTH:
-        case TARGET_TOTEM_WATER:
-        case TARGET_TOTEM_AIR:
-        case TARGET_TOTEM_FIRE:
+        case TARGET_LOCATION_FRONT_LEFT:
+        case TARGET_LOCATION_BACK_LEFT:
+        case TARGET_LOCATION_BACK_RIGHT:
+        case TARGET_LOCATION_FRONT_RIGHT:
+        case TARGET_LOCATION_FRONT:
+        case TARGET_LOCATION_BACK:
+        case TARGET_LOCATION_LEFT:
+        case TARGET_LOCATION_RIGHT:
+        case TARGET_LOCATION_RANDOM_AROUND_CASTER:
+        case TARGET_LOCATION_RADIUS_AROUND_CASTER:
+        {
+            float x, y, z, angle, dist;
+
+            if (m_spellInfo->EffectRadiusIndex[i])
+                dist = GetSpellRadius(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
+            else
+                dist = 3.0f;
+            if (cur == TARGET_LOCATION_RANDOM_AROUND_CASTER)
+                dist *= rand_norm(); // This case we need to consider caster size
+            else
+                dist -= m_caster->GetObjectSize(); // Size is calculated in GetNearPoint(), but we do not need it 
+
+            switch(cur)
+            {
+                case TARGET_LOCATION_FRONT_LEFT:
+                    angle = -M_PI/4;
+                    break;
+                case TARGET_LOCATION_BACK_LEFT:
+                    angle = -3*M_PI/4;
+                    break;
+                case TARGET_LOCATION_BACK_RIGHT:
+                    angle = 3*M_PI/4;
+                    break;
+                case TARGET_LOCATION_FRONT_RIGHT:
+                    angle = M_PI/4;
+                    break;
+                case TARGET_LOCATION_FRONT:
+                    angle = 0.0f;
+                    break;
+                case TARGET_LOCATION_BACK:
+                    angle = M_PI;
+                    break;
+                case TARGET_LOCATION_LEFT:
+                    angle = -M_PI/2;
+                    break;
+                case TARGET_LOCATION_RIGHT:
+                    angle = M_PI/2;
+                    break;
+                default:
+                    angle = rand_norm()*2*M_PI;
+                    break;
+            }
+
+            m_caster->GetClosePoint(x, y, z, 0, dist, angle);
+            m_targets.setDestination(x, y, z);
+            if (m_targets.getUnitTarget())
+                TagUnitMap.push_back(m_targets.getUnitTarget());
+            else
+                TagUnitMap.push_back(m_caster); 
+        }break;
+        case TARGET_LOCATION_RANDOM_IN_AREA:
+        case TARGET_LOCATION_AROUND_DEST:
+        {
+            float x, y, z, dist, px, py, pz;
+            dist = GetSpellRadius(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
+            if (m_targets.m_targetMask & TARGET_FLAG_DEST_LOCATION)
+            {
+                x = m_targets.m_destX;
+                y = m_targets.m_destY;
+                z = m_targets.m_destZ;
+            }
+            else if (m_targets.getUnitTarget()) // Do not know if possible
+                m_targets.getUnitTarget()->GetPosition(x, y, z);
+            else
+                m_caster->GetPosition(x, y, z);
+
+            m_caster->GetRandomPoint(x, y, z, dist, px, py, pz);
+            m_targets.setDestination(px, py, pz);
+            if (m_targets.getUnitTarget())
+                TagUnitMap.push_back(m_targets.getUnitTarget());
+            else
+                TagUnitMap.push_back(m_caster);
+        }break;
+        case TARGET_LOCATION_AT_DEST:
+        {
+            if (m_targets.getUnitTarget())
+                TagUnitMap.push_back(m_targets.getUnitTarget());
+            else
+                TagUnitMap.push_back(m_caster);
+        }break;
         case TARGET_SELF:
-        case TARGET_SELF2:
-        case TARGET_DYNAMIC_OBJECT:
         case TARGET_AREAEFFECT_CUSTOM:
         case TARGET_AREAEFFECT_CUSTOM_2:
-        case TARGET_SUMMON:
         {
             TagUnitMap.push_back(m_caster);
             break;
@@ -1664,11 +1747,11 @@ void Spell::SetTargetMap(uint32 i,uint32 cur,std::list<Unit*> &TagUnitMap)
                     // IsHostileTo check duel and controlled by enemy
                     if(Target && Target->GetSubGroup()==subgroup && !m_caster->IsHostileTo(Target))
                     {
-                        if( pTarget->IsWithinDistInMap(Target, radius) )
+                        if(Target->getLevel()+10 >= m_spellInfo->spellLevel && pTarget->IsWithinDistInMap(Target, radius))
                             TagUnitMap.push_back(Target);
 
                         if(Pet* pet = Target->GetPet())
-                            if( pTarget->IsWithinDistInMap(pet, radius) )
+                            if(pet->getLevel()+10 >= m_spellInfo->spellLevel && pTarget->IsWithinDistInMap(pet, radius) )
                                 TagUnitMap.push_back(pet);
                     }
                 }
@@ -1683,7 +1766,7 @@ void Spell::SetTargetMap(uint32 i,uint32 cur,std::list<Unit*> &TagUnitMap)
                 TagUnitMap.push_back(pTarget);
 
                 if(Pet* pet = pTarget->GetPet())
-                    if( m_caster->IsWithinDistInMap(pet, radius) )
+                    if(pet->getLevel()+10 >= m_spellInfo->spellLevel && m_caster->IsWithinDistInMap(pet, radius) )
                         TagUnitMap.push_back(pet);
             }
 
@@ -1809,9 +1892,7 @@ void Spell::SetTargetMap(uint32 i,uint32 cur,std::list<Unit*> &TagUnitMap)
                     Player* Target = itr->getSource();
 
                     // IsHostileTo check duel and controlled by enemy
-                    if( Target && targetPlayer->IsWithinDistInMap(Target, radius) &&
-                        targetPlayer->getClass() == Target->getClass() &&
-                        !m_caster->IsHostileTo(Target) )
+                    if( Target && Target->getLevel()+10 >= m_spellInfo->spellLevel && targetPlayer->getClass() == Target->getClass() && !m_caster->IsHostileTo(Target) && targetPlayer->IsWithinDistInMap(Target, radius) )
                     {
                         TagUnitMap.push_back(Target);
                     }
@@ -2490,7 +2571,24 @@ void Spell::finish(bool ok)
     // other code related only to successfully finished spells
     if(!ok)
         return;
-
+    //holy nova heal
+    if(m_spellInfo->SpellFamilyName == SPELLFAMILY_PRIEST && m_spellInfo->SpellIconID == 1874)
+    {
+        int holy_nova_heal = 0;
+        switch(m_spellInfo->Id)
+        {
+            case 15237: holy_nova_heal = 23455; break;
+            case 15430: holy_nova_heal = 23458; break;
+            case 15431: holy_nova_heal = 23459; break;
+            case 27799: holy_nova_heal = 27803; break;
+            case 27804: holy_nova_heal = 27800; break;
+            case 27801: holy_nova_heal = 27805; break;
+            case 25331: holy_nova_heal = 25329; break;
+            default:break;
+        }
+        if(holy_nova_heal)
+            m_caster->CastSpell(m_caster, holy_nova_heal, true);
+    }
     //handle SPELL_AURA_ADD_TARGET_TRIGGER auras
     Unit::AuraList const& targetTriggers = m_caster->GetAurasByType(SPELL_AURA_ADD_TARGET_TRIGGER);
     for(Unit::AuraList::const_iterator i = targetTriggers.begin(); i != targetTriggers.end(); ++i)
@@ -2510,7 +2608,8 @@ void Spell::finish(bool ok)
                     int32 chance = m_caster->CalculateSpellDamage(auraSpellInfo, auraSpellIdx, (*i)->GetBasePoints(),unit);
 
                     if(roll_chance_i(chance))
-                        m_caster->CastSpell(unit, auraSpellInfo->EffectTriggerSpell[auraSpellIdx], true, NULL, (*i));
+                        for ( int j=0; j != (*i)->m_stackAmount; ++j)
+                            m_caster->CastSpell(unit, auraSpellInfo->EffectTriggerSpell[auraSpellIdx], true, NULL, (*i));
                 }
             }
         }
@@ -3267,23 +3366,6 @@ uint8 Spell::CanCast(bool strict)
             }
         }
 
-        // TODO: this check can be applied and for player to prevent cheating when IsPositiveSpell will return always correct result.
-        // check target for pet/charmed casts (not self targeted), self targeted cast used for area effects and etc
-        if(m_caster != target && m_caster->GetTypeId()==TYPEID_UNIT && m_caster->GetCharmerOrOwnerGUID())
-        {
-            // check correctness positive/negative cast target (pet cast real check and cheating check)
-            if(IsPositiveSpell(m_spellInfo->Id))
-            {
-                if(m_caster->IsHostileTo(target))
-                    return SPELL_FAILED_BAD_TARGETS;
-            }
-            else
-            {
-                if(m_caster->IsFriendlyTo(target))
-                    return SPELL_FAILED_BAD_TARGETS;
-            }
-        }
-
         if(IsPositiveSpell(m_spellInfo->Id))
         {
             if(target->IsImmunedToSpell(m_spellInfo,false))
@@ -3898,19 +3980,6 @@ uint8 Spell::CanCast(bool strict)
             case SPELL_EFFECT_LEAP:
             case SPELL_EFFECT_TELEPORT_UNITS_FACE_CASTER:
             {
-                float dis = GetSpellRadius(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
-                float fx = m_caster->GetPositionX() + dis * cos(m_caster->GetOrientation());
-                float fy = m_caster->GetPositionY() + dis * sin(m_caster->GetOrientation());
-                // teleport a bit above terrain level to avoid falling below it
-                float fz = MapManager::Instance().GetBaseMap(m_caster->GetMapId())->GetHeight(fx,fy,m_caster->GetPositionZ(),true);
-                if(fz <= INVALID_HEIGHT)                    // note: this also will prevent use effect in instances without vmaps height enabled
-                    return SPELL_FAILED_TRY_AGAIN;
-
-                float caster_pos_z = m_caster->GetPositionZ();
-                // Control the caster to not climb or drop when +-fz > 8
-                if(!(fz<=caster_pos_z+8 && fz>=caster_pos_z-8))
-                    return SPELL_FAILED_TRY_AGAIN;
-
                 // not allow use this effect at battleground until battleground start
                 if(m_caster->GetTypeId()==TYPEID_PLAYER)
                     if(BattleGround const *bg = ((Player*)m_caster)->GetBattleGround())
@@ -4057,22 +4126,23 @@ int16 Spell::PetCanCast(Unit* target)
             if(!_target->isAlive())
                 return SPELL_FAILED_BAD_TARGETS;
 
-            if(IsPositiveSpell(m_spellInfo->Id))
+            bool duelvsplayertar = false;
+            for(int j=0;j<3;j++)
             {
-                if(m_caster->IsHostileTo(_target))
-                    return SPELL_FAILED_BAD_TARGETS;
+                                                //TARGET_DUELVSPLAYER is positive AND negative
+                duelvsplayertar |= (m_spellInfo->EffectImplicitTargetA[j] == TARGET_DUELVSPLAYER);
             }
-            else
+            if (!duelvsplayertar)
             {
-                bool duelvsplayertar = false;
-                for(int j=0;j<3;j++)
+                if(IsPositiveSpell(m_spellInfo->Id))
                 {
-                                                            //TARGET_DUELVSPLAYER is positive AND negative
-                    duelvsplayertar |= (m_spellInfo->EffectImplicitTargetA[j] == TARGET_DUELVSPLAYER);
+                    if(m_caster->IsHostileTo(_target))
+                        return SPELL_FAILED_BAD_TARGETS;
                 }
-                if(m_caster->IsFriendlyTo(target) && !duelvsplayertar)
+                else
                 {
-                    return SPELL_FAILED_BAD_TARGETS;
+                    if(m_caster->IsFriendlyTo(target))
+                        return SPELL_FAILED_BAD_TARGETS;
                 }
             }
         }
@@ -4092,9 +4162,16 @@ uint8 Spell::CheckCasterAuras() const
 {
     // Flag drop spells totally immuned to caster auras
     // FIXME: find more nice check for all totally immuned spells
-    // AttributesEx3 & 0x10000000?
-    if(m_spellInfo->Id==23336 || m_spellInfo->Id==23334 || m_spellInfo->Id==34991)
-        return 0;
+    switch(m_spellInfo->Id)
+    {
+        case 23336:     // Alliance Flag Drop
+        case 23334:     // Horde Flag Drop
+        case 34991:     // Summon Netherstorm Flag
+        case 22812:     // Barkskin
+            return 0;
+        default:
+            break;
+    }
 
     uint8 school_immune = 0;
     uint32 mechanic_immune = 0;
diff --git a/src/game/SpellAuras.cpp b/src/game/SpellAuras.cpp
index 82770df..64bf9e0 100644
--- a/src/game/SpellAuras.cpp
+++ b/src/game/SpellAuras.cpp
@@ -315,7 +315,7 @@ pAuraHandler AuraHandler[TOTAL_AURAS]=
 };
 
 Aura::Aura(SpellEntry const* spellproto, uint32 eff, int32 *currentBasePoints, Unit *target, Unit *caster, Item* castItem) :
-m_procCharges(0), m_spellmod(NULL), m_effIndex(eff), m_caster_guid(0), m_target(target),
+m_procCharges(0), m_stackAmount(1), m_spellmod(NULL), m_effIndex(eff), m_caster_guid(0), m_target(target),
 m_timeCla(1000), m_castItemGuid(castItem?castItem->GetGUID():0), m_auraSlot(MAX_AURAS),
 m_positive(false), m_permanent(false), m_isPeriodic(false), m_isTrigger(false), m_isAreaAura(false),
 m_isPersistent(false), m_updated(false), m_removeMode(AURA_REMOVE_BY_DEFAULT), m_isRemovedOnShapeLost(true), m_in_use(false),
@@ -857,7 +857,6 @@ void Aura::_AddAura()
         return;
 
     // we can found aura in NULL_AURA_SLOT and then need store state instead check slot != NULL_AURA_SLOT
-    bool samespell = false;
     bool secondaura = false;
     uint8 slot = NULL_AURA_SLOT;
 
@@ -869,15 +868,13 @@ void Aura::_AddAura()
             // allow use single slot only by auras from same caster
             if(itr->second->GetCasterGUID()==GetCasterGUID())
             {
-                samespell = true;
-                if (m_effIndex > itr->second->GetEffIndex())
-                     secondaura = true;
+                secondaura = true;
                 slot = itr->second->GetAuraSlot();
                 break;
             }
         }
 
-        if(samespell)
+        if(secondaura)
             break;
     }
 
@@ -906,7 +903,7 @@ void Aura::_AddAura()
     if((!m_isPassive || (caster && caster->GetTypeId() == TYPEID_UNIT && ((Creature*)caster)->isTotem())) &&
         (m_spellProto->Effect[GetEffIndex()] != SPELL_EFFECT_APPLY_AREA_AURA_ENEMY || m_target != caster))
     {
-        if(!samespell)                                      // new slot need
+        if(!secondaura)                                     // new slot need
         {
             if (IsPositive())                               // empty positive slot
             {
@@ -934,30 +931,24 @@ void Aura::_AddAura()
             SetAuraSlot( slot );
 
             // Not update fields for not first spell's aura, all data already in fields
-            if(!secondaura)
+            if(slot < MAX_AURAS)                        // slot found
             {
-                if(slot < MAX_AURAS)                        // slot found
-                {
-                    SetAura(slot, false);
-                    SetAuraFlag(slot, true);
-                    SetAuraLevel(slot,caster ? caster->getLevel() : sWorld.getConfig(CONFIG_MAX_PLAYER_LEVEL));
-                    UpdateAuraCharges();
-
-                    // update for out of range group members
-                    m_target->UpdateAuraForGroup(slot);
-                }
-
-                UpdateAuraDuration();
+                SetAura(slot, false);
+                SetAuraFlag(slot, true);
+                SetAuraLevel(slot,caster ? caster->getLevel() : sWorld.getConfig(CONFIG_MAX_PLAYER_LEVEL));
+                UpdateAuraCharges();
+                
+                // update for out of range group members
+                m_target->UpdateAuraForGroup(slot);
             }
         }
         else                                                // use found slot
         {
             SetAuraSlot( slot );
-            // Not recalculate stack count for second aura of the same spell
-            if (!secondaura)
-                UpdateSlotCounterAndDuration(true);
         }
 
+        UpdateSlotCounterAndDuration();
+
         // Update Seals information
         if( IsSealSpell(GetSpellProto()) )
             m_target->ModifyAuraState(AURA_STATE_JUDGEMENT, true);
@@ -1008,7 +999,6 @@ void Aura::_RemoveAura()
         return;
 
     bool samespell = false;
-    bool sameaura = false;
 
     // find other aura in same slot (current already removed from list)
     for(uint8 i = 0; i < 3; i++)
@@ -1019,10 +1009,6 @@ void Aura::_RemoveAura()
             if(itr->second->GetAuraSlot()==slot)
             {
                 samespell = true;
-
-                if(GetEffIndex()==i)
-                    sameaura = true;
-
                 break;
             }
         }
@@ -1074,8 +1060,6 @@ void Aura::_RemoveAura()
                 ((Player*)caster)->SendCooldownEvent(GetSpellProto());
         }
     }
-    else if(sameaura)                                       // decrease count for spell, only for same aura effect, or this spell auras in remove process.
-        UpdateSlotCounterAndDuration(false);
 }
 
 void Aura::SetAuraFlag(uint32 slot, bool add)
@@ -1114,35 +1098,13 @@ void Aura::SetAuraApplication(uint32 slot, int8 count)
     m_target->SetUInt32Value(UNIT_FIELD_AURAAPPLICATIONS + index, val);
 }
 
-void Aura::UpdateSlotCounterAndDuration(bool add)
+void Aura::UpdateSlotCounterAndDuration()
 {
     uint8 slot = GetAuraSlot();
     if(slot >= MAX_AURAS)
         return;
 
-    // calculate amount of similar auras by same effect index (similar different spells)
-    int8 count = 0;
-
-    // calculate auras and update durations in case aura adding
-    Unit::AuraList const& aura_list = m_target->GetAurasByType(GetModifier()->m_auraname);
-    for(Unit::AuraList::const_iterator i = aura_list.begin();i != aura_list.end(); ++i)
-    {
-        if( (*i)->GetId()==GetId() && (*i)->GetEffIndex()==m_effIndex &&
-            (*i)->GetCasterGUID()==GetCasterGUID() )
-        {
-            ++count;
-
-            if(add)
-                (*i)->SetAuraDuration(GetAuraDuration());
-        }
-    }
-
-    // at aura add aura not added yet, at aura remove aura already removed
-    // in field stored (count-1)
-    if(!add)
-        --count;
-
-    SetAuraApplication(slot, count);
+    SetAuraApplication(slot, m_stackAmount - 1);
 
     UpdateAuraDuration();
 }
@@ -1176,7 +1138,7 @@ void Aura::HandleAddModifier(bool apply, bool Real)
 
         SpellModifier *mod = new SpellModifier;
         mod->op = SpellModOp(m_modifier.m_miscvalue);
-        mod->value = m_modifier.m_amount;
+        mod->value = m_modifier.m_amount * m_stackAmount;
         mod->type = SpellModType(m_modifier.m_auraname);    // SpellModType value == spell aura types
         mod->spellId = GetId();
         mod->effectId = m_effIndex;
@@ -1645,8 +1607,21 @@ void Aura::TriggerSpell()
 //                    case 40867: break;
 //                    // Prismatic Shield
 //                    case 40879: break;
-//                    // Aura of Desire
-//                    case 41350: break;
+//                  // Aura of Desire
+                    case 41350:
+                    {
+                        Unit::AuraList const& mMod = m_target->GetAurasByType(SPELL_AURA_MOD_INCREASE_ENERGY_PERCENT);
+                        for(Unit::AuraList::const_iterator i = mMod.begin(); i != mMod.end(); ++i)
+                        {
+                            if ((*i)->GetId() == 41350)
+                            {
+                                (*i)->ApplyModifier(false);
+                                (*i)->GetModifier()->m_amount -= 5;
+                                (*i)->ApplyModifier(true);
+                                break;
+                            }
+                        }                        
+                    }break;
 //                    // Dementia
 //                    case 41404: break;
 //                    // Chaos Form
@@ -1866,8 +1841,8 @@ void Aura::TriggerSpell()
                     {
                         switch((*i)->GetModifier()->m_miscvalue)
                         {
-                            case STAT_INTELLECT: intelectLoss += (*i)->GetModifier()->m_amount; break;
-                            case STAT_SPIRIT:    spiritLoss   += (*i)->GetModifier()->m_amount; break;
+                            case STAT_INTELLECT: intelectLoss += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount; break;
+                            case STAT_SPIRIT:    spiritLoss   += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount; break;
                             default: break;
                         }
                     }
@@ -2136,7 +2111,8 @@ void Aura::HandleAuraDummy(bool apply, bool Real)
                             return;
 
                     // final heal
-                    m_target->CastCustomSpell(m_target,33778,&m_modifier.m_amount,NULL,NULL,true,NULL,this,GetCasterGUID());
+                    if(m_target->IsInWorld())
+                        m_target->CastCustomSpell(m_target,33778,&m_modifier.m_amount,NULL,NULL,true,NULL,this,GetCasterGUID());
                 }
                 return;
             }
@@ -2789,7 +2765,7 @@ void Aura::HandleAuraModSkill(bool apply, bool Real)
         return;
 
     uint32 prot=GetSpellProto()->EffectMiscValue[m_effIndex];
-    int32 points = GetModifier()->m_amount;
+    int32 points = GetModifier()->m_amount * m_stackAmount;
 
     ((Player*)m_target)->ModifySkillBonus(prot,(apply ? points: -points),m_modifier.m_auraname==SPELL_AURA_MOD_SKILL_TALENT);
     if(prot == SKILL_DEFENSE)
@@ -2878,7 +2854,7 @@ void Aura::HandleAuraTrackStealthed(bool apply, bool Real)
 
 void Aura::HandleAuraModScale(bool apply, bool Real)
 {
-    m_target->ApplyPercentModFloatValue(OBJECT_FIELD_SCALE_X,m_modifier.m_amount,apply);
+    m_target->ApplyPercentModFloatValue(OBJECT_FIELD_SCALE_X,m_modifier.m_amount * m_stackAmount,apply);
 }
 
 void Aura::HandleModPossess(bool apply, bool Real)
@@ -3180,6 +3156,9 @@ void Aura::HandleAuraModDisarm(bool apply, bool Real)
 
 void Aura::HandleAuraModStun(bool apply, bool Real)
 {
+    if(m_target->isInFlight())
+        return;
+
     if(!Real)
         return;
 
@@ -3197,6 +3176,24 @@ void Aura::HandleAuraModStun(bool apply, bool Real)
         else
             m_target->SetUnitMovementFlags(0);    //Clear movement flags
 
+        // Summon the Naj'entus Spine GameObject on target if spell is Impaling Spine
+        if(GetSpellProto()->Id == 39837)
+        {
+            GameObject* pObj = new GameObject;
+            float x, y, z;
+            m_target->GetPosition(x, y, z);
+ 
+            if(!pObj->Create(objmgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), 185584, m_target->GetMap(), x, y, z, 0, 0, 0, 0, 0, 100, 1))
+            {
+                delete pObj;
+                return;
+            }
+ 
+            pObj->SetRespawnTime(GetSpellDuration(GetSpellProto())/1000);
+            m_target->AddGameObject(pObj);
+            MapManager::Instance().GetMap(pObj->GetMapId(), pObj)->Add(pObj);
+        }
+
         WorldPacket data(SMSG_FORCE_MOVE_ROOT, 8);
 
         data.append(m_target->GetPackGUID());
@@ -3490,15 +3487,11 @@ void Aura::HandleAuraModSilence(bool apply, bool Real)
                     return;
 
                 // Search Mana Tap auras on caster
-                int32 energy = 0;
-                Unit::AuraList const& m_dummyAuras = caster->GetAurasByType(SPELL_AURA_DUMMY);
-                for(Unit::AuraList::const_iterator i = m_dummyAuras.begin(); i != m_dummyAuras.end(); ++i)
-                    if ((*i)->GetId() == 28734)
-                        ++energy;
-                if (energy)
+                Aura * dummy = caster->GetDummyAura(28734);
+                if (dummy)
                 {
-                    energy *= 10;
-                    caster->CastCustomSpell(caster, 25048, &energy, NULL, NULL, true);
+                    int32 bp = dummy->m_stackAmount * 10;
+                    caster->CastCustomSpell(caster, 25048, &bp, NULL, NULL, true);
                     caster->RemoveAurasDueToSpell(28734);
                 }
             }
@@ -3551,7 +3544,7 @@ void Aura::HandleModThreat(bool apply, bool Real)
         if(m_modifier.m_miscvalue & int32(1<<x))
         {
             if(m_target->GetTypeId() == TYPEID_PLAYER)
-                ApplyPercentModFloatVar(m_target->m_threatModifier[x], m_positive ? m_modifier.m_amount : -m_modifier.m_amount, apply);
+                ApplyPercentModFloatVar(m_target->m_threatModifier[x], m_positive ? m_modifier.m_amount * m_stackAmount : -m_modifier.m_amount * m_stackAmount, apply);
         }
     }
 }
@@ -3572,9 +3565,9 @@ void Aura::HandleAuraModTotalThreat(bool apply, bool Real)
 
     float threatMod = 0.0f;
     if(apply)
-        threatMod = float(m_modifier.m_amount);
+        threatMod = float(m_modifier.m_amount * m_stackAmount);
     else
-        threatMod =  float(-m_modifier.m_amount);
+        threatMod =  float(-m_modifier.m_amount * m_stackAmount);
 
     m_target->getHostilRefManager().threatAssist(caster, threatMod);
 }
@@ -4012,6 +4005,40 @@ void Aura::HandlePeriodicDamage(bool apply, bool Real)
 
     Unit *caster = GetCaster();
 
+    // Blood Frenzy, remove when no longer bleeding
+    if (Real && !apply && m_spellProto->SpellFamilyName==SPELLFAMILY_WARRIOR && (m_spellProto->SpellFamilyFlags & 0x1000000020LL) )
+    {
+         // search for another rend or deep wounds
+         bool found = false;
+         Unit::AuraList const& auras = m_target->GetAurasByType(SPELL_AURA_PERIODIC_DAMAGE);
+         for(Unit::AuraList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+         {
+              SpellEntry const* itr_spell = (*itr)->GetSpellProto();
+              if(itr_spell && itr_spell->SpellFamilyName==SPELLFAMILY_WARRIOR && (itr_spell->SpellFamilyFlags & 0x1000000020LL) )
+              {
+                   found = true;
+                   break;
+              }
+         }
+         if(!found)
+         {
+              Unit::AuraList const& auras = m_target->GetAurasByType(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN);
+              for(Unit::AuraList::const_iterator itr = auras.begin(); itr != auras.end();)
+              {
+                   SpellEntry const* itr_spell = (*itr)->GetSpellProto();
+                   if(itr_spell && itr_spell->SpellIconID == 2005 )
+                   {
+                        m_target->RemoveAurasDueToSpell(itr_spell->Id);
+                        itr = auras.begin();
+                   }
+                   else
+                   {
+                       itr++;
+                   }
+              }
+         }
+    }
+
     switch (m_spellProto->SpellFamilyName)
     {
         case SPELLFAMILY_GENERIC:
@@ -4136,6 +4163,7 @@ void Aura::HandlePeriodicDamage(bool apply, bool Real)
                     m_modifier.m_amount += int32(caster->GetTotalAttackPowerValue(BASE_ATTACK) * 3 / 100);
                 return;
             }
+            
             break;
         }
         case SPELLFAMILY_HUNTER:
@@ -4187,6 +4215,10 @@ void Aura::HandlePeriodicDamage(bool apply, bool Real)
             break;
         }
         default:
+           // Parasitic Shadowfiend - handle summoning of two Shadowfiends on DoT expire
+           if((m_spellProto->Id == 41917) && !apply && Real)
+                 m_target->CastSpell(m_target, 41915, true);
+            
             break;
     }
 }
@@ -4229,9 +4261,9 @@ void Aura::HandleAuraModResistanceExclusive(bool apply, bool Real)
     {
         if(m_modifier.m_miscvalue & int32(1<<x))
         {
-            m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + x), BASE_VALUE, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + x), BASE_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
             if(m_target->GetTypeId() == TYPEID_PLAYER)
-                m_target->ApplyResistanceBuffModsMod(SpellSchools(x),m_positive,m_modifier.m_amount, apply);
+                m_target->ApplyResistanceBuffModsMod(SpellSchools(x),m_positive,m_modifier.m_amount * m_stackAmount, apply);
         }
     }
 }
@@ -4242,9 +4274,9 @@ void Aura::HandleAuraModResistance(bool apply, bool Real)
     {
         if(m_modifier.m_miscvalue & int32(1<<x))
         {
-            m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + x), TOTAL_VALUE, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + x), TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
             if(m_target->GetTypeId() == TYPEID_PLAYER || ((Creature*)m_target)->isPet())
-                m_target->ApplyResistanceBuffModsMod(SpellSchools(x),m_positive,m_modifier.m_amount, apply);
+                m_target->ApplyResistanceBuffModsMod(SpellSchools(x),m_positive,m_modifier.m_amount * m_stackAmount, apply);
         }
     }
 
@@ -4264,14 +4296,14 @@ void Aura::HandleAuraModBaseResistancePCT(bool apply, bool Real)
     {
         //pets only have base armor
         if(((Creature*)m_target)->isPet() && (m_modifier.m_miscvalue & SPELL_SCHOOL_MASK_NORMAL))
-            m_target->HandleStatModifier(UNIT_MOD_ARMOR, BASE_PCT, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_ARMOR, BASE_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
     }
     else
     {
         for(int8 x = SPELL_SCHOOL_NORMAL; x < MAX_SPELL_SCHOOL;x++)
         {
             if(m_modifier.m_miscvalue & int32(1<<x))
-                m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + x), BASE_PCT, float(m_modifier.m_amount), apply);
+                m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + x), BASE_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
         }
     }
 }
@@ -4282,11 +4314,11 @@ void Aura::HandleModResistancePercent(bool apply, bool Real)
     {
         if(m_modifier.m_miscvalue & int32(1<<i))
         {
-            m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + i), TOTAL_PCT, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + i), TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
             if(m_target->GetTypeId() == TYPEID_PLAYER || ((Creature*)m_target)->isPet())
             {
-                m_target->ApplyResistanceBuffModsPercentMod(SpellSchools(i),true,m_modifier.m_amount, apply);
-                m_target->ApplyResistanceBuffModsPercentMod(SpellSchools(i),false,m_modifier.m_amount, apply);
+                m_target->ApplyResistanceBuffModsPercentMod(SpellSchools(i),true,m_modifier.m_amount * m_stackAmount, apply);
+                m_target->ApplyResistanceBuffModsPercentMod(SpellSchools(i),false,m_modifier.m_amount * m_stackAmount, apply);
             }
         }
     }
@@ -4299,13 +4331,13 @@ void Aura::HandleModBaseResistance(bool apply, bool Real)
     {
         //only pets have base stats
         if(((Creature*)m_target)->isPet() && (m_modifier.m_miscvalue & SPELL_SCHOOL_MASK_NORMAL))
-            m_target->HandleStatModifier(UNIT_MOD_ARMOR, TOTAL_VALUE, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_ARMOR, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
     }
     else
     {
         for(int i = SPELL_SCHOOL_NORMAL; i < MAX_SPELL_SCHOOL; i++)
             if(m_modifier.m_miscvalue & (1<<i))
-                m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + i), TOTAL_VALUE, float(m_modifier.m_amount), apply);
+                m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + i), TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
     }
 }
 
@@ -4327,9 +4359,9 @@ void Aura::HandleAuraModStat(bool apply, bool Real)
         if (m_modifier.m_miscvalue < 0 || m_modifier.m_miscvalue == i)
         {
             //m_target->ApplyStatMod(Stats(i), m_modifier.m_amount,apply);
-            m_target->HandleStatModifier(UnitMods(UNIT_MOD_STAT_START + i), TOTAL_VALUE, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UnitMods(UNIT_MOD_STAT_START + i), TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
             if(m_target->GetTypeId() == TYPEID_PLAYER || ((Creature*)m_target)->isPet())
-                m_target->ApplyStatBuffMod(Stats(i),m_modifier.m_amount,apply);
+                m_target->ApplyStatBuffMod(Stats(i),m_modifier.m_amount * m_stackAmount,apply);
         }
     }
 }
@@ -4349,7 +4381,7 @@ void Aura::HandleModPercentStat(bool apply, bool Real)
     for (int32 i = STAT_STRENGTH; i < MAX_STATS; ++i)
     {
         if(m_modifier.m_miscvalue == i || m_modifier.m_miscvalue == -1)
-            m_target->HandleStatModifier(UnitMods(UNIT_MOD_STAT_START + i), BASE_PCT, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UnitMods(UNIT_MOD_STAT_START + i), BASE_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
     }
 }
 
@@ -4427,9 +4459,9 @@ void Aura::HandleModTotalPercentStat(bool apply, bool Real)
     {
         if(m_modifier.m_miscvalue == i || m_modifier.m_miscvalue == -1)
         {
-            m_target->HandleStatModifier(UnitMods(UNIT_MOD_STAT_START + i), TOTAL_PCT, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UnitMods(UNIT_MOD_STAT_START + i), TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
             if(m_target->GetTypeId() == TYPEID_PLAYER || ((Creature*)m_target)->isPet())
-                m_target->ApplyStatPercentBuffMod(Stats(i), m_modifier.m_amount, apply );
+                m_target->ApplyStatPercentBuffMod(Stats(i), m_modifier.m_amount * m_stackAmount, apply );
         }
     }
 
@@ -4527,7 +4559,7 @@ void Aura::HandleModRegen(bool apply, bool Real)            // eating
         if(m_periodicTimer <= 0)
         {
             m_periodicTimer += 5000;
-            int32 gain = m_target->ModifyHealth(m_modifier.m_amount);
+            int32 gain = m_target->ModifyHealth(m_modifier.m_amount * m_stackAmount);
             Unit *caster = GetCaster();
             if (caster)
             {
@@ -4543,6 +4575,18 @@ void Aura::HandleModRegen(bool apply, bool Real)            // eating
 
 void Aura::HandleModPowerRegen(bool apply, bool Real)       // drinking
 {
+    // remove old auras from drinking
+    if (apply && (GetSpellProto()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED))
+    {
+        Unit::AuraList const& m_ModPowerRegen = m_target->GetAurasByType(SPELL_AURA_MOD_POWER_REGEN);
+        for(Unit::AuraList::const_iterator i = m_ModPowerRegen.begin(); i != m_ModPowerRegen.end(); ++i)
+            if ( ((*i)->GetSpellProto()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED) && GetSpellProto() != (*i)->GetSpellProto() )
+            {
+                m_target->RemoveAurasDueToSpell( (*i)->GetSpellProto()->Id );
+                break;
+            }
+    }
+
     if ((GetSpellProto()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED) && apply && !m_target->IsSitState())
         m_target->SetStandState(PLAYER_STATE_SIT);
 
@@ -4643,7 +4687,7 @@ void Aura::HandleAuraModIncreaseHealth(bool apply, bool Real)
     }
 
     // generic case
-    m_target->HandleStatModifier(UNIT_MOD_HEALTH, TOTAL_VALUE, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_HEALTH, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void  Aura::HandleAuraModIncreaseMaxHealth(bool apply, bool Real)
@@ -4651,7 +4695,7 @@ void  Aura::HandleAuraModIncreaseMaxHealth(bool apply, bool Real)
     uint32 oldhealth = m_target->GetHealth();
     double healthPercentage = (double)oldhealth / (double)m_target->GetMaxHealth();
 
-    m_target->HandleStatModifier(UNIT_MOD_HEALTH, TOTAL_VALUE, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_HEALTH, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
 
     // refresh percentage
     if(oldhealth > 0)
@@ -4670,7 +4714,7 @@ void Aura::HandleAuraModIncreaseEnergy(bool apply, bool Real)
     if(int32(powerType) != m_modifier.m_miscvalue)
         return;
 
-    m_target->HandleStatModifier(UnitMods(UNIT_MOD_POWER_START + powerType), TOTAL_VALUE, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UnitMods(UNIT_MOD_POWER_START + powerType), TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void Aura::HandleAuraModIncreaseEnergyPercent(bool apply, bool Real)
@@ -4679,13 +4723,13 @@ void Aura::HandleAuraModIncreaseEnergyPercent(bool apply, bool Real)
     if(int32(powerType) != m_modifier.m_miscvalue)
         return;
 
-    m_target->HandleStatModifier(UnitMods(UNIT_MOD_POWER_START + powerType), TOTAL_PCT, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UnitMods(UNIT_MOD_POWER_START + powerType), TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void Aura::HandleAuraModIncreaseHealthPercent(bool apply, bool Real)
 {
     //m_target->ApplyMaxHealthPercentMod(m_modifier.m_amount,apply);
-    m_target->HandleStatModifier(UNIT_MOD_HEALTH, TOTAL_PCT, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_HEALTH, TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 /********************************/
@@ -4749,9 +4793,9 @@ void Aura::HandleAuraModCritPercent(bool apply, bool Real)
 
     if (GetSpellProto()->EquippedItemClass == -1)
     {
-        ((Player*)m_target)->HandleBaseModValue(CRIT_PERCENTAGE,         FLAT_MOD, float (m_modifier.m_amount), apply);
-        ((Player*)m_target)->HandleBaseModValue(OFFHAND_CRIT_PERCENTAGE, FLAT_MOD, float (m_modifier.m_amount), apply);
-        ((Player*)m_target)->HandleBaseModValue(RANGED_CRIT_PERCENTAGE,  FLAT_MOD, float (m_modifier.m_amount), apply);
+        ((Player*)m_target)->HandleBaseModValue(CRIT_PERCENTAGE,         FLAT_MOD, float (m_modifier.m_amount * m_stackAmount), apply);
+        ((Player*)m_target)->HandleBaseModValue(OFFHAND_CRIT_PERCENTAGE, FLAT_MOD, float (m_modifier.m_amount * m_stackAmount), apply);
+        ((Player*)m_target)->HandleBaseModValue(RANGED_CRIT_PERCENTAGE,  FLAT_MOD, float (m_modifier.m_amount * m_stackAmount), apply);
     }
     else
     {
@@ -4761,13 +4805,13 @@ void Aura::HandleAuraModCritPercent(bool apply, bool Real)
 
 void Aura::HandleModHitChance(bool apply, bool Real)
 {
-    m_target->m_modMeleeHitChance += apply ? m_modifier.m_amount : (-m_modifier.m_amount);
-    m_target->m_modRangedHitChance += apply ? m_modifier.m_amount : (-m_modifier.m_amount);
+    m_target->m_modMeleeHitChance += apply ? m_modifier.m_amount * m_stackAmount : (-m_modifier.m_amount * m_stackAmount);
+    m_target->m_modRangedHitChance += apply ? m_modifier.m_amount * m_stackAmount : (-m_modifier.m_amount * m_stackAmount);
 }
 
 void Aura::HandleModSpellHitChance(bool apply, bool Real)
 {
-    m_target->m_modSpellHitChance += apply ? m_modifier.m_amount: (-m_modifier.m_amount);
+    m_target->m_modSpellHitChance += apply ? m_modifier.m_amount * m_stackAmount: (-m_modifier.m_amount * m_stackAmount);
 }
 
 void Aura::HandleModSpellCritChance(bool apply, bool Real)
@@ -4782,7 +4826,7 @@ void Aura::HandleModSpellCritChance(bool apply, bool Real)
     }
     else
     {
-        m_target->m_baseSpellCritChance += apply ? m_modifier.m_amount:(-m_modifier.m_amount);
+        m_target->m_baseSpellCritChance += apply ? m_modifier.m_amount * m_stackAmount:(-m_modifier.m_amount * m_stackAmount);
     }
 }
 
@@ -4806,49 +4850,47 @@ void Aura::HandleModSpellCritChanceShool(bool /*apply*/, bool Real)
 
 void Aura::HandleModCastingSpeed(bool apply, bool Real)
 {
-    m_target->ApplyCastTimePercentMod(m_modifier.m_amount,apply);
+    m_target->ApplyCastTimePercentMod(m_modifier.m_amount * m_stackAmount,apply);
 }
 
 void Aura::HandleModMeleeRangedSpeedPct(bool apply, bool Real)
 {
-    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,m_modifier.m_amount,apply);
-    m_target->ApplyAttackTimePercentMod(OFF_ATTACK,m_modifier.m_amount,apply);
-    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK, m_modifier.m_amount, apply);
+    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,m_modifier.m_amount * m_stackAmount,apply);
+    m_target->ApplyAttackTimePercentMod(OFF_ATTACK,m_modifier.m_amount * m_stackAmount,apply);
+    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK, m_modifier.m_amount * m_stackAmount, apply);
 }
 
 void Aura::HandleModCombatSpeedPct(bool apply, bool Real)
 {
-    m_target->ApplyCastTimePercentMod(m_modifier.m_amount,apply);
-    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,m_modifier.m_amount,apply);
-    m_target->ApplyAttackTimePercentMod(OFF_ATTACK,m_modifier.m_amount,apply);
-    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK, m_modifier.m_amount, apply);
+    m_target->ApplyCastTimePercentMod(m_modifier.m_amount * m_stackAmount,apply);
+    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,m_modifier.m_amount * m_stackAmount,apply);
+    m_target->ApplyAttackTimePercentMod(OFF_ATTACK,m_modifier.m_amount * m_stackAmount,apply);
+    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK, m_modifier.m_amount * m_stackAmount, apply);
 }
 
-void Aura::HandleModAttackSpeed(bool apply, bool Real)
-{
-    if(!m_target->isAlive() )
-        return;
-
-    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,m_modifier.m_amount,apply);
-}
+ void Aura::HandleModAttackSpeed(bool apply, bool Real)
+ {
+    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,m_modifier.m_amount * m_stackAmount,apply);
+    m_target->UpdateDamagePhysical(BASE_ATTACK);
+ }
 
 void Aura::HandleHaste(bool apply, bool Real)
 {
-    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,  m_modifier.m_amount,apply);
-    m_target->ApplyAttackTimePercentMod(OFF_ATTACK,   m_modifier.m_amount,apply);
-    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK,m_modifier.m_amount,apply);
+    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,  m_modifier.m_amount * m_stackAmount,apply);
+    m_target->ApplyAttackTimePercentMod(OFF_ATTACK,   m_modifier.m_amount * m_stackAmount,apply);
+    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK,m_modifier.m_amount * m_stackAmount,apply);
 }
 
 void Aura::HandleAuraModRangedHaste(bool apply, bool Real)
 {
-    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK, m_modifier.m_amount, apply);
+    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK, m_modifier.m_amount * m_stackAmount, apply);
 }
 
 void Aura::HandleRangedAmmoHaste(bool apply, bool Real)
 {
     if(m_target->GetTypeId() != TYPEID_PLAYER)
         return;
-    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK,m_modifier.m_amount, apply);
+    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK,m_modifier.m_amount * m_stackAmount, apply);
 }
 
 /********************************/
@@ -4857,7 +4899,7 @@ void Aura::HandleRangedAmmoHaste(bool apply, bool Real)
 
 void Aura::HandleAuraModAttackPower(bool apply, bool Real)
 {
-    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void Aura::HandleAuraModRangedAttackPower(bool apply, bool Real)
@@ -4865,13 +4907,13 @@ void Aura::HandleAuraModRangedAttackPower(bool apply, bool Real)
     if((m_target->getClassMask() & CLASSMASK_WAND_USERS)!=0)
         return;
 
-    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void Aura::HandleAuraModAttackPowerPercent(bool apply, bool Real)
 {
     //UNIT_FIELD_ATTACK_POWER_MULTIPLIER = multiplier - 1
-    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_PCT, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void Aura::HandleAuraModRangedAttackPowerPercent(bool apply, bool Real)
@@ -4880,7 +4922,7 @@ void Aura::HandleAuraModRangedAttackPowerPercent(bool apply, bool Real)
         return;
 
     //UNIT_FIELD_RANGED_ATTACK_POWER_MULTIPLIER = multiplier - 1
-    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_PCT, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void Aura::HandleAuraModRangedAttackPowerOfStatPercent(bool apply, bool Real)
@@ -4930,9 +4972,9 @@ void Aura::HandleModDamageDone(bool apply, bool Real)
         // apply generic physical damage bonuses including wand case
         if (GetSpellProto()->EquippedItemClass == -1 || m_target->GetTypeId() != TYPEID_PLAYER)
         {
-            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_VALUE, float(m_modifier.m_amount), apply);
-            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_VALUE, float(m_modifier.m_amount), apply);
-            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_RANGED, TOTAL_VALUE, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_RANGED, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
         }
         else
         {
@@ -4942,9 +4984,9 @@ void Aura::HandleModDamageDone(bool apply, bool Real)
         if(m_target->GetTypeId() == TYPEID_PLAYER)
         {
             if(m_positive)
-                m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS,m_modifier.m_amount,apply);
+                m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS,m_modifier.m_amount * m_stackAmount,apply);
             else
-                m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_NEG,m_modifier.m_amount,apply);
+                m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_NEG,m_modifier.m_amount * m_stackAmount,apply);
         }
     }
 
@@ -4970,7 +5012,7 @@ void Aura::HandleModDamageDone(bool apply, bool Real)
             for(int i = SPELL_SCHOOL_HOLY; i < MAX_SPELL_SCHOOL; i++)
             {
                 if((m_modifier.m_miscvalue & (1<<i)) != 0)
-                    m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS+i,m_modifier.m_amount,apply);
+                    m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS+i,m_modifier.m_amount * m_stackAmount,apply);
             }
         }
         else
@@ -4978,7 +5020,7 @@ void Aura::HandleModDamageDone(bool apply, bool Real)
             for(int i = SPELL_SCHOOL_HOLY; i < MAX_SPELL_SCHOOL; i++)
             {
                 if((m_modifier.m_miscvalue & (1<<i)) != 0)
-                    m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_NEG+i,m_modifier.m_amount,apply);
+                    m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_NEG+i,m_modifier.m_amount * m_stackAmount,apply);
             }
         }
         Pet* pet = m_target->GetPet();
@@ -5013,9 +5055,9 @@ void Aura::HandleModDamagePercentDone(bool apply, bool Real)
         // apply generic physical damage bonuses including wand case
         if (GetSpellProto()->EquippedItemClass == -1 || m_target->GetTypeId() != TYPEID_PLAYER)
         {
-            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT, float(m_modifier.m_amount), apply);
-            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT, float(m_modifier.m_amount), apply);
-            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
         }
         else
         {
@@ -5054,7 +5096,7 @@ void Aura::HandleModOffhandDamagePercent(bool apply, bool Real)
 
     sLog.outDebug("AURA MOD OFFHAND DAMAGE");
 
-    m_target->HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 /********************************/
@@ -5067,7 +5109,7 @@ void Aura::HandleModPowerCostPCT(bool apply, bool Real)
     if(!Real)
         return;
 
-    float amount = m_modifier.m_amount/100.0f;
+    float amount = m_modifier.m_amount * m_stackAmount /100.0f;
     for(int i = 0; i < MAX_SPELL_SCHOOL; ++i)
         if(m_modifier.m_miscvalue & (1<<i))
             m_target->ApplyModSignedFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER+i,amount,apply);
@@ -5081,7 +5123,7 @@ void Aura::HandleModPowerCost(bool apply, bool Real)
 
     for(int i = 0; i < MAX_SPELL_SCHOOL; ++i)
         if(m_modifier.m_miscvalue & (1<<i))
-            m_target->ApplyModInt32Value(UNIT_FIELD_POWER_COST_MODIFIER+i,m_modifier.m_amount,apply);
+            m_target->ApplyModInt32Value(UNIT_FIELD_POWER_COST_MODIFIER+i,m_modifier.m_amount * m_stackAmount,apply);
 }
 
 /*********************************************************/
@@ -5302,7 +5344,7 @@ void Aura::HandleModRating(bool apply, bool Real)
 
     for (uint32 rating = 0; rating < MAX_COMBAT_RATING; ++rating)
         if (m_modifier.m_miscvalue & (1 << rating))
-            ((Player*)m_target)->ApplyRatingMod(CombatRating(rating), m_modifier.m_amount, apply);
+            ((Player*)m_target)->ApplyRatingMod(CombatRating(rating), m_modifier.m_amount * m_stackAmount, apply);
 }
 
 void Aura::HandleForceMoveForward(bool apply, bool Real)
@@ -5333,11 +5375,11 @@ void Aura::HandleModTargetResistance(bool apply, bool Real)
 
     // show armor penetration
     if (m_target->GetTypeId() == TYPEID_PLAYER && (m_modifier.m_miscvalue & SPELL_SCHOOL_MASK_NORMAL))
-        m_target->ApplyModInt32Value(PLAYER_FIELD_MOD_TARGET_PHYSICAL_RESISTANCE,m_modifier.m_amount, apply);
+        m_target->ApplyModInt32Value(PLAYER_FIELD_MOD_TARGET_PHYSICAL_RESISTANCE,m_modifier.m_amount * m_stackAmount, apply);
 
     // show as spell penetration only full spell penetration bonuses (all resistances except armor and holy
     if (m_target->GetTypeId() == TYPEID_PLAYER && (m_modifier.m_miscvalue & SPELL_SCHOOL_MASK_SPELL)==SPELL_SCHOOL_MASK_SPELL)
-        m_target->ApplyModInt32Value(PLAYER_FIELD_MOD_TARGET_RESISTANCE,m_modifier.m_amount, apply);
+        m_target->ApplyModInt32Value(PLAYER_FIELD_MOD_TARGET_RESISTANCE,m_modifier.m_amount * m_stackAmount, apply);
 }
 
 void Aura::HandleShieldBlockValue(bool apply, bool Real)
@@ -5347,7 +5389,7 @@ void Aura::HandleShieldBlockValue(bool apply, bool Real)
         modType = PCT_MOD;
 
     if(m_target->GetTypeId() == TYPEID_PLAYER)
-        ((Player*)m_target)->HandleBaseModValue(SHIELD_BLOCK_VALUE, modType, float(m_modifier.m_amount), apply);
+        ((Player*)m_target)->HandleBaseModValue(SHIELD_BLOCK_VALUE, modType, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void Aura::HandleAuraRetainComboPoints(bool apply, bool Real)
@@ -5365,7 +5407,7 @@ void Aura::HandleAuraRetainComboPoints(bool apply, bool Real)
     // remove only if aura expire by time (in case combo points amount change aura removed without combo points lost)
     if( !apply && m_duration==0 && target->GetComboTarget())
         if(Unit* unit = ObjectAccessor::GetUnit(*m_target,target->GetComboTarget()))
-            target->AddComboPoints(unit, -m_modifier.m_amount);
+            target->AddComboPoints(unit, -m_modifier.m_amount * m_stackAmount);
 }
 
 void Aura::HandleModUnattackable( bool Apply, bool Real )
@@ -5529,6 +5571,21 @@ void Aura::PeriodicTick()
                         }
                         break;
                     }
+                    case 41337:// aura of anger
+                    {                        
+                        Unit::AuraList const& mMod = m_target->GetAurasByType(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE);
+                        for(Unit::AuraList::const_iterator i = mMod.begin(); i != mMod.end(); ++i)
+                        {
+                            if ((*i)->GetId() == 41337)
+                            {
+                                (*i)->ApplyModifier(false);
+                                (*i)->GetModifier()->m_amount += 5;
+                                (*i)->ApplyModifier(true);
+                                break;
+                            }
+                        }                        
+                        m_modifier.m_amount += 100;
+                    }break;
                     default:
                         break;
                 }
@@ -5574,6 +5631,8 @@ void Aura::PeriodicTick()
             else
                 pdamage = uint32(m_target->GetMaxHealth()*amount/100);
 
+            pdamage *= m_stackAmount;
+
             //As of 2.2 resilience reduces damage from DoT ticks as much as the chance to not be critically hit
             // Reduce dot damage from resilience for players
             if (m_target->GetTypeId()==TYPEID_PLAYER)
@@ -5692,6 +5751,8 @@ void Aura::PeriodicTick()
                 }
             }
 
+            pdamage *= m_stackAmount;
+
             //As of 2.2 resilience reduces damage from DoT ticks as much as the chance to not be critically hit
             // Reduce dot damage from resilience for players
             if (m_target->GetTypeId()==TYPEID_PLAYER)
@@ -5761,6 +5822,8 @@ void Aura::PeriodicTick()
 
             pdamage = pCaster->SpellHealingBonus(GetSpellProto(), pdamage, DOT, m_target);
 
+            pdamage *= m_stackAmount;
+
             sLog.outDetail("PeriodicTick: %u (TypeId: %u) heal of %u (TypeId: %u) for %u health inflicted by %u",
                 GUID_LOPART(GetCasterGUID()), GuidHigh2TypeId(GUID_HIPART(GetCasterGUID())), m_target->GetGUIDLow(), m_target->GetTypeId(), pdamage, GetId());
 
@@ -5842,6 +5905,8 @@ void Aura::PeriodicTick()
             // ignore non positive values (can be result apply spellmods to aura damage
             uint32 pdamage = m_modifier.m_amount > 0 ? m_modifier.m_amount : 0;
 
+            pdamage *= m_stackAmount;
+
             sLog.outDetail("PeriodicTick: %u (TypeId: %u) power leech of %u (TypeId: %u) for %u dmg inflicted by %u",
                 GUID_LOPART(GetCasterGUID()), GuidHigh2TypeId(GUID_HIPART(GetCasterGUID())), m_target->GetGUIDLow(), m_target->GetTypeId(), pdamage, GetId());
 
@@ -5854,6 +5919,12 @@ void Aura::PeriodicTick()
             if(m_target->getPowerType() != power)
                 break;
 
+            // mark of  kaz'rogal part 1/2
+            bool explode = false;
+            if(GetSpellProto()->Id == 31447)
+                if(pdamage>m_target->GetPower(POWER_MANA))
+                    explode = true;
+
             int32 drain_amount = m_target->GetPower(power) > pdamage ? pdamage : m_target->GetPower(power);
 
             // resilience reduce mana draining effect at spell crit damage reduction (added in 2.4)
@@ -5862,6 +5933,10 @@ void Aura::PeriodicTick()
 
             m_target->ModifyPower(power, -drain_amount);
 
+            // mark of kaz'rogal part 2/2
+            if(explode)
+                pCaster->CastSpell(m_target,31463,true,0,this);
+
             float gain_multiplier = 0;
 
             if(pCaster->GetMaxPower(power) > 0)
@@ -5897,6 +5972,8 @@ void Aura::PeriodicTick()
             // ignore non positive values (can be result apply spellmods to aura damage
             uint32 pdamage = m_modifier.m_amount > 0 ? m_modifier.m_amount : 0;
 
+            pdamage *= m_stackAmount;
+
             sLog.outDetail("PeriodicTick: %u (TypeId: %u) energize %u (TypeId: %u) for %u dmg inflicted by %u",
                 GUID_LOPART(GetCasterGUID()), GuidHigh2TypeId(GUID_HIPART(GetCasterGUID())), m_target->GetGUIDLow(), m_target->GetTypeId(), pdamage, GetId());
 
@@ -5931,6 +6008,8 @@ void Aura::PeriodicTick()
 
             uint32 pdamage = uint32(m_target->GetMaxPower(POWER_MANA) * amount/100);
 
+            pdamage *= m_stackAmount;
+
             sLog.outDetail("PeriodicTick: %u (TypeId: %u) energize %u (TypeId: %u) for %u mana inflicted by %u",
                 GUID_LOPART(GetCasterGUID()), GuidHigh2TypeId(GUID_HIPART(GetCasterGUID())), m_target->GetGUIDLow(), m_target->GetTypeId(), pdamage, GetId());
 
@@ -5965,6 +6044,8 @@ void Aura::PeriodicTick()
 
             int32 pdamage = m_modifier.m_amount > 0 ? m_modifier.m_amount : 0;
 
+            pdamage *= m_stackAmount;
+
             Powers powerType = Powers(m_modifier.m_miscvalue);
 
             if(!m_target->isAlive() || m_target->getPowerType() != powerType)
diff --git a/src/game/SpellAuras.h b/src/game/SpellAuras.h
index ea4f25f..c58ebf2 100644
--- a/src/game/SpellAuras.h
+++ b/src/game/SpellAuras.h
@@ -228,6 +228,7 @@ class MANGOS_DLL_SPEC Aura
         time_t GetAuraApplyTime() { return m_applyTime; }
         void UpdateAuraDuration();
         void SendAuraDurationForCaster(Player* caster);
+        void UpdateSlotCounterAndDuration();
 
         uint64 const& GetCasterGUID() const { return m_caster_guid; }
         Unit* GetCaster() const;
@@ -281,6 +282,8 @@ class MANGOS_DLL_SPEC Aura
 
         int32 m_procCharges;
 
+        int32 m_stackAmount;
+
         virtual Unit* GetTriggerTarget() const { return m_target; }
 
         // add/remove SPELL_AURA_MOD_SHAPESHIFT (36) linked auras
@@ -328,7 +331,6 @@ class MANGOS_DLL_SPEC Aura
         uint32 m_PeriodicEventId;
         DiminishingGroup m_AuraDRGroup;
     private:
-        void UpdateSlotCounterAndDuration(bool add);
         void CleanupTriggeredSpells();
         void SetAura(uint32 slot, bool remove) { m_target->SetUInt32Value(UNIT_FIELD_AURA + slot, remove ? 0 : GetId()); }
         void SetAuraFlag(uint32 slot, bool add);
diff --git a/src/game/SpellEffects.cpp b/src/game/SpellEffects.cpp
index a681589..6fbaf93 100644
--- a/src/game/SpellEffects.cpp
+++ b/src/game/SpellEffects.cpp
@@ -335,6 +335,13 @@ void Spell::EffectSchoolDMG(uint32 effect_idx)
                             damage = 200;
                         break;
                     }
+                    // must only affect demons
+                    case 45072:
+                    {
+                        if(unitTarget->GetCreatureType() != CREATURE_TYPE_DEMON)
+                            return;
+                        break;
+                    }
                 }
                 break;
             }
@@ -915,16 +922,12 @@ void Spell::EffectDummy(uint32 i)
                 }
                 case 28730:                                 // Arcane Torrent (Mana)
                 {
-                    int32 count = 0;
-                    Unit::AuraList const& m_dummyAuras = m_caster->GetAurasByType(SPELL_AURA_DUMMY);
-                    for(Unit::AuraList::const_iterator i = m_dummyAuras.begin(); i != m_dummyAuras.end(); ++i)
-                        if ((*i)->GetId() == 28734)
-                            ++count;
-                    if (count)
-                    {
-                        m_caster->RemoveAurasDueToSpell(28734);
-                        int32 bp = damage * count;
+                    Aura * dummy = m_caster->GetDummyAura(28734);
+                    if (dummy)
+                    {                        
+                        int32 bp = damage * dummy->m_stackAmount;
                         m_caster->CastCustomSpell(m_caster, 28733, &bp, NULL, NULL, true);
+                        m_caster->RemoveAurasDueToSpell(28734);
                     }
                     return;
                 }
@@ -2332,7 +2335,7 @@ void Spell::EffectHeal( uint32 /*i*/ )
             Unit::AuraList const& mDummyAuras = m_caster->GetAurasByType(SPELL_AURA_DUMMY);
             for(Unit::AuraList::const_iterator i = mDummyAuras.begin();i != mDummyAuras.end(); ++i)
                 if((*i)->GetId() == 45062)
-                    damageAmount+=(*i)->GetModifier()->m_amount;
+                    damageAmount+=(*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
             if (damageAmount)
                 m_caster->RemoveAurasDueToSpell(45062);
 
@@ -2598,7 +2601,7 @@ void Spell::DoCreateItem(uint32 i, uint32 itemtype)
                 return;
         }
 
-        if(BattleGround* bg = sBattleGroundMgr.GetBattleGround(bgType))
+        if(BattleGround* bg = sBattleGroundMgr.GetBattleGroundTemplate(bgType))
             bg->SendRewardMarkByMail(player,newitemid,no_space);
     }
 }
@@ -5420,25 +5423,59 @@ void Spell::EffectMomentMove(uint32 i)
         uint32 mapid = m_caster->GetMapId();
         float dis = GetSpellRadius(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
 
-        // before caster
-        float fx,fy,fz;
-        unitTarget->GetClosePoint(fx,fy,fz,unitTarget->GetObjectSize(),dis);
-        float ox,oy,oz;
-        unitTarget->GetPosition(ox,oy,oz);
-
-        float fx2,fy2,fz2;                                  // getObjectHitPos overwrite last args in any result case
-        if(VMAP::VMapFactory::createOrGetVMapManager()->getObjectHitPos(mapid, ox,oy,oz+0.5, fx,fy,oz+0.5,fx2,fy2,fz2, -0.5))
-        {
-            fx = fx2;
-            fy = fy2;
-            fz = fz2;
-            unitTarget->UpdateGroundPositionZ(fx,fy,fz);
-        }
+            // Start Info //
+            float cx,cy,cz;
+            float dx,dy,dz;
+            float angle = unitTarget->GetOrientation();
+            unitTarget->GetPosition(cx,cy,cz);
+            
+            //Check use of vamps//
+            bool useVmap = false;
+            bool swapZone = true;
+            if( MapManager::Instance().GetMap(mapid, unitTarget)->GetHeight(cx, cy, cz, false) <  MapManager::Instance().GetMap(mapid, unitTarget)->GetHeight(cx, cy, cz, true) )
+                useVmap = true;
+            
+            //Going foward 0.5f until max distance
+            for(float i=0.5f; i<dis; i+=0.5f)
+            {
+                unitTarget->GetNearPoint2D(dx,dy,i,angle);
+                dz = MapManager::Instance().GetMap(mapid, unitTarget)->GetHeight(dx, dy, cz, useVmap);
+                
+                //Prevent climbing and go around object maybe 2.0f is to small? use 3.0f?
+                if( (dz-cz) < 2.0f && (dz-cz) > -2.0f && (unitTarget->IsWithinLOS(dx, dy, dz)))
+                {
+                    //No climb, the z differenze between this and prev step is ok. Store this destination for future use or check.
+                    cx = dx;
+                    cy = dy;
+                    cz = dz;
+                }
+                else
+                {
+                    //Something wrong with los or z differenze... maybe we are going from outer world inside a building or viceversa
+                    if(swapZone)
+                    {
+                        //so... change use of vamp and go back 1 step backward and recheck again.
+                        swapZone = false;
+                        useVmap = !useVmap;
+                        i-=0.5f;
+                    }
+                    else
+                    {
+                        //bad recheck result... so break this and use last good coord for teleport player...
+                        dz += 0.5f;
+                        break;
+                    }
+                }
+            }
+            
+            //Prevent Falling during swap building/outerspace
+            unitTarget->UpdateGroundPositionZ(cx, cy, cz);
+        
 
         if(unitTarget->GetTypeId() == TYPEID_PLAYER)
-            ((Player*)unitTarget)->TeleportTo(mapid, fx, fy, fz, unitTarget->GetOrientation(), TELE_TO_NOT_LEAVE_COMBAT | TELE_TO_NOT_UNSUMMON_PET | (unitTarget==m_caster ? TELE_TO_SPELL : 0));
+            ((Player*)unitTarget)->TeleportTo(mapid, cx, cy, cz, unitTarget->GetOrientation(), TELE_TO_NOT_LEAVE_COMBAT | TELE_TO_NOT_UNSUMMON_PET | (unitTarget==m_caster ? TELE_TO_SPELL : 0));
         else
-            MapManager::Instance().GetMap(mapid, unitTarget)->CreatureRelocation((Creature*)unitTarget, fx, fy, fz, unitTarget->GetOrientation());
+            MapManager::Instance().GetMap(mapid, unitTarget)->CreatureRelocation((Creature*)unitTarget, cx, cy, cz, unitTarget->GetOrientation());
     }
 }
 
diff --git a/src/game/StatSystem.cpp b/src/game/StatSystem.cpp
index f215701..689c372 100644
--- a/src/game/StatSystem.cpp
+++ b/src/game/StatSystem.cpp
@@ -153,7 +153,7 @@ void Player::UpdateArmor()
     {
         Modifier* mod = (*i)->GetModifier();
         if(mod->m_miscvalue & SPELL_SCHOOL_MASK_NORMAL)
-            value += int32(GetStat(Stats((*i)->GetMiscBValue())) * mod->m_amount / 100.0f);
+            value += int32(GetStat(Stats((*i)->GetMiscBValue())) * mod->m_amount * (*i)->m_stackAmount / 100.0f);
     }
 
     value *= GetModifierValue(unitMod, TOTAL_PCT);
@@ -311,7 +311,7 @@ void Player::UpdateAttackPowerAndDamage(bool ranged )
     {
         AuraList const& mRAPbyIntellect = GetAurasByType(SPELL_AURA_MOD_RANGED_ATTACK_POWER_OF_STAT_PERCENT);
         for(AuraList::const_iterator i = mRAPbyIntellect.begin();i != mRAPbyIntellect.end(); ++i)
-            attPowerMod += int32(GetStat(Stats((*i)->GetModifier()->m_miscvalue)) * (*i)->GetModifier()->m_amount / 100.0f);
+            attPowerMod += int32(GetStat(Stats((*i)->GetModifier()->m_miscvalue)) * (*i)->GetModifier()->m_amount * (*i)->m_stackAmount / 100.0f);
     }
 
     float attPowerMultiplier = GetModifierValue(unitMod, TOTAL_PCT) - 1.0f;
@@ -393,6 +393,12 @@ void Player::CalculateMinMaxDamage(WeaponAttackType attType, bool normalized, fl
         weapon_maxdamage += GetAmmoDPS() * att_speed;
     }
 
+    if (attType == BASE_ATTACK)
+    {
+        int32 ModSpeed = GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKSPEED);
+        base_pct = base_pct * 100.0f/(100.0f+float(ModSpeed));
+    }
+
     min_damage = ((base_value + weapon_mindamage) * base_pct + total_value) * total_pct;
     max_damage = ((base_value + weapon_maxdamage) * base_pct + total_value) * total_pct;
 }
@@ -570,10 +576,10 @@ void Player::UpdateExpertise(WeaponAttackType attack)
     {
         // item neutral spell
         if((*itr)->GetSpellProto()->EquippedItemClass == -1)
-            expertise += (*itr)->GetModifier()->m_amount;
+            expertise += (*itr)->GetModifier()->m_amount * (*itr)->m_stackAmount;
         // item dependent spell
         else if(weapon && weapon->IsFitToSpellRequirements((*itr)->GetSpellProto()))
-            expertise += (*itr)->GetModifier()->m_amount;
+            expertise += (*itr)->GetModifier()->m_amount * (*itr)->m_stackAmount;
     }
 
     if(expertise < 0)
@@ -603,7 +609,7 @@ void Player::UpdateManaRegen()
     for(AuraList::const_iterator i = regenAura.begin();i != regenAura.end(); ++i)
     {
         Modifier* mod = (*i)->GetModifier();
-        power_regen_mp5 += GetStat(Stats(mod->m_miscvalue)) * mod->m_amount / 500.0f;
+        power_regen_mp5 += GetStat(Stats(mod->m_miscvalue)) * mod->m_amount * (*i)->m_stackAmount / 500.0f;
     }
 
     // Bonus from some dummy auras
@@ -731,6 +737,9 @@ void Creature::UpdateDamagePhysical(WeaponAttackType attType)
     float weapon_mindamage = GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE);
     float weapon_maxdamage = GetWeaponDamageRange(BASE_ATTACK, MAXDAMAGE);
 
+    int32 ModSpeed = GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKSPEED);
+    base_pct = base_pct * 100.0f/(100.0f+float(ModSpeed));
+
     float mindamage = ((base_value + weapon_mindamage) * base_pct + total_value) * total_pct ;
     float maxdamage = ((base_value + weapon_maxdamage) * base_pct + total_value) * total_pct ;
 
@@ -936,6 +945,9 @@ void Pet::UpdateDamagePhysical(WeaponAttackType attType)
     float weapon_mindamage = GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE);
     float weapon_maxdamage = GetWeaponDamageRange(BASE_ATTACK, MAXDAMAGE);
 
+    int32 ModSpeed = GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKSPEED);
+    base_pct = base_pct * 100.0f/(100.0f+float(ModSpeed));
+
     float mindamage = ((base_value + weapon_mindamage) * base_pct + total_value) * total_pct;
     float maxdamage = ((base_value + weapon_maxdamage) * base_pct + total_value) * total_pct;
 
diff --git a/src/game/TaxiHandler.cpp b/src/game/TaxiHandler.cpp
index 7673622..53257f7 100644
--- a/src/game/TaxiHandler.cpp
+++ b/src/game/TaxiHandler.cpp
@@ -192,7 +192,7 @@ void WorldSession::HandleActivateTaxiFarOpcode ( WorldPacket & recv_data )
     GetPlayer()->ActivateTaxiPathTo(nodes, 0, npc);
 }
 
-void WorldSession::HandleTaxiNextDestinationOpcode(WorldPacket& /*recv_data*/)
+void WorldSession::HandleTaxiNextDestinationOpcode(WorldPacket& recv_data)
 {
     sLog.outDebug( "WORLD: Received CMSG_MOVE_SPLINE_DONE" );
 
@@ -200,12 +200,46 @@ void WorldSession::HandleTaxiNextDestinationOpcode(WorldPacket& /*recv_data*/)
     // 1) end taxi path in far (multi-node) flight
     // 2) switch from one map to other in case multim-map taxi path
     // we need proccess only (1)
+
+    //movement anticheat code
+    MovementInfo movementInfo;
+    uint32 MovementFlags;
+
+    recv_data >> MovementFlags;
+    recv_data >> movementInfo.unk1;
+    recv_data >> movementInfo.time;
+    recv_data >> movementInfo.x;
+    recv_data >> movementInfo.y;
+    recv_data >> movementInfo.z;
+    recv_data >> movementInfo.o;
+    //<<< end movement anticheat
+
     uint32 curDest = GetPlayer()->m_taxi.GetTaxiDestination();
     if(!curDest)
+    {
+        //movement anticheat code
+        GetPlayer()->SetPosition(movementInfo.x, movementInfo.y, movementInfo.z, movementInfo.o);
+        GetPlayer()->m_movementInfo = movementInfo;
+        GetPlayer()->m_anti_lastmovetime = movementInfo.time;
+        GetPlayer()->m_anti_justteleported = 1;
+        //<<< end movement anticheat
         return;
+    }
 
     TaxiNodesEntry const* curDestNode = sTaxiNodesStore.LookupEntry(curDest);
 
+    if(curDestNode && curDestNode->map_id == GetPlayer()->GetMapId())
+    {
+        while(GetPlayer()->GetMotionMaster()->GetCurrentMovementGeneratorType()==FLIGHT_MOTION_TYPE)
+            GetPlayer()->GetMotionMaster()->MovementExpired(false);
+    }
+
+    //movement anticheat code
+    GetPlayer()->SetPosition(movementInfo.x, movementInfo.y, movementInfo.z, movementInfo.o);
+    GetPlayer()->m_movementInfo = movementInfo;
+    GetPlayer()->m_anti_lastmovetime = movementInfo.time;
+    //<<< end movement anticheat
+
     // far teleport case
     if(curDestNode && curDestNode->map_id != GetPlayer()->GetMapId())
     {
diff --git a/src/game/Unit.cpp b/src/game/Unit.cpp
index dc9d837..f3f14f8 100644
--- a/src/game/Unit.cpp
+++ b/src/game/Unit.cpp
@@ -442,19 +442,6 @@ bool Unit::HasAuraType(AuraType auraType) const
     return (!m_modAuras[auraType].empty());
 }
 
-/* Called by DealDamage for auras that have a chance to be dispelled on damage taken. */
-void Unit::RemoveSpellbyDamageTaken(AuraType auraType, uint32 damage)
-{
-    if(!HasAuraType(auraType))
-        return;
-
-    // The chance to dispel an aura depends on the damage taken with respect to the casters level.
-    uint32 max_dmg = getLevel() > 8 ? 25 * getLevel() - 150 : 50;
-    float chance = float(damage) / max_dmg * 100.0f;
-    if (roll_chance_f(chance))
-        RemoveSpellsCausingAura(auraType);
-}
-
 uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDamage, DamageEffectType damagetype, SpellSchoolMask damageSchoolMask, SpellEntry const *spellProto, bool durabilityLoss)
 {
     if (!pVictim->isAlive() || pVictim->isInFlight() || pVictim->GetTypeId() == TYPEID_UNIT && ((Creature*)pVictim)->IsInEvadeMode())
@@ -502,11 +489,6 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
         return 0;
     }
 
-    pVictim->RemoveSpellbyDamageTaken(SPELL_AURA_MOD_FEAR, damage);
-    // root type spells do not dispel the root effect
-    if(!spellProto || spellProto->Mechanic != MECHANIC_ROOT)
-        pVictim->RemoveSpellbyDamageTaken(SPELL_AURA_MOD_ROOT, damage);
-
     if(pVictim->GetTypeId() != TYPEID_PLAYER)
     {
         // no xp,health if type 8 /critters/
@@ -605,25 +587,6 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
         ((Creature*)pVictim)->SetLootRecipient(this);
     if (health <= damage)
     {
-        // battleground things
-        if(pVictim->GetTypeId() == TYPEID_PLAYER && (((Player*)pVictim)->InBattleGround()))
-        {
-            Player *killed = ((Player*)pVictim);
-            Player *killer = NULL;
-            if(GetTypeId() == TYPEID_PLAYER)
-                killer = ((Player*)this);
-            else if(GetTypeId() == TYPEID_UNIT && ((Creature*)this)->isPet())
-            {
-                Unit *owner = GetOwner();
-                if(owner && owner->GetTypeId() == TYPEID_PLAYER)
-                    killer = ((Player*)owner);
-            }
-
-            if(killer)
-                if(BattleGround *bg = killed->GetBattleGround())
-                    bg->HandleKillPlayer(killed, killer);   // drop flags and etc
-        }
-
         DEBUG_LOG("DealDamage: victim just died");
 
         // find player: owner of controlled `this` or `this` itself maybe
@@ -762,6 +725,25 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
 
             he->DuelComplete(DUEL_INTERUPTED);
         }
+
+        // battleground things (do this at the end, so the death state flag will be properly set to handle in the bg->handlekill)
+        if(pVictim->GetTypeId() == TYPEID_PLAYER && (((Player*)pVictim)->InBattleGround()))
+        {
+            Player *killed = ((Player*)pVictim);
+            Player *killer = NULL;
+            if(GetTypeId() == TYPEID_PLAYER)
+                killer = ((Player*)this);
+            else if(GetTypeId() == TYPEID_UNIT && ((Creature*)this)->isPet())
+            {
+                Unit *owner = GetOwner();
+                if(owner && owner->GetTypeId() == TYPEID_PLAYER)
+                    killer = ((Player*)owner);
+            }
+
+            if(killer)
+                if(BattleGround *bg = killed->GetBattleGround())
+                    bg->HandleKillPlayer(killed, killer);   // drop flags and etc
+        }
     }
     else                                                    // if (health <= damage)
     {
@@ -858,6 +840,16 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
                     // FIXME: this may cause the auras with proc chance to be rerolled several times
                     next = vAuras.begin();
                 }
+            } 
+            else if ( (se->Attributes & 0x40000000LL) && (!spellProto || se->Id != spellProto->Id) )
+            {
+                uint32 max_dmg = pVictim->getLevel() > 8 ? 25 * pVictim->getLevel() - 150 : 50;
+                float chance = float(damage) / max_dmg * 100.0f;
+                if (roll_chance_f(chance))
+                {
+                    pVictim->RemoveAurasDueToSpell(i->second->GetId());
+                    next = vAuras.begin();
+                }
             }
         }
 
@@ -1134,7 +1126,7 @@ void Unit::DealFlatDamage(Unit *pVictim, SpellEntry const *spellInfo, uint32 *da
                     AuraList const& mDamageDoneVersus = GetAurasByType(SPELL_AURA_MOD_CRIT_PERCENT_VERSUS);
                     for(AuraList::const_iterator i = mDamageDoneVersus.begin();i != mDamageDoneVersus.end(); ++i)
                         if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-                            bonusDmg = uint32(bonusDmg * ((*i)->GetModifier()->m_amount+100.0f)/100.0f);
+                            bonusDmg = uint32(bonusDmg * ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount +100.0f)/100.0f);
 
                     *damage += bonusDmg;
 
@@ -1816,7 +1808,7 @@ void Unit::DoAttackDamage (Unit *pVictim, uint32 *damage, CleanDamage *cleanDama
                 AuraList const& mDamageDoneVersus = GetAurasByType(SPELL_AURA_MOD_CRIT_PERCENT_VERSUS);
                 for(AuraList::const_iterator i = mDamageDoneVersus.begin();i != mDamageDoneVersus.end(); ++i)
                     if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-                        crit_bonus = uint32(crit_bonus * ((*i)->GetModifier()->m_amount+100.0f)/100.0f);
+                        crit_bonus = uint32(crit_bonus * ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount +100.0f)/100.0f);
             }
 
             *damage += crit_bonus;
@@ -2151,7 +2143,7 @@ void Unit::DoAttackDamage (Unit *pVictim, uint32 *damage, CleanDamage *cleanDama
         if (alreadyDone.find(*i) == alreadyDone.end())
         {
             alreadyDone.insert(*i);
-            pVictim->SpellNonMeleeDamageLog(this, (*i)->GetId(), (*i)->GetModifier()->m_amount, false, false);
+            pVictim->SpellNonMeleeDamageLog(this, (*i)->GetId(), (*i)->GetModifier()->m_amount * (*i)->m_stackAmount, false, false);
             if (pVictim->m_removedAuras > removedAuras)
             {
                 removedAuras = pVictim->m_removedAuras;
@@ -2824,7 +2816,7 @@ SpellMissInfo Unit::SpellHitResult(Unit *pVictim, SpellEntry const *spell, bool
         {
             if((*i)->GetModifier()->m_miscvalue & GetSpellSchoolMask(spell))
             {
-                int32 reflectchance = (*i)->GetModifier()->m_amount;
+                int32 reflectchance = (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
                 if (reflectchance > 0 && roll_chance_i(reflectchance))
                 {
                     if((*i)->m_procCharges > 0)
@@ -2842,7 +2834,7 @@ SpellMissInfo Unit::SpellHitResult(Unit *pVictim, SpellEntry const *spell, bool
         Unit::AuraList const& mReflectSpells = pVictim->GetAurasByType(SPELL_AURA_REFLECT_SPELLS);
         for(Unit::AuraList::const_iterator i = mReflectSpells.begin(); i != mReflectSpells.end(); ++i)
         {
-            int32 reflectchance = (*i)->GetModifier()->m_amount;
+            int32 reflectchance = (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
             if (reflectchance > 0 && roll_chance_i(reflectchance))
             {
                 if((*i)->m_procCharges > 0)
@@ -3457,7 +3449,7 @@ int32 Unit::GetTotalAuraModifier(AuraType auratype) const
 
     AuraList const& mTotalAuraList = GetAurasByType(auratype);
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
-        modifier += (*i)->GetModifier()->m_amount;
+        modifier += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
 
     return modifier;
 }
@@ -3468,7 +3460,7 @@ float Unit::GetTotalAuraMultiplier(AuraType auratype) const
 
     AuraList const& mTotalAuraList = GetAurasByType(auratype);
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
-        multiplier *= (100.0f + (*i)->GetModifier()->m_amount)/100.0f;
+        multiplier *= (100.0f + (*i)->GetModifier()->m_amount * (*i)->m_stackAmount)/100.0f;
 
     return multiplier;
 }
@@ -3479,8 +3471,11 @@ int32 Unit::GetMaxPositiveAuraModifier(AuraType auratype) const
 
     AuraList const& mTotalAuraList = GetAurasByType(auratype);
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
-        if ((*i)->GetModifier()->m_amount > modifier)
-            modifier = (*i)->GetModifier()->m_amount;
+    {
+        int32 amount = (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
+        if (amount > modifier)
+            modifier = amount;
+    }
 
     return modifier;
 }
@@ -3491,8 +3486,11 @@ int32 Unit::GetMaxNegativeAuraModifier(AuraType auratype) const
 
     AuraList const& mTotalAuraList = GetAurasByType(auratype);
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
-        if ((*i)->GetModifier()->m_amount < modifier)
-            modifier = (*i)->GetModifier()->m_amount;
+    {
+        int32 amount = (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
+        if (amount < modifier)
+            modifier = amount;
+    }
 
     return modifier;
 }
@@ -3506,7 +3504,7 @@ int32 Unit::GetTotalAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask)
     {
         Modifier* mod = (*i)->GetModifier();
         if (mod->m_miscvalue & misc_mask)
-            modifier += mod->m_amount;
+            modifier += mod->m_amount * (*i)->m_stackAmount;
     }
     return modifier;
 }
@@ -3520,7 +3518,7 @@ float Unit::GetTotalAuraMultiplierByMiscMask(AuraType auratype, uint32 misc_mask
     {
         Modifier* mod = (*i)->GetModifier();
         if (mod->m_miscvalue & misc_mask)
-            multiplier *= (100.0f + mod->m_amount)/100.0f;
+            multiplier *= (100.0f + mod->m_amount * (*i)->m_stackAmount)/100.0f;
     }
     return multiplier;
 }
@@ -3533,8 +3531,9 @@ int32 Unit::GetMaxPositiveAuraModifierByMiscMask(AuraType auratype, uint32 misc_
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
     {
         Modifier* mod = (*i)->GetModifier();
-        if (mod->m_miscvalue & misc_mask && mod->m_amount > modifier)
-            modifier = mod->m_amount;
+        int32 amount = mod->m_amount * (*i)->m_stackAmount;
+        if (mod->m_miscvalue & misc_mask && amount > modifier)
+            modifier = amount;
     }
 
     return modifier;
@@ -3548,8 +3547,9 @@ int32 Unit::GetMaxNegativeAuraModifierByMiscMask(AuraType auratype, uint32 misc_
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
     {
         Modifier* mod = (*i)->GetModifier();
-        if (mod->m_miscvalue & misc_mask && mod->m_amount < modifier)
-            modifier = mod->m_amount;
+        int32 amount = mod->m_amount * (*i)->m_stackAmount;
+        if (mod->m_miscvalue & misc_mask && amount < modifier)
+            modifier = amount;
     }
 
     return modifier;
@@ -3564,7 +3564,7 @@ int32 Unit::GetTotalAuraModifierByMiscValue(AuraType auratype, int32 misc_value)
     {
         Modifier* mod = (*i)->GetModifier();
         if (mod->m_miscvalue == misc_value)
-            modifier += mod->m_amount;
+            modifier += mod->m_amount * (*i)->m_stackAmount;
     }
     return modifier;
 }
@@ -3578,7 +3578,7 @@ float Unit::GetTotalAuraMultiplierByMiscValue(AuraType auratype, int32 misc_valu
     {
         Modifier* mod = (*i)->GetModifier();
         if (mod->m_miscvalue == misc_value)
-            multiplier *= (100.0f + mod->m_amount)/100.0f;
+            multiplier *= (100.0f + mod->m_amount * (*i)->m_stackAmount)/100.0f;
     }
     return multiplier;
 }
@@ -3591,8 +3591,9 @@ int32 Unit::GetMaxPositiveAuraModifierByMiscValue(AuraType auratype, int32 misc_
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
     {
         Modifier* mod = (*i)->GetModifier();
-        if (mod->m_miscvalue == misc_value && mod->m_amount > modifier)
-            modifier = mod->m_amount;
+        int32 amount = mod->m_amount * (*i)->m_stackAmount;
+        if (mod->m_miscvalue == misc_value && amount > modifier)
+            modifier = amount;
     }
 
     return modifier;
@@ -3606,8 +3607,9 @@ int32 Unit::GetMaxNegativeAuraModifierByMiscValue(AuraType auratype, int32 misc_
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
     {
         Modifier* mod = (*i)->GetModifier();
-        if (mod->m_miscvalue == misc_value && mod->m_amount < modifier)
-            modifier = mod->m_amount;
+        int32 amount = mod->m_amount * (*i)->m_stackAmount;
+        if (mod->m_miscvalue == misc_value && amount < modifier)
+            modifier = amount;
     }
 
     return modifier;
@@ -3646,8 +3648,10 @@ bool Unit::AddAura(Aura *Aur)
             // replace aura if next will > spell StackAmount
             if(aurSpellInfo->StackAmount)
             {
-                if(m_Auras.count(spair) >= aurSpellInfo->StackAmount)
-                    RemoveAura(i,AURA_REMOVE_BY_STACK);
+                Aur->m_stackAmount = i->second->m_stackAmount;
+                if(Aur->m_stackAmount < aurSpellInfo->StackAmount)
+                    ++Aur->m_stackAmount;
+                RemoveAura(i,AURA_REMOVE_BY_STACK);
             }
             // if StackAmount==0 not allow auras from same caster
             else
@@ -4030,7 +4034,19 @@ void Unit::RemoveSingleAuraFromStack(uint32 spellId, uint32 effindex)
 {
     AuraMap::iterator iter = m_Auras.find(spellEffectPair(spellId, effindex));
     if(iter != m_Auras.end())
+    {
+        if(iter->second->m_stackAmount > 1)
+        {
+            // reapply modifier with reduced stack amount
+            iter->second->ApplyModifier(false,true);
+            --iter->second->m_stackAmount;
+            iter->second->ApplyModifier(true,true);
+
+            iter->second->UpdateSlotCounterAndDuration();
+            return; // not remove aura if stack amount > 1
+        }
         RemoveAura(iter);
+    }
 }
 
 void Unit::RemoveAurasDueToSpell(uint32 spellId, Aura* except)
@@ -4135,6 +4151,9 @@ void Unit::RemoveAura(AuraMap::iterator &i, AuraRemoveMode mode)
 
     sLog.outDebug("Aura %u now is remove mode %d",Aur->GetModifier()->m_auraname, mode);
     Aur->ApplyModifier(false,true);
+
+    Aur->m_stackAmount = 0;
+
     Aur->_RemoveAura();
     delete Aur;
 
@@ -4157,6 +4176,22 @@ void Unit::RemoveAllAuras()
     }
 }
 
+void Unit::RemoveArenaAuras(bool onleave)
+{
+    // in join, remove positive buffs, on end, remove negative
+    // used to remove positive visible auras in arenas
+    for(AuraMap::iterator iter = m_Auras.begin(); iter != m_Auras.end();)
+    {
+        if ( !(iter->second->GetSpellProto()->AttributesEx4 & (1<<21)) // don't remove stances, shadowform, pally/hunter auras
+            && !iter->second->IsPassive()                               // don't remove passive auras
+            && (!(iter->second->GetSpellProto()->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY) || !(iter->second->GetSpellProto()->Attributes & SPELL_ATTR_UNK8))   // not unaffected by invulnerability auras or not having that unknown flag (that seemed the most probable)
+            && (iter->second->IsPositive() ^ onleave))                   // remove positive buffs on enter, negative buffs on leave
+            RemoveAura(iter);
+        else
+            ++iter;
+    }
+}
+
 void Unit::RemoveAllAurasOnDeath()
 {
     // used just after dieing to remove all visible auras
@@ -6098,14 +6133,12 @@ bool Unit::HandleProcTriggerSpell(Unit *pVictim, uint32 damage, Aura* triggeredB
                         ((Player*)this)->AddSpellCooldown(37657,0,time(NULL)+(roll_chance_i(50) ? 2 : 3));
 
                         // counting
-                        uint32 count = 0;
-                        AuraList const& dummyAura = GetAurasByType(SPELL_AURA_DUMMY);
-                        for(AuraList::const_iterator itr = dummyAura.begin(); itr != dummyAura.end(); ++itr)
-                            if((*itr)->GetId()==37658)
-                                ++count;
+                        Aura * dummy = GetDummyAura(37658);
+                        if (!dummy)
+                            return false;
 
                         // release at 3 aura in stack
-                        if(count <= 2)
+                        if(dummy->m_stackAmount <= 2)
                             return true;                    // main triggered spell casted anyway
 
                         RemoveAurasDueToSpell(37658);
@@ -7229,7 +7262,7 @@ uint32 Unit::SpellDamageBonus(Unit *pVictim, SpellEntry const *spellProto, uint3
             (*i)->GetSpellProto()->EquippedItemInventoryTypeMask == 0 )
                                                             // 0 == any inventory type (not wand then)
         {
-            DoneTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+            DoneTotalMod *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount +100.0f)/100.0f;
         }
     }
 
@@ -7237,13 +7270,13 @@ uint32 Unit::SpellDamageBonus(Unit *pVictim, SpellEntry const *spellProto, uint3
     AuraList const& mDamageDoneVersus = GetAurasByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS);
     for(AuraList::const_iterator i = mDamageDoneVersus.begin();i != mDamageDoneVersus.end(); ++i)
         if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-            DoneTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+            DoneTotalMod *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount +100.0f)/100.0f;
 
     // ..taken
     AuraList const& mModDamagePercentTaken = pVictim->GetAurasByType(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN);
     for(AuraList::const_iterator i = mModDamagePercentTaken.begin(); i != mModDamagePercentTaken.end(); ++i)
         if( (*i)->GetModifier()->m_miscvalue & GetSpellSchoolMask(spellProto) )
-            TakenTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+            TakenTotalMod *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount +100.0f)/100.0f;
 
     // .. taken pct: scripted (increases damage of * against targets *)
     AuraList const& mOverrideClassScript = GetAurasByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
@@ -7515,14 +7548,14 @@ uint32 Unit::SpellDamageBonus(Unit *pVictim, SpellEntry const *spellProto, uint3
     float LvlPenalty = CalculateLevelPenalty(spellProto);
 
     // Spellmod SpellDamage
-    float SpellModSpellDamage = 100.0f;
+    float CoefficientPtc = ((float)CastingTime/3500.0f)*DotFactor*100.0f;
 
     if(Player* modOwner = GetSpellModOwner())
-        modOwner->ApplySpellMod(spellProto->Id,SPELLMOD_SPELL_BONUS_DAMAGE,SpellModSpellDamage);
+        modOwner->ApplySpellMod(spellProto->Id,SPELLMOD_SPELL_BONUS_DAMAGE,CoefficientPtc);
 
-    SpellModSpellDamage /= 100.0f;
+    CoefficientPtc /= 100.0f;
 
-    float DoneActualBenefit = DoneAdvertisedBenefit * (CastingTime / 3500.0f) * DotFactor * SpellModSpellDamage * LvlPenalty;
+    float DoneActualBenefit = DoneAdvertisedBenefit * CoefficientPtc * LvlPenalty;
     float TakenActualBenefit = TakenAdvertisedBenefit * (CastingTime / 3500.0f) * DotFactor * LvlPenalty;
 
     float tmpDamage = (float(pdamage)+DoneActualBenefit)*DoneTotalMod;
@@ -7554,7 +7587,7 @@ int32 Unit::SpellBaseDamageBonus(SpellSchoolMask schoolMask)
                                                             // -1 == any item class (not wand then)
         (*i)->GetSpellProto()->EquippedItemInventoryTypeMask == 0 )
                                                             // 0 == any inventory type (not wand then)
-            DoneAdvertisedBenefit += (*i)->GetModifier()->m_amount;
+            DoneAdvertisedBenefit += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
 
     if (GetTypeId() == TYPEID_PLAYER)
     {
@@ -7572,14 +7605,14 @@ int32 Unit::SpellBaseDamageBonus(SpellSchoolMask schoolMask)
                 if(eff < 2 && iSpellProto->EffectApplyAuraName[eff+1]==SPELL_AURA_MOD_SPELL_HEALING_OF_STAT_PERCENT)
                     usedStat = Stats(iSpellProto->EffectMiscValue[eff+1]);
 
-                DoneAdvertisedBenefit += int32(GetStat(usedStat) * (*i)->GetModifier()->m_amount / 100.0f);
+                DoneAdvertisedBenefit += int32(GetStat(usedStat) * (*i)->GetModifier()->m_amount * (*i)->m_stackAmount / 100.0f);
             }
         }
         // ... and attack power
         AuraList const& mDamageDonebyAP = GetAurasByType(SPELL_AURA_MOD_SPELL_DAMAGE_OF_ATTACK_POWER);
         for(AuraList::const_iterator i =mDamageDonebyAP.begin();i != mDamageDonebyAP.end(); ++i)
             if ((*i)->GetModifier()->m_miscvalue & schoolMask)
-                DoneAdvertisedBenefit += int32(GetTotalAttackPowerValue(BASE_ATTACK) * (*i)->GetModifier()->m_amount / 100.0f);
+                DoneAdvertisedBenefit += int32(GetTotalAttackPowerValue(BASE_ATTACK) * (*i)->GetModifier()->m_amount * (*i)->m_stackAmount / 100.0f);
 
     }
     return DoneAdvertisedBenefit;
@@ -7594,13 +7627,13 @@ int32 Unit::SpellBaseDamageBonusForVictim(SpellSchoolMask schoolMask, Unit *pVic
     AuraList const& mDamageDoneCreature = GetAurasByType(SPELL_AURA_MOD_DAMAGE_DONE_CREATURE);
     for(AuraList::const_iterator i = mDamageDoneCreature.begin();i != mDamageDoneCreature.end(); ++i)
         if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-            TakenAdvertisedBenefit += (*i)->GetModifier()->m_amount;
+            TakenAdvertisedBenefit += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
 
     // ..taken
     AuraList const& mDamageTaken = pVictim->GetAurasByType(SPELL_AURA_MOD_DAMAGE_TAKEN);
     for(AuraList::const_iterator i = mDamageTaken.begin();i != mDamageTaken.end(); ++i)
         if(((*i)->GetModifier()->m_miscvalue & schoolMask) != 0)
-            TakenAdvertisedBenefit += (*i)->GetModifier()->m_amount;
+            TakenAdvertisedBenefit += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
 
     return TakenAdvertisedBenefit;
 }
@@ -7803,6 +7836,11 @@ uint32 Unit::SpellHealingBonus(SpellEntry const *spellProto, uint32 healamount,
         // Exception
         switch (spellProto->SpellFamilyName)
         {
+            case  SPELLFAMILY_GENERIC:      
+                // Frenzied Regeneration triggered Spell
+                if( spellProto->Id == 22845 )
+                    CastingTime = 0;
+                break;      
             case  SPELLFAMILY_SHAMAN:
                 // Healing stream from totem (add 6% per tick from hill bonus owner)
                 if (spellProto->SpellFamilyFlags & 0x000000002000LL)
@@ -7851,14 +7889,14 @@ uint32 Unit::SpellHealingBonus(SpellEntry const *spellProto, uint32 healamount,
         float LvlPenalty = CalculateLevelPenalty(spellProto);
 
         // Spellmod SpellDamage
-        float SpellModSpellDamage = 100.0f;
+        float CoefficientPtc = ((float)CastingTime/3500.0f)*DotFactor*100.0f;
 
         if(Player* modOwner = GetSpellModOwner())
-            modOwner->ApplySpellMod(spellProto->Id,SPELLMOD_SPELL_BONUS_DAMAGE,SpellModSpellDamage);
+            modOwner->ApplySpellMod(spellProto->Id,SPELLMOD_SPELL_BONUS_DAMAGE,CoefficientPtc);
 
-        SpellModSpellDamage /= 100.0f;
+        CoefficientPtc /= 100.0f;
 
-        ActualBenefit = (float)AdvertisedBenefit * ((float)CastingTime / 3500.0f) * DotFactor * SpellModSpellDamage * LvlPenalty;
+        ActualBenefit = (float)AdvertisedBenefit * CoefficientPtc * LvlPenalty;
     }
 
     // use float as more appropriate for negative values and percent applying
@@ -7868,7 +7906,7 @@ uint32 Unit::SpellHealingBonus(SpellEntry const *spellProto, uint32 healamount,
     // Healing done percent
     AuraList const& mHealingDonePct = GetAurasByType(SPELL_AURA_MOD_HEALING_DONE_PERCENT);
     for(AuraList::const_iterator i = mHealingDonePct.begin();i != mHealingDonePct.end(); ++i)
-        heal *= (100.0f + (*i)->GetModifier()->m_amount) / 100.0f;
+        heal *= (100.0f + (*i)->GetModifier()->m_amount * (*i)->m_stackAmount) / 100.0f;
 
     // apply spellmod to Done amount
     if(Player* modOwner = GetSpellModOwner())
@@ -7909,7 +7947,7 @@ int32 Unit::SpellBaseHealingBonus(SpellSchoolMask schoolMask)
     AuraList const& mHealingDone = GetAurasByType(SPELL_AURA_MOD_HEALING_DONE);
     for(AuraList::const_iterator i = mHealingDone.begin();i != mHealingDone.end(); ++i)
         if(((*i)->GetModifier()->m_miscvalue & schoolMask) != 0)
-            AdvertisedBenefit += (*i)->GetModifier()->m_amount;
+            AdvertisedBenefit += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
 
     // Healing bonus of spirit, intellect and strength
     if (GetTypeId() == TYPEID_PLAYER)
@@ -7920,14 +7958,14 @@ int32 Unit::SpellBaseHealingBonus(SpellSchoolMask schoolMask)
         {
             // stat used dependent from misc value (stat index)
             Stats usedStat = Stats((*i)->GetSpellProto()->EffectMiscValue[(*i)->GetEffIndex()]);
-            AdvertisedBenefit += int32(GetStat(usedStat) * (*i)->GetModifier()->m_amount / 100.0f);
+            AdvertisedBenefit += int32(GetStat(usedStat) * (*i)->GetModifier()->m_amount * (*i)->m_stackAmount / 100.0f);
         }
 
         // ... and attack power
         AuraList const& mHealingDonebyAP = GetAurasByType(SPELL_AURA_MOD_SPELL_HEALING_OF_ATTACK_POWER);
         for(AuraList::const_iterator i = mHealingDonebyAP.begin();i != mHealingDonebyAP.end(); ++i)
             if ((*i)->GetModifier()->m_miscvalue & schoolMask)
-                AdvertisedBenefit += int32(GetTotalAttackPowerValue(BASE_ATTACK) * (*i)->GetModifier()->m_amount / 100.0f);
+                AdvertisedBenefit += int32(GetTotalAttackPowerValue(BASE_ATTACK) * (*i)->GetModifier()->m_amount * (*i)->m_stackAmount / 100.0f);
     }
     return AdvertisedBenefit;
 }
@@ -7938,7 +7976,7 @@ int32 Unit::SpellBaseHealingBonusForVictim(SpellSchoolMask schoolMask, Unit *pVi
     AuraList const& mDamageTaken = pVictim->GetAurasByType(SPELL_AURA_MOD_HEALING);
     for(AuraList::const_iterator i = mDamageTaken.begin();i != mDamageTaken.end(); ++i)
         if(((*i)->GetModifier()->m_miscvalue & schoolMask) != 0)
-            AdvertisedBenefit += (*i)->GetModifier()->m_amount;
+            AdvertisedBenefit += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
     return AdvertisedBenefit;
 }
 
@@ -8091,7 +8129,7 @@ void Unit::MeleeDamageBonus(Unit *pVictim, uint32 *pdamage,WeaponAttackType attT
     AuraList const& mDamageDoneCreature = GetAurasByType(SPELL_AURA_MOD_DAMAGE_DONE_CREATURE);
     for(AuraList::const_iterator i = mDamageDoneCreature.begin();i != mDamageDoneCreature.end(); ++i)
         if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-            DoneFlatBenefit += (*i)->GetModifier()->m_amount;
+            DoneFlatBenefit += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
 
     // ..done
     // SPELL_AURA_MOD_DAMAGE_DONE included in weapon damage
@@ -8106,7 +8144,7 @@ void Unit::MeleeDamageBonus(Unit *pVictim, uint32 *pdamage,WeaponAttackType attT
         AuraList const& mCreatureAttackPower = GetAurasByType(SPELL_AURA_MOD_RANGED_ATTACK_POWER_VERSUS);
         for(AuraList::const_iterator i = mCreatureAttackPower.begin();i != mCreatureAttackPower.end(); ++i)
             if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-                APbonus += (*i)->GetModifier()->m_amount;
+                APbonus += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
     }
     else
     {
@@ -8116,7 +8154,7 @@ void Unit::MeleeDamageBonus(Unit *pVictim, uint32 *pdamage,WeaponAttackType attT
         AuraList const& mCreatureAttackPower = GetAurasByType(SPELL_AURA_MOD_MELEE_ATTACK_POWER_VERSUS);
         for(AuraList::const_iterator i = mCreatureAttackPower.begin();i != mCreatureAttackPower.end(); ++i)
             if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-                APbonus += (*i)->GetModifier()->m_amount;
+                APbonus += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
     }
 
     if (APbonus!=0)                                         // Can be negative
@@ -8141,7 +8179,7 @@ void Unit::MeleeDamageBonus(Unit *pVictim, uint32 *pdamage,WeaponAttackType attT
     AuraList const& mDamageTaken = pVictim->GetAurasByType(SPELL_AURA_MOD_DAMAGE_TAKEN);
     for(AuraList::const_iterator i = mDamageTaken.begin();i != mDamageTaken.end(); ++i)
         if((*i)->GetModifier()->m_miscvalue & GetMeleeDamageSchoolMask())
-            TakenFlatBenefit += (*i)->GetModifier()->m_amount;
+            TakenFlatBenefit += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
 
     if(attType!=RANGED_ATTACK)
         TakenFlatBenefit += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN);
@@ -8159,13 +8197,13 @@ void Unit::MeleeDamageBonus(Unit *pVictim, uint32 *pdamage,WeaponAttackType attT
     AuraList const& mDamageDoneVersus = GetAurasByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS);
     for(AuraList::const_iterator i = mDamageDoneVersus.begin();i != mDamageDoneVersus.end(); ++i)
         if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-            DoneTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+            DoneTotalMod *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount+100.0f)/100.0f;
 
     // ..taken
     AuraList const& mModDamagePercentTaken = pVictim->GetAurasByType(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN);
     for(AuraList::const_iterator i = mModDamagePercentTaken.begin(); i != mModDamagePercentTaken.end(); ++i)
         if((*i)->GetModifier()->m_miscvalue & GetMeleeDamageSchoolMask())
-            TakenTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+            TakenTotalMod *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount+100.0f)/100.0f;
 
     // .. taken pct: dummy auras
     AuraList const& mDummyAuras = pVictim->GetAurasByType(SPELL_AURA_DUMMY);
@@ -8223,13 +8261,13 @@ void Unit::MeleeDamageBonus(Unit *pVictim, uint32 *pdamage,WeaponAttackType attT
     {
         AuraList const& mModMeleeDamageTakenPercent = pVictim->GetAurasByType(SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN_PCT);
         for(AuraList::const_iterator i = mModMeleeDamageTakenPercent.begin(); i != mModMeleeDamageTakenPercent.end(); ++i)
-            TakenTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+            TakenTotalMod *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount+100.0f)/100.0f;
     }
     else
     {
         AuraList const& mModRangedDamageTakenPercent = pVictim->GetAurasByType(SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN_PCT);
         for(AuraList::const_iterator i = mModRangedDamageTakenPercent.begin(); i != mModRangedDamageTakenPercent.end(); ++i)
-            TakenTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+            TakenTotalMod *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount+100.0f)/100.0f;
     }
 
     float tmpDamage = float(int32(*pdamage) + DoneFlatBenefit) * DoneTotalMod;
diff --git a/src/game/Unit.h b/src/game/Unit.h
index 9447c5d..f75da58 100644
--- a/src/game/Unit.h
+++ b/src/game/Unit.h
@@ -910,8 +910,6 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
 
         bool isFrozen() const;
 
-        void RemoveSpellbyDamageTaken(AuraType auraType, uint32 damage);
-
         bool isTargetableForAttack() const;
         virtual bool IsInWater() const;
         virtual bool IsUnderWater() const;
@@ -1006,6 +1004,7 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
         void RemoveAurasWithDispelType( DispelType type );
 
         void RemoveAllAuras();
+        void RemoveArenaAuras(bool onleave = false);
         void RemoveAllAurasOnDeath();
         void DelayAura(uint32 spellId, uint32 effindex, int32 delaytime);
 
diff --git a/src/game/World.cpp b/src/game/World.cpp
index db9bee3..166de4d 100644
--- a/src/game/World.cpp
+++ b/src/game/World.cpp
@@ -41,6 +41,7 @@
 #include "Database/DBCStores.h"
 #include "LootMgr.h"
 #include "ItemEnchantmentMgr.h"
+#include "AuctionHouseBot.h"
 #include "MapManager.h"
 #include "ScriptCalls.h"
 #include "CreatureAIRegistry.h"
@@ -58,6 +59,7 @@
 #include "WaypointManager.h"
 #include "GMTicketMgr.h"
 #include "Util.h"
+#include "Language.h"
 
 INSTANTIATE_SINGLETON_1( World );
 
@@ -70,7 +72,9 @@ float World::m_MaxVisibleDistanceForObject    = DEFAULT_VISIBILITY_DISTANCE;
 float World::m_MaxVisibleDistanceInFlight     = DEFAULT_VISIBILITY_DISTANCE;
 float World::m_VisibleUnitGreyDistance        = 0;
 float World::m_VisibleObjectGreyDistance      = 0;
-
+//movement anticheat
+bool World::m_EnableMvAnticheat = true;
+uint32  World::m_TeleportToPlaneAlarms = 50;
 // ServerMessages.dbc
 enum ServerMessageType
 {
@@ -510,7 +514,17 @@ void World::LoadConfigSettings(bool reload)
         sLog.outError("DurabilityLossChance.Block (%f) must be >=0. Using 0.0 instead.",rate_values[RATE_DURABILITY_LOSS_BLOCK]);
         rate_values[RATE_DURABILITY_LOSS_BLOCK] = 0.0f;
     }
-
+    // movement anticheat
+    m_EnableMvAnticheat = sConfig.GetBoolDefault("Anticheat.Movement.Enable",true);
+    m_TeleportToPlaneAlarms = sConfig.GetIntDefault("Anticheat.Movement.TeleportToPlaneAlarms", 50);
+    if (m_TeleportToPlaneAlarms<20){
+        sLog.outError("Anticheat.Movement.TeleportToPlaneAlarms (%d) must be >=20. Using 20 instead.",m_TeleportToPlaneAlarms);
+        m_TeleportToPlaneAlarms = 20;
+    }
+    if (m_TeleportToPlaneAlarms>100){
+        sLog.outError("Anticheat.Movement.TeleportToPlaneAlarms (%d) must be <=100. Using 100 instead.",m_TeleportToPlaneAlarms);
+        m_TeleportToPlaneAlarms = 100;
+    }
     ///- Read other configuration items from the config file
 
     m_configs[CONFIG_COMPRESSION] = sConfig.GetIntDefault("Compression", 1);
@@ -796,6 +810,13 @@ void World::LoadConfigSettings(bool reload)
     m_configs[CONFIG_LISTEN_RANGE_TEXTEMOTE] = sConfig.GetIntDefault("ListenRange.TextEmote", 25);
     m_configs[CONFIG_LISTEN_RANGE_YELL]      = sConfig.GetIntDefault("ListenRange.Yell", 300);
 
+    m_configs[CONFIG_ARENA_MAX_RATING_DIFFERENCE] = sConfig.GetIntDefault("Arena.MaxRatingDifference", 0);
+    m_configs[CONFIG_ARENA_RATING_DISCARD_TIMER] = sConfig.GetIntDefault("Arena.RatingDiscardTimer",300000);
+    m_configs[CONFIG_ARENA_AUTO_DISTRIBUTE_POINTS] = sConfig.GetBoolDefault("Arena.AutoDistributePoints", false);
+    m_configs[CONFIG_ARENA_AUTO_DISTRIBUTE_INTERVAL_DAYS] = sConfig.GetIntDefault("Arena.AutoDistributeInterval", 7);
+
+    m_configs[CONFIG_BATTLEGROUND_PREMATURE_FINISH_TIMER] = sConfig.GetIntDefault("BattleGround.PrematureFinishTimer", 0);
+
     m_VisibleUnitGreyDistance = sConfig.GetFloatDefault("Visibility.Distance.Grey.Unit", 1);
     if(m_VisibleUnitGreyDistance >  MAX_VISIBILITY_DISTANCE)
     {
@@ -1164,6 +1185,9 @@ void World::SetInitialWorldSettings()
     WorldDatabase.PExecute("INSERT INTO uptime (startstring, starttime, uptime) VALUES('%s', " I64FMTD ", 0)",
         isoDate, uint64(m_startTime));
 
+	static uint32 abtimer = 0;
+	abtimer = sConfig.GetIntDefault("AutoBroadcast.Timer", 60000);
+	
     m_timers[WUPDATE_OBJECTS].SetInterval(0);
     m_timers[WUPDATE_SESSIONS].SetInterval(0);
     m_timers[WUPDATE_WEATHERS].SetInterval(1000);
@@ -1171,6 +1195,7 @@ void World::SetInitialWorldSettings()
     m_timers[WUPDATE_UPTIME].SetInterval(m_configs[CONFIG_UPTIME_UPDATE]*MINUTE*1000);
                                                             //Update "uptime" table based on configuration entry in minutes.
     m_timers[WUPDATE_CORPSES].SetInterval(20*MINUTE*1000);  //erase corpses every 20 minutes
+	m_timers[WUPDATE_AUTOBROADCAST].SetInterval(abtimer);
 
     //to set mailtimer to return mails every day between 4 and 5 am
     //mailtimer is increased when updating auctions
@@ -1192,6 +1217,7 @@ void World::SetInitialWorldSettings()
     ///- Initialize Battlegrounds
     sLog.outString( "Starting BattleGround System" );
     sBattleGroundMgr.CreateInitialBattleGrounds();
+    sBattleGroundMgr.InitAutomaticArenaPointDistribution();
 
     //Not sure if this can be moved up in the sequence (with static data loading) as it uses MapManager
     sLog.outString( "Loading Transports..." );
@@ -1207,6 +1233,8 @@ void World::SetInitialWorldSettings()
     uint32 nextGameEvent = gameeventmgr.Initialize();
     m_timers[WUPDATE_EVENTS].SetInterval(nextGameEvent);    //depend on next event
 
+    AuctionHouseBotInit();
+
     sLog.outString( "WORLD: World initialized" );
 }
 
@@ -1275,6 +1303,7 @@ void World::Update(time_t diff)
     /// <ul><li> Handle auctions when the timer has passed
     if (m_timers[WUPDATE_AUCTIONS].Passed())
     {
+        AuctionHouseBot();
         m_timers[WUPDATE_AUCTIONS].Reset();
 
         ///- Update mails (return old mails with item, or delete them)
@@ -1408,6 +1437,17 @@ void World::Update(time_t diff)
         m_timers[WUPDATE_EVENTS].Reset();
     }
 
+	static uint32 autobroadcaston = 0;
+	autobroadcaston = sConfig.GetIntDefault("AutoBroadcast.On", 0);
+	if(autobroadcaston == 1)
+	{
+		if (m_timers[WUPDATE_AUTOBROADCAST].Passed())
+		{
+			m_timers[WUPDATE_AUTOBROADCAST].Reset();
+			SendRNDBroadcast();
+		}
+	}
+	
     /// </ul>
     ///- Move all creatures with "delayed move" and remove and delete all objects with "delayed remove"
     MapManager::Instance().DoDelayedMovesAndRemoves();
@@ -2132,6 +2172,24 @@ void World::SendWorldText(int32 string_id, ...)
             delete data_cache[i][j];
 }
 
+/// Send a System Message to all players (except self if mentioned)
+void World::SendGlobalText(const char* text, WorldSession *self)
+{
+    WorldPacket data;
+
+    // need copy to prevent corruption by strtok call in LineFromMessage original string
+    char* buf = strdup(text);
+    char* pos = buf;
+
+    while(char* line = ChatHandler::LineFromMessage(pos))
+    {
+        ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_SYSTEM, LANG_UNIVERSAL, NULL, 0, line, NULL);
+        SendGlobalMessage(&data, self);
+    }
+
+    free(buf);
+}
+
 /// Send a packet to all players (or players selected team) in the zone (except self if mentioned)
 void World::SendZoneMessage(uint32 zone, WorldPacket *packet, WorldSession *self, uint32 team)
 {
@@ -2466,6 +2524,45 @@ void World::ProcessCliCommands()
     zprint("mangos>");
 }
 
+void World::SendRNDBroadcast()
+{
+	std::string msg;
+	QueryResult *result = WorldDatabase.PQuery("SELECT `text` FROM `autobroadcast` ORDER BY RAND() LIMIT 1");
+	
+	if(!result)
+		return;
+	
+	msg = result->Fetch()[0].GetString();
+	delete result;
+
+	static uint32 abcenter = 0;
+    abcenter = sConfig.GetIntDefault("AutoBroadcast.Center", 0);
+    if(abcenter == 0)
+    {
+		sWorld.SendWorldText(LANG_AUTO_BROADCAST, msg.c_str());
+
+		sLog.outString("AutoBroadcast: '%s'",msg.c_str());
+	}
+	if(abcenter == 1)
+	{
+		WorldPacket data(SMSG_NOTIFICATION, (msg.size()+1));
+		data << msg;
+		sWorld.SendGlobalMessage(&data);
+
+		sLog.outString("AutoBroadcast: '%s'",msg.c_str());
+	}
+	if(abcenter == 2)
+	{
+		sWorld.SendWorldText(LANG_AUTO_BROADCAST, msg.c_str());
+
+		WorldPacket data(SMSG_NOTIFICATION, (msg.size()+1));
+		data << msg;
+		sWorld.SendGlobalMessage(&data);
+
+		sLog.outString("AutoBroadcast: '%s'",msg.c_str());
+	}
+}
+
 void World::InitResultQueue()
 {
     m_resultQueue = new SqlResultQueue;
diff --git a/src/game/World.h b/src/game/World.h
index baa36fd..e21fbb6 100644
--- a/src/game/World.h
+++ b/src/game/World.h
@@ -59,7 +59,8 @@ enum WorldTimers
     WUPDATE_UPTIME      = 4,
     WUPDATE_CORPSES     = 5,
     WUPDATE_EVENTS      = 6,
-    WUPDATE_COUNT       = 7
+    WUPDATE_AUTOBROADCAST = 7,
+	WUPDATE_COUNT 		= 8
 };
 
 /// Configuration elements
@@ -160,6 +161,11 @@ enum WorldConfigs
     CONFIG_LISTEN_RANGE_SAY,
     CONFIG_LISTEN_RANGE_TEXTEMOTE,
     CONFIG_LISTEN_RANGE_YELL,
+    CONFIG_ARENA_MAX_RATING_DIFFERENCE,
+    CONFIG_ARENA_RATING_DISCARD_TIMER,
+    CONFIG_ARENA_AUTO_DISTRIBUTE_POINTS,
+    CONFIG_ARENA_AUTO_DISTRIBUTE_INTERVAL_DAYS,
+    CONFIG_BATTLEGROUND_PREMATURE_FINISH_TIMER,
     CONFIG_VALUE_COUNT
 };
 
@@ -318,6 +324,7 @@ class World
 
         WorldSession* FindSession(uint32 id) const;
         void AddSession(WorldSession *s);
+		void SendRNDBroadcast();
         bool RemoveSession(uint32 id);
         /// Get the number of current active sessions
         void UpdateMaxSessionCounters();
@@ -381,6 +388,7 @@ class World
         void LoadConfigSettings(bool reload = false);
 
         void SendWorldText(int32 string_id, ...);
+        void SendGlobalText(const char* text, WorldSession *self);
         void SendGlobalMessage(WorldPacket *packet, WorldSession *self = 0, uint32 team = 0);
         void SendZoneMessage(uint32 zone, WorldPacket *packet, WorldSession *self = 0, uint32 team = 0);
         void SendZoneText(uint32 zone, const char *text, WorldSession *self = 0, uint32 team = 0);
@@ -439,7 +447,10 @@ class World
         static float GetMaxVisibleDistanceInFlight()    { return m_MaxVisibleDistanceInFlight;    }
         static float GetVisibleUnitGreyDistance()       { return m_VisibleUnitGreyDistance;       }
         static float GetVisibleObjectGreyDistance()     { return m_VisibleObjectGreyDistance;     }
-
+        //movement anticheat
+        static bool GetEnableMvAnticheat()     {return m_EnableMvAnticheat;}
+        static uint32 GetTeleportToPlaneAlarms()  {return m_TeleportToPlaneAlarms;}
+        //<<< end movement anticheat
         void ProcessCliCommands();
         void QueueCliCommand( CliCommandHolder::Print* zprintf, char const* input ) { cliCmdQueue.add(new CliCommandHolder(input, zprintf)); }
 
@@ -503,7 +514,9 @@ class World
         static float m_MaxVisibleDistanceInFlight;
         static float m_VisibleUnitGreyDistance;
         static float m_VisibleObjectGreyDistance;
-
+        //movement anticheat enable flag
+        static bool m_EnableMvAnticheat;
+        static uint32 m_TeleportToPlaneAlarms;
         // CLI command holder to be thread safe
         ZThread::LockedQueue<CliCommandHolder*, ZThread::FastMutex> cliCmdQueue;
         SqlResultQueue *m_resultQueue;
diff --git a/src/game/debugcmds.cpp b/src/game/debugcmds.cpp
index 4fd1efd..78836a9 100644
--- a/src/game/debugcmds.cpp
+++ b/src/game/debugcmds.cpp
@@ -30,6 +30,7 @@
 #include "GossipDef.h"
 #include "Language.h"
 #include "MapManager.h"
+#include "BattleGroundMgr.h"
 #include <fstream>
 
 bool ChatHandler::HandleDebugInArcCommand(const char* /*args*/)
@@ -513,3 +514,9 @@ bool ChatHandler::HandleGetItemState(const char* args)
 
     return true;
 }
+
+bool ChatHandler::HandleDebugArenaCommand(const char * /*args*/)
+{
+    sBattleGroundMgr.ToggleArenaTesting();
+    return true;
+}
diff --git a/src/mangosd/mangosd.conf.dist.in b/src/mangosd/mangosd.conf.dist.in
index 4c69f2d..4eec7ed 100644
--- a/src/mangosd/mangosd.conf.dist.in
+++ b/src/mangosd/mangosd.conf.dist.in
@@ -294,6 +294,78 @@ GmLogTimestamp = 0
 RaLogFile = ""
 LogColors = ""
 
+# Chat log parameters
+ChatLogEnable = 0
+
+# If this is enabled, all $d in file names are replaced with current date
+# This does include innormative lexics log
+ChatLogDateSplit = 1
+
+# If this is enabled, UTF8 header is written into new files
+ChatLogUTFHeader = 1
+
+# If this is enabled, chat log will ignore messages with unprintable chars
+ChatLogIgnoreUnprintable = 1
+
+# Chat log files
+ChatLogChatFile = main_chat-$d.log
+ChatLogPartyFile = party_chat-$d.log
+ChatLogGuildFile = guild_chat-$d.log
+ChatLogWhisperFile = whisper_chat-$d.log
+ChatLogChannelFile = channel_chat-$d.log
+ChatLogRaidFile = raid_chat-$d.log
+ChatLogBattleGroundFile = bg_chat-$d.log
+
+# Chat log screen logging
+ChatLogChatScreen = 0
+ChatLogPartyScreen = 0
+ChatLogGuildScreen = 0
+ChatLogWhisperScreen = 0
+ChatLogChannelScreen = 0
+ChatLogRaidScreen = 0
+ChatLogBattleGroundScreen = 0
+
+# Lexics cutter parameters
+LexicsCutterEnable = 1
+
+LexicsCutterInnormativeCut = 1
+LexicsCutterCutReplacement = &!@^%!^&*!!!
+LexicsCutterLogFile = innormative-$d.log
+LexicsCutterScreenLog = 0
+LexicsCutterAnalogsFile = letter_analogs.txt
+LexicsCutterWordsFile = innormative_words.txt
+
+# Where to cut lexics
+LexicsCutInChat = 1
+LexicsCutInParty = 1
+LexicsCutInGuild = 1
+LexicsCutInWhisper = 1
+LexicsCutInChannel = 1
+LexicsCutInRaid = 1
+LexicsCutInBattleGround = 1
+
+# Ignore word spaces like: W O R D
+LexicsCutterIgnoreSpaces = 1
+
+# Ignore repeats like: WWOOOORRRRRD
+LexicsCutterIgnoreRepeats = 1
+
+# --- Action:
+# ---   0: log only
+# ---   1: sheep
+# ---   2: stun
+# ---   3: kill
+# ---   4: leave 5 health
+# ---   5: disable chat
+# ---   6: stuck (works as stun + 50% health) [by KAPATEJIb]
+# ---   7: resurrection sickness [by Koshei]
+# ---   8: shear [by Koshei]
+LexicsCutterAction = 0
+LexicsCutterActionDuration = 60000
+
+# Do not perform action on GM if this is enabled
+LexicsCutterNoActionOnGM = 1
+
 ###################################################################################################################
 # SERVER SETTINGS
 #
@@ -1047,6 +1119,22 @@ Network.OutUBuff = 65536
 Network.TcpNodelay = 1
 
 ###################################################################################################################
+# MOVEMENT ANTICHEAT
+#
+#    Anticheat.Movement.Enable
+#        Enable Movement Anticheat
+#        Default: 1 - on
+#                 0 - off
+#
+#    Anticheat.Movement.TeleportToPlaneAlarms
+#        maximum alarms before player will be kicked (default 50, allowed 20 - 100)
+#
+###################################################################################################################
+
+Anticheat.Movement.Enable = 1
+Anticheat.Movement.TeleportToPlaneAlarms = 50
+
+###################################################################################################################
 # CONSOLE AND REMOTE ACCESS
 #
 #    Console.Enable
@@ -1079,3 +1167,226 @@ Ra.IP = 0.0.0.0
 Ra.Port = 3443
 Ra.MinLevel = 3
 Ra.Secure = 1
+
+###################################################################################################################
+# AUTO BROADCAST
+#
+#    AutoBroadcast.On
+#        Enable auto broadcast
+#        Default: 0 - off
+#                 1 - on
+#
+#    AutoBroadcast.Center
+#        Display method
+#        Default: 0 - announce
+#                 1 - notify
+#                 2 - both
+#
+#    AutoBroadcast.Timer
+#        Timer for auto broadcast
+#
+###################################################################################################################
+
+AutoBroadcast.On = 0
+AutoBroadcast.Center = 0
+AutoBroadcast.Timer = 60000
+
+###################################################################################################################
+# AUCTION HOUSE BOT SETTINGS
+# 
+#    Auction House Bot character data
+#        AuctionHouseBot.Account is the account number (in realmd->account table) of the player you want to run as the auction bot.
+# 	    AuctionHouseBot.GUID is the GUID (in characters->characters table) of the player you want to run as the auction bot. 
+#    Default: 0 (Auction House Bot disabled)
+#
+#    AuctionHouseBot.NoMail
+#        This is a flag to disable mail for successfull auctions. 
+#        A value of 0 will allow mail for successful auctions to be sent, which is the default.
+#        Non-zero (e.g. AuctionHouseBot.NoMail = 1) will stop successful auction mail.
+#    Default: 0 (Send auction successful mail)
+# 
+#    AuctionHouseBot.AllianceItems
+#        This is the number of items you want to keep in the Alliance auction house.
+#    AuctionHouseBot.HordeItems
+#        This is the number of items you want to keep in the Horde auction house.
+#    AuctionHouseBot.NeutralItems
+#        This is the number of items you want to keep in the Neutral auction house.
+#    Default: 0 (No items generated)
+#        Note: If you enable AllowTwoSide.Interaction.Trade, ALL auction houses are linked to the neutral auction house.
+#
+#    AuctionHouseBot.MinAllianceItems
+#        This is the minimum number of items you want to keep in the Alliance auction house.
+#    AuctionHouseBot.MinHordeItems
+#        This is the minimum number of items you want to keep in the Horde auction house.
+#    AuctionHouseBot.MinNeutralItems
+#        This is the minimum number of items you want to keep in the Neutral auction house.
+#    Default: -1 (minimum will be the same as maximum)
+# 
+#    AuctionHouseBot.MinTime
+#        Sets the minimum number of hours for an auction.
+#    Default: 8
+#
+#    AuctionHouseBot.MaxTime
+#        Sets the maximum number of hours for an auction.
+#    Default: 24
+#
+#    Item distribution
+#        Sets the percentage of the auction items that should be trade goods of white quality.
+#        A value of 0 will disable.
+#    AuctionHouseBot.PercentWhiteTradeGoods
+#        Sets the percentage of the White Trade Goods auction items
+#    Default: 30
+#    AuctionHouseBot.PercentGreenTradeGoods
+#        Sets the percentage of the Green Trade Goods auction items
+#    Default: 13
+#    AuctionHouseBot.PercentBlueTradeGoods
+#        Sets the percentage of the Blue Trade Goods auction items
+#    Default: 9
+#    AuctionHouseBot.PercentPurpleTradeGoods
+#        Sets the percentage of the Purple Trade Goods auction items
+#    Default: 1
+#        Note: All of the above values (AuctionHouseBot Percent TradeGoods) must add together to make 100 percent.
+#
+#    AuctionHouseBot.PercentWhiteItems
+#        Sets the percentage of the non trade White auction items
+#    Default: 6
+#    AuctionHouseBot.PercentGreenItems
+#        Sets the percentage of the non trade Green auction items
+#    Default: 30
+#    AuctionHouseBot.PercentBlueItems
+#        Sets the percentage of the non trade Blue auction items
+#    Default: 9
+#    AuctionHouseBot.PercentPurpleItems
+#        Sets the percentage of the non trade Purple auction items
+#    Default: 2
+#        Note: All of the above values (AuctionHouseBot Percent Items) must add together to make 100 percent.
+#
+#    Minimum and maximim price mark-up for items.  Percentage of vendor sale price.
+#        Example: If a vendor would sell an item for 1g and MinPrice = 150 and MaxPrice = 250,
+#        then that item would be randomly priced between 1g 50s and 2g 50s.
+#    AuctionHouseBot.MinPriceWhite
+#        Minimum price of White items.
+#    Default: 150
+#    AuctionHouseBot.MaxPriceWhite
+#        Maximum price of White items.
+#    Default: 250
+#    AuctionHouseBot.MinPriceGreen
+#        Minimum price of Green items.
+#    Default: 200
+#    AuctionHouseBot.MaxPriceGreen
+#        Maximum price of Green items.
+#    Default: 300
+#    AuctionHouseBot.MinPriceBlue
+#        Minimum price of Blue items.
+#    Default: 250
+#    AuctionHouseBot.MaxPriceBlue
+#        Maximum price of Blue items.
+#    Default: 350
+#    AuctionHouseBot.MinPricePurple
+#        Minimum price of Purple items.
+#    Default: 300
+#    AuctionHouseBot.MaxPricePurple
+#        Maximum price of Purple items.
+#    Default: 450
+#
+#    AuctionHouseBot.BidPrice
+#    Starting bid price as a percentage of the randomly chosen buyout price
+#    AuctionHouseBot.BidPriceWhite
+#    Default: 100 (Bid and buyout price the same)
+#    AuctionHouseBot.BidPriceGreen
+#    Default: 100 (Bid and buyout price the same)
+#    AuctionHouseBot.BidPriceBlue
+#    Default: 100 (Bid and buyout price the same)
+#    +AuctionHouseBot.BidPricePurple
+#    Default: 100 (Bid and buyout price the same)
+#
+#    AuctionHouseBot.MaxStack
+#        Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality,
+#        which will allow the bot to create items in stack as large as the item allows.
+#    AuctionHouseBot.MaxStackWhite
+#    Default: 0
+#    AuctionHouseBot.MaxStackGreen
+#    Default: 3
+#    AuctionHouseBot.MaxStackBlue
+#    Default: 2
+#    AuctionHouseBot.MaxStackPurple
+#    Default: 1
+#
+###################################################################################################################
+
+AuctionHouseBot.Account = 0
+AuctionHouseBot.GUID = 0
+AuctionHouseBot.NoMail = 0
+AuctionHouseBot.AllianceItems = 0
+AuctionHouseBot.HordeItems = 0
+AuctionHouseBot.NeutralItems = 0
+AuctionHouseBot.MinAllianceItems = -1
+AuctionHouseBot.MinHordeItems = -1
+AuctionHouseBot.MinNeutralItems = -1
+AuctionHouseBot.MinTime = 8
+AuctionHouseBot.MaxTime = 24
+AuctionHouseBot.PercentWhiteTradeGoods = 30
+AuctionHouseBot.PercentGreenTradeGoods = 13
+AuctionHouseBot.PercentBlueTradeGoods = 9
+AuctionHouseBot.PercentPurpleTradeGoods = 1
+AuctionHouseBot.PercentWhiteItems = 6
+AuctionHouseBot.PercentGreenItems = 30
+AuctionHouseBot.PercentBlueItems = 9
+AuctionHouseBot.PercentPurpleItems = 2
+AuctionHouseBot.MinPriceWhite = 150
+AuctionHouseBot.MaxPriceWhite = 250
+AuctionHouseBot.MinPriceGreen = 200
+AuctionHouseBot.MaxPriceGreen = 300
+AuctionHouseBot.MinPriceBlue = 250
+AuctionHouseBot.MaxPriceBlue = 350
+AuctionHouseBot.MinPricePurple = 300
+AuctionHouseBot.MaxPricePurple = 450
+AuctionHouseBot.BidPriceWhite = 100
+AuctionHouseBot.BidPriceGreen = 100
+AuctionHouseBot.BidPriceBlue = 100
+AuctionHouseBot.BidPricePurple = 100
+AuctionHouseBot.MaxStackWhite = 0
+AuctionHouseBot.MaxStackGreen = 3
+AuctionHouseBot.MaxStackBlue = 2
+AuctionHouseBot.MaxStackPurple = 1
+
+###################################################################################################################
+#
+# Rated arena matches config
+#
+# MaxRatingDifference: the maximum rating difference between two groups in rated matches
+#             Default: 0 (disable, rating difference is discarded)  
+#
+# RatingDiscardTimer: after the specified milliseconds has passed, 
+#                     rating information will be discarded when selecting teams for matches
+#                     also initiates an update by this timer
+#             Default: 60000
+#
+# AutoDistributePoints: set if arena points should be distributed automatically, or by GM command
+#             Default: 0 (disable) (recommended): use gm command or sql query to distribute the points
+#                      1 (enable): arena points are distributed automatically
+#
+# AutoDistributeInterval: how often should the distribution take place 
+#                         if automatic distribution is enabled
+#                         in days
+#             Default: 7 (weekly)
+#
+###################################################################################################################
+
+Arena.MaxRatingDifference = 0
+Arena.RatingDiscardTimer = 60000
+Arena.AutoDistributePoints = 0
+Arena.AutoDistributeInterval = 7
+
+###################################################################################################################
+#
+# Battleground config
+#
+# PrematureFinishTimer: the time to end the bg if there are less than minplayersperteam on one side
+#                       in milliseconds
+#              Default: 300000
+#                       0 - disable
+#
+###################################################################################################################
+
+BattleGround.PrematureFinishTimer = 300000
diff --git a/src/shared/Database/DBCStructure.h b/src/shared/Database/DBCStructure.h
index b45f9c9..a6b7e23 100644
--- a/src/shared/Database/DBCStructure.h
+++ b/src/shared/Database/DBCStructure.h
@@ -418,9 +418,10 @@ struct MapEntry
 
     // Helpers
     uint32 Expansion() const { return addon; }
-    bool Instanceable() const { return map_type == MAP_INSTANCE || map_type == MAP_RAID; }
-    // NOTE: this duplicate of Instanceable(), but Instanceable() can be changed when BG also will be instanceable
+
+
     bool IsDungeon() const { return map_type == MAP_INSTANCE || map_type == MAP_RAID; }
+    bool Instanceable() const { return map_type == MAP_INSTANCE || map_type == MAP_RAID || map_type == MAP_BATTLEGROUND || map_type == MAP_ARENA; }
     bool IsRaid() const { return map_type == MAP_RAID; }
     bool IsBattleGround() const { return map_type == MAP_BATTLEGROUND; }
     bool IsBattleArena() const { return map_type == MAP_ARENA; }
diff --git a/src/shared/Database/DatabaseMysql.cpp b/src/shared/Database/DatabaseMysql.cpp
index e8a944f..c08fd4e 100644
--- a/src/shared/Database/DatabaseMysql.cpp
+++ b/src/shared/Database/DatabaseMysql.cpp
@@ -165,6 +165,22 @@ bool DatabaseMysql::Initialize(const char *infoString)
         PExecute("SET NAMES `utf8`");
         PExecute("SET CHARACTER SET `utf8`");
 
+#if MYSQL_VERSION_ID >= 50003
+//  #if MYSQL_VERSIOB_ID >= 50013
+        my_bool my_true = (my_bool)1;
+        if (mysql_options(mMysql, MYSQL_OPT_RECONNECT, &my_true))
+        {
+            sLog.outDetail("Failed to turn on MYSQL_OPT_RECONNECT.");
+        }
+        else
+        {
+            sLog.outDetail("Successfully turned on MYSQL_OPT_RECONNECT.");
+        }
+#else
+        sLog.outDetail("Your mySQL client lib version does not support reconnecting after a timeout.");
+        sLog.outDetail("If this causes you any trouble we advice you to upgrade");
+        sLog.outDetail("your mySQL client libs to at least mySQL 5.0.13 to resolve this problem.");
+#endif
         return true;
     }
     else
diff --git a/win/VC71/game.vcproj b/win/VC71/game.vcproj
index d131d0f..9174dfc 100644
--- a/win/VC71/game.vcproj
+++ b/win/VC71/game.vcproj
@@ -240,6 +240,18 @@
 			<File
 				RelativePath="..\..\src\game\ChatHandler.cpp">
 			</File>
+            <File
+                RelativePath="..\..\src\game\ChatLexicsCutter.cpp">
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLexicsCutter.h">
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLog.cpp">
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLog.h">
+            </File>
 			<File
 				RelativePath="..\..\src\game\CombatHandler.cpp">
 			</File>
@@ -475,6 +487,12 @@
 				RelativePath="..\..\src\game\ArenaTeam.h">
 			</File>
 			<File
+				RelativePath="..\..\src\game\AuctionHouseBot.cpp">
+			</File>
+			<File
+				RelativePath="..\..\src\game\AuctionHouseBot.h">
+			</File>
+			<File
 				RelativePath="..\..\src\game\AuctionHouseObject.h">
 			</File>
 			<File
diff --git a/win/VC80/game.vcproj b/win/VC80/game.vcproj
index 80aa58b..6098468 100644
--- a/win/VC80/game.vcproj
+++ b/win/VC80/game.vcproj
@@ -494,6 +494,22 @@
 				RelativePath="..\..\src\game\ChatHandler.cpp"
 				>
 			</File>
+            <File
+                RelativePath="..\..\src\game\ChatLexicsCutter.cpp"
+                >
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLexicsCutter.h"
+                >
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLog.cpp"
+                >
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLog.h"
+                >
+            </File>
 			<File
 				RelativePath="..\..\src\game\CombatHandler.cpp"
 				>
@@ -807,6 +823,14 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\game\AuctionHouseBot.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\AuctionHouseBot.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\AuctionHouseObject.h"
 				>
 			</File>
diff --git a/win/VC90/game.vcproj b/win/VC90/game.vcproj
index 19b0ae4..4408c4a 100644
--- a/win/VC90/game.vcproj
+++ b/win/VC90/game.vcproj
@@ -496,6 +496,22 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\game\ChatLexicsCutter.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\ChatLexicsCutter.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\ChatLog.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\ChatLog.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\CombatHandler.cpp"
 				>
 			</File>
@@ -808,6 +824,14 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\game\AuctionHouseBot.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\AuctionHouseBot.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\AuctionHouseObject.h"
 				>
 			</File>
