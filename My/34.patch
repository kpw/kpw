diff --git a/src/game/AggressorAI.cpp b/src/game/AggressorAI.cpp
index 637410c..9be41e5 100644
--- a/src/game/AggressorAI.cpp
+++ b/src/game/AggressorAI.cpp
@@ -55,7 +55,7 @@ AggressorAI::MoveInLineOfSight(Unit *u)
         if(i_creature.IsWithinDistInMap(u, attackRadius) && i_creature.IsWithinLOSInMap(u) )
         {
             AttackStart(u);
-            u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
+            //u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
         }
     }
 }
diff --git a/src/game/ArenaTeam.cpp b/src/game/ArenaTeam.cpp
index 36ae281..87dc140 100644
--- a/src/game/ArenaTeam.cpp
+++ b/src/game/ArenaTeam.cpp
@@ -51,7 +51,7 @@ bool ArenaTeam::create(uint64 captainGuid, uint32 type, std::string ArenaTeamNam
     if(objmgr.GetArenaTeamByName(ArenaTeamName))            // arena team with this name already exist
         return false;
 
-    sLog.outDebug("GUILD: creating arena team %s to leader: %u", ArenaTeamName.c_str(), GUID_LOPART(CaptainGuid));
+    sLog.outDebug("GUILD: creating arena team %s to leader: %u", ArenaTeamName.c_str(), GUID_LOPART(captainGuid));
 
     CaptainGuid = captainGuid;
     Name = ArenaTeamName;
@@ -138,10 +138,8 @@ bool ArenaTeam::AddMember(uint64 PlayerGuid)
     {
         pl->SetInArenaTeam(Id, GetSlot());
         pl->SetArenaTeamIdInvited(0);
-    }
-    else
-    {
-        Player::SetUInt32ValueInDB(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot() * 6), Id, PlayerGuid);
+        // personal rating
+        pl->SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot() * 6) + 5, 1500);
     }
 
     // hide promote/remove buttons
@@ -149,18 +147,39 @@ bool ArenaTeam::AddMember(uint64 PlayerGuid)
     {
         if(pl)
             pl->SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 1 + (GetSlot() * 6), 1);
-        else
-            Player::SetUInt32ValueInDB(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 1 + (GetSlot() * 6), 1, PlayerGuid);
     }
+
+    // setuint32valueindb is asynch, can't be used here
+    Tokens tokens;
+    if(!Player::LoadValuesArrayFromDB(tokens,PlayerGuid))
+        return false;
+
+    // arena team id
+    uint16 index = PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot() * 6);
+    char buf[11];
+    snprintf(buf,11,"%u",Id);
+    tokens[index] = buf;
+    // pers rating
+    index = PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot() * 6) + 5;
+    buf[11];
+    snprintf(buf,11,"%u",1500);
+    tokens[index] = buf;
+    // hide promote/remove buttons
+    if(CaptainGuid != PlayerGuid)
+    {
+        index = PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 1 + (GetSlot() * 6);
+        buf[11];
+        snprintf(buf,11,"%u",1);
+        tokens[index] = buf;
+    }
+
+    Player::SaveValuesArrayInDB(tokens,PlayerGuid);
+
     return true;
 }
 
 bool ArenaTeam::LoadArenaTeamFromDB(uint32 ArenaTeamId)
 {
-    LoadStatsFromDB(ArenaTeamId);
-    LoadMembersFromDB(ArenaTeamId);
-
-    //                                                      0          1    2           3    4               5           6           7           8
     QueryResult *result = CharacterDatabase.PQuery("SELECT arenateamid,name,captainguid,type,BackgroundColor,EmblemStyle,EmblemColor,BorderStyle,BorderColor FROM arena_team WHERE arenateamid = '%u'", ArenaTeamId);
 
     if(!result)
@@ -180,6 +199,22 @@ bool ArenaTeam::LoadArenaTeamFromDB(uint32 ArenaTeamId)
 
     delete result;
 
+    // only load here, so additional checks can be made
+    LoadStatsFromDB(ArenaTeamId);
+    LoadMembersFromDB(ArenaTeamId);
+
+    if(!GetMembersSize())
+    {
+        // arena team is empty, delete from db
+        CharacterDatabase.BeginTransaction();
+        CharacterDatabase.PExecute("DELETE FROM arena_team WHERE arenateamid = '%u'", ArenaTeamId);
+        CharacterDatabase.PExecute("DELETE FROM arena_team_member WHERE arenateamid = '%u'", ArenaTeamId);
+        CharacterDatabase.PExecute("DELETE FROM arena_team_stats WHERE arenateamid = '%u'", ArenaTeamId);
+        CharacterDatabase.CommitTransaction();
+        // return false
+        return false;
+    }
+
     return true;
 }
 
@@ -207,7 +242,7 @@ void ArenaTeam::LoadMembersFromDB(uint32 ArenaTeamId)
 {
     Field *fields;
 
-    QueryResult *result = CharacterDatabase.PQuery("SELECT guid,played_week,wons_week,played_season,wons_season FROM arena_team_member WHERE arenateamid = '%u'", ArenaTeamId);
+    QueryResult *result = CharacterDatabase.PQuery("SELECT guid,played_week,wons_week,played_season,wons_season,points_to_add FROM arena_team_member WHERE arenateamid = '%u'", ArenaTeamId);
     if(!result)
         return;
 
@@ -216,6 +251,14 @@ void ArenaTeam::LoadMembersFromDB(uint32 ArenaTeamId)
         fields = result->Fetch();
         ArenaTeamMember newmember;
         newmember.guid          = MAKE_NEW_GUID(fields[0].GetUInt32(), 0, HIGHGUID_PLAYER);
+        // check if this member is in this arenateam
+        // based on character data field
+        if(Player::GetUInt32ValueFromDB(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot() * 6),newmember.guid) != ArenaTeamId)
+        {
+            // the player's registered arena team for this slot isn't this team, so delete member info from here
+            CharacterDatabase.PExecute("DELETE FROM arena_team_member WHERE guid = '%u' AND arenateamid = '%u'",fields[0].GetUInt32(), ArenaTeamId);
+            continue;
+        }
         LoadPlayerStats(&newmember);
         newmember.played_week   = fields[1].GetUInt32();
         newmember.wons_week     = fields[2].GetUInt32();
@@ -276,17 +319,36 @@ void ArenaTeam::DelMember(uint64 guid)
     }
 
     Player *player = objmgr.GetPlayer(guid);
+    // this will be ugly. because of the asynchronous sql handling, we have to set all the fields of the player at once, and save them at once, or else the save will only modify the last field.
+    // rip off of setuint32valueindb
     if(player)
     {
         player->SetInArenaTeam(0, GetSlot());
         player->GetSession()->SendArenaTeamCommandResult(ERR_ARENA_TEAM_QUIT_S, GetName(), "", 0);
+        // delete all info regarding this team
+        for(int i = 0; i < 6; ++i)
+        {
+            player->SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot() * 6) + i, 0);
+        }
     }
-    else
+
+    // we have to do it this way, setuint32valueindb is asynch, unsafe to use multiple times in a row on the same player
+    Tokens tokens;
+    if(!Player::LoadValuesArrayFromDB(tokens,guid))
+        return;
+
+    for(int i = 0; i < 6; ++i)
     {
-        Player::SetUInt32ValueInDB(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot() * 6), 0, guid);
+        uint16 index = PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot() * 6) + i;
+        char buf[11];
+        snprintf(buf,11,"%u",0);
+        tokens[index] = buf;
     }
 
-    CharacterDatabase.PExecute("DELETE FROM arena_team_member WHERE guid = '%u'", GUID_LOPART(guid));
+    Player::SaveValuesArrayInDB(tokens,guid);
+
+    // only delete from this arena team!
+    CharacterDatabase.PExecute("DELETE FROM arena_team_member WHERE arenateamid = '%u' AND guid = '%u'", GetId(), GUID_LOPART(guid));
 }
 
 void ArenaTeam::Disband(WorldSession *session)
@@ -313,6 +375,7 @@ void ArenaTeam::Disband(WorldSession *session)
 
     CharacterDatabase.BeginTransaction();
     CharacterDatabase.PExecute("DELETE FROM arena_team WHERE arenateamid = '%u'", Id);
+    CharacterDatabase.PExecute("DELETE FROM arena_team_member WHERE arenateamid = '%u'", Id);
     CharacterDatabase.PExecute("DELETE FROM arena_team_stats WHERE arenateamid = '%u'", Id);
     CharacterDatabase.CommitTransaction();
     objmgr.RemoveArenaTeam(this);
@@ -342,7 +405,7 @@ void ArenaTeam::Roster(WorldSession *session)
             data << uint32(itr->wons_week);                 // wins this week
             data << uint32(itr->played_season);             // played this season
             data << uint32(itr->wons_season);               // wins this season
-            data << uint32(0);                              // personal rating?
+            data << uint32(pl->GetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + GetSlot() * 6 + 5));                              // personal rating?
         }
         else
         {
@@ -356,7 +419,7 @@ void ArenaTeam::Roster(WorldSession *session)
             data << uint32(itr->wons_week);                 // wins this week
             data << uint32(itr->played_season);             // played this season
             data << uint32(itr->wons_season);               // wins this season
-            data << uint32(0);                              // personal rating?
+            data << uint32(Player::GetUInt32ValueFromDB(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + GetSlot() * 6 + 5, itr->guid));                              // personal rating?
         }
     }
     session->SendPacket(&data);
@@ -391,6 +454,18 @@ void ArenaTeam::Stats(WorldSession *session)
     session->SendPacket(&data);
 }
 
+void ArenaTeam::NotifyStatsChanged()
+{
+    // this is called after a rated match ended
+    // updates arena team stats for every member of the team (not only the ones who participated!)
+    for(MemberList::iterator itr = members.begin(); itr != members.end(); ++itr)
+    {
+        Player * plr=objmgr.GetPlayer(itr->guid);
+        if(plr)
+            Stats(plr->GetSession());
+    }
+}
+
 void ArenaTeam::InspectStats(WorldSession *session, uint64 guid)
 {
     WorldPacket data(MSG_INSPECT_ARENA_TEAMS, 8+1+4*6);
@@ -398,10 +473,20 @@ void ArenaTeam::InspectStats(WorldSession *session, uint64 guid)
     data << uint8(GetSlot());                               // slot (0...2)
     data << uint32(GetId());                                // arena team id
     data << uint32(stats.rating);                           // rating
-    data << uint32(stats.games);                            // games
-    data << uint32(stats.wins);                             // wins
-    data << uint32(stats.played);                           // played (count of all games, that played...)
-    data << uint32(0);                                      // 2.3.3 personal rating?
+    data << uint32(stats.played);                           // season played
+    data << uint32(stats.wins2);                            // season wins
+    uint32 participated = 0;
+    for(MemberList::iterator itr = members.begin(); itr!= members.end(); ++itr)
+    {
+        if(itr->guid == guid)
+        {
+            participated = itr->played_season;
+            break;
+        }
+    }
+    data << uint32(participated);                            // played (count of all games, that the inspected member participated...)
+    data << uint32(Player::GetUInt32ValueFromDB(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + GetSlot() * 6 + 5, guid));                                       // unk, 2.3.3 (personal rating?)
+
     session->SendPacket(&data);
 }
 
@@ -494,24 +579,211 @@ bool ArenaTeam::HaveMember( uint64 guid ) const
     return false;
 }
 
+uint32 ArenaTeam::GetPoints(uint32 MemberRating)
+{
+    // returns how many points would be awarded with this team type with this rating
+    float points;
+
+    uint32 rating = MemberRating + 150 < stats.rating ? MemberRating : stats.rating;
+
+    if(rating<=1500)
+    {
+        points = (float)rating * 0.22f + 14.0f;
+    }
+    else
+    {
+        points = 1511.26f / (1.0f + 1639.28f * exp(-0.00412f * (float)rating));
+    }
+
+    // type penalties for <5v5 teams
+    if(Type == ARENA_TEAM_2v2)
+        points *= 0.76f;
+    else if(Type == ARENA_TEAM_3v3)
+        points *= 0.88f;
+
+    return (uint32) points;
+}
+
+float ArenaTeam::GetChanceAgainst(uint32 rating)
+{
+    // returns the chance to win against a team with the given rating, used in the rating adjustment calculation
+    // ELO system
+    return 1.0f/(1.0f+exp(log(10.0f)*(float)((float)rating - (float)stats.rating)/400.0f));
+}
+
+int32 ArenaTeam::WonAgainstChance(float chance)
+{
+    // called when the team has won, and had 'chance' calculated chance to beat the opponent
+    // calculate the rating modification (ELO system with k=32)
+    int32 mod = (int32)floor(32.0f * (1.0f - chance));
+    // modify the team stats accordingly
+    stats.rating += mod;
+    stats.games += 1;
+    stats.wins += 1;
+    stats.played += 1;
+    stats.wins2 += 1;
+/*  this should be done in .flusharenapoints; not a breaker though.
+    uint32 higher_rank = 0;
+    QueryResult *result = CharacterDatabase.PQuery("SELECT DISTINCT COUNT(arenateamid) FROM arena_team_stats WHERE rating > '%u' AND arenateamid <> '%u'",stats.rating, Id);
+    if(result)
+    {
+        higher_rank = result->Fetch()->GetUInt32();
+        delete result;
+    }
+    stats.rank = higher_rank + 1;*/
+    // return the rating change, used to display it on the results screen
+    return mod;
+}
+
+int32 ArenaTeam::LostAgainstChance(float chance)
+{
+    // called when the team has lost, and had 'chance' calculated chance to beat the opponent
+    // calculate the rating modification (ELO system with k=32)
+    int32 mod = (int32)ceil(32.0f * (0.0f - chance));
+    // modify the team stats accordingly
+    stats.rating += mod;
+    stats.games += 1;
+    stats.played += 1;
+/*    uint32 higher_rank = 0;
+    QueryResult *result = CharacterDatabase.PQuery("SELECT DISTINCT COUNT (arenateamid) FROM arena_team_stats WHERE rating > '%u' AND arenateamid <> '%u'",stats.rating, Id);
+    if(result)
+    {
+        higher_rank = result->Fetch()->GetUInt32();
+        delete result;
+    }
+    stats.rank = higher_rank + 1;*/
+    // return the rating adjustment for display
+    return mod;
+}
+
+void ArenaTeam::MemberLost(Player * plr, uint32 againstrating)
+{
+    // called for each participant of a match after losing
+    for(MemberList::iterator itr = members.begin(); itr !=  members.end(); ++itr)
+    {
+        if(itr->guid == plr->GetGUID())
+        {
+            // update personal rating
+            int32 personalrating = plr->GetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot()*6) + 5);
+            float chance = 1.0f/(1.0f+exp(log(10.0f)*(float)((float)againstrating - (float)personalrating)/400.0f));
+            int32 mod = (int32)ceil(32.0f * (0.0f - chance));
+            personalrating += mod;
+            if(personalrating < 0)
+                personalrating = 0;
+            plr->SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot()*6) + 5, personalrating);
+            // update personal played stats
+            itr->played_week +=1;
+            itr->played_season +=1;
+            // update the unit fields
+            plr->SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 6 * GetSlot() + 2, itr->played_week);
+            plr->SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 6 * GetSlot() + 3, itr->played_season);
+            return;
+        }
+    }
+}
+
+void ArenaTeam::MemberWon(Player * plr, uint32 againstrating)
+{
+    // called for each participant after winning a match
+    for(MemberList::iterator itr = members.begin(); itr !=  members.end(); ++itr)
+    {
+        if(itr->guid == plr->GetGUID())
+        {
+            // update personal rating
+            int32 personalrating = plr->GetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot()*6) + 5);
+            float chance = 1.0f/(1.0f+exp(log(10.0f)*(float)((float)againstrating - (float)personalrating)/400.0f));
+            int32 mod = (int32)floor(32.0f * (1.0f - chance));
+            personalrating += mod;
+            if(personalrating < 0)
+                personalrating = 0;
+            plr->SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot()*6) + 5, personalrating);
+            // update personal stats
+            itr->played_week +=1;
+            itr->played_season +=1;
+            itr->wons_season += 1;
+            itr->wons_week += 1;
+            // update unit fields
+            plr->SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 6 * GetSlot() + 2, itr->played_week);
+            plr->SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 6 * GetSlot() + 3, itr->played_season);
+            return;
+        }
+    }
+}
+
+void ArenaTeam::UpdateArenaPointsHelper()
+{
+    // called after a match has ended and the stats are already modified
+    // helper function for arena point distribution (this way, when distributing, no actual calculation is required, just a few comparisons)
+    // 10 played games per week is a minimum
+    if(stats.games < 10)
+        return;
+    // to get points, a player has to participate in at least 30% of the matches
+    uint32 min_plays = ceil(stats.games * 0.3);
+    for(MemberList::iterator itr = members.begin(); itr !=  members.end(); ++itr)
+    {
+        // the player participated in enough games, update his points
+        if(itr->played_week >= min_plays)
+        {
+            // do it separately for online and offline players
+            // online players might have modified personal rating in MemberLost/MemberWon, that's not already saved to DB because of asynch queries
+            // offline player cant have a personal rating not matching the db
+            Player * plr = objmgr.GetPlayer(itr->guid);
+            uint32 points_to_add = 0;
+            if(plr)
+                points_to_add = GetPoints(plr->GetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot()*6) + 5));
+            else
+                points_to_add = GetPoints(Player::GetUInt32ValueFromDB(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (GetSlot()*6) + 5,itr->guid));
+            // it's enough to set the points in memory, the saving is done in separate function
+            CharacterDatabase.PExecute("UPDATE arena_team_member SET points_to_add = '%u' WHERE arenateamid = '%u' AND guid = '%u'", points_to_add, Id, itr->guid);
+        }
+        // the player failed to participate in enough games, so no points for him
+        else
+        {
+            CharacterDatabase.PExecute("UPDATE arena_team_member SET points_to_add = '%u' WHERE arenateamid = '%u' AND guid = '%u'", 0, Id, itr->guid);
+        }
+    }
+}
+
+void ArenaTeam::SaveToDB()
+{
+    // save team and member stats to db
+    // called after a match has ended
+    CharacterDatabase.PExecute("UPDATE arena_team_stats SET rating = '%u',games = '%u',played = '%u',rank = '%u',wins = '%u',wins2 = '%u' WHERE arenateamid = '%u'", stats.rating, stats.games, stats.played, stats.rank, stats.wins, stats.wins2, GetId());
+    for(MemberList::iterator itr = members.begin(); itr !=  members.end(); ++itr)
+    {
+        CharacterDatabase.PExecute("UPDATE arena_team_member SET played_week = '%u', wons_week = '%u', played_season = '%u', wons_season = '%u' WHERE arenateamid = '%u' AND guid = '%u'", itr->played_week, itr->wons_week, itr->played_season, itr->wons_season, Id, itr->guid);
+    }
+}
+
+void ArenaTeam::FinishWeek()
+{
+    stats.games = 0; // played this week
+    stats.wins = 0; // wins this week
+    for(MemberList::iterator itr = members.begin(); itr !=  members.end(); ++itr)
+    {
+        itr->played_week = 0;
+        itr->wons_week = 0;
+    }
+}
+
 /*
 arenateam fields (id from 2.3.3 client):
 1414 - arena team id 2v2
 1415 - 0=captain, 1=member
-1416 - played this season
-1417 - played this week
+1416 - played this week
+1417 - played this season
 1418 - unk
-1419 - unk
+1419 - personal arena rating
 1420 - arena team id 3v3
 1421 - 0=captain, 1=member
-1422 - played this season
-1423 - played this week
+1422 - played this week
+1423 - played this season
 1424 - unk
-1425 - unk
+1425 - personal arena rating
 1426 - arena team id 5v5
 1427 - 0=captain, 1=member
-1428 - played this season
-1429 - played this week
+1428 - played this week
+1429 - played this season
 1430 - unk
-1431 - unk
+1431 - personal arena rating
 */
diff --git a/src/game/ArenaTeam.h b/src/game/ArenaTeam.h
index 0d26b00..73ac7ac 100644
--- a/src/game/ArenaTeam.h
+++ b/src/game/ArenaTeam.h
@@ -149,6 +149,8 @@ class ArenaTeam
         void LoadStatsFromDB(uint32 ArenaTeamId);
         void LoadPlayerStats(ArenaTeamMember* member);
 
+        void SaveToDB();
+
         void BroadcastPacket(WorldPacket *packet);
 
         void Roster(WorldSession *session);
@@ -156,6 +158,19 @@ class ArenaTeam
         void Stats(WorldSession *session);
         void InspectStats(WorldSession *session, uint64 guid);
 
+        uint32 GetPoints(uint32 MemberRating);
+        float GetChanceAgainst(uint32 rating);
+        int32 WonAgainstChance(float chance);
+        void MemberWon(Player * plr, uint32 againstrating);
+        int32 LostAgainstChance(float chance);
+        void MemberLost(Player * plr, uint32 againstrating);
+
+        void UpdateArenaPointsHelper();
+
+        void FinishWeek();
+
+        void NotifyStatsChanged();
+
     protected:
 
         uint32 Id;
diff --git a/src/game/ArenaTeamHandler.cpp b/src/game/ArenaTeamHandler.cpp
index c6b9059..d302703 100644
--- a/src/game/ArenaTeamHandler.cpp
+++ b/src/game/ArenaTeamHandler.cpp
@@ -182,7 +182,7 @@ void WorldSession::HandleArenaTeamInviteAcceptOpcode(WorldPacket & /*recv_data*/
         return;
     }
 
-    if(_player->GetArenaTeamId(at->GetSlot()))
+    if(_player->GetArenaTeamIdFromDB(_player->GetGUIDLow(), at->GetType()))
     {
         // already in arena team that size
         return;
diff --git a/src/game/AuctionHouseBot.cpp b/src/game/AuctionHouseBot.cpp
new file mode 100644
index 0000000..304ea5f
--- /dev/null
+++ b/src/game/AuctionHouseBot.cpp
@@ -0,0 +1,697 @@
+#include "AuctionHouseBot.h"
+#include "Bag.h"
+#include "Config/ConfigEnv.h"
+#include "Database/DatabaseEnv.h"
+#include "Item.h"
+#include "Log.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+#include "World.h"
+#include "WorldSession.h"
+#include <vector>
+
+using namespace std;
+
+//#define NO_VENDOR_ITEMS
+#define ONLY_LOOT_ITEMS
+
+static vector<uint32> whiteTradeGoods;
+static vector<uint32> greenTradeGoods;
+static vector<uint32> blueTradeGoods;
+static vector<uint32> purpleTradeGoods;
+static vector<uint32> whiteItems;
+static vector<uint32> greenItems;
+static vector<uint32> blueItems;
+static vector<uint32> purpleItems;
+
+static uint32 AHBplayerAccount = 0; 
+static uint32 AHBplayerGUID = 0; 
+static uint32 noMail = 0; 
+static uint32 numAllianceItems = 0;
+static uint32 numMinAllianceItems = 0;
+static uint32 numHordeItems = 0;
+static uint32 numMinHordeItems = 0;
+static uint32 numNeutralItems = 0;
+static uint32 numMinNeutralItems = 0;
+static uint32 minTime = 0;
+static uint32 maxTime = 0;
+static uint32 percentWhiteTradeGoods = 0;
+static uint32 percentGreenTradeGoods = 0;
+static uint32 percentBlueTradeGoods = 0;
+static uint32 percentPurpleTradeGoods = 0;
+static uint32 percentWhiteItems = 0;
+static uint32 percentGreenItems = 0;
+static uint32 percentBlueItems = 0;
+static uint32 percentPurpleItems = 0;
+static uint32 minPriceWhite = 0;
+static uint32 maxPriceWhite = 0;
+static uint32 bidPriceWhite = 0;
+static uint32 maxStackWhite = 0;
+static uint32 minPriceGreen = 0;
+static uint32 maxPriceGreen = 0;
+static uint32 bidPriceGreen = 0;
+static uint32 maxStackGreen = 0;
+static uint32 minPriceBlue = 0;
+static uint32 maxPriceBlue = 0;
+static uint32 bidPriceBlue = 0;
+static uint32 maxStackBlue = 0;
+static uint32 minPricePurple = 0;
+static uint32 maxPricePurple = 0;
+static uint32 bidPricePurple = 0;
+static uint32 maxStackPurple = 0;
+
+///////////////////////////////////////////////////////////////////////////////
+//
+///////////////////////////////////////////////////////////////////////////////
+uint32 AuctionHouseBotNoMail()
+{
+   return noMail != 0 ? AHBplayerGUID : 0;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+///////////////////////////////////////////////////////////////////////////////
+static inline uint32 minValue(uint32 a, uint32 b)
+{
+   return a <= b ? a : b;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+///////////////////////////////////////////////////////////////////////////////
+static void deleteOldAuctions(uint32 ahMapID)
+{
+   AuctionHouseObject* auctionHouse = objmgr.GetAuctionsMap(ahMapID);
+
+   AuctionHouseObject::AuctionEntryMap::iterator itr;
+   itr = auctionHouse->GetAuctionsBegin();
+
+   while (itr != auctionHouse->GetAuctionsEnd())
+   {
+      AuctionHouseObject::AuctionEntryMap::iterator tmp = itr;
+      ++itr;
+
+      if (tmp->second->owner != AHBplayerGUID)
+         continue;
+
+      if (tmp->second->bidder != 0)
+         continue;
+
+      if (tmp->second->time > sWorld.GetGameTime())
+         continue;
+
+      // quietly delete the item and auction...
+
+      Item* item = objmgr.GetAItem(tmp->second->item_guidlow);
+      if (item != NULL)
+      {
+         objmgr.RemoveAItem(tmp->second->item_guidlow);
+         item->DeleteFromDB();
+         delete item;
+      }
+      else
+      {
+         sLog.outString("AuctionHouseBot: "
+                        "clearing auction for non-existant item_guidlow (%d)",
+                        tmp->second->item_guidlow);
+      }
+
+	CharacterDatabase.PExecute("DELETE FROM `auctionhouse` WHERE `id` = '%u'",
+                                 tmp->second->Id);
+       AuctionEntry* auctionEntry = tmp->second;
+       auctionHouse->RemoveAuction(auctionEntry->Id);
+       delete auctionEntry;
+   }
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+///////////////////////////////////////////////////////////////////////////////
+static void addNewAuctions(uint32 ahMapID, uint32 maxAuctions, uint32 minAuctions, Player *AHBplayer)
+{
+   AuctionHouseObject* auctionHouse = objmgr.GetAuctionsMap(ahMapID);
+
+   if (auctionHouse->Getcount() > minAuctions)
+      return;
+
+   uint32 whiteTradeGoodsBin = percentWhiteTradeGoods;
+   uint32 greenTradeGoodsBin = percentGreenTradeGoods + whiteTradeGoodsBin;
+   uint32 blueTradeGoodsBin = percentBlueTradeGoods + greenTradeGoodsBin;
+   uint32 purpleTradeGoodsBin = percentPurpleTradeGoods + blueTradeGoodsBin;
+   uint32 whiteItemBin = percentWhiteItems + purpleTradeGoodsBin;
+   uint32 greenItemBin = percentGreenItems + whiteItemBin;
+   uint32 blueItemBin = percentBlueItems + greenItemBin;
+   uint32 purpleItemBin = percentPurpleItems + blueItemBin;
+
+   // only insert 100 at a time, so as not to peg the processor
+   for (uint32 count = 0; 
+        (count < 100) && (auctionHouse->Getcount() < maxAuctions); 
+        count++)
+   {
+      uint32 itemID = purpleItems[urand(0, purpleItems.size() - 1)];
+      uint32 value = urand(1, 100);
+      
+      if (value <= blueItemBin)
+         itemID = blueItems[urand(0, blueItems.size() - 1)];
+
+      if (value <= greenItemBin)
+         itemID = greenItems[urand(0, greenItems.size() - 1)];
+
+      if (value <= whiteItemBin)
+         itemID = whiteItems[urand(0, whiteItems.size() - 1)];
+
+      if (value <= purpleTradeGoodsBin)
+         itemID = purpleTradeGoods[urand(0, purpleTradeGoods.size() - 1)];
+
+      if (value <= blueTradeGoodsBin)
+         itemID = blueTradeGoods[urand(0, blueTradeGoods.size() - 1)];
+
+      if (value <= greenTradeGoodsBin)
+         itemID = greenTradeGoods[urand(0, greenTradeGoods.size() - 1)];
+
+      if (value <= whiteTradeGoodsBin)
+         itemID = whiteTradeGoods[urand(0, whiteTradeGoods.size() - 1)];
+
+      ItemPrototype const* prototype = objmgr.GetItemPrototype(itemID);
+      if (prototype == NULL)
+      {
+         sLog.outString("AuctionHouseBot: Huh?!?! prototype == NULL");
+         continue;
+      }
+
+      Item* item = Item::CreateItem(itemID, 1, AHBplayer);
+	  item->AddToUpdateQueueOf(AHBplayer);
+      if (item == NULL)
+      {
+         sLog.outString("AuctionHouseBot: Item::CreateItem() returned NULL");
+         break;
+      }
+
+      uint32 randomPropertyId = Item::GenerateItemRandomPropertyId(itemID);
+      if (randomPropertyId != 0)
+         item->SetItemRandomProperties(randomPropertyId);
+
+      uint32 buyoutPrice = prototype->BuyPrice * item->GetCount();
+      uint32 bidPrice = 0;
+      uint32 stackCount = urand(1, item->GetMaxStackCount());
+
+      switch (prototype->Quality)
+      {
+         case 1:
+            if (maxStackWhite != 0)
+            {
+               stackCount = urand(1, minValue(item->GetMaxStackCount(), 
+                                              maxStackWhite));
+            }
+
+            buyoutPrice *= urand(minPriceWhite, maxPriceWhite) * stackCount;
+            buyoutPrice /= 100;
+            bidPrice = buyoutPrice * bidPriceWhite;
+            bidPrice /= 100;
+
+            break;
+
+         case 2:
+            if (maxStackGreen != 0)
+            {
+               stackCount = urand(1, minValue(item->GetMaxStackCount(), 
+                                              maxStackGreen));
+            }
+
+            buyoutPrice *= urand(minPriceGreen, maxPriceGreen) * stackCount;
+            buyoutPrice /= 100;
+            bidPrice = buyoutPrice * bidPriceGreen;
+            bidPrice /= 100;
+
+            break;
+
+         case 3:
+            if (maxStackBlue != 0)
+            {
+               stackCount = urand(1, minValue(item->GetMaxStackCount(), 
+                                              maxStackBlue));
+            }
+
+            buyoutPrice *= urand(minPriceBlue, maxPriceBlue) * stackCount;
+            buyoutPrice /= 100;
+            bidPrice = buyoutPrice * bidPriceBlue;
+            bidPrice /= 100;
+
+            break;
+
+         case 4:
+            if (maxStackPurple != 0)
+            {
+               stackCount = urand(1, minValue(item->GetMaxStackCount(), 
+                                              maxStackPurple));
+            }
+
+            buyoutPrice *= urand(minPricePurple, maxPricePurple) * stackCount;
+            buyoutPrice /= 100;
+            bidPrice = buyoutPrice * bidPricePurple;
+            bidPrice /= 100;
+
+            break;
+      }
+
+      item->SetCount(stackCount);
+
+      AuctionEntry* auctionEntry = new AuctionEntry;
+      auctionEntry->Id = objmgr.GenerateAuctionID();
+      auctionEntry->auctioneer = 0;
+      auctionEntry->item_guidlow = item->GetGUIDLow();
+      auctionEntry->item_template = item->GetEntry();
+      auctionEntry->owner = AHBplayer->GetGUIDLow();
+      auctionEntry->startbid = bidPrice;
+      auctionEntry->buyout = buyoutPrice;
+      auctionEntry->bidder = 0;
+      auctionEntry->bid = 0;
+      auctionEntry->deposit = 0;
+      auctionEntry->location = ahMapID;
+      auctionEntry->time = (time_t) (urand(minTime, maxTime) * 60 * 60 + 
+                                     time(NULL));
+      
+      item->SaveToDB();
+      item->RemoveFromUpdateQueueOf(AHBplayer);
+      objmgr.AddAItem(item);
+      auctionHouse->AddAuction(auctionEntry);
+
+      CharacterDatabase.PExecute("INSERT INTO `auctionhouse` (`id`,"
+                                 "`auctioneerguid`,`itemguid`,`item_template`,"
+                                 "`itemowner`,`buyoutprice`,`time`,`buyguid`,"
+                                 "`lastbid`,`startbid`,`deposit`,`location`) "
+                                 "VALUES ('%u', '%u', '%u', '%u', '%u', '%u', "
+                                 "'" I64FMTD "', '%u', '%u', '%u', '%u', '%u')",
+                                 auctionEntry->Id, 
+                                 auctionEntry->auctioneer,
+                                 auctionEntry->item_guidlow, 
+                                 auctionEntry->item_template, 
+                                 auctionEntry->owner, 
+                                 auctionEntry->buyout, 
+                                 (uint64) auctionEntry->time, 
+                                 auctionEntry->bidder, 
+                                 auctionEntry->bid, 
+                                 auctionEntry->startbid, 
+                                 auctionEntry->deposit, 
+                                 auctionEntry->location);
+   }
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+///////////////////////////////////////////////////////////////////////////////
+void AuctionHouseBot()
+{
+   if ((AHBplayerAccount == 0) || (AHBplayerGUID == 0))
+      return;
+
+   WorldSession _session(AHBplayerAccount, NULL, 0, true, 0, LOCALE_enUS);
+   Player _AHBplayer(&_session);
+   _AHBplayer.MinimalLoadFromDB(NULL, AHBplayerGUID);
+   ObjectAccessor::Instance().AddObject(&_AHBplayer);
+
+   deleteOldAuctions(2);
+   deleteOldAuctions(6);
+   deleteOldAuctions(7);
+
+   addNewAuctions(2, numAllianceItems, numMinAllianceItems, &_AHBplayer);
+   addNewAuctions(6, numHordeItems, numMinHordeItems, &_AHBplayer);
+   addNewAuctions(7, numNeutralItems, numMinNeutralItems, &_AHBplayer);
+   
+   ObjectAccessor::Instance().RemoveObject(&_AHBplayer);
+}
+///////////////////////////////////////////////////////////////////////////////
+//
+///////////////////////////////////////////////////////////////////////////////
+void AuctionHouseBotInit()
+{
+   AHBplayerAccount = sConfig.GetIntDefault("AuctionHouseBot.Account", 0);
+   AHBplayerGUID = sConfig.GetIntDefault("AuctionHouseBot.GUID", 0);
+                         
+   if ((AHBplayerAccount == 0) || (AHBplayerGUID == 0))
+   {
+      sLog.outString("AuctionHouseBot disabled");
+      return;            
+   }
+
+   noMail = sConfig.GetIntDefault("AuctionHouseBot.NoMail", 0);
+
+   numAllianceItems = sConfig.GetIntDefault("AuctionHouseBot.AllianceItems", 0);
+   numMinAllianceItems = sConfig.GetIntDefault("AuctionHouseBot.MinAllianceItems", -1);
+   numHordeItems = sConfig.GetIntDefault("AuctionHouseBot.HordeItems", 0);
+   numMinHordeItems = sConfig.GetIntDefault("AuctionHouseBot.MinHordeItems", -1);
+   numNeutralItems = sConfig.GetIntDefault("AuctionHouseBot.NeutralItems", 0);
+   numMinNeutralItems = sConfig.GetIntDefault("AuctionHouseBot.MinNeutralItems", -1);
+
+   if (numMinAllianceItems < 0)
+	   numMinAllianceItems = numAllianceItems;
+
+   if (numMinHordeItems  < 0)
+	   numMinHordeItems = numHordeItems;
+
+   if (numMinNeutralItems  < 0)
+	   numMinNeutralItems = numNeutralItems;
+
+   if (numMinAllianceItems > numAllianceItems)
+	   numMinAllianceItems = numAllianceItems;
+
+   if (numMinHordeItems > numHordeItems)
+	   numMinHordeItems = numHordeItems;
+
+   if (numMinNeutralItems > numNeutralItems)
+	   numMinNeutralItems = numNeutralItems;
+
+   minTime = sConfig.GetIntDefault("AuctionHouseBot.MinTime", 8);
+   maxTime = sConfig.GetIntDefault("AuctionHouseBot.MaxTime", 24);
+
+   if (minTime < 1)
+      minTime = 1;
+
+   if (maxTime > 24)
+      maxTime = 24;
+
+   if (minTime > maxTime)
+      minTime = maxTime;
+
+   percentWhiteTradeGoods = sConfig.GetIntDefault("AuctionHouseBot."
+                                                  "PercentWhiteTradeGoods",
+                                                  27);
+   percentGreenTradeGoods = sConfig.GetIntDefault("AuctionHouseBot."
+                                                  "PercentGreenTradeGoods",
+                                                  12);
+   percentBlueTradeGoods = sConfig.GetIntDefault("AuctionHouseBot."
+                                                  "PercentBlueTradeGoods",
+                                                  10);
+   percentPurpleTradeGoods = sConfig.GetIntDefault("AuctionHouseBot."
+                                                  "PercentPurpleTradeGoods",
+                                                  1);
+   percentWhiteItems = sConfig.GetIntDefault("AuctionHouseBot."
+                                             "PercentWhiteItems",
+                                             10);
+   percentGreenItems = sConfig.GetIntDefault("AuctionHouseBot."
+                                             "PercentGreenItems",
+                                             30);
+   percentBlueItems = sConfig.GetIntDefault("AuctionHouseBot."
+                                            "PercentBlueItems",
+                                            8);
+   percentPurpleItems = sConfig.GetIntDefault("AuctionHouseBot."
+                                              "PercentPurpleItems",
+                                              2);
+
+   uint32 totalPercent = percentWhiteTradeGoods + percentGreenTradeGoods +
+                         percentBlueTradeGoods + percentPurpleTradeGoods +
+                         percentWhiteItems + percentGreenItems + 
+                         percentBlueItems + percentPurpleItems;
+
+   if (totalPercent == 0)
+   {
+      numAllianceItems = 0;
+      numHordeItems = 0;
+      numNeutralItems = 0;
+   }
+   else if (totalPercent != 100)
+   {
+      double scale = (double) 100 / (double) totalPercent;
+
+      percentPurpleItems = (uint32) (scale * (double) percentPurpleItems);
+      percentBlueItems = (uint32) (scale * (double) percentBlueItems);
+      percentGreenItems = (uint32) (scale * (double) percentGreenItems);
+      percentWhiteItems = (uint32) (scale * (double) percentWhiteItems);
+      percentPurpleTradeGoods = (uint32) (scale * 
+                                          (double) percentPurpleTradeGoods);
+      percentBlueTradeGoods = (uint32) (scale * 
+                                        (double) percentBlueTradeGoods);
+      percentGreenTradeGoods = (uint32) (scale * 
+                                         (double) percentGreenTradeGoods);
+      percentWhiteTradeGoods = 100 - 
+                               percentGreenTradeGoods - 
+                               percentBlueTradeGoods -
+                               percentPurpleTradeGoods -
+                               percentWhiteItems -
+                               percentGreenItems -
+                               percentBlueItems -
+                               percentPurpleItems;
+
+      sLog.outString("AuctionHouseBot:");
+      sLog.outString("sum of item percentages not equal to 100, adjusting...");
+      sLog.outString("AuctionHouseBot.PercentWhiteTradeGoods = %d",
+                     percentWhiteTradeGoods);
+      sLog.outString("AuctionHouseBot.PercentGreenTradeGoods = %d",
+                     percentGreenTradeGoods);
+      sLog.outString("AuctionHouseBot.PercentBlueTradeGoods = %d",
+                     percentBlueTradeGoods);
+      sLog.outString("AuctionHouseBot.PercentPurpleTradeGoods = %d",
+                     percentPurpleTradeGoods);
+      sLog.outString("AuctionHouseBot.PercentWhiteItems = %d",
+                     percentWhiteItems);
+      sLog.outString("AuctionHouseBot.PercentGreenItems = %d",
+                     percentGreenItems);
+      sLog.outString("AuctionHouseBot.PercentBlueItems = %d",
+                     percentBlueItems);
+      sLog.outString("AuctionHouseBot.PercentPurpleItems = %d",
+                     percentPurpleItems);
+   }
+
+   minPriceWhite = sConfig.GetIntDefault("AuctionHouseBot.MinPriceWhite",
+                                         150);
+   maxPriceWhite = sConfig.GetIntDefault("AuctionHouseBot.MaxPriceWhite",
+                                         250);
+
+   if (minPriceWhite == 0)
+      minPriceWhite = 1;
+
+   if (maxPriceWhite == 0)
+      maxPriceWhite = 1;
+
+   if (minPriceWhite > maxPriceWhite)
+      minPriceWhite = maxPriceWhite;
+
+   bidPriceWhite = sConfig.GetIntDefault("AuctionHouseBot.BidPriceWhite",
+                                         100);
+   if (bidPriceWhite > 100)
+      bidPriceWhite = 100;
+
+   maxStackWhite = sConfig.GetIntDefault("AuctionHouseBot.MaxStackWhite", 0);
+
+   minPriceGreen = sConfig.GetIntDefault("AuctionHouseBot.MinPriceGreen",
+                                         200);
+   maxPriceGreen = sConfig.GetIntDefault("AuctionHouseBot.MaxPriceGreen",
+                                         300);
+
+   if (minPriceGreen == 0)
+      minPriceGreen = 1;
+
+   if (maxPriceGreen == 0)
+      maxPriceGreen = 1;
+
+   if (minPriceGreen > maxPriceGreen)
+      minPriceGreen = maxPriceGreen;
+
+   bidPriceGreen = sConfig.GetIntDefault("AuctionHouseBot.BidPriceGreen",
+                                         100);
+   if (bidPriceGreen > 100)
+      bidPriceGreen = 100;
+
+   maxStackGreen = sConfig.GetIntDefault("AuctionHouseBot.MaxStackGreen", 0);
+
+   minPriceBlue = sConfig.GetIntDefault("AuctionHouseBot.MinPriceBlue",
+                                        250);
+   maxPriceBlue = sConfig.GetIntDefault("AuctionHouseBot.MaxPriceBlue",
+                                        350);
+
+   if (minPriceBlue == 0)
+      minPriceBlue = 1;
+
+   if (maxPriceBlue == 0)
+      maxPriceBlue = 1;
+
+   if (minPriceBlue > maxPriceBlue)
+      minPriceBlue = maxPriceBlue;
+
+   bidPriceBlue = sConfig.GetIntDefault("AuctionHouseBot.BidPriceBlue",
+                                        100);
+   if (bidPriceBlue > 100)
+      bidPriceBlue = 100;
+
+   maxStackBlue = sConfig.GetIntDefault("AuctionHouseBot.MaxStackBlue", 0);
+
+   minPricePurple = sConfig.GetIntDefault("AuctionHouseBot.MinPricePurple",
+                                          300);
+   maxPricePurple = sConfig.GetIntDefault("AuctionHouseBot.MaxPricePurple",
+                                          450);
+
+   if (minPricePurple == 0)
+      minPricePurple = 1;
+
+   if (maxPricePurple == 0)
+      maxPricePurple = 1;
+
+   if (minPricePurple > maxPricePurple)
+      minPricePurple = maxPricePurple;
+
+   bidPricePurple = sConfig.GetIntDefault("AuctionHouseBot.BidPricePurple",
+                                          100);
+   if (bidPricePurple > 100)
+      bidPricePurple = 100;
+
+   maxStackPurple = sConfig.GetIntDefault("AuctionHouseBot.MaxStackPurple", 0);
+
+   QueryResult* results = (QueryResult*) NULL;
+
+#ifdef NO_VENDOR_ITEMS
+   vector<uint32> npcItems;
+
+   char npcQuery[] = "SELECT `item` FROM `npc_vendor`";
+
+   results = WorldDatabase.PQuery(npcQuery);
+   if (results != NULL)
+   {
+      do
+      {
+         Field* fields = results->Fetch();
+         npcItems.push_back(fields[0].GetUInt32());
+
+      } while (results->NextRow());
+
+      delete results;
+   }
+   else
+   {
+      sLog.outString("AuctionHouseBot: \"%s\" failed", npcQuery);
+   }
+#endif
+
+#ifdef ONLY_LOOT_ITEMS
+   vector<uint32> lootItems;
+
+   char lootQuery[] = "SELECT `item` FROM `creature_loot_template` UNION "
+                      "SELECT `item` FROM `disenchant_loot_template` UNION "
+                      "SELECT `item` FROM `fishing_loot_template` UNION "
+                      "SELECT `item` FROM `gameobject_loot_template` UNION "
+                      "SELECT `item` FROM `item_loot_template` UNION "
+                      "SELECT `item` FROM `pickpocketing_loot_template` UNION "
+                      "SELECT `item` FROM `prospecting_loot_template` UNION "
+                      "SELECT `item` FROM `skinning_loot_template`";
+
+   results = WorldDatabase.PQuery(lootQuery);
+   if (results != NULL)
+   {
+      do
+      {
+         Field* fields = results->Fetch();
+         lootItems.push_back(fields[0].GetUInt32());
+   
+      } while (results->NextRow());
+   
+      delete results;
+   }
+   else
+   {
+      sLog.outString("AuctionHouseBot: \"%s\" failed", lootQuery);
+   }
+#endif
+
+   for (uint32 itemID = 0; itemID < sItemStorage.MaxEntry; itemID++)
+   {
+      ItemPrototype const* prototype = objmgr.GetItemPrototype(itemID);
+
+      if (prototype == NULL)
+         continue;
+
+      if ((prototype->Bonding != NO_BIND) &&
+          (prototype->Bonding != BIND_WHEN_EQUIPED))
+      {
+         continue;
+      }
+
+      if (prototype->BuyPrice == 0)
+         continue;
+         
+      if ((prototype->Quality < 1) || (prototype->Quality > 4))
+         continue;
+
+#ifdef NO_VENDOR_ITEMS
+      bool isVendorItem = false;
+
+      for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorItem); i++)
+      {         
+         if (itemID == npcItems[i])
+            isVendorItem = true;
+      }
+
+      if (isVendorItem)
+         continue;
+#endif
+
+#ifdef ONLY_LOOT_ITEMS
+      bool isLootItem = false;
+
+      for (unsigned int i = 0; (i < lootItems.size()) && (!isLootItem); i++)
+      {         
+         if (itemID == lootItems[i])
+            isLootItem = true;
+      }
+      
+      if (!isLootItem)
+         continue;
+#endif
+
+      switch (prototype->Quality)
+      {
+         case 1:
+            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+               whiteTradeGoods.push_back(itemID);
+            else
+               whiteItems.push_back(itemID);
+            break;
+   
+         case 2:
+            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+               greenTradeGoods.push_back(itemID);
+            else
+               greenItems.push_back(itemID);
+            break;
+   
+         case 3:
+            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+               blueTradeGoods.push_back(itemID);
+            else
+               blueItems.push_back(itemID);
+            break;
+   
+         case 4:
+            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+               purpleTradeGoods.push_back(itemID);
+            else
+               purpleItems.push_back(itemID);
+            break;
+      }
+   }
+   
+   if ((whiteTradeGoods.size() == 0) ||
+       (greenTradeGoods.size() == 0) ||
+       (blueTradeGoods.size() == 0) ||
+       (purpleTradeGoods.size() == 0) ||
+       (whiteItems.size() == 0) ||
+       (greenItems.size() == 0) ||
+       (blueItems.size() == 0) ||
+       (purpleItems.size() == 0))
+   {
+      sLog.outString("AuctionHouseBot: not loaded DB error?");
+      AHBplayerAccount = 0;
+      AHBplayerGUID = 0;
+      return;
+   }
+  
+   sLog.outString("AuctionHouseBot:");
+   sLog.outString("loaded %d white trade goods", whiteTradeGoods.size());
+   sLog.outString("loaded %d green trade goods", greenTradeGoods.size());
+   sLog.outString("loaded %d blue trade goods", blueTradeGoods.size());
+   sLog.outString("loaded %d purple trade goods", purpleTradeGoods.size());
+   sLog.outString("loaded %d white items", whiteItems.size());
+   sLog.outString("loaded %d green items", greenItems.size());
+   sLog.outString("loaded %d blue items", blueItems.size());
+   sLog.outString("loaded %d purple items", purpleItems.size());
+   sLog.outString("AuctionHouseBot v5.8.6691 by |Paradox| (original by ChrisK)  has been loaded.");
+
+}
diff --git a/src/game/AuctionHouseBot.h b/src/game/AuctionHouseBot.h
new file mode 100644
index 0000000..04815b7
--- /dev/null
+++ b/src/game/AuctionHouseBot.h
@@ -0,0 +1,10 @@
+#ifndef AUCTION_HOUSE_BOT_H
+#define AUCTION_HOUSE_BOT_H
+
+#include "Common.h"
+
+uint32 AuctionHouseBotNoMail();
+void AuctionHouseBot();
+void AuctionHouseBotInit();
+
+#endif
diff --git a/src/game/BattleGround.cpp b/src/game/BattleGround.cpp
index dd199e2..5a1bef8 100644
--- a/src/game/BattleGround.cpp
+++ b/src/game/BattleGround.cpp
@@ -24,6 +24,7 @@
 #include "Language.h"
 #include "Chat.h"
 #include "SpellAuras.h"
+#include "ArenaTeam.h"
 #include "World.h"
 #include "Util.h"
 
@@ -47,6 +48,8 @@ BattleGround::BattleGround()
     m_Name              = "";
     m_LevelMin          = 0;
     m_LevelMax          = 0;
+    m_InBGFreeSlotQueue = false;
+    m_SetDeleteThis     = false;
 
     m_MaxPlayersPerTeam = 0;
     m_MaxPlayers        = 0;
@@ -67,21 +70,54 @@ BattleGround::BattleGround()
     m_TeamStartLocO[BG_TEAM_ALLIANCE]   = 0;
     m_TeamStartLocO[BG_TEAM_HORDE]      = 0;
 
+    m_ArenaTeamIds[BG_TEAM_ALLIANCE]   = 0;
+    m_ArenaTeamIds[BG_TEAM_HORDE]      = 0;
+
+    m_ArenaTeamRatingChanges[BG_TEAM_ALLIANCE]   = 0;
+    m_ArenaTeamRatingChanges[BG_TEAM_HORDE]      = 0;
+
     m_BgRaids[BG_TEAM_ALLIANCE]         = NULL;
     m_BgRaids[BG_TEAM_HORDE]            = NULL;
 
     m_PlayersCount[BG_TEAM_ALLIANCE]    = 0;
     m_PlayersCount[BG_TEAM_HORDE]       = 0;
+
+    m_PrematureCountDown = false;
+    m_PrematureCountDown = 0;
 }
 
 BattleGround::~BattleGround()
 {
+    // remove objects and creatures
+    // (this is done automatically in mapmanager update, when the instance is reset after the reset time)    
+    int size = m_BgCreatures.size();
+    for(int i = 0; i < size; ++i)
+    {
+        DelCreature(i);
+    }
+    size = m_BgObjects.size();
+    for(int i = 0; i < size; ++i)
+    {
+        DelObject(i);
+    }
 
+    // delete creature and go respawn times
+    WorldDatabase.PExecute("DELETE FROM creature_respawn WHERE instance = '%u'",GetInstanceID());
+    WorldDatabase.PExecute("DELETE FROM gameobject_respawn WHERE instance = '%u'",GetInstanceID());
+    // delete instance from db
+    CharacterDatabase.PExecute("DELETE FROM instance WHERE id = '%u'",GetInstanceID());
+    // remove from battlegrounds
+    sBattleGroundMgr.RemoveBattleGround(GetInstanceID());
+    // unload map
+    if(Map * map = MapManager::Instance().FindMap(GetMapId(), GetInstanceID()))
+        if(map->IsBattleGroundOrArena())
+            ((BattleGroundMap*)map)->SetUnload();
+    // remove from bg free slot queue
+    this->RemoveFromBGFreeSlotQueue();
 }
 
 void BattleGround::Update(time_t diff)
 {
-
     if(!GetPlayersSize() && !GetRemovedPlayersSize() && !GetReviveQueueSize())
         //BG is empty
         return;
@@ -182,12 +218,56 @@ void BattleGround::Update(time_t diff)
             if(!plr)
                 continue;
             plr->ResurrectPlayer(1.0f);
+
+            //restore player's pet
+            if(plr->GetLastPetNumber() && plr->isAlive())
+            {
+                Pet* NewPet = new Pet();
+
+				if(!NewPet->LoadPetFromDB(plr, 0, plr->GetLastPetNumber(), true))
+                    delete NewPet;
+				//restore pet's Health and Mana
+				else
+				{	
+					NewPet->SetHealth(NewPet->GetMaxHealth());
+					NewPet->SetPower(POWER_MANA,NewPet->GetMaxPower(POWER_MANA));
+                    NewPet->SetPower(POWER_HAPPINESS ,NewPet->GetMaxPower(POWER_HAPPINESS));
+				}
+            }
+
             plr->CastSpell(plr, SPELL_SPIRIT_HEAL_MANA, true);
             ObjectAccessor::Instance().ConvertCorpseForPlayer(*itr);
         }
         m_ResurrectQueue.clear();
     }
 
+    // if less then minimum players are in on one side, then start premature finish timer
+    if(GetStatus() == STATUS_IN_PROGRESS && !isArena() && sBattleGroundMgr.GetPrematureFinishTime() && (GetPlayersCountByTeam(ALLIANCE) < GetMinPlayersPerTeam() || GetPlayersCountByTeam(HORDE) < GetMinPlayersPerTeam()))
+    {
+        if(!m_PrematureCountDown)
+        {
+            m_PrematureCountDown = true;
+            m_PrematureCountDownTimer = sBattleGroundMgr.GetPrematureFinishTime();
+            SendMessageToAll(LANG_BATTLEGROUND_PREMATURE_FINISH_WARNING);
+        }
+        else if(m_PrematureCountDownTimer < diff)
+        {
+            // time's up!
+            EndBattleGround(0); // noone wins
+            m_PrematureCountDown = false;
+        } 
+        else 
+        {
+            uint32 newtime = m_PrematureCountDownTimer - diff;
+            // announce every minute
+            if(m_PrematureCountDownTimer != sBattleGroundMgr.GetPrematureFinishTime() && newtime / 60000 != m_PrematureCountDownTimer / 60000)
+                SendMessageToAll(LANG_BATTLEGROUND_PREMATURE_FINISH_WARNING);
+            m_PrematureCountDownTimer = newtime;
+        }
+    }
+    else if (m_PrematureCountDown)
+        m_PrematureCountDown = false;
+
     if(GetStatus() == STATUS_WAIT_LEAVE)
     {
         // remove all players from battleground after 2 minutes
@@ -239,7 +319,10 @@ void BattleGround::SendPacketToTeam(uint32 TeamID, WorldPacket *packet, Player *
         if(!self && sender == plr)
             continue;
 
-        if(plr->GetTeam() == TeamID)
+        uint32 team = itr->second.Team;//GetPlayerTeam(plr->GetGUID());
+        if(!team) team = plr->GetTeam();
+
+        if(team == TeamID)
             plr->GetSession()->SendPacket(packet);
     }
 }
@@ -265,7 +348,10 @@ void BattleGround::PlaySoundToTeam(uint32 SoundID, uint32 TeamID)
             continue;
         }
 
-        if(plr->GetTeam() == TeamID)
+        uint32 team = itr->second.Team;//GetPlayerTeam(plr->GetGUID());
+        if(!team) team = plr->GetTeam();
+
+        if(team == TeamID)
         {
             sBattleGroundMgr.BuildPlaySoundPacket(&data, SoundID);
             plr->GetSession()->SendPacket(&data);
@@ -285,11 +371,31 @@ void BattleGround::CastSpellOnTeam(uint32 SpellID, uint32 TeamID)
             continue;
         }
 
-        if(plr->GetTeam() == TeamID)
+        uint32 team = itr->second.Team;//GetPlayerTeam(plr->GetGUID());
+        if(!team) team = plr->GetTeam();
+       
+        if(team == TeamID)
             plr->CastSpell(plr, SpellID, true);
     }
 }
 
+void BattleGround::YellToAll(Creature* creature, const char* text, uint32 language)
+{
+    for(std::map<uint64, BattleGroundPlayer>::iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
+    {
+        WorldPacket data(SMSG_MESSAGECHAT, 200);
+        Player *plr = objmgr.GetPlayer(itr->first);
+        if(!plr)
+        {
+            sLog.outError("BattleGround: Player " I64FMTD " not found!", itr->first);
+            continue;
+        }
+        creature->BuildMonsterChat(&data,CHAT_MSG_MONSTER_YELL,text,language,creature->GetName(),itr->first);
+        plr->GetSession()->SendPacket(&data);
+    }
+}
+
+
 void BattleGround::RewardHonorToTeam(uint32 Honor, uint32 TeamID)
 {
     for(std::map<uint64, BattleGroundPlayer>::iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
@@ -302,7 +408,10 @@ void BattleGround::RewardHonorToTeam(uint32 Honor, uint32 TeamID)
             continue;
         }
 
-        if(plr->GetTeam() == TeamID)
+        uint32 team = itr->second.Team;//GetPlayerTeam(plr->GetGUID());
+        if(!team) team = plr->GetTeam();
+
+        if(team == TeamID)
             UpdatePlayerScore(plr, SCORE_BONUS_HONOR, Honor);
     }
 }
@@ -324,7 +433,10 @@ void BattleGround::RewardReputationToTeam(uint32 faction_id, uint32 Reputation,
             continue;
         }
 
-        if(plr->GetTeam() == TeamID)
+        uint32 team = itr->second.Team;//GetPlayerTeam(plr->GetGUID());
+        if(!team) team = plr->GetTeam();
+
+        if(team == TeamID)
             plr->ModifyFactionReputation(factionEntry, Reputation);
     }
 }
@@ -345,30 +457,86 @@ void BattleGround::UpdateWorldStateForPlayer(uint32 Field, uint32 Value, Player
 
 void BattleGround::EndBattleGround(uint32 winner)
 {
+    this->RemoveFromBGFreeSlotQueue();
+
+    ArenaTeam * winner_arena_team = NULL;
+    ArenaTeam * loser_arena_team = NULL;
+    uint32 loser_rating = 0;
+    uint32 winner_rating = 0;
     WorldPacket data;
     Player *Source = NULL;
     const char *winmsg = "";
 
     if(winner == ALLIANCE)
     {
-        winmsg = GetMangosString(LANG_BG_A_WINS);
+        if(isBattleGround())
+            winmsg = GetMangosString(LANG_BG_A_WINS);
+        else
+            winmsg = GetMangosString(LANG_ARENA_GOLD_WINS);
 
         PlaySoundToAll(SOUND_ALLIANCE_WINS);                // alliance wins sound
 
         SetWinner(WINNER_ALLIANCE);
     }
-    else
+    else if(winner == HORDE)
     {
-        winmsg = GetMangosString(LANG_BG_H_WINS);
+        if(isBattleGround())
+            winmsg = GetMangosString(LANG_BG_H_WINS);
+        else
+            winmsg = GetMangosString(LANG_ARENA_GREEN_WINS);
 
         PlaySoundToAll(SOUND_HORDE_WINS);                   // horde wins sound
 
         SetWinner(WINNER_HORDE);
     }
+    else
+    {
+        SetWinner(3);
+    }
 
     SetStatus(STATUS_WAIT_LEAVE);
     m_EndTime = 0;
 
+    // arena rating calculation
+    if(isArena() && isRated())
+    {
+        if(winner == ALLIANCE)
+        {
+            winner_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(ALLIANCE));
+            loser_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(HORDE));
+        }
+        else if(winner == HORDE)
+        {
+            winner_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(HORDE));
+            loser_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(ALLIANCE));
+        }
+        if(winner_arena_team && loser_arena_team)
+        {
+            loser_rating = loser_arena_team->GetStats().rating;
+            winner_rating = winner_arena_team->GetStats().rating;
+            float winner_chance = winner_arena_team->GetChanceAgainst(loser_rating);
+            float loser_chance = loser_arena_team->GetChanceAgainst(winner_rating);
+            int32 winner_change = winner_arena_team->WonAgainstChance(winner_chance);
+            int32 loser_change = loser_arena_team->LostAgainstChance(loser_chance);
+            sLog.outDebug("--- %u ; %u ; %d ; %d ; %u ; %u ---",winner_rating,loser_rating,winner_chance,loser_chance,winner_change,loser_change);
+            if(winner == ALLIANCE)
+            {
+                SetArenaTeamRatingChangeForTeam(ALLIANCE, winner_change);
+                SetArenaTeamRatingChangeForTeam(HORDE, loser_change);
+            }
+            else
+            {
+                SetArenaTeamRatingChangeForTeam(HORDE, winner_change);
+                SetArenaTeamRatingChangeForTeam(ALLIANCE, loser_change);
+            }
+        }
+        else
+        {
+            SetArenaTeamRatingChangeForTeam(ALLIANCE, 0);
+            SetArenaTeamRatingChangeForTeam(HORDE, 0);
+        }
+    }
+
     for(std::map<uint64, BattleGroundPlayer>::iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
     {
         Player *plr = objmgr.GetPlayer(itr->first);
@@ -378,13 +546,29 @@ void BattleGround::EndBattleGround(uint32 winner)
             continue;
         }
 
+        // should remove spirit of redemption
+        if(plr->HasAuraType(SPELL_AURA_SPIRIT_OF_REDEMPTION))
+            plr->RemoveSpellsCausingAura(SPELL_AURA_MOD_SHAPESHIFT);
+
         if(!plr->isAlive())
         {
             plr->ResurrectPlayer(1.0f);
             plr->SpawnCorpseBones();
         }
 
-        if(plr->GetTeam() == winner)
+        uint32 team = itr->second.Team;//GetPlayerTeam(plr->GetGUID());
+        if(!team) team = plr->GetTeam();
+
+        // per player calculation
+        if(isArena() && isRated() && winner_arena_team && loser_arena_team)
+        {
+            if(team == winner)
+                winner_arena_team->MemberWon(plr,loser_rating);
+            else
+                loser_arena_team->MemberLost(plr,winner_rating);
+        }
+
+        if(team == winner)
         {
             if(!Source)
                 Source = plr;
@@ -404,10 +588,28 @@ void BattleGround::EndBattleGround(uint32 winner)
         sBattleGroundMgr.BuildPvpLogDataPacket(&data, this);
         plr->GetSession()->SendPacket(&data);
 
-        sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, this, plr->GetTeam(), plr->GetBattleGroundQueueIndex(m_TypeID), STATUS_IN_PROGRESS, TIME_TO_AUTOREMOVE, GetStartTime());
+        uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(GetTypeID(), GetArenaType());
+        sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, this, plr->GetTeam(), plr->GetBattleGroundQueueIndex(bgQueueTypeId), STATUS_IN_PROGRESS, TIME_TO_AUTOREMOVE, GetStartTime());
         plr->GetSession()->SendPacket(&data);
     }
 
+    if(isArena() && isRated() && winner_arena_team && loser_arena_team)
+    {
+        // update arena points only after increasing the player's match count!
+        winner_arena_team->UpdateArenaPointsHelper();
+        loser_arena_team->UpdateArenaPointsHelper();
+        // save the stat changes
+        winner_arena_team->SaveToDB();
+        loser_arena_team->SaveToDB();
+        // send updated arena team stats to players
+        // this way all arena team members will get notified, not only the ones who participated in this match
+        winner_arena_team->NotifyStatsChanged();
+        loser_arena_team->NotifyStatsChanged();
+    }
+
+    // inform invited players about the removal
+    sBattleGroundMgr.m_BattleGroundQueues[sBattleGroundMgr.BGQueueTypeId(GetTypeID(), GetArenaType())].BGEndedRemoveInvites(this);
+
     if(Source)
     {
         ChatHandler(Source).FillMessageData(&data, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, Source->GetGUID(), winmsg);
@@ -558,12 +760,16 @@ void BattleGround::BlockMovement(Player *plr)
 
 void BattleGround::RemovePlayerAtLeave(uint64 guid, bool Transport, bool SendPacket)
 {
+    uint32 team = GetPlayerTeam(guid);
+    bool participant = false;
     // Remove from lists/maps
     std::map<uint64, BattleGroundPlayer>::iterator itr = m_Players.find(guid);
     if(itr != m_Players.end())
     {
-        UpdatePlayersCountByTeam(itr->second.Team, true);   // -1 player
+        UpdatePlayersCountByTeam(team, true);   // -1 player
         m_Players.erase(itr);
+        // check if the player was a participant of the match, or only entered through gm command (goname)
+        participant = true;
     }
 
     std::map<uint64, BattleGroundScore*>::iterator itr2 = m_PlayerScores.find(guid);
@@ -577,6 +783,10 @@ void BattleGround::RemovePlayerAtLeave(uint64 guid, bool Transport, bool SendPac
 
     Player *plr = objmgr.GetPlayer(guid);
 
+    // should remove spirit of redemption
+    if(plr && plr->HasAuraType(SPELL_AURA_SPIRIT_OF_REDEMPTION))
+        plr->RemoveSpellsCausingAura(SPELL_AURA_MOD_SHAPESHIFT);
+
     if(plr && !plr->isAlive())                              // resurrect on exit
     {
         plr->ResurrectPlayer(1.0f);
@@ -589,66 +799,106 @@ void BattleGround::RemovePlayerAtLeave(uint64 guid, bool Transport, bool SendPac
     {
         plr->ClearAfkReports();
 
-        if(isArena())
+        if(participant) // if the player was a match participant, remove auras, calc rating, update queue
         {
-            if(!sWorld.IsFFAPvPRealm())
-                plr->RemoveFlag(PLAYER_FLAGS, PLAYER_FLAGS_FFA_PVP);
-        }
+            if(!team) team = plr->GetTeam();
 
-        WorldPacket data;
-        if(SendPacket)
-        {
-            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, this, plr->GetTeam(), plr->GetBattleGroundQueueIndex(m_TypeID), STATUS_NONE, 0, 0);
-            plr->GetSession()->SendPacket(&data);
-        }
+            uint32 bgTypeId = GetTypeID();
+            uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(GetTypeID(), GetArenaType());
+            // if arena, remove the specific arena auras
+            if(isArena())
+            {
+                plr->RemoveArenaAuras(true);    // removes debuffs / dots etc., we don't want the player to die after porting out
+                bgTypeId=BATTLEGROUND_AA;       // set the bg type to all arenas (it will be used for queue refreshing)
 
-        // this call is important, because player, when joins to battleground, this method is not called, so it must be called when leaving bg
-        plr->RemoveBattleGroundQueueId(m_TypeID);
+                // summon old pet if there was one and there isn't a current pet
+                if(!plr->GetPet() && plr->GetTemporaryUnsummonedPetNumber())
+                {
+                    Pet* NewPet = new Pet;
+                    if(!NewPet->LoadPetFromDB(plr, 0, (plr)->GetTemporaryUnsummonedPetNumber(), true))
+                        delete NewPet;
 
-        DecreaseInvitedCount(plr->GetTeam());
-        //we should update battleground queue, but only if bg isn't ending
-        if (GetQueueType() < MAX_BATTLEGROUND_QUEUES)
-            sBattleGroundMgr.m_BattleGroundQueues[GetTypeID()].Update(GetTypeID(), GetQueueType());
+                    (plr)->SetTemporaryUnsummonedPetNumber(0);
+                }
 
-        if(!plr->GetBattleGroundId())
-            return;
+                if(isRated() && GetStatus() == STATUS_IN_PROGRESS)
+                {
+                    //left a rated match while the encounter was in progress, consider as loser
+                    ArenaTeam * winner_arena_team = 0;
+                    ArenaTeam * loser_arena_team = 0;
+                    if(team == HORDE)
+                    {
+                        winner_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(ALLIANCE));
+                        loser_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(HORDE));
+                    }
+                    else
+                    {
+                        winner_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(HORDE));
+                        loser_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(ALLIANCE));
+                    }
+                    if(winner_arena_team && loser_arena_team)
+                    {
+                        loser_arena_team->MemberLost(plr,winner_arena_team->GetRating());
+                    }
+                }
+            }
+
+            WorldPacket data;
+            if(SendPacket)
+            {
+                sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, this, team, plr->GetBattleGroundQueueIndex(bgQueueTypeId), STATUS_NONE, 0, 0);
+                plr->GetSession()->SendPacket(&data);
+            }
 
-        Group * group = plr->GetGroup();
+            // this call is important, because player, when joins to battleground, this method is not called, so it must be called when leaving bg
+            plr->RemoveBattleGroundQueueId(bgQueueTypeId);
 
-        // remove from raid group if exist
-        if(group && group == GetBgRaid(plr->GetTeam()))
-        {
-            if(!group->RemoveMember(guid, 0))               // group was disbanded
+            DecreaseInvitedCount(team);
+            //we should update battleground queue, but only if bg isn't ending
+            if (GetQueueType() < MAX_BATTLEGROUND_QUEUES)
+                sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].Update(bgTypeId, GetQueueType());
+
+            Group * group = plr->GetGroup();
+            // remove from raid group if exist
+            if(group && group == GetBgRaid(team))
             {
-                SetBgRaid(plr->GetTeam(), NULL);
-                delete group;
+                if(!group->RemoveMember(guid, 0))               // group was disbanded
+                {
+                    SetBgRaid(team, NULL);
+                    delete group;
+                }
             }
+
+            // Let others know
+            sBattleGroundMgr.BuildPlayerLeftBattleGroundPacket(&data, plr);
+            SendPacketToTeam(team, &data, plr, false);
         }
 
         // Do next only if found in battleground
         plr->SetBattleGroundId(0);                          // We're not in BG.
-
-        // Let others know
-        sBattleGroundMgr.BuildPlayerLeftBattleGroundPacket(&data, plr);
-        SendPacketToTeam(plr->GetTeam(), &data, plr, false);
+        // reset destination bg team
+        plr->SetBGTeam(0);
 
         if(Transport)
         {
             plr->TeleportTo(plr->GetBattleGroundEntryPointMap(), plr->GetBattleGroundEntryPointX(), plr->GetBattleGroundEntryPointY(), plr->GetBattleGroundEntryPointZ(), plr->GetBattleGroundEntryPointO());
-            //sLog.outDetail("BATTLEGROUND: Sending %s to %f,%f,%f,%f", pl->GetName(), x,y,z,O);
         }
 
         // Log
         sLog.outDetail("BATTLEGROUND: Removed player %s from BattleGround.", plr->GetName());
     }
 
-    /// there will be code which will add battleground to BGFreeSlotQueue , when battleground instance will exist
-    // we always should check if BG is in that queue before adding..
-
-    if(!GetPlayersSize())
+    if(!GetPlayersSize() && !GetInvitedCount(HORDE) && !GetInvitedCount(ALLIANCE))
     {
-        Reset();
+        // if no players left AND no invitees left, set this bg to delete in next update
+        // direct deletion could cause crashes
+        m_SetDeleteThis = true;
+        // return to prevent addition to freeslotqueue
+        return;
     }
+
+    // a player exited the battleground, so there are free slots. add to queue
+    this->AddToBGFreeSlotQueue();
 }
 
 // this method is called when no players remains in battleground
@@ -660,6 +910,8 @@ void BattleGround::Reset()
     SetStartTime(0);
     SetEndTime(0);
     SetLastResurrectTime(0);
+    SetArenaType(0);
+    SetRated(false);
 
     m_Events = 0;
 
@@ -668,11 +920,12 @@ void BattleGround::Reset()
 
     m_InvitedAlliance = 0;
     m_InvitedHorde = 0;
+    m_InBGFreeSlotQueue = false;
 
     m_Players.clear();
     m_PlayerScores.clear();
 
-    // reset BGSubclass
+    // reset BGSubclass (this cleans up creatures and gos as well)
     this->ResetBGSubclass();
 }
 
@@ -704,10 +957,11 @@ void BattleGround::AddPlayer(Player *plr)
     sBattleGroundMgr.BuildPlayerJoinedBattleGroundPacket(&data, plr);
     SendPacketToTeam(team, &data, plr, false);
 
+    // add arena specific auras
     if(isArena())
     {
         plr->RemoveArenaSpellCooldowns();
-        //plr->RemoveArenaAuras();
+        plr->RemoveArenaAuras();
         plr->RemoveAllEnchantments(TEMP_ENCHANTMENT_SLOT);
         if(team == ALLIANCE && plr->GetTeam() == ALLIANCE)
             plr->CastSpell(plr,SPELL_ALLIANCE_GOLD_FLAG,true);
@@ -719,6 +973,19 @@ void BattleGround::AddPlayer(Player *plr)
             plr->CastSpell(plr,SPELL_HORDE_GREEN_FLAG,true);
         plr->DestroyConjuredItems(true);
 
+        Pet* pet = plr->GetPet();
+        if(pet)
+        {
+            if(pet->getPetType() == SUMMON_PET || pet->getPetType() == HUNTER_PET)
+            {
+                (plr)->SetTemporaryUnsummonedPetNumber(pet->GetCharmInfo()->GetPetNumber());
+                (plr)->SetOldPetSpell(pet->GetUInt32Value(UNIT_CREATED_BY_SPELL));
+            }
+            (plr)->RemovePet(NULL,PET_SAVE_NOT_IN_SLOT);
+        }
+    else
+            (plr)->SetTemporaryUnsummonedPetNumber(0);
+
         if(GetStatus() == STATUS_WAIT_JOIN)                 // not started yet
         {
             plr->CastSpell(plr, SPELL_ARENA_PREPARATION, true);
@@ -733,9 +1000,6 @@ void BattleGround::AddPlayer(Player *plr)
             plr->CastSpell(plr, SPELL_PREPARATION, true);   // reduces all mana cost of spells.
     }
 
-    if(isArena())
-        plr->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_FFA_PVP);
-
     // Log
     sLog.outDetail("BATTLEGROUND: Player %s joined the battle.", plr->GetName());
 }
@@ -743,13 +1007,20 @@ void BattleGround::AddPlayer(Player *plr)
 /* This method should be called only once ... it adds pointer to queue */
 void BattleGround::AddToBGFreeSlotQueue()
 {
-    sBattleGroundMgr.BGFreeSlotQueue[m_TypeID].push_front(this);
+    // make sure to add only once
+    if(!m_InBGFreeSlotQueue)
+    {
+        sBattleGroundMgr.BGFreeSlotQueue[m_TypeID].push_front(this);
+        m_InBGFreeSlotQueue = true;
+    }
 }
 
 /* This method removes this battleground from free queue - it must be called when deleting battleground - not used now*/
 void BattleGround::RemoveFromBGFreeSlotQueue()
 {
-    /* uncomment this code when battlegrounds will work like instances
+    // set to be able to re-add if needed
+    m_InBGFreeSlotQueue = false;
+    // uncomment this code when battlegrounds will work like instances
     for (std::deque<BattleGround*>::iterator itr = sBattleGroundMgr.BGFreeSlotQueue[m_TypeID].begin(); itr != sBattleGroundMgr.BGFreeSlotQueue[m_TypeID].end(); ++itr)
     {
         if ((*itr)->GetInstanceID() == m_InstanceID)
@@ -757,30 +1028,66 @@ void BattleGround::RemoveFromBGFreeSlotQueue()
             sBattleGroundMgr.BGFreeSlotQueue[m_TypeID].erase(itr);
             return;
         }
-    }*/
+    }
 }
 
-/*
-this method should decide, if we can invite new player of certain team to BG, it is based on BATTLEGROUND_STATUS
-*/
-bool BattleGround::HasFreeSlotsForTeam(uint32 Team) const
+// get the number of free slots for team
+// works in similar way that HasFreeSlotsForTeam did, but this is needed for join as group
+uint32 BattleGround::GetFreeSlotsForTeam(uint32 Team) const
 {
     //if BG is starting ... invite anyone:
     if (GetStatus() == STATUS_WAIT_JOIN)
-        return GetInvitedCount(Team) < GetMaxPlayersPerTeam();
+        return (GetInvitedCount(Team) < GetMaxPlayersPerTeam()) ? GetMaxPlayersPerTeam() - GetInvitedCount(Team) : 0;
     //if BG is already started .. do not allow to join too much players of one faction
     uint32 otherTeam;
+    uint32 otherIn;
     if (Team == ALLIANCE)
+    {
         otherTeam = GetInvitedCount(HORDE);
+        otherIn = GetPlayersCountByTeam(HORDE);
+    }
     else
+    {
         otherTeam = GetInvitedCount(ALLIANCE);
+        otherIn = GetPlayersCountByTeam(ALLIANCE);
+    }
     if (GetStatus() == STATUS_IN_PROGRESS)
-        return (GetInvitedCount(Team) <= otherTeam && GetInvitedCount(Team) < GetMaxPlayersPerTeam());
+    {
+        // difference based on ppl invited (not necessarily entered battle)
+        // default: allow 0
+        uint32 diff = 0;
+        // allow join one person if the sides are equal (to fill up bg to minplayersperteam)
+        if (otherTeam == GetInvitedCount(Team)) 
+            diff = 1;
+        // allow join more ppl if the other side has more players
+        else if(otherTeam > GetInvitedCount(Team))
+            diff = otherTeam - GetInvitedCount(Team);
+
+        // difference based on max players per team (don't allow inviting more)
+        uint32 diff2 = (GetInvitedCount(Team) < GetMaxPlayersPerTeam()) ? GetMaxPlayersPerTeam() - GetInvitedCount(Team) : 0;
+
+        // difference based on players who already entered
+        // default: allow 0
+        uint32 diff3 = 0;
+        // allow join one person if the sides are equal (to fill up bg minplayersperteam)
+        if (otherIn == GetPlayersCountByTeam(Team))
+            diff3 = 1;
+        // allow join more ppl if the other side has more players
+        else if (otherIn > GetPlayersCountByTeam(Team))
+            diff3 = otherIn - GetPlayersCountByTeam(Team);
+
+        // return the minimum of the 3 differences
+
+        // min of diff and diff 2
+        diff = diff < diff2 ? diff : diff2;
+
+        // min of diff, diff2 and diff3
+        return diff < diff3 ? diff : diff3 ;
+    }
 
-    return false;
+    return 0;
 }
 
-/* this method isn't called already, it will be useful when more battlegrounds of one type will be available */
 bool BattleGround::HasFreeSlots() const
 {
     return GetPlayersSize() < GetMaxPlayers();
@@ -806,9 +1113,15 @@ void BattleGround::UpdatePlayerScore(Player *Source, uint32 type, uint32 value)
             itr->second->HonorableKills += value;
             break;
         case SCORE_BONUS_HONOR:                             // Honor bonus
-            // reward honor instantly
-            if(Source->RewardHonor(NULL, 1, value))
-                itr->second->BonusHonor += value;
+            // do not add honor in arenas
+            if(isBattleGround())
+            {
+                // reward honor instantly
+                if(Source->RewardHonor(NULL, 1, value))
+                    itr->second->BonusHonor += value;
+            }
+            else
+
             break;
             //used only in EY, but in MSG_PVP_LOG_DATA opcode
         case SCORE_DAMAGE_DONE:                             // Damage Done
@@ -864,15 +1177,26 @@ void BattleGround::RemovePlayerFromResurrectQueue(uint64 player_guid)
 
 bool BattleGround::AddObject(uint32 type, uint32 entry, float x, float y, float z, float o, float rotation0, float rotation1, float rotation2, float rotation3, uint32 respawnTime)
 {
-    GameObjectInfo const* goinfo = objmgr.GetGameObjectInfo(entry);
-    if(!goinfo)
+    Map * map = MapManager::Instance().FindMap(GetMapId(),GetInstanceID());
+    if(!map)
+        return false;
+
+    // must be created this way, adding to godatamap would add it to the base map of the instance
+    // and when loading it (in go::LoadFromDB()), a new guid would be assigned to the object, and a new object would be created
+    // so we must create it specific for this instance
+    GameObject * go = new GameObject;
+    if(!go->Create(objmgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT),entry, map,x,y,z,o,rotation0,rotation1,rotation2,rotation3,100,1))
     {
         sLog.outErrorDb("Gameobject template %u not found in database! BattleGround not created!", entry);
+        sLog.outError("Cannot create gameobject template %u! BattleGround not created!", entry);
+        delete go;
         return false;
     }
+/*
+    uint32 guid = go->GetGUIDLow();
 
-    uint32 guid = objmgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT);
-
+    // without this, UseButtonOrDoor caused the crash, since it tried to get go info from godata
+    // iirc that was changed, so adding to go data map is no longer required if that was the only function using godata from GameObject without checking if it existed
     GameObjectData& data = objmgr.NewGOData(guid);
 
     data.id             = entry;
@@ -886,13 +1210,13 @@ bool BattleGround::AddObject(uint32 type, uint32 entry, float x, float y, float
     data.rotation2      = rotation2;
     data.rotation3      = rotation3;
     data.spawntimesecs  = respawnTime;
+    data.spawnMask      = 1;
     data.animprogress   = 100;
     data.go_state       = 1;
-    data.spawnMask      = 1;
-    objmgr.AddGameobjectToGrid(guid, &data);
-
-    m_BgObjects[type] = MAKE_NEW_GUID(guid, entry, HIGHGUID_GAMEOBJECT);
-
+*/
+    // add to world, so it can be later looked up from HashMapHolder
+    go->AddToWorld();
+    m_BgObjects[type] = go->GetGUID();
     return true;
 }
 
@@ -932,8 +1256,27 @@ void BattleGround::DoorOpen(uint32 type)
     }
 }
 
+GameObject* BattleGround::GetBGObject(uint32 type)
+{
+    GameObject *obj = HashMapHolder<GameObject>::Find(m_BgObjects[type]);
+    if(!obj)
+        sLog.outError("couldn't get gameobject %i",type);
+    return obj;
+}
+
+Creature* BattleGround::GetBGCreature(uint32 type)
+{
+    Creature *creature = HashMapHolder<Creature>::Find(m_BgCreatures[type]);
+    if(!creature)
+        sLog.outError("couldn't get creature %i",type);
+    return creature;
+}
+
 void BattleGround::SpawnBGObject(uint32 type, uint32 respawntime)
 {
+    Map * map = MapManager::Instance().FindMap(GetMapId(),GetInstanceID());
+    if(!map)
+        return;
     if( respawntime == 0 )
     {
         GameObject *obj = HashMapHolder<GameObject>::Find(m_BgObjects[type]);
@@ -942,30 +1285,27 @@ void BattleGround::SpawnBGObject(uint32 type, uint32 respawntime)
             //we need to change state from GO_JUST_DEACTIVATED to GO_READY in case battleground is starting again
             if( obj->getLootState() == GO_JUST_DEACTIVATED )
                 obj->SetLootState(GO_READY);
-            obj->Respawn();
+            obj->SetRespawnTime(0);
+            map->Add(obj);
         }
-        else
-            objmgr.SaveGORespawnTime(GUID_LOPART(m_BgObjects[type]), 0, 0);
     }
     else
     {
         GameObject *obj = HashMapHolder<GameObject>::Find(m_BgObjects[type]);
         if(obj)
         {
+            map->Add(obj);
             obj->SetRespawnTime(respawntime);
             obj->SetLootState(GO_JUST_DEACTIVATED);
         }
-        else
-            objmgr.SaveGORespawnTime(GUID_LOPART(m_BgObjects[type]), 0, time(NULL) + respawntime);
     }
 }
 
-Creature* BattleGround::AddCreature(uint32 entry, uint32 type, uint32 teamval, float x, float y, float z, float o)
+Creature* BattleGround::AddCreature(uint32 entry, uint32 type, uint32 teamval, float x, float y, float z, float o, uint32 respawntime)
 {
-    // note: this should normally be FindMap
-    // but it's a hack to allow the battlegrounds to initialize at server startup
-    Map * map = MapManager::Instance().GetMap(GetMapId(), 0);
-    if(!map) return NULL;
+    Map * map = MapManager::Instance().FindMap(GetMapId(),GetInstanceID());
+    if(!map)
+        return NULL;
 
     Creature* pCreature = new Creature;
     if (!pCreature->Create(objmgr.GenerateLowGuid(HIGHGUID_UNIT), map, entry, teamval))
@@ -989,9 +1329,39 @@ Creature* BattleGround::AddCreature(uint32 entry, uint32 type, uint32 teamval, f
 
     map->Add(pCreature);
     m_BgCreatures[type] = pCreature->GetGUID();
+
     return  pCreature;
 }
+/*
+void BattleGround::SpawnBGCreature(uint32 type, uint32 respawntime)
+{
+    Map * map = MapManager::Instance().FindMap(GetMapId(),GetInstanceId());
+    if(!map)
+        return false;
 
+    if(respawntime == 0)
+    {
+        Creature *obj = HashMapHolder<Creature>::Find(m_BgCreatures[type]);
+        if(obj)
+        {
+            //obj->Respawn();                               // bugged
+            obj->SetRespawnTime(0);
+            objmgr.SaveCreatureRespawnTime(obj->GetGUIDLow(), GetInstanceID(), 0);
+            map->Add(obj);
+        }
+    }
+    else
+    {
+        Creature *obj = HashMapHolder<Creature>::Find(m_BgCreatures[type]);
+        if(obj)
+        {
+            obj->setDeathState(DEAD);
+            obj->SetRespawnTime(respawntime);
+            map->Add(obj);
+        }
+    }
+}
+*/
 bool BattleGround::DelCreature(uint32 type)
 {
     Creature *cr = HashMapHolder<Creature>::Find(m_BgCreatures[type]);
@@ -1072,8 +1442,11 @@ void BattleGround::SendMessageToAll(int32 entry)
 
 void BattleGround::EndNow()
 {
+    RemoveFromBGFreeSlotQueue();
     SetStatus(STATUS_WAIT_LEAVE);
     SetEndTime(TIME_TO_AUTOREMOVE);
+    // inform invited players about the removal
+    sBattleGroundMgr.m_BattleGroundQueues[sBattleGroundMgr.BGQueueTypeId(GetTypeID(), GetArenaType())].BGEndedRemoveInvites(this);
 }
 
 // Battleground messages are localized using the dbc lang, they are not client language dependent
@@ -1151,3 +1524,44 @@ void BattleGround::HandleKillPlayer( Player *player, Player *killer )
     // to be able to remove insignia
     player->SetFlag( UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE );
 }
+
+// return the player's team based on battlegroundplayer info
+// used in same faction arena matches mainly
+uint32 BattleGround::GetPlayerTeam(uint64 guid)
+{
+    std::map<uint64, BattleGroundPlayer>::const_iterator itr = m_Players.find(guid);
+    if(itr!=m_Players.end())
+        return itr->second.Team;
+    return 0;
+}
+
+uint32 BattleGround::GetAlivePlayersCountByTeam(uint32 Team) const
+{
+    int count = 0;
+    for(std::map<uint64, BattleGroundPlayer>::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
+    {
+        if(itr->second.Team == Team)
+        {
+            Player * pl = objmgr.GetPlayer(itr->first);
+            if(pl && pl->isAlive())
+                ++count;
+        }
+    }
+    return count;
+}
+
+int32 BattleGround::GetObjectType(uint64 guid)
+{
+    for(uint32 i = 0;i <= m_BgObjects.size(); i++)
+        if(m_BgObjects[i] == guid)
+            return i;
+    sLog.outError("BattleGround: cheating? a player used a gameobject which isnt supposed to be a usable object!");
+    return -1;
+}
+
+void BattleGround::HandleKillUnit(Creature *creature, Player *killer)
+{
+}
+
+    
+
diff --git a/src/game/BattleGround.h b/src/game/BattleGround.h
index 9e41e66..ed2dd2b 100644
--- a/src/game/BattleGround.h
+++ b/src/game/BattleGround.h
@@ -143,6 +143,18 @@ enum BattleGroundTypeId
     BATTLEGROUND_RL     = 8
 };
 
+// handle the queue types and bg types separately to enable joining queue for different sized arenas at the same time
+enum BattleGroundQueueTypeId
+{
+    BATTLEGROUND_QUEUE_AV     = 1,
+    BATTLEGROUND_QUEUE_WS     = 2,
+    BATTLEGROUND_QUEUE_AB     = 3,
+    BATTLEGROUND_QUEUE_EY     = 4,
+    BATTLEGROUND_QUEUE_2v2     = 5,
+    BATTLEGROUND_QUEUE_3v3     = 6,
+    BATTLEGROUND_QUEUE_5v5     = 7,
+};
+
 enum ScoreType
 {
     SCORE_KILLING_BLOWS         = 1,
@@ -195,6 +207,20 @@ enum BattleGroundTeamId
     BG_TEAM_HORDE           = 1
 };
 
+enum BattleGroundJoinError
+{
+    BG_JOIN_ERR_OK = 0,
+    BG_JOIN_ERR_OFFLINE_MEMBER = 1,
+    BG_JOIN_ERR_GROUP_TOO_MANY = 2,
+    BG_JOIN_ERR_MIXED_FACTION = 3,
+    BG_JOIN_ERR_MIXED_LEVELS = 4,
+    BG_JOIN_ERR_MIXED_ARENATEAM = 5,
+    BG_JOIN_ERR_GROUP_MEMBER_ALREADY_IN_QUEUE = 6,
+    BG_JOIN_ERR_GROUP_DESERTER = 7,
+    BG_JOIN_ERR_ALL_QUEUES_USED = 8,
+    BG_JOIN_ERR_GROUP_NOT_ENOUGH = 9
+};
+
 class BattleGroundScore
 {
     public:
@@ -224,6 +250,7 @@ class BattleGround
     public:
         /* Construction */
         BattleGround();
+        /*BattleGround(const BattleGround& bg);*/
         virtual ~BattleGround();
         virtual void Update(time_t diff);                   // must be implemented in BG subclass of BG specific update code, but must in begginning call parent version
         virtual bool SetupBattleGround()                    // must be implemented in BG subclass
@@ -296,6 +323,7 @@ class BattleGround
         }
         bool HasFreeSlotsForTeam(uint32 Team) const;
         bool HasFreeSlots() const;
+        uint32 GetFreeSlotsForTeam(uint32 Team) const;
 
         bool isArena() const        { return m_IsArena; }
         bool isBattleGround() const { return !m_IsArena; }
@@ -317,6 +345,8 @@ class BattleGround
 
         void StartBattleGround();
 
+        GameObject* GetBGObject(uint32 type);
+        Creature* GetBGCreature(uint32 type);
         /* Location */
         void SetMapId(uint32 MapID) { m_MapId = MapID; }
         uint32 GetMapId() const { return m_MapId; }
@@ -336,6 +366,7 @@ class BattleGround
         virtual void FillInitialWorldStates(WorldPacket& /*data*/) {}
         void SendPacketToTeam(uint32 TeamID, WorldPacket *packet, Player *sender = NULL, bool self = true);
         void SendPacketToAll(WorldPacket *packet);
+        void YellToAll(Creature* creature, const char* text, uint32 language);
         void PlaySoundToTeam(uint32 SoundID, uint32 TeamID);
         void PlaySoundToAll(uint32 SoundID);
         void CastSpellOnTeam(uint32 SpellID, uint32 TeamID);
@@ -366,6 +397,7 @@ class BattleGround
 
         uint8 GetTeamIndexByTeamId(uint32 Team) const { return Team == ALLIANCE ? BG_TEAM_ALLIANCE : BG_TEAM_HORDE; }
         uint32 GetPlayersCountByTeam(uint32 Team) const { return m_PlayersCount[GetTeamIndexByTeamId(Team)]; }
+        uint32 GetAlivePlayersCountByTeam(uint32 Team) const;   // used in arenas to correctly handle death in spirit of redemption / last stand etc. (killer = killed) cases
         void UpdatePlayersCountByTeam(uint32 Team, bool remove)
         {
             if(remove)
@@ -374,11 +406,18 @@ class BattleGround
                 ++m_PlayersCount[GetTeamIndexByTeamId(Team)];
         }
 
+        // used for rated arena battles
+        void SetArenaTeamIdForTeam(uint32 Team, uint32 ArenaTeamId) { m_ArenaTeamIds[GetTeamIndexByTeamId(Team)] = ArenaTeamId; }
+        uint32 GetArenaTeamIdForTeam(uint32 Team) const { return m_ArenaTeamIds[GetTeamIndexByTeamId(Team)]; }
+        void SetArenaTeamRatingChangeForTeam(uint32 Team, int32 RatingChange) { m_ArenaTeamRatingChanges[GetTeamIndexByTeamId(Team)] = RatingChange; }
+        int32 GetArenaTeamRatingChangeForTeam(uint32 Team) const { return m_ArenaTeamRatingChanges[GetTeamIndexByTeamId(Team)]; }
+
         /* Triggers handle */
         // must be implemented in BG subclass
         virtual void HandleAreaTrigger(Player* /*Source*/, uint32 /*Trigger*/) {}
         // must be implemented in BG subclass if need AND call base class generic code
         virtual void HandleKillPlayer(Player *player, Player *killer);
+        virtual void HandleKillUnit(Creature* /*unit*/, Player* /*killer*/);
 
         /* Battleground events */
         /* these functions will return true event is possible, but false if player is bugger */
@@ -390,6 +429,7 @@ class BattleGround
         virtual WorldSafeLocsEntry const* GetClosestGraveYard(float /*x*/, float /*y*/, float /*z*/, uint32 /*team*/)  { return NULL; }
 
         virtual void AddPlayer(Player *plr);                // must be implemented in BG subclass
+
         virtual void RemovePlayerAtLeave(uint64 guid, bool Transport, bool SendPacket);
                                                             // can be extended in in BG subclass
 
@@ -402,15 +442,24 @@ class BattleGround
         BGCreatures m_BgCreatures;
         void SpawnBGObject(uint32 type, uint32 respawntime);
         bool AddObject(uint32 type, uint32 entry, float x, float y, float z, float o, float rotation0, float rotation1, float rotation2, float rotation3, uint32 respawnTime = 0);
-        Creature* AddCreature(uint32 entry, uint32 type, uint32 teamval, float x, float y, float z, float o);
+//        void SpawnBGCreature(uint32 type, uint32 respawntime);
+        Creature* AddCreature(uint32 entry, uint32 type, uint32 teamval, float x, float y, float z, float o, uint32 respawntime = 0);
         bool DelCreature(uint32 type);
         bool DelObject(uint32 type);
         bool AddSpiritGuide(uint32 type, float x, float y, float z, float o, uint32 team);
+        int32 GetObjectType(uint64 guid);
 
         void DoorOpen(uint32 type);
         void DoorClose(uint32 type);
         const char *GetMangosString(int32 entry);
 
+        virtual bool HandlePlayerUnderMap(Player * plr) {return false;}
+
+        // since arenas can be AvA or Hvh, we have to get the "temporary" team of a player
+        uint32 GetPlayerTeam(uint64 guid);
+
+        void SetDeleteThis() {m_SetDeleteThis = true;}
+
     protected:
         //this method is called, when BG cannot spawn its own spirit guide, or something is wrong, It correctly ends BattleGround
         void EndNow();
@@ -443,6 +492,8 @@ class BattleGround
         uint32 m_LastResurrectTime;
         uint32 m_Queue_type;
         uint8  m_ArenaType;                                 // 2=2v2, 3=3v3, 5=5v5
+        bool   m_InBGFreeSlotQueue;                         // used to make sure that BG is only once inserted into the BattleGroundMgr.BGFreeSlotQueue[bgTypeId] deque
+        bool   m_SetDeleteThis;                             // used for safe deletion of the bg after end / all players leave
         // this variable is not used .... it can be found in many other ways... but to store it in BG object instance is useless
         //uint8  m_BattleGroundType;                        // 3=BG, 4=arena
         //instead of uint8 (in previous line) is bool used
@@ -450,6 +501,8 @@ class BattleGround
         uint8  m_Winner;                                    // 0=alliance, 1=horde, 2=none
         int32  m_StartDelayTime;
         bool   m_IsRated;                                   // is this battle rated?
+        bool   m_PrematureCountDown;
+        uint32 m_PrematureCountDownTimer;
         char const *m_Name;
 
         /* Player lists */
@@ -468,6 +521,11 @@ class BattleGround
         /* Players count by team */
         uint32 m_PlayersCount[2];
 
+        /* Arena team ids by team */
+        uint32 m_ArenaTeamIds[2];
+
+        int32 m_ArenaTeamRatingChanges[2];
+
         /* Limits */
         uint32 m_LevelMin;
         uint32 m_LevelMax;
diff --git a/src/game/BattleGroundAB.cpp b/src/game/BattleGroundAB.cpp
index dcf23cc..5200a3f 100644
--- a/src/game/BattleGroundAB.cpp
+++ b/src/game/BattleGroundAB.cpp
@@ -50,6 +50,13 @@ void BattleGroundAB::Update(time_t diff)
         {
             m_Events |= 0x01;
 
+            // setup here, only when at least one player has ported to the map
+            if(!SetupBattleGround())
+            {
+                EndNow();
+                return;
+            }
+
             sLog.outDebug("Arathi Basin: entering state STATUS_WAIT_JOIN ...");
 
             // despawn banners, auras and buffs
@@ -377,6 +384,7 @@ void BattleGroundAB::_NodeOccupied(uint8 node,Team team)
 {
    if( !AddSpiritGuide(node, BG_AB_SpiritGuidePos[node][0], BG_AB_SpiritGuidePos[node][1], BG_AB_SpiritGuidePos[node][2], BG_AB_SpiritGuidePos[node][3], team) )
         sLog.outError("Failed to spawn spirit guide! point: %u, team: %u,", node, team);
+//   SpawnBGCreature(node,RESPAWN_IMMEDIATELY);
 
     uint8 capturedNodes = 0;
     for (uint8 i = 0; i < BG_AB_DYNAMIC_NODES_COUNT; ++i)
diff --git a/src/game/BattleGroundAV.cpp b/src/game/BattleGroundAV.cpp
index 9421e97..3717fdf 100644
--- a/src/game/BattleGroundAV.cpp
+++ b/src/game/BattleGroundAV.cpp
@@ -16,27 +16,424 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "Object.h"
 #include "Player.h"
 #include "BattleGround.h"
 #include "BattleGroundAV.h"
 #include "Creature.h"
+#include "Chat.h"
+#include "Object.h"
+#include "ObjectMgr.h"
+#include "ObjectAccessor.h"
 #include "MapManager.h"
 #include "Language.h"
+#include "SpellAuras.h"
 
 BattleGroundAV::BattleGroundAV()
 {
 
+    m_BgObjects.resize(BG_AV_OBJECT_MAX);
+    m_BgCreatures.resize(AV_CPLACE_MAX+AV_STATICCPLACE_MAX);
 }
 
 BattleGroundAV::~BattleGroundAV()
 {
+}
 
+const uint16 BattleGroundAV::GetBonusHonor(uint8 kills) //TODO: move this function to Battleground.cpp (needs to find a way to get m_MaxLevel)
+{
+    if(m_MaxLevel==70)
+        return 21*kills;
+    else
+        return 14*kills;
+}
+
+void BattleGroundAV::HandleKillPlayer(Player *player, Player *killer)
+{
+    if(GetStatus() != STATUS_IN_PROGRESS)
+        return;
+
+    BattleGround::HandleKillPlayer(player, killer);
+	UpdateScore(player->GetTeam(),-1);
+}
+
+void BattleGroundAV::HandleKillUnit(Creature *unit, Player *killer)
+{
+    sLog.outDebug("bg_av HandleKillUnit %i",unit->GetEntry());
+    if(GetStatus() != STATUS_IN_PROGRESS)
+        return;
+    uint32 entry = unit->GetEntry();
+    if(entry == BG_AV_CreatureInfo[AV_NPC_A_BOSS][0])
+    {
+        CastSpellOnTeam(23658,HORDE); //this is a spell which finishes a quest where a player has to kill the boss
+        RewardReputationToTeam(729,BG_AV_REP_BOSS,HORDE);
+        RewardHonorToTeam(BG_AV_HONOR_BOSS,HORDE);
+        EndBattleGround(HORDE);
+    }
+    else if ( entry == BG_AV_CreatureInfo[AV_NPC_H_BOSS][0] )
+    {
+        CastSpellOnTeam(23658,ALLIANCE); //this is a spell which finishes a quest where a player has to kill the boss
+        m_CaptainAlive[1]=false;
+        RewardReputationToTeam(730,BG_AV_REP_BOSS,ALLIANCE);
+        RewardHonorToTeam(BG_AV_HONOR_BOSS,ALLIANCE);
+        EndBattleGround(ALLIANCE);
+    }
+    else if(entry == BG_AV_CreatureInfo[AV_NPC_A_CAPTAIN][0])
+    {
+        m_CaptainAlive[0]=false;
+        RewardReputationToTeam(729,BG_AV_REP_CAPTAIN,HORDE);
+        RewardHonorToTeam(GetBonusHonor(BG_AV_KILL_CAPTAIN),HORDE);
+	    UpdateScore(ALLIANCE,(-1)*BG_AV_RES_CAPTAIN);
+        //spawn destroyed aura
+        for(uint8 i=0; i<=9; i++)
+            SpawnBGObject(BG_AV_OBJECT_BURN_BUILDING_ALLIANCE+i,RESPAWN_IMMEDIATELY);
+    }
+    else if ( entry == BG_AV_CreatureInfo[AV_NPC_H_CAPTAIN][0] )
+    {
+        RewardReputationToTeam(730,BG_AV_REP_CAPTAIN,ALLIANCE);
+        RewardHonorToTeam(GetBonusHonor(BG_AV_KILL_CAPTAIN),ALLIANCE);
+    	UpdateScore(HORDE,(-1)*BG_AV_RES_CAPTAIN);
+        //spawn destroyed aura
+        for(uint8 i=0; i<=9; i++)
+            SpawnBGObject(BG_AV_OBJECT_BURN_BUILDING_HORDE+i,RESPAWN_IMMEDIATELY);
+    }
+    else if ( entry == BG_AV_CreatureInfo[AV_NPC_N_MINE_N_4][0] || entry == BG_AV_CreatureInfo[AV_NPC_N_MINE_A_4][0] || entry == BG_AV_CreatureInfo[AV_NPC_N_MINE_H_4][0])
+        ChangeMineOwner(AV_NORTH_MINE,killer->GetTeam());
+    else if ( entry == BG_AV_CreatureInfo[AV_NPC_S_MINE_N_4][0] || entry == BG_AV_CreatureInfo[AV_NPC_S_MINE_A_4][0] || entry == BG_AV_CreatureInfo[AV_NPC_S_MINE_H_4][0])
+        ChangeMineOwner(AV_SOUTH_MINE,killer->GetTeam());
+}
+
+void BattleGroundAV::HandleQuestComplete(uint32 questid, Player *player)
+{
+    if (GetStatus() != STATUS_IN_PROGRESS)
+        return;//maybe we should log this, cause this must be a cheater or a big bug
+    uint8 team = GetTeamIndexByTeamId(player->GetTeam());
+    //TODO add reputation, events (including quest not available anymore, next quest availabe, go/npc de/spawning)and maybe honor
+    sLog.outError("BG_AV Quest %i completed",questid);
+    switch(questid)
+    {
+        case AV_QUEST_A_SCRAPS1:
+        case AV_QUEST_A_SCRAPS2:
+        case AV_QUEST_H_SCRAPS1:
+        case AV_QUEST_H_SCRAPS2:
+            m_Team_QuestStatus[team][0]+=20;
+            if(m_Team_QuestStatus[team][0] == 500 || m_Team_QuestStatus[team][0] == 1000 || m_Team_QuestStatus[team][0] == 1500) //25,50,75 turn ins
+            {
+                sLog.outDebug("BG_AV Quest %i completed starting with unit upgrading..",questid);
+                for (BG_AV_Nodes i = BG_AV_NODES_FIRSTAID_STATION; i <= BG_AV_NODES_FROSTWOLF_HUT; ++i)
+                    if (m_Nodes[i].Owner == player->GetTeam() && m_Nodes[i].State == POINT_CONTROLED)
+                    {
+                        DePopulateNode(i);
+                        PopulateNode(i);
+                            //maybe this is bad, because it will instantly respawn all creatures on every grave..
+                     }
+            }
+            break;
+        case AV_QUEST_A_COMMANDER1:
+        case AV_QUEST_H_COMMANDER1:
+            m_Team_QuestStatus[team][1]++;
+            RewardReputationToTeam(team,1,player->GetTeam());
+            if(m_Team_QuestStatus[team][1] == 30)
+                sLog.outDebug("BG_AV Quest %i completed (need to implement some events here",questid);
+            break;
+        case AV_QUEST_A_COMMANDER2:
+        case AV_QUEST_H_COMMANDER2:
+            m_Team_QuestStatus[team][2]++;
+            RewardReputationToTeam(team,1,player->GetTeam());
+            if(m_Team_QuestStatus[team][2] == 60)
+                sLog.outDebug("BG_AV Quest %i completed (need to implement some events here",questid);
+            break;
+        case AV_QUEST_A_COMMANDER3:
+        case AV_QUEST_H_COMMANDER3:
+            m_Team_QuestStatus[team][3]++;
+            RewardReputationToTeam(team,1,player->GetTeam());
+            if(m_Team_QuestStatus[team][1] == 120)
+                sLog.outDebug("BG_AV Quest %i completed (need to implement some events here",questid);
+            break;
+        case AV_QUEST_A_BOSS1:
+        case AV_QUEST_H_BOSS1:
+            m_Team_QuestStatus[team][4] += 9; //you can turn in 10 or 1 item..
+        case AV_QUEST_A_BOSS2:
+        case AV_QUEST_H_BOSS2:
+            m_Team_QuestStatus[team][4]++;
+            if(m_Team_QuestStatus[team][4] >= 200)
+                sLog.outDebug("BG_AV Quest %i completed (need to implement some events here",questid);
+            break;
+        case AV_QUEST_A_NEAR_MINE:
+        case AV_QUEST_H_NEAR_MINE:
+            m_Team_QuestStatus[team][5]++;
+            if(m_Team_QuestStatus[team][5] == 28)
+            {
+                sLog.outDebug("BG_AV Quest %i completed (need to implement some events here",questid);
+                if(m_Team_QuestStatus[team][6] == 7)
+                    sLog.outDebug("BG_AV Quest %i completed (need to implement some events here - ground assault ready",questid);
+            }
+            break;
+        case AV_QUEST_A_OTHER_MINE:
+        case AV_QUEST_H_OTHER_MINE:
+            m_Team_QuestStatus[team][6]++;
+            if(m_Team_QuestStatus[team][6] == 7)
+            {
+                sLog.outDebug("BG_AV Quest %i completed (need to implement some events here",questid);
+                if(m_Team_QuestStatus[team][5] == 20)
+                    sLog.outDebug("BG_AV Quest %i completed (need to implement some events here - ground assault ready",questid);
+            }
+            break;
+        case AV_QUEST_A_RIDER_HIDE:
+        case AV_QUEST_H_RIDER_HIDE:
+            m_Team_QuestStatus[team][7]++;
+            if(m_Team_QuestStatus[team][7] == 25)
+            {
+                sLog.outDebug("BG_AV Quest %i completed (need to implement some events here",questid);
+                if(m_Team_QuestStatus[team][8] == 25)
+                    sLog.outDebug("BG_AV Quest %i completed (need to implement some events here - rider assault ready",questid);
+            }
+            break;
+        case AV_QUEST_A_RIDER_TAME:
+        case AV_QUEST_H_RIDER_TAME:
+            m_Team_QuestStatus[team][8]++;
+            if(m_Team_QuestStatus[team][8] == 25)
+            {
+                sLog.outDebug("BG_AV Quest %i completed (need to implement some events here",questid);
+                if(m_Team_QuestStatus[team][7] == 25)
+                    sLog.outDebug("BG_AV Quest %i completed (need to implement some events here - rider assault ready",questid);
+            }
+            break;
+        default:
+            sLog.outDebug("BG_AV Quest %i completed but is not interesting at all",questid);
+            return; //was no interesting quest at all
+            break;
+    }
+}
+
+
+void BattleGroundAV::UpdateScore(uint16 team, int16 points )
+{ //note: to remove reinforcementpoints points must be negative, for adding reinforcements points must be positive
+    assert( team == ALLIANCE || team == HORDE);
+    uint8 teamindex = GetTeamIndexByTeamId(team); //0=ally 1=horde
+    m_Team_Scores[teamindex] += points;
+
+    UpdateWorldState(((teamindex==BG_TEAM_HORDE)?AV_Horde_Score:AV_Alliance_Score), m_Team_Scores[teamindex]);
+    if( points < 0)
+    {
+        if( m_Team_Scores[teamindex] < 1)
+        {
+            m_Team_Scores[teamindex]=0;
+            EndBattleGround(((teamindex==BG_TEAM_HORDE)?ALLIANCE:HORDE));
+        }
+        else if(!m_IsInformedNearVictory[teamindex] && m_Team_Scores[teamindex] < SEND_MSG_NEAR_LOSE)
+        {
+            SendMessageToAll(GetMangosString((teamindex==BG_TEAM_HORDE)?LANG_BG_AV_H_NEAR_LOSE:LANG_BG_AV_A_NEAR_LOSE));
+            PlaySoundToAll(AV_SOUND_NEAR_VICTORY);
+            m_IsInformedNearVictory[teamindex] = true;
+        }
+    }
+}
+
+
+Creature* BattleGroundAV::AddAVCreature(uint8 cinfoid, uint16 type )
+{
+    uint32 level;
+    Creature* creature = NULL;
+    assert(type <= AV_CPLACE_MAX + AV_STATICCPLACE_MAX);
+    if(type>=AV_CPLACE_MAX) //static
+    {
+        type-=(AV_CPLACE_MAX);
+        cinfoid=int(BG_AV_StaticCreaturePos[type][4]);
+
+        creature = AddCreature(BG_AV_StaticCreatureInfo[cinfoid][0],(type+AV_CPLACE_MAX),BG_AV_StaticCreatureInfo[cinfoid][1],BG_AV_StaticCreaturePos[type][0],BG_AV_StaticCreaturePos[type][1],BG_AV_StaticCreaturePos[type][2],BG_AV_StaticCreaturePos[type][3]);
+        level = ( BG_AV_StaticCreatureInfo[cinfoid][2] == BG_AV_StaticCreatureInfo[cinfoid][3] ) ? BG_AV_StaticCreatureInfo[cinfoid][2] : urand(BG_AV_StaticCreatureInfo[cinfoid][2],BG_AV_StaticCreatureInfo[cinfoid][3]);
+        CreatureData &data = objmgr.NewOrExistCreatureData(creature->GetDBTableGUIDLow());
+        data.posX = BG_AV_StaticCreaturePos[type][0]; //this is needed, else they have a wrong aggrorange
+        data.posY = BG_AV_StaticCreaturePos[type][1];
+        data.posZ = BG_AV_StaticCreaturePos[type][2];
+    }
+    else
+    {
+        creature = AddCreature(BG_AV_CreatureInfo[cinfoid][0],type,BG_AV_CreatureInfo[cinfoid][1],BG_AV_CreaturePos[type][0],BG_AV_CreaturePos[type][1],BG_AV_CreaturePos[type][2],BG_AV_CreaturePos[type][3]);
+        level = ( BG_AV_CreatureInfo[cinfoid][2] == BG_AV_CreatureInfo[cinfoid][3] ) ? BG_AV_CreatureInfo[cinfoid][2] : urand(BG_AV_CreatureInfo[cinfoid][2],BG_AV_CreatureInfo[cinfoid][3]);
+        CreatureData &data = objmgr.NewOrExistCreatureData(creature->GetDBTableGUIDLow());
+        data.posX = BG_AV_CreaturePos[type][0]; //this is needed, else they have a wrong aggrorange
+        data.posY = BG_AV_CreaturePos[type][1];
+        data.posZ = BG_AV_CreaturePos[type][2];
+    }
+    creature->LoadCreaturesAddon(true); //currently it's only for the bowman, so they have the entangling-aura.. but later it's needed for the watchdogs
+    if(level != 0)
+        level += m_MaxLevel-60; //maybe we can do this more generic for custom level-range.. actually it's blizzlike
+    creature->SetLevel(level);
+    return creature;
 }
 
 void BattleGroundAV::Update(time_t diff)
 {
     BattleGround::Update(diff);
+    if (GetStatus() == STATUS_WAIT_JOIN && GetPlayersSize())
+    {
+        ModifyStartDelayTime(diff);
+
+        if (!(m_Events & 0x01))
+        {
+            m_Events |= 0x01;
+            //comment this out if you are running with arenapatch
+            if(!SetupBattleGround())
+            {
+                EndNow();
+                return;
+            }
+
+            uint16 i;
+            sLog.outDebug("Alterac Valley: entering state STATUS_WAIT_JOIN ...");
+            // Initial Nodes
+            for(i = 0; i < BG_AV_OBJECT_MAX; i++)
+                SpawnBGObject(i, RESPAWN_ONE_DAY);
+            for(i = BG_AV_OBJECT_FLAG_A_FIRSTAID_STATION; i <= BG_AV_OBJECT_FLAG_A_STONEHEART_GRAVE ; i++){
+                SpawnBGObject(BG_AV_OBJECT_AURA_A_FIRSTAID_STATION+3*i,RESPAWN_IMMEDIATELY);
+                SpawnBGObject(i, RESPAWN_IMMEDIATELY);
+            }
+            for(i = BG_AV_OBJECT_FLAG_A_DUNBALDAR_SOUTH; i <= BG_AV_OBJECT_FLAG_A_STONEHEART_BUNKER ; i++)
+                SpawnBGObject(i, RESPAWN_IMMEDIATELY);
+            for(i = BG_AV_OBJECT_FLAG_H_ICEBLOOD_GRAVE; i <= BG_AV_OBJECT_FLAG_H_FROSTWOLF_WTOWER ; i++){
+                SpawnBGObject(i, RESPAWN_IMMEDIATELY);
+                if(i<=BG_AV_OBJECT_FLAG_H_FROSTWOLF_HUT)
+                    SpawnBGObject(BG_AV_OBJECT_AURA_H_FIRSTAID_STATION+3*GetNodeThroughObject(i),RESPAWN_IMMEDIATELY);
+            }
+            for(i = BG_AV_OBJECT_TFLAG_A_DUNBALDAR_SOUTH; i <= BG_AV_OBJECT_TFLAG_A_STONEHEART_BUNKER; i+=2)
+            {
+                SpawnBGObject(i, RESPAWN_IMMEDIATELY); //flag
+                SpawnBGObject(i+16, RESPAWN_IMMEDIATELY); //aura
+            }
+            for(i = BG_AV_OBJECT_TFLAG_H_ICEBLOOD_TOWER; i <= BG_AV_OBJECT_TFLAG_H_FROSTWOLF_WTOWER; i+=2)
+            {
+                SpawnBGObject(i, RESPAWN_IMMEDIATELY); //flag
+                SpawnBGObject(i+16, RESPAWN_IMMEDIATELY); //aura
+            }
+            //snowfall and the doors
+            for(i = BG_AV_OBJECT_FLAG_N_SNOWFALL_GRAVE; i <= BG_AV_OBJECT_DOOR_A; i++)
+                SpawnBGObject(i, RESPAWN_IMMEDIATELY);
+            SpawnBGObject(BG_AV_OBJECT_AURA_N_SNOWFALL_GRAVE,RESPAWN_IMMEDIATELY);
+
+            //creatures
+            sLog.outDebug("BG_AV start poputlating nodes");
+			for(BG_AV_Nodes i= BG_AV_NODES_FIRSTAID_STATION; i < BG_AV_NODES_MAX; ++i )
+            {
+                if(m_Nodes[i].Owner)
+    				PopulateNode(i);
+            }
+            //all creatures which don't get despawned through the script are static
+            sLog.outDebug("BG_AV: start spawning static creatures");
+            for(i=0; i < AV_STATICCPLACE_MAX; i++ )
+                AddAVCreature(0,i+AV_CPLACE_MAX);
+        	//mainspiritguides:
+            sLog.outDebug("BG_AV: start spawning spiritguides creatures");
+	        AddSpiritGuide(7, BG_AV_CreaturePos[7][0], BG_AV_CreaturePos[7][1], BG_AV_CreaturePos[7][2], BG_AV_CreaturePos[7][3], ALLIANCE);
+        	AddSpiritGuide(8, BG_AV_CreaturePos[8][0], BG_AV_CreaturePos[8][1], BG_AV_CreaturePos[8][2], BG_AV_CreaturePos[8][3], HORDE);
+            //spawn the marshals (those who get deleted, if a tower gets destroyed)
+            sLog.outDebug("BG_AV: start spawning marshal creatures");
+            for(i=AV_NPC_A_MARSHAL_SOUTH; i<= AV_NPC_H_MARSHAL_WTOWER; i++)
+                AddAVCreature(i,AV_CPLACE_A_MARSHAL_SOUTH+(i-AV_NPC_A_MARSHAL_SOUTH));
+
+            AddAVCreature(AV_NPC_HERALD,AV_CPLACE_HERALD);
+            DoorClose(BG_AV_OBJECT_DOOR_A);
+            DoorClose(BG_AV_OBJECT_DOOR_H);
+
+            SetStartDelayTime(START_DELAY0);
+        }
+        // After 1 minute, warning is signalled
+        else if (GetStartDelayTime() <= START_DELAY1 && !(m_Events & 0x04))
+        {
+            m_Events |= 0x04;
+            SendMessageToAll(GetMangosString(LANG_BG_AV_ONEMINTOSTART));
+        }
+        // After 1,5 minute, warning is signalled
+        else if (GetStartDelayTime() <= START_DELAY2 && !(m_Events & 0x08))
+        {
+            m_Events |= 0x08;
+            SendMessageToAll(GetMangosString(LANG_BG_AV_HALFMINTOSTART));
+        }
+        // After 2 minutes, gates OPEN ! x)
+        else if (GetStartDelayTime() <= 0 && !(m_Events & 0x10))
+        {
+            UpdateWorldState(AV_SHOW_H_SCORE, 1);
+            UpdateWorldState(AV_SHOW_A_SCORE, 1);
+            m_Events |= 0x10;
+
+            SendMessageToAll(GetMangosString(LANG_BG_AV_STARTED));
+            PlaySoundToAll(SOUND_BG_START);
+            SetStatus(STATUS_IN_PROGRESS);
+
+            sLog.outDebug("BG_AV: start spawning mine stuff");
+            for(uint16 i= BG_AV_OBJECT_MINE_SUPPLY_N_MIN; i<=BG_AV_OBJECT_MINE_SUPPLY_N_MAX;i++)
+                SpawnBGObject(i,RESPAWN_IMMEDIATELY);
+            for(uint16 i= BG_AV_OBJECT_MINE_SUPPLY_S_MIN; i<=BG_AV_OBJECT_MINE_SUPPLY_S_MAX;i++)
+                SpawnBGObject(i,RESPAWN_IMMEDIATELY);
+            for(uint8 mine = AV_NORTH_MINE; mine <= AV_SOUTH_MINE; mine++) //mine population
+                ChangeMineOwner(mine, AV_NEUTRAL_TEAM,true);
+            DoorOpen(BG_AV_OBJECT_DOOR_H);
+            DoorOpen(BG_AV_OBJECT_DOOR_A);
+
+
+            for(BattleGroundPlayerMap::const_iterator itr = GetPlayers().begin(); itr != GetPlayers().end(); ++itr)
+                if(Player* plr = objmgr.GetPlayer(itr->first))
+                    plr->RemoveAurasDueToSpell(SPELL_PREPARATION);
+        }
+    }
+    else if(GetStatus() == STATUS_IN_PROGRESS)
+    {
+        for(uint8 i=0; i<=1;i++)//0=alliance, 1=horde
+        {
+            if(!m_CaptainAlive[i])
+                continue;
+            if(m_CaptainBuffTimer[i] > diff)
+                m_CaptainBuffTimer[i] -= diff;
+            else
+            {
+                if(i==0)
+                {
+                    CastSpellOnTeam(AV_BUFF_A_CAPTAIN,ALLIANCE);
+                    Creature* creature = GetBGCreature(AV_CPLACE_MAX + 61);
+                    if(creature)
+                        YellToAll(creature,LANG_BG_AV_A_CAPTAIN_BUFF,LANG_COMMON);
+//                    creature->Yell(LANG_BG_AV_A_CAPTAIN_BUFF,LANG_UNIVERSAL,0); //TODO look if this position here is right or if this is sd2 stuff
+                }
+                else
+                {
+                    CastSpellOnTeam(AV_BUFF_H_CAPTAIN,HORDE);
+                    Creature* creature = GetBGCreature(AV_CPLACE_MAX + 59); //TODO: make the captains a dynamic creature
+                    if(creature)
+                        YellToAll(creature,LANG_BG_AV_H_CAPTAIN_BUFF,LANG_ORCISH);
+                        //creature->Yell(LANG_BG_AV_H_CAPTAIN_BUFF,LANG_UNIVERSAL,0); //TODO look if this position here is right or if this is sd2 stuff
+                }
+                m_CaptainBuffTimer[i] = 120000 + urand(0,4)* 60000; //as far as i could see, the buff is randomly so i make 2minutes (thats the duration of the buff itself) + 0-4minutes TODO get the right times
+            }
+        }
+        //add points from mine owning, and look if he neutral team wanrts to reclaim the mine
+        m_Mine_Timer -=diff;
+        for(uint8 mine=0; mine <2; mine++)
+        {
+            if(m_Mine_Owner[mine] == ALLIANCE || m_Mine_Owner[mine] == HORDE)
+            {
+                if( m_Mine_Timer <= 0)
+                    UpdateScore(m_Mine_Owner[mine],1);
+
+                if(m_Mine_Reclaim_Timer[mine] > diff)
+                    m_Mine_Reclaim_Timer[mine] -= diff;
+                else{ //we don't need to set this timer to 0 cause this codepart wont get called when this thing is 0
+                    ChangeMineOwner(mine,AV_NEUTRAL_TEAM);
+                }
+            }
+        }
+        if( m_Mine_Timer <= 0)
+            m_Mine_Timer=AV_MINE_TICK_TIMER; //this is at the end, cause we need to update both mines
+
+        //looks for all timers of the nodes and destroy the building (for graveyards the building wont get destroyed, it goes just to the other team
+        for(BG_AV_Nodes i = BG_AV_NODES_FIRSTAID_STATION; i < BG_AV_NODES_MAX; ++i)
+            if(m_Nodes[i].State == POINT_ASSAULTED) //maybe remove this
+            {
+                if(m_Nodes[i].Timer > diff)
+                    m_Nodes[i].Timer -= diff;
+                else
+                     EventPlayerDestroyedPoint( i);
+            }
+    }
 }
 
 void BattleGroundAV::AddPlayer(Player *plr)
@@ -44,15 +441,26 @@ void BattleGroundAV::AddPlayer(Player *plr)
     BattleGround::AddPlayer(plr);
     //create score and add it to map, default values are set in constructor
     BattleGroundAVScore* sc = new BattleGroundAVScore;
-
     m_PlayerScores[plr->GetGUID()] = sc;
+    if(m_MaxLevel==0)
+        m_MaxLevel=(plr->getLevel()%10 == 0)? plr->getLevel() : (plr->getLevel()-(plr->getLevel()%10))+10; //TODO: just look at the code \^_^/ --but queue-info should provide this information..
+
 }
 
-void BattleGroundAV::RemovePlayer(Player* /*plr*/,uint64 /*guid*/)
+void BattleGroundAV::RemovePlayer(Player* plr,uint64 /*guid*/)
 {
-
+   if(!plr)
+    {
+        sLog.outError("bg_AV no player at remove");
+        return;
+    }
+    //TODO search more buffs
+    plr->RemoveAurasDueToSpell(AV_BUFF_ARMOR);
+    plr->RemoveAurasDueToSpell(AV_BUFF_A_CAPTAIN);
+    plr->RemoveAurasDueToSpell(AV_BUFF_H_CAPTAIN);
 }
 
+
 void BattleGroundAV::HandleAreaTrigger(Player *Source, uint32 Trigger)
 {
     // this is wrong way to implement these things. On official it done by gameobject spell cast.
@@ -63,18 +471,29 @@ void BattleGroundAV::HandleAreaTrigger(Player *Source, uint32 Trigger)
     switch(Trigger)
     {
         case 95:
-        case 2606:
         case 2608:
+			if(Source->GetTeam() != ALLIANCE)
+                Source->GetSession()->SendAreaTriggerMessage("Only The Alliance can use that portal");
+            else
+                Source->LeaveBattleground();
+            break;
+        case 2606:
+            if(Source->GetTeam() != HORDE)
+                Source->GetSession()->SendAreaTriggerMessage("Only The Horde can use that portal");
+            else
+                Source->LeaveBattleground();
+            break;
         case 3326:
         case 3327:
         case 3328:
         case 3329:
         case 3330:
         case 3331:
+			//Source->Unmount();
             break;
         default:
-            sLog.outError("WARNING: Unhandled AreaTrigger in Battleground: %u", Trigger);
-            Source->GetSession()->SendAreaTriggerMessage("Warning: Unhandled AreaTrigger in Battleground: %u", Trigger);
+            sLog.outDebug("WARNING: Unhandled AreaTrigger in Battleground: %u", Trigger);
+//            Source->GetSession()->SendAreaTriggerMessage("Warning: Unhandled AreaTrigger in Battleground: %u", Trigger);
             break;
     }
 
@@ -118,3 +537,841 @@ void BattleGroundAV::UpdatePlayerScore(Player* Source, uint32 type, uint32 value
             break;
     }
 }
+
+
+
+void BattleGroundAV::EventPlayerDestroyedPoint(BG_AV_Nodes node)
+{
+
+    uint32 object = GetObjectThroughNode(node);
+    sLog.outDebug("bg_av: player destroyed point node %i object %i",node,object);
+
+    //despawn banner
+    SpawnBGObject(object, RESPAWN_ONE_DAY);
+    DestroyNode(node);
+    UpdateNodeWorldState(node);
+
+    uint32 owner = m_Nodes[node].Owner;
+    if( IsTower(node) )
+    {
+        uint8 tmp = node-BG_AV_NODES_DUNBALDAR_SOUTH;
+        //despawn marshal
+        if(m_BgCreatures[AV_CPLACE_A_MARSHAL_SOUTH + tmp])
+            DelCreature(AV_CPLACE_A_MARSHAL_SOUTH + tmp);
+        else
+            sLog.outError("BG_AV: playerdestroyedpoint: marshal %i doesn't exist",AV_CPLACE_A_MARSHAL_SOUTH + tmp);
+        //spawn destroyed aura
+        for(uint8 i=0; i<=9; i++)
+            SpawnBGObject(BG_AV_OBJECT_BURN_DUNBALDAR_SOUTH + i + (tmp * 10),RESPAWN_IMMEDIATELY);
+
+        UpdateScore((owner == ALLIANCE) ? HORDE : ALLIANCE, (-1)*BG_AV_RES_TOWER);
+        RewardReputationToTeam((owner == ALLIANCE)?730:729,BG_AV_REP_TOWER,owner);
+        RewardHonorToTeam(GetBonusHonor(BG_AV_KILL_TOWER),owner);
+
+        //despawn big banner+aura on top of tower TODO: look if this works (i think it doesn't)
+        SpawnBGObject(BG_AV_OBJECT_TAURA_A_DUNBALDAR_SOUTH+GetTeamIndexByTeamId(owner)+(2*tmp),RESPAWN_ONE_DAY);
+        SpawnBGObject(BG_AV_OBJECT_TFLAG_A_DUNBALDAR_SOUTH+GetTeamIndexByTeamId(owner)+(2*tmp),RESPAWN_ONE_DAY);
+    }
+    else
+    {
+        if( owner == ALLIANCE )
+            SpawnBGObject(object-11, RESPAWN_IMMEDIATELY);
+        else
+            SpawnBGObject(object+11, RESPAWN_IMMEDIATELY);
+        SpawnBGObject(BG_AV_OBJECT_AURA_N_FIRSTAID_STATION+3*node,RESPAWN_ONE_DAY);
+        SpawnBGObject(BG_AV_OBJECT_AURA_A_FIRSTAID_STATION+GetTeamIndexByTeamId(owner)+3*node,RESPAWN_IMMEDIATELY);
+        PopulateNode(node);
+        if(node == BG_AV_NODES_SNOWFALL_GRAVE) //snowfall eyecandy
+        {
+            for(uint8 i = 0; i < 4; i++)
+            {
+                SpawnBGObject(((owner==ALLIANCE)?BG_AV_OBJECT_SNOW_EYECANDY_PA : BG_AV_OBJECT_SNOW_EYECANDY_PH)+i,RESPAWN_ONE_DAY);
+                SpawnBGObject(((owner==ALLIANCE)?BG_AV_OBJECT_SNOW_EYECANDY_A  : BG_AV_OBJECT_SNOW_EYECANDY_H )+i,RESPAWN_IMMEDIATELY);
+            }
+        }
+    }
+    //send a nice message to all :)
+    char buf[256];
+    if(IsTower(node))
+        sprintf(buf, GetMangosString(LANG_BG_AV_TOWER_TAKEN) , GetNodeName(node),( owner == ALLIANCE ) ? GetMangosString(LANG_BG_AV_ALLY) : GetMangosString(LANG_BG_AV_HORDE)  );
+    else
+        sprintf(buf, GetMangosString(LANG_BG_AV_GRAVE_TAKEN) , GetNodeName(node),( owner == ALLIANCE ) ? GetMangosString(LANG_BG_AV_ALLY) :GetMangosString(LANG_BG_AV_HORDE)  );
+        
+    Creature* creature = GetBGCreature(AV_CPLACE_HERALD);
+    if(creature)
+        YellToAll(creature,buf,LANG_UNIVERSAL);
+}
+
+void BattleGroundAV::ChangeMineOwner(uint8 mine, uint32 team, bool initial)
+{ //mine=0 northmine mine=1 southmin
+//changing the owner results in setting respawntim to infinite for current creatures, spawning new mine owners creatures and changing the chest-objects so that the current owning team can use them
+    assert(mine == AV_NORTH_MINE || mine == AV_SOUTH_MINE);
+    if(team != ALLIANCE && team != HORDE)
+        team = AV_NEUTRAL_TEAM;
+    else
+        PlaySoundToAll((team==ALLIANCE)?AV_SOUND_ALLIANCE_GOOD:AV_SOUND_HORDE_GOOD);
+
+    if(m_Mine_Owner[mine] == team && !initial)
+        return;
+    m_Mine_PrevOwner[mine] = m_Mine_Owner[mine];
+    m_Mine_Owner[mine] = team;
+
+    if(!initial)
+    {
+        sLog.outDebug("bg_av depopulating mine %i (0=north,1=south)",mine);
+        if(mine==AV_SOUTH_MINE)
+            for(uint16 i=AV_CPLACE_MINE_S_S_MIN; i <= AV_CPLACE_MINE_S_S_MAX; i++)
+                if( m_BgCreatures[i] )
+                    DelCreature(i); //TODO just set the respawntime to 999999
+        for(uint16 i=((mine==AV_NORTH_MINE)?AV_CPLACE_MINE_N_1_MIN:AV_CPLACE_MINE_S_1_MIN); i <= ((mine==AV_NORTH_MINE)?AV_CPLACE_MINE_N_3:AV_CPLACE_MINE_S_3); i++)
+            if( m_BgCreatures[i] )
+                DelCreature(i); //TODO here also
+    }
+    SendMineWorldStates(mine);
+
+    sLog.outDebug("bg_av populating mine %i (0=north,1=south)",mine);
+    uint16 miner;
+    //also neutral team exists.. after a big time, the neutral team tries to conquer the mine
+    if(mine==AV_NORTH_MINE)
+    {
+        if(team == ALLIANCE)
+            miner = AV_NPC_N_MINE_A_1;
+        else if (team == HORDE)
+            miner = AV_NPC_N_MINE_H_1;
+        else
+            miner = AV_NPC_N_MINE_N_1;
+    }
+    else
+    {
+        uint16 cinfo;
+        if(team == ALLIANCE)
+            miner = AV_NPC_S_MINE_A_1;
+        else if (team == HORDE)
+            miner = AV_NPC_S_MINE_H_1;
+        else
+            miner = AV_NPC_S_MINE_N_1;
+       //vermin
+        sLog.outDebug("spawning vermin");
+        if(team == ALLIANCE)
+            cinfo = AV_NPC_S_MINE_A_3;
+        else if (team == HORDE)
+            cinfo = AV_NPC_S_MINE_H_3;
+        else
+            cinfo = AV_NPC_S_MINE_N_S;
+        for(uint16 i=AV_CPLACE_MINE_S_S_MIN; i <= AV_CPLACE_MINE_S_S_MAX; i++)
+            AddAVCreature(cinfo,i);
+    }
+    for(uint16 i=( (mine==AV_NORTH_MINE)?AV_CPLACE_MINE_N_1_MIN:AV_CPLACE_MINE_S_1_MIN ); i <= ((mine==AV_NORTH_MINE)?AV_CPLACE_MINE_N_1_MAX:AV_CPLACE_MINE_S_1_MAX); i++)
+        AddAVCreature(miner,i);
+    //the next chooses randomly between 2 cretures
+    for(uint16 i=((mine==AV_NORTH_MINE)?AV_CPLACE_MINE_N_2_MIN:AV_CPLACE_MINE_S_2_MIN); i <= ((mine==AV_NORTH_MINE)?AV_CPLACE_MINE_N_2_MAX:AV_CPLACE_MINE_S_2_MAX); i++)
+        AddAVCreature(miner+(urand(1,2)),i);
+    AddAVCreature(miner+3,(mine==AV_NORTH_MINE)?AV_CPLACE_MINE_N_3:AV_CPLACE_MINE_S_3);
+    //because the gameobjects in this mine have changed, update all surrounding players:
+//    for(uint16 i = ((mine==AV_NORTH_MINE)?BG_AV_OBJECT_MINE_SUPPLY_N_MIN:BG_AV_OBJECT_MINE_SUPPLY_N_MIN); i <= ((mine==AV_NORTH_MINE)?BG_AV_OBJECT_MINE_SUPPLY_N_MAX:BG_AV_OBJECT_MINE_SUPPLY_N_MAX); i++)
+//    {
+        //TODO: add gameobject-update code
+//    }
+    if(team == ALLIANCE || team == HORDE)
+    {
+        m_Mine_Reclaim_Timer[mine]=AV_MINE_RECLAIM_TIMER;
+    	char buf[256];
+	    sprintf(buf, GetMangosString(LANG_BG_AV_MINE_TAKEN), GetMangosString(( mine == AV_NORTH_MINE ) ? LANG_BG_AV_MINE_NORTH : LANG_BG_AV_MINE_SOUTH), ( team == ALLIANCE ) ?  GetMangosString(LANG_BG_AV_ALLY) : GetMangosString(LANG_BG_AV_HORDE));
+        Creature* creature = GetBGCreature(AV_CPLACE_HERALD);
+        if(creature)
+            YellToAll(creature,buf,LANG_UNIVERSAL);
+    }
+    else
+    {
+        if(mine==AV_SOUTH_MINE) //i think this gets called all the time
+        {
+            Creature* creature = GetBGCreature(AV_CPLACE_MINE_S_3);
+            YellToAll(creature,LANG_BG_AV_S_MINE_BOSS_CLAIMS,LANG_UNIVERSAL);
+        }
+    }
+    return;
+}
+
+bool BattleGroundAV::PlayerCanDoMineQuest(int32 GOId,uint32 team)
+{
+    if(GOId == BG_AV_OBJECTID_MINE_N)
+         return (m_Mine_Owner[AV_NORTH_MINE]==team);
+    if(GOId == BG_AV_OBJECTID_MINE_S)
+         return (m_Mine_Owner[AV_SOUTH_MINE]==team);
+    return true; //cause it's no mine'object it is ok if this is true
+}
+
+void BattleGroundAV::PopulateNode(BG_AV_Nodes node)
+{
+    uint32 owner = m_Nodes[node].Owner;
+	assert(owner);
+
+    uint32 c_place = AV_CPLACE_DEFENSE_STORM_AID + ( 4 * node );
+    uint32 creatureid;
+    if(IsTower(node))
+        creatureid=(owner==ALLIANCE)?AV_NPC_A_TOWERDEFENSE:AV_NPC_H_TOWERDEFENSE;
+    else
+    {
+        uint8 team2 = GetTeamIndexByTeamId(owner);
+    	if (m_Team_QuestStatus[team2][0] < 500 )
+            creatureid = ( owner == ALLIANCE )? AV_NPC_A_GRAVEDEFENSE0 : AV_NPC_H_GRAVEDEFENSE0;
+        else if ( m_Team_QuestStatus[team2][0] < 1000 )
+            creatureid = ( owner == ALLIANCE )? AV_NPC_A_GRAVEDEFENSE1 : AV_NPC_H_GRAVEDEFENSE1;
+        else if ( m_Team_QuestStatus[team2][0] < 1500 )
+            creatureid = ( owner == ALLIANCE )? AV_NPC_A_GRAVEDEFENSE2 : AV_NPC_H_GRAVEDEFENSE2;
+        else
+           creatureid = ( owner == ALLIANCE )? AV_NPC_A_GRAVEDEFENSE3 : AV_NPC_H_GRAVEDEFENSE3;
+        //spiritguide
+        if( m_BgCreatures[node] )
+            DelCreature(node);
+        if( !AddSpiritGuide(node, BG_AV_CreaturePos[node][0], BG_AV_CreaturePos[node][1], BG_AV_CreaturePos[node][2], BG_AV_CreaturePos[node][3], owner))
+            sLog.outError("AV: couldn't spawn spiritguide at node %i",node);
+
+    }
+    for(uint8 i=0; i<4; i++)
+        AddAVCreature(creatureid,c_place+i);
+}
+void BattleGroundAV::DePopulateNode(BG_AV_Nodes node)
+{
+	uint32 c_place = AV_CPLACE_DEFENSE_STORM_AID + ( 4 * node );
+    for(uint8 i=0; i<4; i++)
+        if( m_BgCreatures[c_place+i] )
+            DelCreature(c_place+i);
+    //spiritguide
+    if( !IsTower(node) && m_BgCreatures[node] )
+        DelCreature(node);
+}
+
+
+const BG_AV_Nodes BattleGroundAV::GetNodeThroughObject(uint32 object)
+{
+    sLog.outDebug("bg_AV getnodethroughobject %i",object);
+	if( object <= BG_AV_OBJECT_FLAG_A_STONEHEART_BUNKER )
+		return BG_AV_Nodes(object);
+	if( object <= BG_AV_OBJECT_FLAG_C_A_FROSTWOLF_HUT )
+		return BG_AV_Nodes(object - 11);
+	if( object <= BG_AV_OBJECT_FLAG_C_A_FROSTWOLF_WTOWER )
+		return BG_AV_Nodes(object - 7);
+	if( object <= BG_AV_OBJECT_FLAG_C_H_STONEHEART_BUNKER )
+		return BG_AV_Nodes(object -22);
+	if( object <= BG_AV_OBJECT_FLAG_H_FROSTWOLF_HUT )
+		return BG_AV_Nodes(object - 33);
+	if( object <= BG_AV_OBJECT_FLAG_H_FROSTWOLF_WTOWER )
+		return BG_AV_Nodes(object - 29);
+	if( object == BG_AV_OBJECT_FLAG_N_SNOWFALL_GRAVE )
+		return BG_AV_NODES_SNOWFALL_GRAVE;
+	sLog.outError("BattleGroundAV: ERROR! GetPlace got a wrong object :(");
+    assert(false);
+    return BG_AV_Nodes(0);
+}
+
+const uint32 BattleGroundAV::GetObjectThroughNode(BG_AV_Nodes node)
+{ //this function is the counterpart to GetNodeThroughObject()
+    sLog.outDebug("bg_AV GetObjectThroughNode %i",node);
+    if( m_Nodes[node].Owner == ALLIANCE )
+    {
+        if( m_Nodes[node].State == POINT_ASSAULTED )
+        {
+            if( node <= BG_AV_NODES_FROSTWOLF_HUT )
+                return node+11;
+            if( node >= BG_AV_NODES_ICEBLOOD_TOWER && node <= BG_AV_NODES_FROSTWOLF_WTOWER)
+                return node+7;
+        }
+        else if ( m_Nodes[node].State == POINT_CONTROLED )
+            if( node <= BG_AV_NODES_STONEHEART_BUNKER )
+                return node;
+    }
+    else if ( m_Nodes[node].Owner == HORDE )
+    {
+        if( m_Nodes[node].State == POINT_ASSAULTED )
+            if( node <= BG_AV_NODES_STONEHEART_BUNKER )
+                return node+22;
+        else if ( m_Nodes[node].State == POINT_CONTROLED )
+        {
+            if( node <= BG_AV_NODES_FROSTWOLF_HUT )
+                return node+33;
+            if( node >= BG_AV_NODES_ICEBLOOD_TOWER && node <= BG_AV_NODES_FROSTWOLF_WTOWER)
+                return node+29;
+        }
+    }
+    else if ( m_Nodes[node].Owner == AV_NEUTRAL_TEAM )
+        return BG_AV_OBJECT_FLAG_N_SNOWFALL_GRAVE;
+    sLog.outError("BattleGroundAV: Error! GetPlaceNode couldn't resolve node %i",node);
+    assert(false);
+    return 0; //i don't know what i should return, maybe I should crash the server at this point :>
+}
+
+
+//called when using banner
+
+void BattleGroundAV::EventPlayerClickedOnFlag(Player *source, GameObject* target_obj)
+{
+    if(GetStatus() != STATUS_IN_PROGRESS)
+        return;
+    int32 object = GetObjectType(target_obj->GetGUID());
+    sLog.outDebug("BG_AV using gameobject %i with type %i",target_obj->GetEntry(),object);
+    if(object < 0)
+        return;
+    switch(target_obj->GetEntry())
+    {
+        case BG_AV_OBJECTID_BANNER_A:
+        case BG_AV_OBJECTID_BANNER_A_B:
+        case BG_AV_OBJECTID_BANNER_H:
+        case BG_AV_OBJECTID_BANNER_H_B:
+        case BG_AV_OBJECTID_BANNER_SNOWFALL_N:
+            EventPlayerAssaultsPoint(source, object);
+            break;
+        case BG_AV_OBJECTID_BANNER_CONT_A:
+        case BG_AV_OBJECTID_BANNER_CONT_A_B:
+        case BG_AV_OBJECTID_BANNER_CONT_H:
+        case BG_AV_OBJECTID_BANNER_CONT_H_B:
+            EventPlayerDefendsPoint(source, object);
+            break;
+        default:
+            break;
+    }
+}
+
+void BattleGroundAV::EventPlayerDefendsPoint(Player* player, uint32 object)
+{
+    assert(GetStatus() == STATUS_IN_PROGRESS);
+    BG_AV_Nodes node = GetNodeThroughObject(object);
+
+    uint32 owner = m_Nodes[node].Owner; //maybe should name it prevowner
+    uint32 team = player->GetTeam();
+
+    if(owner == player->GetTeam() || m_Nodes[node].State != POINT_ASSAULTED)
+        return;
+    if(m_Nodes[node].TotalOwner == AV_NEUTRAL_TEAM)
+    { //until snowfall doesn't belong to anyone it is better handled in assault-code
+        assert(node == BG_AV_NODES_SNOWFALL_GRAVE); //currently the only neutral grave
+        EventPlayerAssaultsPoint(player,object);
+        return;
+    }
+    sLog.outDebug("player defends point object: %i node: %i",object,node);
+    if(m_Nodes[node].PrevOwner != team)
+    {
+        sLog.outError("BG_AV: player defends point which doesn't belong to his team %i",node);
+        return;
+    }
+
+
+   //spawn new go :)
+    if(m_Nodes[node].Owner == ALLIANCE)
+        SpawnBGObject(object+22, RESPAWN_IMMEDIATELY); //spawn horde banner
+    else
+        SpawnBGObject(object-22, RESPAWN_IMMEDIATELY); //spawn alliance banner
+
+    if(!IsTower(node))
+    {
+        SpawnBGObject(BG_AV_OBJECT_AURA_N_FIRSTAID_STATION+3*node,RESPAWN_ONE_DAY);
+        SpawnBGObject(BG_AV_OBJECT_AURA_A_FIRSTAID_STATION+GetTeamIndexByTeamId(team)+3*node,RESPAWN_IMMEDIATELY);
+    }
+        // despawn old go
+    SpawnBGObject(object, RESPAWN_ONE_DAY);
+
+    DefendNode(node,team);
+	PopulateNode(node);
+    UpdateNodeWorldState(node);
+
+    if(IsTower(node))
+    {
+        //spawn big flag+aura on top of tower
+        SpawnBGObject(BG_AV_OBJECT_TAURA_A_DUNBALDAR_SOUTH+(2*(node-BG_AV_NODES_DUNBALDAR_SOUTH)),(team == ALLIANCE)? RESPAWN_IMMEDIATELY : RESPAWN_ONE_DAY);
+        SpawnBGObject(BG_AV_OBJECT_TAURA_H_DUNBALDAR_SOUTH+(2*(node-BG_AV_NODES_DUNBALDAR_SOUTH)),(team == HORDE)? RESPAWN_IMMEDIATELY : RESPAWN_ONE_DAY);
+        SpawnBGObject(BG_AV_OBJECT_TFLAG_A_DUNBALDAR_SOUTH+(2*(node-BG_AV_NODES_DUNBALDAR_SOUTH)),(team == ALLIANCE)? RESPAWN_IMMEDIATELY : RESPAWN_ONE_DAY);
+        SpawnBGObject(BG_AV_OBJECT_TFLAG_H_DUNBALDAR_SOUTH+(2*(node-BG_AV_NODES_DUNBALDAR_SOUTH)),(team == HORDE)? RESPAWN_IMMEDIATELY : RESPAWN_ONE_DAY);
+    }
+    else if(node == BG_AV_NODES_SNOWFALL_GRAVE) //snowfall eyecandy
+    {
+        for(uint8 i = 0; i < 4; i++)
+        {
+            SpawnBGObject(((owner==ALLIANCE)?BG_AV_OBJECT_SNOW_EYECANDY_PA : BG_AV_OBJECT_SNOW_EYECANDY_PH)+i,RESPAWN_ONE_DAY);
+            SpawnBGObject(((team==ALLIANCE)?BG_AV_OBJECT_SNOW_EYECANDY_A : BG_AV_OBJECT_SNOW_EYECANDY_H)+i,RESPAWN_IMMEDIATELY);
+        }
+    }
+	//send a nice message to all :)
+	char buf[256];
+	sprintf(buf, GetMangosString(( IsTower(node) ) ? LANG_BG_AV_TOWER_DEFENDED : LANG_BG_AV_GRAVE_DEFENDED), GetNodeName(node),( team == ALLIANCE ) ?  GetMangosString(LANG_BG_AV_ALLY) : GetMangosString(LANG_BG_AV_HORDE));
+    Creature* creature = GetBGCreature(AV_CPLACE_HERALD);
+    if(creature)
+        YellToAll(creature,buf,LANG_UNIVERSAL);
+	//update the statistic for the defending player
+	UpdatePlayerScore(player, ( IsTower(node) ) ? SCORE_TOWERS_DEFENDED : SCORE_GRAVEYARDS_DEFENDED, 1);
+    if(IsTower(node))
+        PlaySoundToAll(AV_SOUND_BOTH_TOWER_DEFEND);
+    else
+        PlaySoundToAll((team==ALLIANCE)?AV_SOUND_ALLIANCE_GOOD:AV_SOUND_HORDE_GOOD);
+}
+
+void BattleGroundAV::EventPlayerAssaultsPoint(Player* player, uint32 object)
+{
+    assert(GetStatus() == STATUS_IN_PROGRESS);
+
+    BG_AV_Nodes node = GetNodeThroughObject(object);
+    uint32 owner = m_Nodes[node].Owner; //maybe name it prevowner
+    uint32 team  = player->GetTeam();
+    sLog.outDebug("bg_av: player assaults point object %i node %i",object,node);
+    if(owner == team || team == m_Nodes[node].TotalOwner)
+        return; //surely a gm used this object
+
+
+    if(node == BG_AV_NODES_SNOWFALL_GRAVE) //snowfall is a bit special in capping + it gets eyecandy stuff
+    {
+        if(object == BG_AV_OBJECT_FLAG_N_SNOWFALL_GRAVE) //initial capping
+        {
+            assert(owner == AV_NEUTRAL_TEAM && m_Nodes[node].TotalOwner == AV_NEUTRAL_TEAM);
+            if( team == ALLIANCE )
+                SpawnBGObject(BG_AV_OBJECT_FLAG_C_A_SNOWFALL_GRAVE, RESPAWN_IMMEDIATELY);
+            else
+                SpawnBGObject(BG_AV_OBJECT_FLAG_C_H_SNOWFALL_GRAVE, RESPAWN_IMMEDIATELY);
+            SpawnBGObject(BG_AV_OBJECT_AURA_N_FIRSTAID_STATION+3*node,RESPAWN_IMMEDIATELY); //neutral aura spawn
+        }
+        else if(m_Nodes[node].TotalOwner == AV_NEUTRAL_TEAM) //recapping, when no team owns this node realy
+        {
+            assert(m_Nodes[node].State != POINT_CONTROLED);
+            if(team == ALLIANCE)
+                SpawnBGObject(object-11, RESPAWN_IMMEDIATELY);
+            else
+                SpawnBGObject(object+11, RESPAWN_IMMEDIATELY);
+        }
+        //eyecandy
+        uint32 spawn,despawn;
+        if(team == ALLIANCE)
+        {
+            despawn = ( m_Nodes[node].State == POINT_ASSAULTED )?BG_AV_OBJECT_SNOW_EYECANDY_PH : BG_AV_OBJECT_SNOW_EYECANDY_H;
+            spawn = BG_AV_OBJECT_SNOW_EYECANDY_PA;
+        }
+        else
+        {
+            despawn = ( m_Nodes[node].State == POINT_ASSAULTED )?BG_AV_OBJECT_SNOW_EYECANDY_PA : BG_AV_OBJECT_SNOW_EYECANDY_A;
+            spawn = BG_AV_OBJECT_SNOW_EYECANDY_PH;
+        }
+        for(uint8 i = 0; i < 4; i++)
+        {
+            SpawnBGObject(despawn+i,RESPAWN_ONE_DAY);
+            SpawnBGObject(spawn+i,RESPAWN_IMMEDIATELY);
+        }
+    }
+
+    //if snowfall gots capped it can be handled like all other graveyards
+    if( m_Nodes[node].TotalOwner != AV_NEUTRAL_TEAM)
+    {
+        assert(m_Nodes[node].Owner != AV_NEUTRAL_TEAM);
+        if(team == ALLIANCE)
+            SpawnBGObject(object-22, RESPAWN_IMMEDIATELY);
+        else
+            SpawnBGObject(object+22, RESPAWN_IMMEDIATELY);
+        if(IsTower(node))
+        { //spawning/despawning of bigflag+aura
+            SpawnBGObject(BG_AV_OBJECT_TAURA_A_DUNBALDAR_SOUTH+(2*(node-BG_AV_NODES_DUNBALDAR_SOUTH)),(team==ALLIANCE)? RESPAWN_IMMEDIATELY : RESPAWN_ONE_DAY);
+            SpawnBGObject(BG_AV_OBJECT_TAURA_H_DUNBALDAR_SOUTH+(2*(node-BG_AV_NODES_DUNBALDAR_SOUTH)),(team==HORDE)? RESPAWN_IMMEDIATELY : RESPAWN_ONE_DAY);
+            SpawnBGObject(BG_AV_OBJECT_TFLAG_A_DUNBALDAR_SOUTH+(2*(node-BG_AV_NODES_DUNBALDAR_SOUTH)),(team==ALLIANCE)? RESPAWN_IMMEDIATELY : RESPAWN_ONE_DAY);
+            SpawnBGObject(BG_AV_OBJECT_TFLAG_H_DUNBALDAR_SOUTH+(2*(node-BG_AV_NODES_DUNBALDAR_SOUTH)),(team==HORDE)? RESPAWN_IMMEDIATELY : RESPAWN_ONE_DAY);
+        }
+        else
+        {
+            //spawning/despawning of aura
+            SpawnBGObject(BG_AV_OBJECT_AURA_N_FIRSTAID_STATION+3*node,RESPAWN_IMMEDIATELY); //neutral aura spawn
+            SpawnBGObject(BG_AV_OBJECT_AURA_A_FIRSTAID_STATION+GetTeamIndexByTeamId(owner)+3*node,RESPAWN_ONE_DAY); //teeamaura despawn
+            // Those who are waiting to resurrect at this object are taken to the closest own object's graveyard
+            std::vector<uint64> ghost_list = m_ReviveQueue[m_BgCreatures[node]];
+            if( !ghost_list.empty() )
+            {
+                Player *plr;
+                WorldSafeLocsEntry const *ClosestGrave = NULL;
+                for (std::vector<uint64>::iterator itr = ghost_list.begin(); itr != ghost_list.end(); ++itr)
+                {
+                    plr = objmgr.GetPlayer(*ghost_list.begin());
+                    if( !plr )
+                        continue;
+                    if(!ClosestGrave)
+                        ClosestGrave = GetClosestGraveYard(plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ(), team);
+                    else
+                        plr->TeleportTo(GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
+                }
+                m_ReviveQueue[m_BgCreatures[node]].clear();
+            }
+        }
+        DePopulateNode(node);
+    }
+
+    SpawnBGObject(object, RESPAWN_ONE_DAY); //delete old banner
+    AssaultNode(node,team);
+    UpdateNodeWorldState(node);
+
+    //send a nice message to all :)
+    char buf[256];
+    sprintf(buf, ( IsTower(node) ) ? GetMangosString(LANG_BG_AV_TOWER_ASSAULTED) : GetMangosString(LANG_BG_AV_GRAVE_ASSAULTED), GetNodeName(node),  ( team == ALLIANCE ) ?  GetMangosString(LANG_BG_AV_ALLY) : GetMangosString(LANG_BG_AV_HORDE ));
+    Creature* creature = GetBGCreature(AV_CPLACE_HERALD);
+    if(creature)
+        YellToAll(creature,buf,LANG_UNIVERSAL);
+    //update the statistic for the assaulting player
+    UpdatePlayerScore(player, ( IsTower(node) ) ? SCORE_TOWERS_ASSAULTED : SCORE_GRAVEYARDS_ASSAULTED, 1);
+    PlaySoundToAll((team==ALLIANCE)?AV_SOUND_ALLIANCE_ASSAULTS:AV_SOUND_HORDE_ASSAULTS);
+}
+
+void BattleGroundAV::FillInitialWorldStates(WorldPacket& data)
+{
+    bool stateok;
+    //graveyards
+    for (uint8 i = BG_AV_NODES_FIRSTAID_STATION; i <= BG_AV_NODES_FROSTWOLF_HUT; i++)
+    {
+        for (uint8 j =1; j <= 3; j+=2)
+        {//j=1=assaulted j=3=controled
+            stateok = (m_Nodes[i].State == j);
+            data << uint32(BG_AV_NodeWorldStates[i][GetWorldStateType(j,ALLIANCE)]) << uint32((m_Nodes[i].Owner == ALLIANCE && stateok)?1:0);
+            data << uint32(BG_AV_NodeWorldStates[i][GetWorldStateType(j,HORDE)]) << uint32((m_Nodes[i].Owner == HORDE && stateok)?1:0);
+        }
+    }
+
+    //towers
+    for (uint8 i = BG_AV_NODES_DUNBALDAR_SOUTH; i <= BG_AV_NODES_MAX; i++)
+        for (uint8 j =1; j <= 3; j+=2)
+        {//j=1=assaulted j=3=controled //i dont have j=2=destroyed cause destroyed is the same like enemy-team controll
+            stateok = (m_Nodes[i].State == j || (m_Nodes[i].State == POINT_DESTROYED && j==3));
+            data << uint32(BG_AV_NodeWorldStates[i][GetWorldStateType(j,ALLIANCE)]) << uint32((m_Nodes[i].Owner == ALLIANCE && stateok)?1:0);
+            data << uint32(BG_AV_NodeWorldStates[i][GetWorldStateType(j,HORDE)]) << uint32((m_Nodes[i].Owner == HORDE && stateok)?1:0);
+        }
+    if(m_Nodes[BG_AV_NODES_SNOWFALL_GRAVE].Owner == AV_NEUTRAL_TEAM) //cause neutral teams aren't handled generic
+        data << uint32(AV_SNOWFALL_N) << uint32(1);
+    data << uint32(AV_Alliance_Score)  << uint32(m_Team_Scores[0]);
+    data << uint32(AV_Horde_Score) << uint32(m_Team_Scores[1]);
+    if(GetStatus() == STATUS_IN_PROGRESS){ //only if game started the teamscores are displayed
+        data << uint32(AV_SHOW_A_SCORE) << uint32(1);
+        data << uint32(AV_SHOW_H_SCORE) << uint32(1);
+    }
+    else
+    {
+        data << uint32(AV_SHOW_A_SCORE) << uint32(0);
+        data << uint32(AV_SHOW_H_SCORE) << uint32(0);
+    }
+    SendMineWorldStates(AV_NORTH_MINE);
+    SendMineWorldStates(AV_SOUTH_MINE);
+}
+
+const uint8 BattleGroundAV::GetWorldStateType(uint8 state, uint16 team) //this is used for node worldstates and returns values which fit good into the worldstatesarray
+{
+    //neutral stuff cant get handled (currently its only snowfall)
+    assert(team != AV_NEUTRAL_TEAM);
+//a_c a_a h_c h_a the positions in worldstate-array
+    if(team == ALLIANCE)
+    {
+        if(state==POINT_CONTROLED || state==POINT_DESTROYED)
+            return 0;
+        if(state==POINT_ASSAULTED)
+            return 1;
+    }
+    if(team == HORDE)
+    {
+        if(state==POINT_DESTROYED || state==POINT_CONTROLED)
+            return 2;
+        if(state==POINT_ASSAULTED)
+            return 3;
+    }
+    sLog.outError("BG_AV: should update a strange worldstate state:%i team:%i",state,team);
+    return 5; //this will crash the game, but i want to know if something is wrong here
+}
+
+void BattleGroundAV::UpdateNodeWorldState(BG_AV_Nodes node)
+{
+    UpdateWorldState(BG_AV_NodeWorldStates[node][GetWorldStateType(m_Nodes[node].State,m_Nodes[node].Owner)],1);
+    if(m_Nodes[node].PrevOwner == AV_NEUTRAL_TEAM) //currently only snowfall is supported as neutral node (i don't want to make an extra row (neutral states) in worldstatesarray just for one node
+        UpdateWorldState(AV_SNOWFALL_N,0);
+    else
+        UpdateWorldState(BG_AV_NodeWorldStates[node][GetWorldStateType(m_Nodes[node].PrevState,m_Nodes[node].PrevOwner)],0);
+}
+
+void BattleGroundAV::SendMineWorldStates(uint32 mine)
+{
+    assert(mine == AV_NORTH_MINE || mine==AV_SOUTH_MINE);
+// currently i'm sure, that this works (:
+//    assert(m_Mine_PrevOwner[mine] == ALLIANCE || m_Mine_PrevOwner[mine] == HORDE || m_Mine_PrevOwner[mine] == AV_NEUTRAL_TEAM);
+//    assert(m_Mine_Owner[mine] == ALLIANCE || m_Mine_Owner[mine] == HORDE || m_Mine_Owner[mine] == AV_NEUTRAL_TEAM);
+
+    uint8 owner,prevowner,mine2; //those variables are needed to access the right worldstate in the BG_AV_MineWorldStates array
+    mine2 = (mine==AV_NORTH_MINE)?0:1;
+    if(m_Mine_PrevOwner[mine] == ALLIANCE)
+        prevowner = 0;
+    else if(m_Mine_PrevOwner[mine] == HORDE)
+        prevowner = 2;
+    else
+        prevowner = 1;
+    if(m_Mine_Owner[mine] == ALLIANCE)
+        owner = 0;
+    else if(m_Mine_Owner[mine] == HORDE)
+        owner = 2;
+    else
+        owner = 1;
+
+    UpdateWorldState(BG_AV_MineWorldStates[mine2][owner],1);
+    if( prevowner != owner)
+        UpdateWorldState(BG_AV_MineWorldStates[mine2][prevowner],0);
+}
+
+
+WorldSafeLocsEntry const* BattleGroundAV::GetClosestGraveYard(float x, float y, float z, uint32 team)
+{
+    WorldSafeLocsEntry const* good_entry = NULL;
+    if( GetStatus() == STATUS_IN_PROGRESS)
+    {
+        // Is there any occupied node for this team?
+        float mindist = 9999999.0f;
+        for (uint8 i = BG_AV_NODES_FIRSTAID_STATION; i <= BG_AV_NODES_FROSTWOLF_HUT; ++i)
+        {
+            if (m_Nodes[i].Owner != team || m_Nodes[i].State != POINT_CONTROLED)
+                continue;
+            WorldSafeLocsEntry const*entry = sWorldSafeLocsStore.LookupEntry( BG_AV_GraveyardIds[i] );
+            if( !entry )
+                continue;
+            float dist = (entry->x - x)*(entry->x - x)+(entry->y - y)*(entry->y - y);
+            if( mindist > dist )
+            {
+                mindist = dist;
+                good_entry = entry;
+            }
+        }
+    }
+    // If not, place ghost on starting location
+    if( !good_entry )
+        good_entry = sWorldSafeLocsStore.LookupEntry( BG_AV_GraveyardIds[GetTeamIndexByTeamId(team)+7] );
+
+    return good_entry;
+}
+
+
+bool BattleGroundAV::SetupBattleGround()
+{
+    // Create starting objects
+    if(
+       // alliance gates
+        !AddObject(BG_AV_OBJECT_DOOR_A, BG_AV_OBJECTID_GATE_A, BG_AV_DoorPositons[0][0],BG_AV_DoorPositons[0][1],BG_AV_DoorPositons[0][2],BG_AV_DoorPositons[0][3],0,0,sin(BG_AV_DoorPositons[0][3]/2),cos(BG_AV_DoorPositons[0][3]/2),RESPAWN_IMMEDIATELY)
+        // horde gates
+        || !AddObject(BG_AV_OBJECT_DOOR_H, BG_AV_OBJECTID_GATE_H, BG_AV_DoorPositons[1][0],BG_AV_DoorPositons[1][1],BG_AV_DoorPositons[1][2],BG_AV_DoorPositons[1][3],0,0,sin(BG_AV_DoorPositons[1][3]/2),cos(BG_AV_DoorPositons[1][3]/2),RESPAWN_IMMEDIATELY))
+    {
+        sLog.outErrorDb("BatteGroundAV: Failed to spawn some object BattleGround not created!1");
+        return false;
+    }
+
+//spawn node-objects
+    for (uint8 i = BG_AV_NODES_FIRSTAID_STATION ; i < BG_AV_NODES_MAX; ++i)
+    {
+        if( i <= BG_AV_NODES_FROSTWOLF_HUT )
+        {
+            if(    !AddObject(i,BG_AV_OBJECTID_BANNER_A_B,BG_AV_ObjectPos[i][0],BG_AV_ObjectPos[i][1],BG_AV_ObjectPos[i][2],BG_AV_ObjectPos[i][3], 0, 0, sin(BG_AV_ObjectPos[i][3]/2), cos(BG_AV_ObjectPos[i][3]/2),RESPAWN_ONE_DAY)
+                || !AddObject(i+11,BG_AV_OBJECTID_BANNER_CONT_A_B,BG_AV_ObjectPos[i][0],BG_AV_ObjectPos[i][1],BG_AV_ObjectPos[i][2],BG_AV_ObjectPos[i][3], 0, 0, sin(BG_AV_ObjectPos[i][3]/2), cos(BG_AV_ObjectPos[i][3]/2),RESPAWN_ONE_DAY)
+                || !AddObject(i+33,BG_AV_OBJECTID_BANNER_H_B,BG_AV_ObjectPos[i][0],BG_AV_ObjectPos[i][1],BG_AV_ObjectPos[i][2],BG_AV_ObjectPos[i][3], 0, 0, sin(BG_AV_ObjectPos[i][3]/2), cos(BG_AV_ObjectPos[i][3]/2),RESPAWN_ONE_DAY)
+                || !AddObject(i+22,BG_AV_OBJECTID_BANNER_CONT_H_B,BG_AV_ObjectPos[i][0],BG_AV_ObjectPos[i][1],BG_AV_ObjectPos[i][2],BG_AV_ObjectPos[i][3], 0, 0, sin(BG_AV_ObjectPos[i][3]/2), cos(BG_AV_ObjectPos[i][3]/2),RESPAWN_ONE_DAY)
+                //aura
+                || !AddObject(BG_AV_OBJECT_AURA_N_FIRSTAID_STATION+i*3,BG_AV_OBJECTID_AURA_N,BG_AV_ObjectPos[i][0],BG_AV_ObjectPos[i][1],BG_AV_ObjectPos[i][2],BG_AV_ObjectPos[i][3], 0, 0, sin(BG_AV_ObjectPos[i][3]/2), cos(BG_AV_ObjectPos[i][3]/2),RESPAWN_ONE_DAY)
+                || !AddObject(BG_AV_OBJECT_AURA_A_FIRSTAID_STATION+i*3,BG_AV_OBJECTID_AURA_A,BG_AV_ObjectPos[i][0],BG_AV_ObjectPos[i][1],BG_AV_ObjectPos[i][2],BG_AV_ObjectPos[i][3], 0, 0, sin(BG_AV_ObjectPos[i][3]/2), cos(BG_AV_ObjectPos[i][3]/2),RESPAWN_ONE_DAY)
+                || !AddObject(BG_AV_OBJECT_AURA_H_FIRSTAID_STATION+i*3,BG_AV_OBJECTID_AURA_H,BG_AV_ObjectPos[i][0],BG_AV_ObjectPos[i][1],BG_AV_ObjectPos[i][2],BG_AV_ObjectPos[i][3], 0, 0, sin(BG_AV_ObjectPos[i][3]/2), cos(BG_AV_ObjectPos[i][3]/2),RESPAWN_ONE_DAY))
+            {
+                sLog.outError("BatteGroundAV: Failed to spawn some object BattleGround not created!2");
+                return false;
+            }
+        }
+        else //towers
+        {
+            if( i <= BG_AV_NODES_STONEHEART_BUNKER ) //alliance towers
+            {
+                if(   !AddObject(i,BG_AV_OBJECTID_BANNER_A,BG_AV_ObjectPos[i][0],BG_AV_ObjectPos[i][1],BG_AV_ObjectPos[i][2],BG_AV_ObjectPos[i][3], 0, 0, sin(BG_AV_ObjectPos[i][3]/2), cos(BG_AV_ObjectPos[i][3]/2),RESPAWN_ONE_DAY)
+                    || !AddObject(i+22,BG_AV_OBJECTID_BANNER_CONT_H,BG_AV_ObjectPos[i][0],BG_AV_ObjectPos[i][1],BG_AV_ObjectPos[i][2],BG_AV_ObjectPos[i][3], 0, 0, sin(BG_AV_ObjectPos[i][3]/2), cos(BG_AV_ObjectPos[i][3]/2),RESPAWN_ONE_DAY)
+                    || !AddObject(BG_AV_OBJECT_TAURA_A_DUNBALDAR_SOUTH+(2*(i-BG_AV_NODES_DUNBALDAR_SOUTH)),BG_AV_OBJECTID_AURA_A,BG_AV_ObjectPos[i+8][0],BG_AV_ObjectPos[i+8][1],BG_AV_ObjectPos[i+8][2],BG_AV_ObjectPos[i+8][3], 0, 0, sin(BG_AV_ObjectPos[i+8][3]/2), cos(BG_AV_ObjectPos[i+8][3]/2),RESPAWN_ONE_DAY)
+                    || !AddObject(BG_AV_OBJECT_TAURA_H_DUNBALDAR_SOUTH+(2*(i-BG_AV_NODES_DUNBALDAR_SOUTH)),BG_AV_OBJECTID_AURA_N,BG_AV_ObjectPos[i+8][0],BG_AV_ObjectPos[i+8][1],BG_AV_ObjectPos[i+8][2],BG_AV_ObjectPos[i+8][3], 0, 0, sin(BG_AV_ObjectPos[i+8][3]/2), cos(BG_AV_ObjectPos[i+8][3]/2),RESPAWN_ONE_DAY)
+                    || !AddObject(BG_AV_OBJECT_TFLAG_A_DUNBALDAR_SOUTH+(2*(i-BG_AV_NODES_DUNBALDAR_SOUTH)),BG_AV_OBJECTID_TOWER_BANNER_A,BG_AV_ObjectPos[i+8][0],BG_AV_ObjectPos[i+8][1],BG_AV_ObjectPos[i+8][2],BG_AV_ObjectPos[i+8][3], 0, 0, sin(BG_AV_ObjectPos[i+8][3]/2), cos(BG_AV_ObjectPos[i+8][3]/2),RESPAWN_ONE_DAY)
+                    || !AddObject(BG_AV_OBJECT_TFLAG_H_DUNBALDAR_SOUTH+(2*(i-BG_AV_NODES_DUNBALDAR_SOUTH)),BG_AV_OBJECTID_TOWER_BANNER_PH,BG_AV_ObjectPos[i+8][0],BG_AV_ObjectPos[i+8][1],BG_AV_ObjectPos[i+8][2],BG_AV_ObjectPos[i+8][3], 0, 0, sin(BG_AV_ObjectPos[i+8][3]/2), cos(BG_AV_ObjectPos[i+8][3]/2),RESPAWN_ONE_DAY))
+                {
+                    sLog.outError("BatteGroundAV: Failed to spawn some object BattleGround not created!3");
+                    return false;
+                }
+            }
+            else //horde towers
+            {
+                if(     !AddObject(i+7,BG_AV_OBJECTID_BANNER_CONT_A,BG_AV_ObjectPos[i][0],BG_AV_ObjectPos[i][1],BG_AV_ObjectPos[i][2],BG_AV_ObjectPos[i][3], 0, 0, sin(BG_AV_ObjectPos[i][3]/2), cos(BG_AV_ObjectPos[i][3]/2),RESPAWN_ONE_DAY)
+                    || !AddObject(i+29,BG_AV_OBJECTID_BANNER_H,BG_AV_ObjectPos[i][0],BG_AV_ObjectPos[i][1],BG_AV_ObjectPos[i][2],BG_AV_ObjectPos[i][3], 0, 0, sin(BG_AV_ObjectPos[i][3]/2), cos(BG_AV_ObjectPos[i][3]/2),RESPAWN_ONE_DAY)
+                    || !AddObject(BG_AV_OBJECT_TAURA_A_DUNBALDAR_SOUTH+(2*(i-BG_AV_NODES_DUNBALDAR_SOUTH)),BG_AV_OBJECTID_AURA_N,BG_AV_ObjectPos[i+8][0],BG_AV_ObjectPos[i+8][1],BG_AV_ObjectPos[i+8][2],BG_AV_ObjectPos[i+8][3], 0, 0, sin(BG_AV_ObjectPos[i+8][3]/2), cos(BG_AV_ObjectPos[i+8][3]/2),RESPAWN_ONE_DAY)
+                    || !AddObject(BG_AV_OBJECT_TAURA_H_DUNBALDAR_SOUTH+(2*(i-BG_AV_NODES_DUNBALDAR_SOUTH)),BG_AV_OBJECTID_AURA_H,BG_AV_ObjectPos[i+8][0],BG_AV_ObjectPos[i+8][1],BG_AV_ObjectPos[i+8][2],BG_AV_ObjectPos[i+8][3], 0, 0, sin(BG_AV_ObjectPos[i+8][3]/2), cos(BG_AV_ObjectPos[i+8][3]/2),RESPAWN_ONE_DAY)
+                    || !AddObject(BG_AV_OBJECT_TFLAG_A_DUNBALDAR_SOUTH+(2*(i-BG_AV_NODES_DUNBALDAR_SOUTH)),BG_AV_OBJECTID_TOWER_BANNER_PA,BG_AV_ObjectPos[i+8][0],BG_AV_ObjectPos[i+8][1],BG_AV_ObjectPos[i+8][2],BG_AV_ObjectPos[i+8][3], 0, 0, sin(BG_AV_ObjectPos[i+8][3]/2), cos(BG_AV_ObjectPos[i+8][3]/2),RESPAWN_ONE_DAY)
+                    || !AddObject(BG_AV_OBJECT_TFLAG_H_DUNBALDAR_SOUTH+(2*(i-BG_AV_NODES_DUNBALDAR_SOUTH)),BG_AV_OBJECTID_TOWER_BANNER_H,BG_AV_ObjectPos[i+8][0],BG_AV_ObjectPos[i+8][1],BG_AV_ObjectPos[i+8][2],BG_AV_ObjectPos[i+8][3], 0, 0, sin(BG_AV_ObjectPos[i+8][3]/2), cos(BG_AV_ObjectPos[i+8][3]/2),RESPAWN_ONE_DAY))
+                {
+                    sLog.outError("BatteGroundAV: Failed to spawn some object BattleGround not created!4");
+                    return false;
+                }
+            }
+            for(uint8 j=0; j<=9; j++) //burning aura
+            {
+                if(!AddObject(BG_AV_OBJECT_BURN_DUNBALDAR_SOUTH+((i-BG_AV_NODES_DUNBALDAR_SOUTH)*10)+j,BG_AV_OBJECTID_FIRE,BG_AV_ObjectPos[AV_OPLACE_BURN_DUNBALDAR_SOUTH+((i-BG_AV_NODES_DUNBALDAR_SOUTH)*10)+j][0],BG_AV_ObjectPos[AV_OPLACE_BURN_DUNBALDAR_SOUTH+((i-BG_AV_NODES_DUNBALDAR_SOUTH)*10)+j][1],BG_AV_ObjectPos[AV_OPLACE_BURN_DUNBALDAR_SOUTH+((i-BG_AV_NODES_DUNBALDAR_SOUTH)*10)+j][2],BG_AV_ObjectPos[AV_OPLACE_BURN_DUNBALDAR_SOUTH+((i-BG_AV_NODES_DUNBALDAR_SOUTH)*10)+j][3], 0, 0, sin(BG_AV_ObjectPos[AV_OPLACE_BURN_DUNBALDAR_SOUTH+((i-BG_AV_NODES_DUNBALDAR_SOUTH)*10)+j][3]/2), cos(BG_AV_ObjectPos[AV_OPLACE_BURN_DUNBALDAR_SOUTH+((i-BG_AV_NODES_DUNBALDAR_SOUTH)*10)+j][3]/2),RESPAWN_ONE_DAY))
+                {
+                    sLog.outError("BatteGroundAV: Failed to spawn some object BattleGround not created!5.%i",i);
+                    return false;
+                }
+            }
+        }
+    }
+    for(uint8 i=0;i<2;i++) //burning aura for buildings
+    {
+        for(uint8 j=0; j<=9; j++)
+        {
+            if(j<5)
+            {
+                if(!AddObject(BG_AV_OBJECT_BURN_BUILDING_ALLIANCE+(i*10)+j,BG_AV_OBJECTID_SMOKE,BG_AV_ObjectPos[AV_OPLACE_BURN_BUILDING_A+(i*10)+j][0],BG_AV_ObjectPos[AV_OPLACE_BURN_BUILDING_A+(i*10)+j][1],BG_AV_ObjectPos[AV_OPLACE_BURN_BUILDING_A+(i*10)+j][2],BG_AV_ObjectPos[AV_OPLACE_BURN_BUILDING_A+(i*10)+j][3], 0, 0, sin(BG_AV_ObjectPos[AV_OPLACE_BURN_BUILDING_A+(i*10)+j][3]/2), cos(BG_AV_ObjectPos[AV_OPLACE_BURN_BUILDING_A+(i*10)+j][3]/2),RESPAWN_ONE_DAY))
+                {
+                    sLog.outError("BatteGroundAV: Failed to spawn some object BattleGround not created!6.%i",i);
+                    return false;
+                }
+            }
+            else
+            {
+                if(!AddObject(BG_AV_OBJECT_BURN_BUILDING_ALLIANCE+(i*10)+j,BG_AV_OBJECTID_FIRE,BG_AV_ObjectPos[AV_OPLACE_BURN_BUILDING_A+(i*10)+j][0],BG_AV_ObjectPos[AV_OPLACE_BURN_BUILDING_A+(i*10)+j][1],BG_AV_ObjectPos[AV_OPLACE_BURN_BUILDING_A+(i*10)+j][2],BG_AV_ObjectPos[AV_OPLACE_BURN_BUILDING_A+(i*10)+j][3], 0, 0, sin(BG_AV_ObjectPos[AV_OPLACE_BURN_BUILDING_A+(i*10)+j][3]/2), cos(BG_AV_ObjectPos[AV_OPLACE_BURN_BUILDING_A+(i*10)+j][3]/2),RESPAWN_ONE_DAY))
+                {
+                    sLog.outError("BatteGroundAV: Failed to spawn some object BattleGround not created!7.%i",i);
+                    return false;
+                }
+            }
+        }
+    }
+    for(uint16 i= 0; i<=(BG_AV_OBJECT_MINE_SUPPLY_N_MAX-BG_AV_OBJECT_MINE_SUPPLY_N_MIN);i++)
+    {
+        if(!AddObject(BG_AV_OBJECT_MINE_SUPPLY_N_MIN+i,BG_AV_OBJECTID_MINE_N,BG_AV_ObjectPos[AV_OPLACE_MINE_SUPPLY_N_MIN+i][0],BG_AV_ObjectPos[AV_OPLACE_MINE_SUPPLY_N_MIN+i][1],BG_AV_ObjectPos[AV_OPLACE_MINE_SUPPLY_N_MIN+i][2],BG_AV_ObjectPos[AV_OPLACE_MINE_SUPPLY_N_MIN+i][3], 0, 0, sin(BG_AV_ObjectPos[AV_OPLACE_MINE_SUPPLY_N_MIN+i][3]/2), cos(BG_AV_ObjectPos[AV_OPLACE_MINE_SUPPLY_N_MIN+i][3]/2),RESPAWN_ONE_DAY))
+        {
+            sLog.outError("BatteGroundAV: Failed to spawn some mine supplies BattleGround not created!7.5.%i",i);
+            return false;
+        }
+    }
+    for(uint16 i= 0 ; i<=(BG_AV_OBJECT_MINE_SUPPLY_S_MAX-BG_AV_OBJECT_MINE_SUPPLY_S_MIN);i++)
+    {
+        if(!AddObject(BG_AV_OBJECT_MINE_SUPPLY_S_MIN+i,BG_AV_OBJECTID_MINE_S,BG_AV_ObjectPos[AV_OPLACE_MINE_SUPPLY_S_MIN+i][0],BG_AV_ObjectPos[AV_OPLACE_MINE_SUPPLY_S_MIN+i][1],BG_AV_ObjectPos[AV_OPLACE_MINE_SUPPLY_S_MIN+i][2],BG_AV_ObjectPos[AV_OPLACE_MINE_SUPPLY_S_MIN+i][3], 0, 0, sin(BG_AV_ObjectPos[AV_OPLACE_MINE_SUPPLY_S_MIN+i][3]/2), cos(BG_AV_ObjectPos[AV_OPLACE_MINE_SUPPLY_S_MIN+i][3]/2),RESPAWN_ONE_DAY))
+        {
+            sLog.outError("BatteGroundAV: Failed to spawn some mine supplies BattleGround not created!7.6.%i",i);
+            return false;
+        }
+    }
+
+    if(!AddObject(BG_AV_OBJECT_FLAG_N_SNOWFALL_GRAVE, BG_AV_OBJECTID_BANNER_SNOWFALL_N ,BG_AV_ObjectPos[BG_AV_NODES_SNOWFALL_GRAVE][0],BG_AV_ObjectPos[BG_AV_NODES_SNOWFALL_GRAVE][1],BG_AV_ObjectPos[BG_AV_NODES_SNOWFALL_GRAVE][2],BG_AV_ObjectPos[BG_AV_NODES_SNOWFALL_GRAVE][3],0,0,sin(BG_AV_ObjectPos[BG_AV_NODES_SNOWFALL_GRAVE][3]/2), cos(BG_AV_ObjectPos[BG_AV_NODES_SNOWFALL_GRAVE][3]/2), RESPAWN_ONE_DAY))
+    {
+        sLog.outError("BatteGroundAV: Failed to spawn some object BattleGround not created!8");
+        return false;
+    }
+    for(uint8 i = 0; i < 4; i++)
+    {
+        if(!AddObject(BG_AV_OBJECT_SNOW_EYECANDY_A+i, BG_AV_OBJECTID_SNOWFALL_CANDY_A ,BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][0],BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][1],BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][2],BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][3],0,0,sin(BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][3]/2), cos(BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][3]/2), RESPAWN_ONE_DAY)
+            || !AddObject(BG_AV_OBJECT_SNOW_EYECANDY_PA+i, BG_AV_OBJECTID_SNOWFALL_CANDY_PA ,BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][0],BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][1],BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][2],BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][3],0,0,sin(BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][3]/2), cos(BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][3]/2), RESPAWN_ONE_DAY)
+            || !AddObject(BG_AV_OBJECT_SNOW_EYECANDY_H+i, BG_AV_OBJECTID_SNOWFALL_CANDY_H ,BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][0],BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][1],BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][2],BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][3],0,0,sin(BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][3]/2), cos(BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][3]/2), RESPAWN_ONE_DAY)
+            || !AddObject(BG_AV_OBJECT_SNOW_EYECANDY_PH+i, BG_AV_OBJECTID_SNOWFALL_CANDY_PH ,BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][0],BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][1],BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][2],BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][3],0,0,sin(BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][3]/2), cos(BG_AV_ObjectPos[AV_OPLACE_SNOW_1+i][3]/2), RESPAWN_ONE_DAY))
+        {
+            sLog.outError("BatteGroundAV: Failed to spawn some object BattleGround not created!9.%i",i);
+            return false;
+        }
+    }
+    return true;
+}
+
+const char* BattleGroundAV::GetNodeName(BG_AV_Nodes node)
+{
+    switch (node)
+    {
+        case BG_AV_NODES_FIRSTAID_STATION:  return GetMangosString(LANG_BG_AV_NODE_GRAVE_STORM_AID);
+        case BG_AV_NODES_DUNBALDAR_SOUTH:   return GetMangosString(LANG_BG_AV_NODE_TOWER_DUN_S);
+        case BG_AV_NODES_DUNBALDAR_NORTH:   return GetMangosString(LANG_BG_AV_NODE_TOWER_DUN_N);
+        case BG_AV_NODES_STORMPIKE_GRAVE:   return GetMangosString(LANG_BG_AV_NODE_GRAVE_STORMPIKE);
+        case BG_AV_NODES_ICEWING_BUNKER:    return GetMangosString(LANG_BG_AV_NODE_TOWER_ICEWING);
+        case BG_AV_NODES_STONEHEART_GRAVE:  return GetMangosString(LANG_BG_AV_NODE_GRAVE_STONE);
+        case BG_AV_NODES_STONEHEART_BUNKER: return GetMangosString(LANG_BG_AV_NODE_TOWER_STONE);
+        case BG_AV_NODES_SNOWFALL_GRAVE:    return GetMangosString(LANG_BG_AV_NODE_GRAVE_SNOW);
+        case BG_AV_NODES_ICEBLOOD_TOWER:    return GetMangosString(LANG_BG_AV_NODE_TOWER_ICE);
+        case BG_AV_NODES_ICEBLOOD_GRAVE:    return GetMangosString(LANG_BG_AV_NODE_GRAVE_ICE);
+        case BG_AV_NODES_TOWER_POINT:       return GetMangosString(LANG_BG_AV_NODE_TOWER_POINT);
+        case BG_AV_NODES_FROSTWOLF_GRAVE:   return GetMangosString(LANG_BG_AV_NODE_GRAVE_FROST);
+        case BG_AV_NODES_FROSTWOLF_ETOWER:  return GetMangosString(LANG_BG_AV_NODE_TOWER_FROST_E);
+        case BG_AV_NODES_FROSTWOLF_WTOWER:  return GetMangosString(LANG_BG_AV_NODE_TOWER_FROST_W);
+        case BG_AV_NODES_FROSTWOLF_HUT:     return GetMangosString(LANG_BG_AV_NODE_GRAVE_FROST_HUT);
+        default:
+            {
+            sLog.outError("tried to get name for node %u%",node);
+            return "Unknown";
+            break;
+            }
+    }
+}
+
+void BattleGroundAV::AssaultNode(BG_AV_Nodes node, uint16 team)
+{
+    assert(m_Nodes[node].TotalOwner != team);
+    assert(m_Nodes[node].Owner != team);
+    assert(m_Nodes[node].State != POINT_DESTROYED);
+    assert(m_Nodes[node].State != POINT_ASSAULTED || !m_Nodes[node].TotalOwner ); //only assault an assaulted node if no totalowner exists
+    //the timer gets another time, if the previous owner was 0==Neutral
+    m_Nodes[node].Timer      = (m_Nodes[node].PrevOwner)? BG_AV_CAPTIME : BG_AV_SNOWFALL_FIRSTCAP;
+    m_Nodes[node].PrevOwner  = m_Nodes[node].Owner;
+    m_Nodes[node].Owner      = team;
+    m_Nodes[node].PrevState  = m_Nodes[node].State;
+    m_Nodes[node].State      = POINT_ASSAULTED;
+}
+
+void BattleGroundAV::DestroyNode(BG_AV_Nodes node)
+{
+    assert(m_Nodes[node].State == POINT_ASSAULTED);
+
+    m_Nodes[node].TotalOwner = m_Nodes[node].Owner;
+    m_Nodes[node].PrevOwner  = m_Nodes[node].Owner;
+    m_Nodes[node].PrevState  = m_Nodes[node].State;
+    m_Nodes[node].State      = (m_Nodes[node].Tower)? POINT_DESTROYED : POINT_CONTROLED;
+    m_Nodes[node].Timer      = 0;
+}
+
+void BattleGroundAV::InitNode(BG_AV_Nodes node, uint16 team, bool tower)
+{
+    m_Nodes[node].TotalOwner = team;
+    m_Nodes[node].Owner      = team;
+    m_Nodes[node].PrevOwner  = 0;
+    m_Nodes[node].State      = POINT_CONTROLED;
+    m_Nodes[node].PrevState  = m_Nodes[node].State;
+    m_Nodes[node].State      = POINT_CONTROLED;
+    m_Nodes[node].Timer      = 0;
+    m_Nodes[node].Tower      = tower;
+}
+
+void BattleGroundAV::DefendNode(BG_AV_Nodes node, uint16 team)
+{
+    assert(m_Nodes[node].TotalOwner == team);
+    assert(m_Nodes[node].Owner != team);
+    assert(m_Nodes[node].State != POINT_CONTROLED && m_Nodes[node].State != POINT_DESTROYED);
+    m_Nodes[node].PrevOwner  = m_Nodes[node].Owner;
+    m_Nodes[node].Owner      = team;
+    m_Nodes[node].PrevState  = m_Nodes[node].State;
+    m_Nodes[node].State      = POINT_CONTROLED;
+    m_Nodes[node].Timer      = 0;
+}
+
+void BattleGroundAV::ResetBGSubclass()
+{
+    m_MaxLevel=0;
+    for(uint8 i=0; i<2; i++) //forloop for both teams (it just make 0==alliance and 1==horde also for both mines 0=north 1=south
+    {
+        for(uint8 j=0; j<9; j++)
+            m_Team_QuestStatus[i][j]=0;
+    	m_Team_Scores[i]=BG_AV_SCORE_INITIAL_POINTS;
+        m_IsInformedNearVictory[i]=false;
+        m_CaptainAlive[i] = true;
+        m_CaptainBuffTimer[i] = 120000 + urand(0,4)* 60; //as far as i could see, the buff is randomly so i make 2minutes (thats the duration of the buff itself) + 0-4minutes TODO get the right times
+        m_Mine_Owner[i] = AV_NEUTRAL_TEAM;
+        m_Mine_PrevOwner[i] = m_Mine_Owner[i];
+    }
+    for(BG_AV_Nodes i = BG_AV_NODES_FIRSTAID_STATION; i <= BG_AV_NODES_STONEHEART_GRAVE; ++i) //alliance graves
+        InitNode(i,ALLIANCE,false);
+	for(BG_AV_Nodes i = BG_AV_NODES_DUNBALDAR_SOUTH; i <= BG_AV_NODES_STONEHEART_BUNKER; ++i) //alliance towers
+        InitNode(i,ALLIANCE,true);
+    for(BG_AV_Nodes i = BG_AV_NODES_ICEBLOOD_GRAVE; i <= BG_AV_NODES_FROSTWOLF_HUT; ++i) //horde graves
+        InitNode(i,HORDE,false);
+    for(BG_AV_Nodes i = BG_AV_NODES_ICEBLOOD_TOWER; i <= BG_AV_NODES_FROSTWOLF_WTOWER; ++i) //horde towers
+        InitNode(i,HORDE,true);
+    InitNode(BG_AV_NODES_SNOWFALL_GRAVE,AV_NEUTRAL_TEAM,false); //give snowfall neutral owner
+
+    m_Mine_Timer=AV_MINE_TICK_TIMER;
+    for(uint16 i = 0; i < AV_CPLACE_MAX+AV_STATICCPLACE_MAX; i++)
+        if(m_BgCreatures[i])
+            DelCreature(i);
+
+}
+
diff --git a/src/game/BattleGroundAV.h b/src/game/BattleGroundAV.h
index 11bd08b..e4a0ff8 100644
--- a/src/game/BattleGroundAV.h
+++ b/src/game/BattleGroundAV.h
@@ -21,6 +21,1459 @@
 
 class BattleGround;
 
+#define LANG_BG_AV_A_CAPTAIN_BUFF       "Take heart, Alliance! Throw these villains from Alterac Valley!"
+#define LANG_BG_AV_H_CAPTAIN_BUFF       "Now is the time to attack! For the Horde!"
+
+#define LANG_BG_AV_S_MINE_BOSS_CLAIMS   "Snivvle is here! Snivvle claims the Coldtooth Mine!"
+
+#define SEND_MSG_NEAR_LOSE               120
+#define BG_AV_SPIRITGUIDE_ENTRY_A        13116
+#define BG_AV_CAPTIME                    240000  //4:00
+#define BG_AV_SNOWFALL_FIRSTCAP          300000  //5:00 but i also have seen 4:05
+#define BG_AV_SCORE_INITIAL_POINTS       600
+#define BG_AV_BANNER_RESPAWN_TIMER       3000
+
+#define BG_AV_REP_BOSS                  100 //not sure
+#define BG_AV_HONOR_BOSS                80 //not sure (4kills)
+#define BG_AV_REP_CAPTAIN               125 //not sure
+#define BG_AV_KILL_CAPTAIN              3
+#define BG_AV_RES_CAPTAIN               100
+#define BG_AV_REP_TOWER                 12
+#define BG_AV_KILL_TOWER                 3
+#define BG_AV_RES_TOWER                 75
+#define BG_AV_KILL_COMMANDER            1 //for a safely returned wingcommander
+//bonushonor at the end
+#define BG_AV_SURVIVING_TOWER           2
+#define BG_AV_SURVIVING_CAPTAIN         2
+
+
+enum BG_AV_Sounds
+{ //TODO: get out if there comes a sound when neutral team captures mine
+
+/*
+8212:
+    alliance grave assault
+    alliance tower assault
+    drek "mlanzenabschaum! In meiner Burg?! Toetet sie all" - nicht immer der sound
+8333:
+    galv "sterbt fuer euch ist kein platz hier"
+
+8332:
+    bal "Verschwinde, dreckiger Abschaum! Die Allianz wird im Alteractal "
+8174:
+    horde tower assault
+    horde grave assault
+    van "es Sturmlanzenklans, euer General wird angegriffen! Ich fordere Unterst"
+8173:
+    ally grave capture/defend
+    tower destroy
+    mine capture
+    ally wins
+8192:
+    ally tower destroy(only iceblood - found a bug^^)
+    ally tower  defend
+    horde tower defend
+8213
+horde:
+    grave defend/capture
+    tower destroy
+    mine capture
+    horde wins
+    */
+
+    AV_SOUND_NEAR_VICTORY                   = 8456, //not confirmed yet
+
+    AV_SOUND_ALLIANCE_ASSAULTS              = 8212, //tower,grave + enemy boss if someone tries to attack him
+    AV_SOUND_HORDE_ASSAULTS                 = 8174,
+    AV_SOUND_ALLIANCE_GOOD                  = 8173, //if something good happens for the team:  wins(maybe only through killing the boss), captures mine or grave, destroys tower and defends grave
+    AV_SOUND_HORDE_GOOD                     = 8213,
+    AV_SOUND_BOTH_TOWER_DEFEND              = 8192,
+
+    AV_SOUND_ALLIANCE_CAPTAIN               = 8232, //gets called when someone attacks them and at the beginning after 3min+rand(x)*10sec (maybe buff)
+    AV_SOUND_HORDE_CAPTAIN                  = 8333,
+
+
+};
+
+enum BG_AV_OTHER_VALUES
+{
+    AV_STATICCPLACE_MAX        = 128,
+    AV_NORTH_MINE              = 0,
+    AV_SOUTH_MINE              = 1,
+    AV_MINE_TICK_TIMER         = 45000,
+    AV_MINE_RECLAIM_TIMER      = 1200000, //TODO: get the right value.. this is currently 20 minutes
+    AV_NEUTRAL_TEAM            = 0 //this is the neutral owner of snowfall
+};
+enum BG_AV_ObjectIds
+{
+    //cause the mangos-system is a bit different, we don't use the right go-ids for every node.. if we want to be 100% like another big server, we must take one object for every node
+    //snowfall 4flags as eyecandy 179424 (alliance neutral)
+    //Banners - stolen from battleground_AB.h ;-)
+    BG_AV_OBJECTID_BANNER_A             = 178925, // can only be used by horde
+    BG_AV_OBJECTID_BANNER_H             = 178943, // can only be used by alliance
+    BG_AV_OBJECTID_BANNER_CONT_A        = 178940, // can only be used by horde
+    BG_AV_OBJECTID_BANNER_CONT_H        = 179435, // can only be used by alliance
+
+    BG_AV_OBJECTID_BANNER_A_B           = 178365,
+    BG_AV_OBJECTID_BANNER_H_B           = 178364,
+    BG_AV_OBJECTID_BANNER_CONT_A_B      = 179286,
+    BG_AV_OBJECTID_BANNER_CONT_H_B      = 179287,
+    BG_AV_OBJECTID_BANNER_SNOWFALL_N    = 180418,
+
+    //snowfall eyecandy banner:
+    BG_AV_OBJECTID_SNOWFALL_CANDY_A     = 179044,
+    BG_AV_OBJECTID_SNOWFALL_CANDY_PA    = 179424,
+    BG_AV_OBJECTID_SNOWFALL_CANDY_H     = 179064,
+    BG_AV_OBJECTID_SNOWFALL_CANDY_PH    = 179425,
+
+    //banners on top of towers:
+    BG_AV_OBJECTID_TOWER_BANNER_A  = 178927, //[PH] Alliance A1 Tower Banner BIG
+    BG_AV_OBJECTID_TOWER_BANNER_H  = 178955, //[PH] Horde H1 Tower Banner BIG
+    BG_AV_OBJECTID_TOWER_BANNER_PA = 179446, //[PH] Alliance H1 Tower Pre-Banner BIG
+    BG_AV_OBJECTID_TOWER_BANNER_PH = 179436, //[PH] Horde A1 Tower Pre-Banner BIG
+
+    //Auras
+    BG_AV_OBJECTID_AURA_A               = 180421,
+    BG_AV_OBJECTID_AURA_H               = 180422,
+    BG_AV_OBJECTID_AURA_N               = 180423,
+    BG_AV_OBJECTID_AURA_A_S             = 180100,
+    BG_AV_OBJECTID_AURA_H_S             = 180101,
+    BG_AV_OBJECTID_AURA_N_S             = 180102,
+
+    BG_AV_OBJECTID_GATE_A               = 180424,
+    BG_AV_OBJECTID_GATE_H               = 180424,
+
+    //mine supplies
+    BG_AV_OBJECTID_MINE_N        = 178785,
+    BG_AV_OBJECTID_MINE_S       = 178784,
+
+    BG_AV_OBJECTID_FIRE                 = 179065,
+    BG_AV_OBJECTID_SMOKE                 = 179066
+};
+
+enum BG_AV_Nodes
+{
+    BG_AV_NODES_FIRSTAID_STATION        = 0,
+    BG_AV_NODES_STORMPIKE_GRAVE         = 1,
+    BG_AV_NODES_STONEHEART_GRAVE        = 2,
+    BG_AV_NODES_SNOWFALL_GRAVE          = 3,
+    BG_AV_NODES_ICEBLOOD_GRAVE          = 4,
+    BG_AV_NODES_FROSTWOLF_GRAVE         = 5,
+    BG_AV_NODES_FROSTWOLF_HUT           = 6,
+    BG_AV_NODES_DUNBALDAR_SOUTH         = 7,
+    BG_AV_NODES_DUNBALDAR_NORTH         = 8,
+    BG_AV_NODES_ICEWING_BUNKER          = 9,
+    BG_AV_NODES_STONEHEART_BUNKER       = 10,
+    BG_AV_NODES_ICEBLOOD_TOWER          = 11,
+    BG_AV_NODES_TOWER_POINT             = 12,
+    BG_AV_NODES_FROSTWOLF_ETOWER        = 13,
+    BG_AV_NODES_FROSTWOLF_WTOWER        = 14,
+
+    BG_AV_NODES_MAX                     = 15
+};
+
+enum BG_AV_ObjectTypes
+{
+    BG_AV_OBJECT_FLAG_A_FIRSTAID_STATION    = 0,
+    BG_AV_OBJECT_FLAG_A_STORMPIKE_GRAVE     = 1,
+    BG_AV_OBJECT_FLAG_A_STONEHEART_GRAVE    = 2,
+    BG_AV_OBJECT_FLAG_A_SNOWFALL_GRAVE      = 3,
+    BG_AV_OBJECT_FLAG_A_ICEBLOOD_GRAVE      = 4,
+    BG_AV_OBJECT_FLAG_A_FROSTWOLF_GRAVE     = 5,
+    BG_AV_OBJECT_FLAG_A_FROSTWOLF_HUT       = 6,
+    BG_AV_OBJECT_FLAG_A_DUNBALDAR_SOUTH     = 7,
+    BG_AV_OBJECT_FLAG_A_DUNBALDAR_NORTH     = 8,
+    BG_AV_OBJECT_FLAG_A_ICEWING_BUNKER      = 9,
+    BG_AV_OBJECT_FLAG_A_STONEHEART_BUNKER   = 10,
+
+    BG_AV_OBJECT_FLAG_C_A_FIRSTAID_STATION    = 11,
+    BG_AV_OBJECT_FLAG_C_A_STORMPIKE_GRAVE     = 12,
+    BG_AV_OBJECT_FLAG_C_A_STONEHEART_GRAVE    = 13,
+    BG_AV_OBJECT_FLAG_C_A_SNOWFALL_GRAVE      = 14,
+    BG_AV_OBJECT_FLAG_C_A_ICEBLOOD_GRAVE      = 15,
+    BG_AV_OBJECT_FLAG_C_A_FROSTWOLF_GRAVE     = 16,
+    BG_AV_OBJECT_FLAG_C_A_FROSTWOLF_HUT       = 17,
+    BG_AV_OBJECT_FLAG_C_A_ICEBLOOD_TOWER      = 18,
+    BG_AV_OBJECT_FLAG_C_A_TOWER_POINT         = 19,
+    BG_AV_OBJECT_FLAG_C_A_FROSTWOLF_ETOWER    = 20,
+    BG_AV_OBJECT_FLAG_C_A_FROSTWOLF_WTOWER    = 21,
+
+    BG_AV_OBJECT_FLAG_C_H_FIRSTAID_STATION    = 22,
+    BG_AV_OBJECT_FLAG_C_H_STORMPIKE_GRAVE     = 23,
+    BG_AV_OBJECT_FLAG_C_H_STONEHEART_GRAVE    = 24,
+    BG_AV_OBJECT_FLAG_C_H_SNOWFALL_GRAVE      = 25,
+    BG_AV_OBJECT_FLAG_C_H_ICEBLOOD_GRAVE      = 26,
+    BG_AV_OBJECT_FLAG_C_H_FROSTWOLF_GRAVE     = 27,
+    BG_AV_OBJECT_FLAG_C_H_FROSTWOLF_HUT       = 28,
+    BG_AV_OBJECT_FLAG_C_H_DUNBALDAR_SOUTH     = 29,
+    BG_AV_OBJECT_FLAG_C_H_DUNBALDAR_NORTH     = 30,
+    BG_AV_OBJECT_FLAG_C_H_ICEWING_BUNKER      = 31,
+    BG_AV_OBJECT_FLAG_C_H_STONEHEART_BUNKER   = 32,
+
+    BG_AV_OBJECT_FLAG_H_FIRSTAID_STATION    = 33,
+    BG_AV_OBJECT_FLAG_H_STORMPIKE_GRAVE     = 34,
+    BG_AV_OBJECT_FLAG_H_STONEHEART_GRAVE    = 35,
+    BG_AV_OBJECT_FLAG_H_SNOWFALL_GRAVE      = 36,
+    BG_AV_OBJECT_FLAG_H_ICEBLOOD_GRAVE      = 37,
+    BG_AV_OBJECT_FLAG_H_FROSTWOLF_GRAVE     = 38,
+    BG_AV_OBJECT_FLAG_H_FROSTWOLF_HUT       = 39,
+    BG_AV_OBJECT_FLAG_H_ICEBLOOD_TOWER      = 40,
+    BG_AV_OBJECT_FLAG_H_TOWER_POINT         = 41,
+    BG_AV_OBJECT_FLAG_H_FROSTWOLF_ETOWER    = 42,
+    BG_AV_OBJECT_FLAG_H_FROSTWOLF_WTOWER    = 43,
+
+    BG_AV_OBJECT_FLAG_N_SNOWFALL_GRAVE      = 44,
+
+    BG_AV_OBJECT_DOOR_H                     = 45,
+    BG_AV_OBJECT_DOOR_A                     = 46,
+//auras for graveyards (3auras per graveyard neutral,alliance,horde)
+    BG_AV_OBJECT_AURA_N_FIRSTAID_STATION    = 47,
+    BG_AV_OBJECT_AURA_A_FIRSTAID_STATION    = 48,
+    BG_AV_OBJECT_AURA_H_FIRSTAID_STATION    = 49,
+    BG_AV_OBJECT_AURA_N_STORMPIKE_GRAVE     = 50,
+    BG_AV_OBJECT_AURA_A_STORMPIKE_GRAVE     = 51,
+    BG_AV_OBJECT_AURA_H_STORMPIKE_GRAVE     = 52,
+    BG_AV_OBJECT_AURA_N_STONEHEART_GRAVE    = 53,
+    BG_AV_OBJECT_AURA_A_STONEHEART_GRAVE    = 54,
+    BG_AV_OBJECT_AURA_H_STONEHEART_GRAVE    = 55,
+    BG_AV_OBJECT_AURA_N_SNOWFALL_GRAVE      = 56,
+    BG_AV_OBJECT_AURA_A_SNOWFALL_GRAVE      = 57,
+    BG_AV_OBJECT_AURA_H_SNOWFALL_GRAVE      = 58,
+    BG_AV_OBJECT_AURA_N_ICEBLOOD_GRAVE      = 59,
+    BG_AV_OBJECT_AURA_A_ICEBLOOD_GRAVE      = 60,
+    BG_AV_OBJECT_AURA_H_ICEBLOOD_GRAVE      = 61,
+    BG_AV_OBJECT_AURA_N_FROSTWOLF_GRAVE     = 62,
+    BG_AV_OBJECT_AURA_A_FROSTWOLF_GRAVE     = 63,
+    BG_AV_OBJECT_AURA_H_FROSTWOLF_GRAVE     = 64,
+    BG_AV_OBJECT_AURA_N_FROSTWOLF_HUT       = 65,
+    BG_AV_OBJECT_AURA_A_FROSTWOLF_HUT       = 66,
+    BG_AV_OBJECT_AURA_H_FROSTWOLF_HUT       = 67,
+
+    //big flags on top of towers 2 flags on each (contested,(alliance | horde)) + 2 auras
+    BG_AV_OBJECT_TFLAG_A_DUNBALDAR_SOUTH     = 67,
+    BG_AV_OBJECT_TFLAG_H_DUNBALDAR_SOUTH     = 68,
+    BG_AV_OBJECT_TFLAG_A_DUNBALDAR_NORTH     = 69,
+    BG_AV_OBJECT_TFLAG_H_DUNBALDAR_NORTH     = 70,
+    BG_AV_OBJECT_TFLAG_A_ICEWING_BUNKER      = 71,
+    BG_AV_OBJECT_TFLAG_H_ICEWING_BUNKER      = 72,
+    BG_AV_OBJECT_TFLAG_A_STONEHEART_BUNKER   = 73,
+    BG_AV_OBJECT_TFLAG_H_STONEHEART_BUNKER   = 74,
+    BG_AV_OBJECT_TFLAG_A_ICEBLOOD_TOWER      = 75,
+    BG_AV_OBJECT_TFLAG_H_ICEBLOOD_TOWER      = 76,
+    BG_AV_OBJECT_TFLAG_A_TOWER_POINT         = 77,
+    BG_AV_OBJECT_TFLAG_H_TOWER_POINT         = 78,
+    BG_AV_OBJECT_TFLAG_A_FROSTWOLF_ETOWER    = 79,
+    BG_AV_OBJECT_TFLAG_H_FROSTWOLF_ETOWER    = 80,
+    BG_AV_OBJECT_TFLAG_A_FROSTWOLF_WTOWER    = 81,
+    BG_AV_OBJECT_TFLAG_H_FROSTWOLF_WTOWER    = 82,
+    BG_AV_OBJECT_TAURA_A_DUNBALDAR_SOUTH     = 83,
+    BG_AV_OBJECT_TAURA_H_DUNBALDAR_SOUTH     = 84,
+    BG_AV_OBJECT_TAURA_A_DUNBALDAR_NORTH     = 85,
+    BG_AV_OBJECT_TAURA_H_DUNBALDAR_NORTH     = 86,
+    BG_AV_OBJECT_TAURA_A_ICEWING_BUNKER      = 87,
+    BG_AV_OBJECT_TAURA_H_ICEWING_BUNKER      = 88,
+    BG_AV_OBJECT_TAURA_A_STONEHEART_BUNKER   = 89,
+    BG_AV_OBJECT_TAURA_H_STONEHEART_BUNKER   = 90,
+    BG_AV_OBJECT_TAURA_A_ICEBLOOD_TOWER      = 91,
+    BG_AV_OBJECT_TAURA_H_ICEBLOOD_TOWER      = 92,
+    BG_AV_OBJECT_TAURA_A_TOWER_POINT         = 93,
+    BG_AV_OBJECT_TAURA_H_TOWER_POINT         = 94,
+    BG_AV_OBJECT_TAURA_A_FROSTWOLF_ETOWER    = 95,
+    BG_AV_OBJECT_TAURA_H_FROSTWOLF_ETOWER    = 96,
+    BG_AV_OBJECT_TAURA_A_FROSTWOLF_WTOWER    = 97,
+    BG_AV_OBJECT_TAURA_H_FROSTWOLF_WTOWER    = 98,
+
+    BG_AV_OBJECT_BURN_DUNBALDAR_SOUTH        = 99,
+    BG_AV_OBJECT_BURN_DUNBALDAR_NORTH        = 109,
+    BG_AV_OBJECT_BURN_ICEWING_BUNKER         = 119,
+    BG_AV_OBJECT_BURN_STONEHEART_BUNKER      = 129,
+    BG_AV_OBJECT_BURN_ICEBLOOD_TOWER         = 139,
+    BG_AV_OBJECT_BURN_TOWER_POINT            = 149,
+    BG_AV_OBJECT_BURN_FROSTWOLF_ETWOER       = 159,
+    BG_AV_OBJECT_BURN_FROSTWOLF_WTOWER       = 169,
+    BG_AV_OBJECT_BURN_BUILDING_ALLIANCE      = 179,
+    BG_AV_OBJECT_BURN_BUILDING_HORDE         = 189,
+    BG_AV_OBJECT_SNOW_EYECANDY_A             = 199,
+    BG_AV_OBJECT_SNOW_EYECANDY_PA            = 203,
+    BG_AV_OBJECT_SNOW_EYECANDY_H             = 207,
+    BG_AV_OBJECT_SNOW_EYECANDY_PH            = 211,
+    BG_AV_OBJECT_MINE_SUPPLY_N_MIN           = 215,
+    BG_AV_OBJECT_MINE_SUPPLY_N_MAX           = 224,
+    BG_AV_OBJECT_MINE_SUPPLY_S_MIN           = 225,
+    BG_AV_OBJECT_MINE_SUPPLY_S_MAX           = 236,
+
+    BG_AV_OBJECT_MAX                          = 237
+};
+
+
+
+enum BG_AV_OBJECTS
+{
+    AV_OPLACE_FIRSTAID_STATION          = 0,
+    AV_OPLACE_STORMPIKE_GRAVE         = 1,
+    AV_OPLACE_STONEHEART_GRAVE        = 2,
+    AV_OPLACE_SNOWFALL_GRAVE          = 3,
+    AV_OPLACE_ICEBLOOD_GRAVE          = 4,
+    AV_OPLACE_FROSTWOLF_GRAVE         = 5,
+    AV_OPLACE_FROSTWOLF_HUT           = 6,
+    AV_OPLACE_DUNBALDAR_SOUTH         = 7,
+    AV_OPLACE_DUNBALDAR_NORTH         = 8,
+    AV_OPLACE_ICEWING_BUNKER          = 9,
+    AV_OPLACE_STONEHEART_BUNKER       = 10,
+    AV_OPLACE_ICEBLOOD_TOWER          = 11,
+    AV_OPLACE_TOWER_POINT             = 12,
+    AV_OPLACE_FROSTWOLF_ETOWER        = 13,
+    AV_OPLACE_FROSTWOLF_WTOWER        = 14,
+    AV_OPLACE_BIGBANNER_DUNBALDAR_SOUTH         = 15,
+    AV_OPLACE_BIGBANNER_DUNBALDAR_NORTH         = 16,
+    AV_OPLACE_BIGBANNER_ICEWING_BUNKER          = 17,
+    AV_OPLACE_BIGBANNER_STONEHEART_BUNKER       = 18,
+    AV_OPLACE_BIGBANNER_ICEBLOOD_TOWER          = 19,
+    AV_OPLACE_BIGBANNER_TOWER_POINT             = 20,
+    AV_OPLACE_BIGBANNER_FROSTWOLF_ETOWER        = 21,
+    AV_OPLACE_BIGBANNER_FROSTWOLF_WTOWER        = 22,
+
+    AV_OPLACE_BURN_DUNBALDAR_SOUTH         = 23,
+    AV_OPLACE_BURN_DUNBALDAR_NORTH         = 33,
+    AV_OPLACE_BURN_ICEWING_BUNKER          = 43,
+    AV_OPLACE_BURN_STONEHEART_BUNKER       = 53,
+    AV_OPLACE_BURN_ICEBLOOD_TOWER          = 63,
+    AV_OPLACE_BURN_TOWER_POINT             = 73,
+    AV_OPLACE_BURN_FROSTWOLF_ETOWER        = 83,
+    AV_OPLACE_BURN_FROSTWOLF_WTOWER        = 93,
+    AV_OPLACE_BURN_BUILDING_A        = 103,
+    AV_OPLACE_BURN_BUILDING_H        = 113,
+    AV_OPLACE_SNOW_1                      = 123,
+    AV_OPLACE_SNOW_2                      = 124,
+    AV_OPLACE_SNOW_3                      = 125,
+    AV_OPLACE_SNOW_4                      = 126,
+    AV_OPLACE_MINE_SUPPLY_N_MIN           = 127,
+    AV_OPLACE_MINE_SUPPLY_N_MAX           = 136,
+    AV_OPLACE_MINE_SUPPLY_S_MIN           = 137,
+    AV_OPLACE_MINE_SUPPLY_S_MAX           = 148,
+
+    AV_OPLACE_MAX                         = 149
+};
+const float BG_AV_ObjectPos[AV_OPLACE_MAX][4] = {
+    {638.592f,-32.422f,46.0608f,-1.62316f },//firstaid station
+    {669.007f,-294.078f,30.2909f,2.77507f },//stormpike
+    {77.8013f,-404.7f,46.7549f,-0.872665f },//stone grave
+    {-202.581f,-112.73f,78.4876f,-0.715585f },//snowfall
+    {-611.962f,-396.17f,60.8351f,2.53682f},  //iceblood grave
+    {-1082.45f,-346.823f,54.9219f,-1.53589f },//frostwolf grave
+    {-1402.21f,-307.431f,89.4424f,0.191986f },//frostwolf hut
+    {553.779f,-78.6566f,51.9378f,-1.22173f }, //dunnbaldar south
+    {674.001f,-143.125f,63.6615f,0.994838f }, //dunbaldar north
+    {203.281f,-360.366f,56.3869f,-0.925024f }, //icew
+    {-152.437f,-441.758f,40.3982f,-1.95477f }, //stone
+    {-571.88f,-262.777f,75.0087f,-0.802851f }, //ice tower
+    {-768.907f,-363.71f,90.8949f,1.07991f},  //tower point
+    {-1302.9f,-316.981f,113.867f,2.00713f }, //frostwolf etower
+    {-1297.5f,-266.767f,114.15f,3.31044f},   //frostwolf wtower
+    //bigbanner:
+    {555.848f,-84.4151f,64.4397f,3.12414f }, //duns
+    {679.339f,-136.468f,73.9626f,-2.16421f }, //dunn
+    {208.973f,-365.971f,66.7409f,-0.244346f }, //icew
+    {-155.832f,-449.401f,52.7306f,0.610865f }, //stone
+    {-572.329f,-262.476f,88.6496f,-0.575959f }, //icetower
+    {-768.199f,-363.105f,104.537f,0.10472f }, //towerp
+    {-1302.84f,-316.582f,127.516f,0.122173f }, //etower
+    {-1297.87f,-266.762f,127.796f,0.0698132f }, //wtower
+    //burning auras towers have 9*179065 captain-buildings have 5*179066+5*179065
+    //dunns
+    {562.632f,-88.1815f,61.993f,0.383972f },
+    {562.523f,-74.5028f,37.9474f,-0.0523599f },
+    {558.097f,-70.9842f,52.4876f,0.820305f },
+    {578.167f,-71.8191f,38.1514f,2.72271f },
+    {556.028f,-94.9242f,44.8191f,3.05433f },
+    {572.451f,-94.3655f,37.9443f,-1.72788f },
+    {549.263f,-79.3645f,44.8191f,0.436332f },
+    {543.513f,-94.4006f,52.4819f,0.0349066f },
+    {572.149f,-93.7862f,52.5726f,0.541052f },
+    {582.162f,-81.2375f,37.9216f,0.0872665f },
+    //dunn
+    {664.797f,-143.65f,64.1784f,-0.453786f},
+    {664.505f,-139.452f,49.6696f,-0.0349067f},
+    {676.067f,-124.319f,49.6726f,-1.01229f},
+    {693.004f,-144.025f,64.1755f,2.44346f},
+    {661.175f,-117.691f,49.645f,1.91986f},
+    {684.423f,-146.582f,63.6662f,0.994838f},
+    {682.791f,-127.769f,62.4155f,1.09956f},
+    {674.576f,-147.101f,56.5425f,-1.6057f},
+    {655.719f,-126.673f,49.8138f,2.80998f},
+    {0,0,0,0},
+    //icew
+    {231.503f,-356.688f,42.3704f,0.296706f},
+    {224.989f,-348.175f,42.5607f,1.50098f},
+    {205.782f,-351.335f,56.8998f,1.01229f},
+    {196.605f,-369.187f,56.3914f,2.46091f},
+    {210.619f,-376.938f,49.2677f,2.86234f},
+    {209.647f,-352.632f,42.3959f,-0.698132f},
+    {220.65f,-368.132f,42.3978f,-0.2618f},
+    {224.682f,-374.031f,57.0679f,0.541052f},
+    {200.26f,-359.968f,49.2677f,-2.89725f},
+    {196.619f,-378.016f,56.9131f,1.01229f},
+    //stone
+    {-155.488f,-437.356f,33.2796f,2.60054f},
+    {-163.441f,-454.188f,33.2796f,1.93732f},
+    {-143.977f,-445.148f,26.4097f,-1.8675f},
+    {-135.764f,-464.708f,26.3823f,2.25147f},
+    {-154.076f,-466.929f,41.0636f,-1.8675f},
+    {-149.908f,-460.332f,26.4083f,-2.09439f},
+    {-151.638f,-439.521f,40.3797f,0.436332f},
+    {-131.301f,-454.905f,26.5771f,2.93215f},
+    {-171.291f,-444.684f,40.9211f,2.30383f},
+    {-143.591f,-439.75f,40.9275f,-1.72788f},
+    //iceblood
+    {-572.667f,-267.923f,56.8542f,2.35619f},
+    {-561.021f,-262.689f,68.4589f,1.37881f},
+    {-572.538f,-262.649f,88.6197f,1.8326f},
+    {-574.77f,-251.45f,74.9422f,-1.18682f},
+    {-578.625f,-267.571f,68.4696f,0.506145f},
+    {-571.476f,-257.234f,63.3223f,3.10669f},
+    {-566.035f,-273.907f,52.9582f,-0.890118f},
+    {-580.948f,-259.77f,68.4696f,1.46608f},
+    {-568.318f,-267.1f,75.0008f,1.01229f},
+    {-559.621f,-268.597f,52.8986f,0.0523599f},
+    //towerp
+    {-776.072f,-368.046f,84.3558f,2.63545f},
+    {-777.564f,-368.521f,90.6701f,1.72788f},
+    {-765.461f,-357.711f,90.888f,0.314159f},
+    {-768.763f,-362.735f,104.612f,1.81514f},
+    {-760.356f,-358.896f,84.3558f,2.1293f},
+    {-771.967f,-352.838f,84.3484f,1.74533f},
+    {-773.333f,-364.653f,79.2351f,-1.64061f},
+    {-764.109f,-366.069f,70.0934f,0.383972f},
+    {-767.103f,-350.737f,68.7933f,2.80998f},
+    {-760.115f,-353.845f,68.8633f,1.79769f},
+    //froste
+    {-1304.87f,-304.525f,91.8366f,-0.680679f},
+    {-1301.77f,-310.974f,95.8252f,0.907571f},
+    {-1305.58f,-320.625f,102.166f,-0.558505f},
+    {-1294.27f,-323.468f,113.893f,-1.67552f},
+    {-1302.65f,-317.192f,127.487f,2.30383f},
+    {-1293.89f,-313.478f,107.328f,1.6057f},
+    {-1312.41f,-312.999f,107.328f,1.5708f},
+    {-1311.57f,-308.08f,91.7666f,-1.85005f},
+    {-1314.7f,-322.131f,107.36f,0.645772f},
+    {-1304.6f,-310.754f,113.859f,-0.401426f},
+    //frostw
+    {-1308.24f,-273.26f,92.0514f,-0.139626f},
+    {-1302.26f,-262.858f,95.9269f,0.418879f},
+    {-1297.28f,-267.773f,126.756f,2.23402f},
+    {-1299.08f,-256.89f,114.108f,-2.44346f},
+    {-1303.41f,-268.237f,114.151f,-1.23918f},
+    {-1304.43f,-273.682f,107.612f,0.244346f},
+    {-1309.53f,-265.951f,92.1418f,-2.49582f},
+    {-1295.55f,-263.865f,105.033f,0.925024f},
+    {-1294.71f,-281.466f,107.664f,-1.50098f},
+    {-1289.69f,-259.521f,107.612f,-2.19912f},
+
+    //the two buildings of the captains
+    //alliance
+    {-64.4987f,-289.33f,33.4616f,-2.82743f},
+    {-5.98025f,-326.144f,38.8538f,0},
+    {-2.67893f,-306.998f,33.4165f,0},
+    {-60.25f,-309.232f,50.2408f,-1.46608f},
+    {-48.7941f,-266.533f,47.7916f,2.44346f},
+    {-3.40929f,-306.288f,33.34f,0},
+    {-48.619f,-266.917f,47.8168f,0},
+    {-62.9474f,-286.212f,66.7288f,0},
+    {-5.05132f,-325.323f,38.8536f,0},
+    {-64.2677f,-289.412f,33.469f,0},
+//horde
+    {-524.276f,-199.6f,82.8733f,-1.46608f},
+    {-518.196f,-173.085f,102.43f,0},
+    {-500.732f,-145.358f,88.5337f,2.44346f},
+    {-501.084f,-150.784f,80.8506f,0},
+    {-518.309f,-163.963f,102.521f,2.96706f},
+    {-517.053f,-200.429f,80.759f,0},
+    {-514.361f,-163.864f,104.163f,0},
+    {-568.04f,-188.707f,81.55f,0},
+    {-501.775f,-151.581f,81.2027f,0},
+    {-509.975f,-191.652f,83.2978f,0},
+
+//snowfall eyecandy
+    {-191.153f,-129.868f,78.5595f,-1.25664f },
+    {-201.282f,-134.319f,78.6753f,-0.942478f },
+    {-215.981f,-91.4101f,80.8702f,-1.74533f },
+    {-200.465f,-96.418f,79.7587f,1.36136f },
+    //mine supplies
+    //irondeep
+    {870.899f,-388.434f,61.6406f,-1.22173f},
+    {825.214f,-320.174f,63.712f,-2.82743f},
+    {837.117f,-452.556f,47.2331f,-3.12414f},
+    {869.755f,-448.867f,52.5448f,-0.855212f},
+    {949.877f,-458.198f,56.4874f,0.314159f},
+    {900.35f,-479.024f,58.3553f,0.122173f},
+    {854.449f,-442.255f,50.6589f,0.401426f},
+    {886.685f,-442.358f,54.6962f,-1.22173f},
+    {817.509f,-457.331f,48.4666f,2.07694f},
+    {793.411f,-326.281f,63.1117f,-2.79253f},
+    //coldtooth
+    {-934.212f,-57.3517f,80.277f,-0.0174535f},
+    {-916.281f,-36.8579f,77.0227f,0.122173f},
+    {-902.73f,-103.868f,75.4378f,-1.58825f},
+    {-900.514f,-143.527f,75.9686f,1.8675f},
+    {-862.882f,-0.353299f,72.1526f,-2.51327f},
+    {-854.932f,-85.9184f,68.6056f,-2.04204f},
+    {-851.833f,-118.959f,63.8672f,-0.0698131f},
+    {-849.832f,-20.8421f,70.4672f,-1.81514f},
+    {-844.25f,-60.0374f,72.1031f,-2.19912f},
+    {-820.644f,-136.043f,63.1977f,2.40855f},
+    {-947.642f,-208.807f,77.0101f,1.36136f},
+    {-951.394f,-193.695f,67.634f,0.802851f}
+};
+
+const float BG_AV_DoorPositons[2][4] = {
+    {780.487f, -493.024f, 99.9553f, 3.0976f},   //alliance
+    {-1375.193f, -538.981f, 55.2824f, 0.72178f} //horde
+};
+
+
+//creaturestuff starts here
+//is related to BG_AV_CreaturePos
+enum BG_AV_CreaturePlace
+{
+    AV_CPLACE_SPIRIT_STORM_AID      = 0,
+    AV_CPLACE_SPIRIT_STORM_GRAVE    = 1,
+    AV_CPLACE_SPIRIT_STONE_GRAVE    = 2,
+    AV_CPLACE_SPIRIT_SNOWFALL       = 3,
+    AV_CPLACE_SPIRIT_ICE_GRAVE      = 4,
+    AV_CPLACE_SPIRIT_FROSTWOLF      = 5,
+    AV_CPLACE_SPIRIT_FROST_HUT      = 6,
+    AV_CPLACE_SPIRIT_MAIN_ALLIANCE  = 7,
+    AV_CPLACE_SPIRIT_MAIN_HORDE     = 8,
+//i don't will add for all 4 positions a variable.. i think one is enough to compute the rest
+    AV_CPLACE_DEFENSE_STORM_AID      = 9,
+    AV_CPLACE_DEFEMSE_STORM_GRAVE    = 13,
+    AV_CPLACE_DEFENSE_STONE_GRAVE    = 17,
+    AV_CPLACE_DEFENSE_SNOWFALL       = 21,
+    AV_CPLACE_DEFENSE_FROSTWOLF      = 25,
+    AV_CPLACE_DEFENSE_ICE_GRAVE      = 29,
+    AV_CPLACE_DEFENSE_FROST_HUT      = 33,
+
+    AV_CPLACE_DEFENSE_DUN_S          = 37,
+    AV_CPLACE_DEFENSE_DUN_N          = 41,
+    AV_CPLACE_DEFENSE_ICEWING        = 45,
+    AV_CPLACE_DEFENSE_STONE_TOWER    = 49,
+    AV_CPLACE_DEFENSE_ICE_TOWER      = 53,
+    AV_CPLACE_DEFENSE_TOWERPOINT     = 57,
+    AV_CPLACE_DEFENSE_FROST_E        = 61,
+    AV_CPLACE_DEFENSE_FROST_t        = 65,
+
+    AV_CPLACE_A_MARSHAL_SOUTH       = 69,
+    AV_CPLACE_A_MARSHAL_NORTH       = 70,
+    AV_CPLACE_A_MARSHAL_ICE         = 71,
+    AV_CPLACE_A_MARSHAL_STONE       = 72,
+    AV_CPLACE_H_MARSHAL_ICE         = 73,
+    AV_CPLACE_H_MARSHAL_TOWER       = 74,
+    AV_CPLACE_H_MARSHAL_ETOWER      = 75,
+    AV_CPLACE_H_MARSHAL_WTOWER      = 76,
+    //irondeep
+    //miner:
+    AV_CPLACE_MINE_N_1_MIN      = 77,
+    AV_CPLACE_MINE_N_1_MAX      = 136,
+    //special types
+    AV_CPLACE_MINE_N_2_MIN      = 137,
+    AV_CPLACE_MINE_N_2_MAX      = 192,
+    //boss
+    AV_CPLACE_MINE_N_3          = 193,
+    //coldtooth
+    //miner:
+    AV_CPLACE_MINE_S_1_MIN      = 194,
+    AV_CPLACE_MINE_S_1_MAX      = 250,
+    //special types
+    AV_CPLACE_MINE_S_2_MIN      = 251,
+    AV_CPLACE_MINE_S_2_MAX      = 289,
+    //vermin
+    AV_CPLACE_MINE_S_S_MIN      = 290,
+    AV_CPLACE_MINE_S_S_MAX      = 299,
+    //boss
+    AV_CPLACE_MINE_S_3          = 300,
+    
+    //herald
+    AV_CPLACE_HERALD          = 301,
+
+    AV_CPLACE_MAX = 302
+};
+
+//x, y, z, o
+const float BG_AV_CreaturePos[AV_CPLACE_MAX][4] = {
+    //spiritguides
+    {643.000000f,44.000000f,69.740196f,-0.001854f},
+    {676.000000f,-374.000000f,30.000000f,-0.001854f},
+    {73.417755f,-496.433105f,48.731918f,-0.001854f},
+    {-157.409195f,31.206272f,77.050598f,-0.001854f},
+    {-531.217834f,-405.231384f,49.551376f,-0.001854f},
+    {-1090.476807f,-253.308670f,57.672371f,-0.001854f},
+    {-1496.065063f,-333.338409f,101.134804f,-0.001854f},
+    {873.001770f,-491.283630f,96.541931f,-0.001854f},
+    {-1437.670044f,-610.088989f,51.161900f,-0.001854f},
+ //grave
+ //firstaid
+    {635.17f,-29.5594f,46.5056f,4.81711f},
+    {642.488f,-32.9437f,46.365f,4.67748f},
+    {642.326f,-27.9442f,46.9211f,4.59022f},
+    {635.945f,-33.6171f,45.7164f,4.97419f},
+   //stormpike
+    {669.272f,-297.304f,30.291f,4.66604f},
+    {674.08f,-292.328f,30.4817f,0.0918785f},
+    {667.01f,-288.532f,29.8809f,1.81583f},
+    {664.153f,-294.042f,30.2851f,3.28531f},
+  //stone
+    {81.7027f,-406.135f,47.7843f,0.598464f},
+    {78.1431f,-409.215f,48.0401f,5.05953f},
+    {73.4135f,-407.035f,46.7527f,3.34736f},
+    {78.2258f,-401.859f,46.4202f,2.05852f},
+  //snowfall
+    {-207.412f,-110.616f,78.7959f,2.43251f},
+    {-197.95f,-112.205f,78.5686f,6.22441f},
+    {-202.709f,-116.829f,78.4358f,5.13742f},
+    {-202.059f,-108.314f,78.5783f,5.91968f},
+  //ice
+    {-615.501f,-393.802f,60.4299f,3.06147f},
+    {-608.513f,-392.717f,62.5724f,2.06323f},
+    {-609.769f,-400.072f,60.7174f,5.22367f},
+    {-616.093f,-398.293f,60.5628f,3.73613f},
+  //frost
+    {-1077.7f,-340.21f,55.4682f,6.25569f},
+    {-1082.74f,-333.821f,54.7962f,2.05459f},
+    {-1090.66f,-341.267f,54.6768f,3.27746f},
+    {-1081.58f,-344.63f,55.256f,4.75636f},
+  //frost hut
+    {-1408.95f,-311.69f,89.2536f,4.49954f},
+    {-1407.15f,-305.323f,89.1993f,2.86827f},
+    {-1400.64f,-304.3f,89.7008f,1.0595f},
+    {-1400.4f,-311.35f,89.3028f,4.99434f},
+  //towers
+  //dun south - OK
+    {569.395f,-101.064f,52.8296f,2.34974f},
+    {574.85f,-92.9842f,52.5869f,3.09325f},
+    {575.411f,-83.597f,52.3626f,6.26573f},
+    {571.352f,-75.6582f,52.479f,0.523599f},
+    //dun north - OK
+    {668.60f,-122.53f,64.12f,2.34f}, //not 100% ok
+    {662.253f,-129.105f,64.1794f,2.77507f},
+    {661.209f,-138.877f,64.2251f,3.38594f},
+    {665.481f,-146.857f,64.1271f,3.75246f},
+    //icewing - OK
+    {225.228f,-368.909f,56.9983f,6.23806f},
+    {191.36f,-369.899f,57.1524f,3.24631f},
+    {215.518f,-384.019f,56.9889f,5.09636f},
+    {199.625f,-382.177f,56.8691f,4.08407f},
+    //stone
+    {-172.851f,-452.366f,40.8725f,3.31829f},
+    {-147.147f,-435.053f,40.8022f,0.599238f},
+    {-169.456f,-440.325f,40.985f,2.59101f},
+    {-163.494f,-434.904f,41.0725f,1.84174f},
+    //ice - OK
+    {-573.522f,-271.854f,75.0078f,3.9619f},
+    {-565.616f,-269.051f,74.9952f,5.02655f},
+    {-562.825f,-261.087f,74.9898f,5.95157f},
+    {-569.176f,-254.446f,74.8771f,0.820305f},
+    //towerpoint
+    {-763.04f,-371.032f,90.7933f,5.25979f},
+    {-759.764f,-358.264f,90.8681f,0.289795f},
+    {-768.808f,-353.056f,90.8811f,1.52601f},
+    {-775.944f,-362.639f,90.8949f,2.59573f},
+    //frost etower
+    {-1294.13f,-313.045f,107.328f,0.270162f},
+    {-1306.5f,-308.105f,113.767f,1.78755f},
+    {-1294.78f,-319.966f,113.79f,5.94545f},
+    {-1294.83f,-312.241f,113.799f,0.295293f},
+    //frost wtower
+    {-1300.96f,-275.111f,114.058f,4.12804f},
+    {-1302.41f,-259.256f,114.065f,1.67602f},
+    {-1287.97f,-262.087f,114.165f,6.18264f},
+    {-1291.59f,-271.166f,114.151f,5.28257f},
+
+    //alliance marshall
+    {721.104f,-7.64155f,50.7046f,3.45575f},// south
+    {723.058f,-14.1548f,50.7046f,3.40339f},// north
+    {715.691f,-4.72233f,50.2187f,3.47321f},// icewing
+    {720.046f,-19.9413f,50.2187f,3.36849f},// stone
+//horde  (coords not 100% ok)
+    {-1363.99f,-221.99f,98.4053f,4.93012f},
+    {-1370.96f,-223.532f,98.4266f,4.93012f},
+    {-1378.37f,-228.614f,99.3546f,5.38565f},
+    {-1358.02f,-228.998f,98.868f,3.87768f},
+
+ //irondeep mine
+ //Irondeep Trogg
+    {971.671f,-442.657f,57.6951f,3.1765f},
+    {969.979f,-457.148f,58.1119f,4.5204f},
+    {958.692f,-333.477f,63.2276f,5.77704f},
+    {957.113f,-325.92f,61.7589f,1.13446f},
+    {948.25f,-448.268f,56.9009f,5.60251f},
+    {934.727f,-385.802f,63.0344f,3.75246f},
+    {931.751f,-403.458f,59.6737f,5.63741f},
+    {931.146f,-359.666f,66.0294f,3.9619f},
+    {929.702f,-412.401f,56.8776f,5.89921f},
+    {926.849f,-379.074f,63.5286f,2.0944f},
+    {921.972f,-358.597f,66.4313f,2.93215f},
+    {921.449f,-341.981f,67.1264f,3.4383f},
+    {921.1f,-395.812f,60.4615f,2.71695f},
+    {919.274f,-394.986f,60.3478f,2.71696f},
+    {916.852f,-393.891f,60.1726f,2.71695f},
+    {914.568f,-326.21f,66.1733f,2.25147f},
+    {913.064f,-395.773f,60.1364f,4.41568f},
+    {909.246f,-474.576f,58.2067f,0.226893f},
+    {909.246f,-474.576f,58.2901f,0.226893f},
+    {907.209f,-428.267f,59.8065f,1.8675f},
+    {905.973f,-459.528f,58.7594f,1.37189f},
+    {905.067f,-396.074f,60.2085f,5.07891f},
+    {901.809f,-457.709f,59.0116f,3.52557f},
+    {900.962f,-427.44f,59.0842f,1.50098f},
+    {897.929f,-471.742f,59.7729f,2.54818f},
+    {893.376f,-343.171f,68.1499f,5.35816f},
+    {890.584f,-406.049f,61.1925f,5.67232f},
+    {888.208f,-332.564f,68.148f,1.93732f},
+    {887.647f,-391.537f,61.8734f,1.37881f},
+    {885.109f,-343.338f,67.0867f,3.78979f},
+    {881.618f,-419.948f,53.5228f,0.593412f},
+    {878.675f,-345.36f,66.1052f,3.45651f},
+    {877.127f,-351.8f,66.5296f,5.74213f},
+    {876.778f,-345.97f,65.7724f,3.45262f},
+    {874.577f,-414.786f,52.7817f,1.67552f},
+    {868.247f,-343.136f,64.9894f,1.6057f},
+    {859.03f,-367.231f,47.4655f,0.0174533f},
+    {857.513f,-351.817f,65.1867f,4.39823f},
+    {852.632f,-372.416f,48.1657f,3.66519f},
+    {849.86f,-340.944f,66.2447f,0.401426f},
+    {847.99f,-386.287f,60.9277f,2.32374f},
+    {847.601f,-423.072f,50.0852f,4.57276f},
+    {847.135f,-411.307f,50.2106f,1.5708f},
+    {835.077f,-379.418f,48.2755f,5.93412f},
+    {834.87f,-453.304f,47.9075f,0.226893f},
+    {834.634f,-365.981f,62.8801f,1.32645f},
+    {834.354f,-355.526f,48.1491f,6.07375f},
+    {833.702f,-327.506f,65.0439f,0.331613f},
+    {833.151f,-374.228f,63.0938f,3.66519f},
+    {831.711f,-346.785f,47.2975f,0.226893f},
+    {827.874f,-413.624f,48.5818f,1.49241f},
+    {827.728f,-415.483f,48.5593f,1.49238f},
+    {827.016f,-424.543f,48.2856f,1.49236f},
+    {823.222f,-334.283f,65.6306f,4.88692f},
+    {821.892f,-464.723f,48.9451f,4.66003f},
+    {821.006f,-387.635f,49.0728f,3.15905f},
+    {817.26f,-447.432f,49.4308f,2.18166f},
+    {805.399f,-320.146f,52.7712f,0.296706f},
+    {801.405f,-328.055f,53.0195f,4.31096f},
+    //irondeep skullthumber irondeep shaman
+    {955.812f,-440.302f,55.3411f,3.19395f},
+    {937.378f,-377.816f,65.3919f,3.56047f},
+    {925.059f,-331.347f,65.7564f,3.66519f},
+    {922.918f,-396.634f,60.3942f,2.71695f},
+    {909.99f,-462.154f,59.0811f,3.7001f},
+    {907.893f,-388.787f,61.7923f,5.74213f},
+    {898.801f,-437.105f,58.5266f,0.959931f},
+    {884.237f,-407.597f,61.566f,0.820305f},
+    {880.744f,-344.683f,66.4086f,3.4644f},
+    {876.047f,-341.857f,65.8743f,4.45059f},
+    {874.674f,-402.077f,61.7573f,0.26341f},
+    {871.914f,-404.209f,62.1269f,6.06163f},
+    {871.606f,-403.665f,62.0795f,0.765774f},
+    {871.561f,-404.114f,62.1297f,0.00981727f},
+    {871.528f,-404.248f,62.1455f,0.498032f},
+    {871.493f,-404.122f,62.1331f,5.65727f},
+    {871.282f,-403.843f,62.1108f,0.788382f},
+    {868.294f,-392.395f,61.4772f,4.38685f},
+    {868.256f,-392.363f,61.4803f,0.732738f},
+    {867.804f,-392.51f,61.5089f,2.30167f},
+    {867.612f,-392.371f,61.524f,2.86149f},
+    {858.593f,-439.614f,50.2184f,0.872665f},
+    {851.471f,-362.52f,47.314f,4.06662f},
+    {846.939f,-347.279f,66.2876f,0.942478f},
+    {842.08f,-421.775f,48.2659f,1.0821f},
+    {838.358f,-371.212f,63.3299f,4.04916f},
+    {827.57f,-417.483f,48.4538f,1.49237f},
+    {827.012f,-457.397f,48.9331f,2.35619f},
+    {825.535f,-322.373f,63.9357f,4.76475f},
+    {867.635f,-443.605f,51.3347f,1.38626f},
+    {957.293f,-455.039f,56.7395f,5.79449f},
+    {950.077f,-326.672f,61.6552f,5.48033f},
+    {936.692f,-356.78f,65.9835f,2.75762f},
+    {926.475f,-419.345f,56.1833f,2.0944f},
+    {924.729f,-397.453f,60.213f,2.71695f},
+    {902.195f,-475.891f,58.312f,1.39626f},
+    {897.464f,-338.758f,68.1715f,2.94961f},
+    {884.237f,-407.597f,61.566f,0.820305f},
+    {882.517f,-344.111f,66.7887f,3.46962f},
+    {881.437f,-400.254f,61.2028f,0.263427f},
+    {880.156f,-400.678f,61.3113f,3.41373f},
+    {877.989f,-418.051f,52.9753f,4.46804f},
+    {871.212f,-404.12f,62.1433f,3.6554f},
+    {871.036f,-404.119f,62.2237f,4.50295f},
+    {857.396f,-395.766f,61.263f,4.78684f},
+    {857.276f,-395.395f,61.2418f,0.0845553f},
+    {857.231f,-394.577f,61.2174f,1.96817f},
+    {857.108f,-395.682f,61.2317f,4.87022f},
+    {856.709f,-395.28f,61.1814f,2.54913f},
+    {850.922f,-390.399f,60.8771f,2.85405f},
+    {847.556f,-388.228f,60.9438f,2.56872f},
+    {842.031f,-384.663f,61.6028f,2.56871f},
+    {832.035f,-389.301f,47.5567f,2.11185f},
+    {827.415f,-419.468f,48.3322f,1.49232f},
+    {826.402f,-349.454f,47.2722f,1.51844f},
+    {817.83f,-455.715f,48.4207f,0.925025f},
+    {808.953f,-325.964f,52.4043f,3.01942f},
+    // Morloch
+    {865.554f,-438.735f,50.7333f,2.12431f},
+    //coldtooth mine
+    //miner/digger
+    {-917.648f,-46.8922f,77.0872f,5.27089f},
+    {-912.689f,-45.4494f,76.2277f,4.60767f},
+    {-905.455f,-84.5179f,75.3642f,3.29867f},
+    {-904.332f,-111.509f,75.5925f,2.47837f},
+    {-904.27f,-160.419f,61.9876f,3.61192f},
+    {-904.023f,-90.4558f,75.3706f,3.40339f},
+    {-978.678f,-37.3136f,75.8364f,2.84489f},
+    {-973.076f,-36.5013f,77.5047f,1.0821f},
+    {-963.951f,-87.734f,81.5555f,0.575959f},
+    {-961.941f,-90.7252f,81.6629f,0.820305f},
+    {-957.623f,-186.582f,66.6021f,1.95477f},
+    {-952.476f,-179.778f,78.6771f,4.5204f},
+    {-950.427f,-115.007f,79.6127f,3.68264f},
+    {-950.25f,-151.95f,79.4598f,-1.81423f},
+    {-950.169f,-188.099f,66.6184f,5.55015f},
+    {-949.944f,-142.977f,80.5382f,2.70526f},
+    {-947.854f,-170.5f,79.7618f,0.942478f},
+    {-946.738f,-139.567f,80.0904f,2.3911f},
+    {-945.503f,-65.0654f,79.7907f,5.02655f},
+    {-943.678f,-110.986f,80.2557f,0.959931f},
+    {-942.993f,-56.9881f,79.8915f,5.65487f},
+    {-938.197f,-155.838f,61.3111f,1.65806f},
+    {-930.488f,-214.524f,72.1431f,2.1236f},
+    {-929.947f,-154.449f,61.5084f,1.67552f},
+    {-927.412f,-135.313f,61.1987f,3.29867f},
+    {-920.677f,-156.859f,62.8033f,3.15306f},
+    {-916.75f,-136.094f,62.2357f,0.0698132f},
+    {-915.319f,-132.718f,62.562f,1.16984f},
+    {-913.589f,-146.794f,76.9366f,1.8675f},
+    {-907.572f,-148.937f,76.6898f,4.76475f},
+    {-902.02f,-64.6174f,73.9707f,1.19169f},
+    {-899.489f,-61.7252f,73.2498f,5.09636f},
+    {-894.792f,-127.141f,75.3834f,6.14356f},
+    {-892.408f,-162.525f,64.1212f,2.69884f},
+    {-892.326f,-123.158f,76.0318f,5.5676f},
+    {-888.468f,-148.462f,61.8012f,1.65806f},
+    {-883.268f,-159.738f,63.5311f,5.20108f},
+    {-877.76f,-118.07f,65.215f,2.94961f},
+    {-876.792f,-128.646f,64.1045f,3.40339f},
+    {-874.901f,-36.6579f,69.4246f,2.00713f},
+    {-874.856f,-151.351f,62.7537f,3.57875f},
+    {-872.135f,-150.08f,62.7513f,3.57201f},
+    {-870.288f,-149.217f,62.5413f,3.56624f},
+    {-870.03f,-6.27443f,70.3867f,2.3911f},
+    {-869.023f,-82.2118f,69.5848f,3.22886f},
+    {-866.354f,-40.2455f,70.842f,0.0698132f},
+    {-865.305f,-152.302f,63.5044f,4.86947f},
+    {-861.926f,-79.0519f,71.4178f,0.20944f},
+    {-857.292f,-152.277f,63.2114f,4.18879f},
+    {-853.357f,-0.696194f,72.0655f,0.994838f},
+    {-850.685f,-14.2596f,70.2298f,0.20944f},
+    {-839.987f,-67.7695f,72.7916f,4.93928f},
+    {-839.199f,-57.0558f,73.4891f,1.67552f},
+    {-836.963f,-153.224f,63.3821f,4.46804f},
+    {-832.721f,-67.7555f,72.9062f,4.99164f},
+    {-821.496f,-143.095f,63.1292f,0.541052f},
+    {-818.829f,-153.004f,62.1757f,6.12611f},
+    //special
+    {-954.622f,-110.958f,80.7911f,6.24828f},
+    {-951.477f,-53.9647f,80.0235f,5.32325f},
+    {-946.812f,-126.04f,78.8601f,5.15265f},
+    {-940.689f,-140.707f,79.9225f,2.79253f},
+    {-933.954f,-159.632f,60.778f,2.56563f},
+    {-922.537f,-130.291f,61.3756f,4.95674f},
+    {-915.862f,-151.74f,76.9427f,0.942478f},
+    {-888.321f,-159.831f,62.5303f,1.20428f},
+    {-874.361f,-42.4751f,69.4316f,0.785398f},
+    {-873.19f,-50.4899f,70.0568f,-2.41288f},
+    {-868.511f,-148.386f,62.3547f,3.57875f},
+    {-868.44f,-121.649f,64.5056f,3.33358f},
+    {-868.324f,-77.7196f,71.4768f,5.41052f},
+    {-859.846f,-19.6549f,70.7304f,1.97222f},
+    {-828.05f,-150.508f,62.2019f,2.14675f},
+    {-826.254f,-58.6911f,72.0041f,3.68264f},
+    {-976.086f,-44.1775f,76.029f,1.46608f},
+    {-971.864f,-87.4223f,81.4954f,5.8294f},
+    {-966.551f,-74.1111f,80.0243f,4.2129f},
+    {-958.509f,-173.652f,77.9013f,6.24828f},
+    {-951.511f,-181.242f,65.529f,4.39823f},
+    {-940.967f,-186.243f,77.698f,1.28164f},
+    {-930.004f,-65.0898f,79.077f,0.0581657f},
+    {-920.864f,-40.2009f,78.256f,5.16617f},
+    {-919.089f,-148.021f,62.0317f,2.59327f},
+    {-901.516f,-116.329f,75.6876f,0.471239f},
+    {-897.864f,-84.4348f,74.083f,3.00197f},
+    {-897.617f,-52.0457f,71.9503f,4.36332f},
+    {-894.891f,-153.951f,61.6827f,3.23569f},
+    {-893.933f,-111.625f,75.6591f,4.22536f},
+    {-883.265f,-152.854f,61.8384f,0.0941087f},
+    {-868.293f,-147.243f,62.1097f,3.2056f},
+    {-867.501f,-11.8709f,70.018f,6.14356f},
+    {-866.699f,-147.54f,62.1646f,3.57878f},
+    {-866.566f,-91.1916f,67.4414f,4.56707f},
+    {-857.272f,-141.142f,61.7356f,4.17134f},
+    {-847.446f,-98.0061f,68.5131f,3.24631f},
+    {-837.026f,-140.729f,62.5141f,5.51524f},
+    {-824.204f,-65.053f,72.3381f,3.01942f},
+    //vermin (s.th special for this mine)
+    {-951.955f,-197.5f,77.212f,5.63741f},
+    {-944.837f,-199.608f,77.0737f,4.97419f},
+    {-933.494f,-209.063f,73.7803f,5.88176f},
+    {-929.666f,-201.308f,73.7032f,5.02655f},
+    {-978.997f,-249.356f,65.4345f,5.05464f},
+    {-974.565f,-224.828f,69.5858f,4.88846f},
+    {-946.514f,-259.239f,66.0874f,3.78132f},
+    {-918.402f,-250.439f,69.5271f,2.21352f},
+    {-910.14f,-229.959f,72.9279f,0.27677f},
+    {-851.563f,-88.6527f,68.5983f,3.61896f},
+    //boss
+    {-848.902f,-92.931f,68.6325f,3.33350},
+    //herald
+    {-48.459f,-288.802f,55.47f,1.0}
+
+};
+
+
+enum BG_AV_CreatureIds
+{
+
+	AV_NPC_A_GRAVEDEFENSE0 = 0,		// stormpike Defender
+	AV_NPC_A_GRAVEDEFENSE1 = 1,		// seasoned defender
+	AV_NPC_A_GRAVEDEFENSE2 = 2,		// veteran defender
+    AV_NPC_A_GRAVEDEFENSE3 = 3,      // champion defender
+    AV_NPC_A_TOWERDEFENSE  = 4,      // stormpike bowman
+    AV_NPC_A_CAPTAIN       = 5,      // balinda
+    AV_NPC_A_BOSS          = 6,      // vanndar
+
+    AV_NPC_H_GRAVEDEFENSE0 = 7,      // frostwolf guardian
+	AV_NPC_H_GRAVEDEFENSE1 = 8,      // seasoned guardian
+	AV_NPC_H_GRAVEDEFENSE2 = 9,      // veteran guardian
+    AV_NPC_H_GRAVEDEFENSE3 = 10,     // champion guardian
+    AV_NPC_H_TOWERDEFENSE  = 11,     // frostwolf bowman
+    AV_NPC_H_CAPTAIN       = 12,     // galvangar
+    AV_NPC_H_BOSS          = 13,      // drek thar
+
+    AV_NPC_A_MARSHAL_SOUTH       = 14,
+    AV_NPC_MARSHAL_NORTH       = 15,
+    AV_NPC_A_MARSHAL_ICE         = 16,
+    AV_NPC_A_MARSHAL_STONE       = 17,
+    AV_NPC_H_MARSHAL_ICE         = 18,
+    AV_NPC_H_MARSHAL_TOWER       = 19,
+    AV_NPC_MARSHAL_ETOWER      = 20,
+    AV_NPC_H_MARSHAL_WTOWER      = 21,
+    AV_NPC_N_MINE_N_1           = 22,
+    AV_NPC_N_MINE_N_2           = 23,
+    AV_NPC_N_MINE_N_3           = 24,
+    AV_NPC_N_MINE_N_4           = 25,
+    AV_NPC_N_MINE_A_1           = 26,
+    AV_NPC_N_MINE_A_2           = 27,
+    AV_NPC_N_MINE_A_3           = 28,
+    AV_NPC_N_MINE_A_4           = 29,
+    AV_NPC_N_MINE_H_1           = 30,
+    AV_NPC_N_MINE_H_2           = 31,
+    AV_NPC_N_MINE_H_3           = 32,
+    AV_NPC_N_MINE_H_4           = 33,
+    AV_NPC_S_MINE_N_1           = 34,
+    AV_NPC_S_MINE_N_2           = 35,
+    AV_NPC_S_MINE_N_3           = 36,
+    AV_NPC_S_MINE_N_4           = 37,
+    AV_NPC_S_MINE_N_S           = 38,
+    AV_NPC_S_MINE_A_1           = 39,
+    AV_NPC_S_MINE_A_2           = 40,
+    AV_NPC_S_MINE_A_3           = 41,
+    AV_NPC_S_MINE_A_4           = 42,
+    AV_NPC_S_MINE_H_1           = 43,
+    AV_NPC_S_MINE_H_2           = 44,
+    AV_NPC_S_MINE_H_3           = 45,
+    AV_NPC_S_MINE_H_4           = 46,
+    AV_NPC_HERALD               = 47,
+    AV_NPC_INFO_MAX              = 48
+
+};
+
+//entry, team, minlevel, maxlevel
+//TODO this array should be removed, the only needed things are the entrys (for spawning(?) and handlekillunit)
+const uint32 BG_AV_CreatureInfo[AV_NPC_INFO_MAX][4] = {
+    { 12050, 1216, 58, 58 }, //Stormpike Defender
+    { 13326, 1216, 59, 59 }, //Seasoned Defender
+    { 13331, 1216, 60, 60 }, //Veteran Defender
+    { 13422, 1216, 61, 61 }, //Champion Defender
+    { 13358, 1216, 59, 60 }, //Stormpike Bowman //i think its 60,61 and 69,70.. but this is until now not possible TODO look if this is ok
+    { 11949,469,0,0},//not spawned with this data, but used for handlekillunit
+    { 11948,469,0,0},//not spawned with this data, but used for handlekillunit
+    { 12053, 1214, 58, 58 }, //Frostwolf Guardian
+    { 13328, 1214, 59, 59 }, //Seasoned Guardian
+    { 13332, 1214, 60, 60 }, //Veteran Guardian
+    { 13421, 1214, 61, 61 }, //Champion Guardian
+    { 13359, 1214, 59, 60 }, //Frostwolf Bowman
+    { 11947,67,0,0}, //not spawned with this data, but used for handlekillunit
+    { 11946,67,0,0}, //not spawned with this data, but used for handlekillunit
+    { 14763, 1534, 60, 60 }, //Dun Baldar South Marshal
+    { 14762, 1534, 60, 60 }, //Dun Baldar North Marshal
+    { 14764, 1534, 60, 60 }, //Icewing Marshal
+    { 14765, 1534, 60, 60 }, //Stonehearth Marshal
+
+    { 14773, 1214, 60, 60 }, //Iceblood Warmaster
+    { 14776, 1214, 60, 60 }, //Tower Point Warmaster
+    { 14772, 1214, 60, 60 }, //East Frostwolf Warmaster
+    { 14777, 1214, 60, 60 }, //West Frostwolf Warmaster
+
+    { 10987, 59, 52, 53 }, //Irondeep Trogg
+    { 11600, 59, 53, 54 }, //Irondeep Shaman
+    { 11602, 59, 54, 55 }, //Irondeep Skullthumper
+    { 11657, 59, 58, 58 }, //Morloch
+
+    {13396,469,52,53}, //irondeep alliance TODO: get the right ids
+    {13080,469,53,54},
+    {13098,469,54,55},
+    {13078,469,58,58},
+
+    {13397,67,52,53}, //irondeep horde
+    {13099,67,53,54},
+    {13081,67,54,55},
+    {13079,67,58,58},
+
+    { 11603, 59, 52, 53 }, //south mine neutral
+    { 11604, 59, 53, 54 },
+    { 11605, 59, 54, 55 },
+    { 11677, 59, 58, 58 },
+    { 10982, 59, 52, 53 }, //vermin
+
+    {13317,469,52,53}, //alliance
+    {13096,469,54,55}, //explorer
+    {13087,469,54,55}, //invader
+    {13086,469,58,58},
+
+    {13316,67,52,53}, //horde
+    {13097,67,54,55}, //surveypr
+    {13089,67,54,55}, //guard
+    {13088,67,58,58},
+    {14848,67,58,58} //Herald
+
+};
+
+//x,y,z,o,static_creature_info-id
+const float BG_AV_StaticCreaturePos[AV_STATICCPLACE_MAX][5] = { //static creatures
+    {-1235.31f,-340.777f,60.5088f,3.31613f,0 },//2225 - Zora Guthrek
+    {-1244.02f,-323.795f,61.0485f,5.21853f,1 },//3343 - Grelkor
+    {-1235.16f,-332.302f,60.2985f,2.96706f,2 },//3625 - Rarck
+    {587.303f,-42.8257f,37.5615f,5.23599f,3 },//4255 - Brogus Thunderbrew
+    {643.635f,-58.3987f,41.7405f,4.72984f,4 },//4257 - Lana Thunderbrew
+    {591.464f,-44.452f,37.6166f,5.65487f,5 },//5134 - Jonivera Farmountain
+    {608.515f,-33.3935f,42.0003f,5.41052f,6 },//5135 - Svalbrad Farmountain
+    {617.656f,-32.0701f,42.7168f,4.06662f,7 },//5139 - Kurdrum Barleybeard
+    {-1183.76f,-268.295f,72.8233f,3.28122f,8 },//10364 - Yaelika Farclaw
+    {-1187.86f,-275.31f,73.0481f,3.63028f,9 },//10367 - Shrye Ragefist
+    {-1008.42f,-368.006f,55.3426f,5.95647f,10 },//10981 - Frostwolf
+    {-1091.92f,-424.28f,53.0139f,2.93958f,10 },//10981 - Frostwolf
+    {-558.455f,-198.768f,58.1755f,4.97946f,10 },//10981 - Frostwolf
+    {-861.247f,-312.51f,55.1427f,3.35382f,10 },//10981 - Frostwolf
+    {-1003.81f,-395.913f,50.4736f,2.85631f,10 },//10981 - Frostwolf
+    {-904.5f,-289.815f,65.1222f,5.7847f,10 },//10981 - Frostwolf
+    {-1064.41f,-438.839f,51.3614f,1.88857f,10 },//10981 - Frostwolf
+    {258.814f,76.2017f,18.6468f,6.19052f,11 },//10986 - Snowblind Harpy
+    {265.838f,-315.846f,-16.5429f,3.15917f,11 },//10986 - Snowblind Harpy
+    {426.485f,-51.1927f,-5.66286f,1.60347f,11 },//10986 - Snowblind Harpy
+    {452.044f,-33.9594f,-0.044651f,2.72815f,11 },//10986 - Snowblind Harpy
+    {266.032f,-315.639f,-16.5429f,4.67962f,11 },//10986 - Snowblind Harpy
+    {532.64f,-54.5863f,20.7024f,2.93215f,11 },//10986 - Snowblind Harpy
+    {295.183f,-299.908f,-34.6123f,0.135851f,12 },//10990 - Alterac Ram
+    {421.08f,-225.006f,-23.73f,0.166754f,12 },//10990 - Alterac Ram
+    {-55.7766f,-192.498f,20.4352f,6.12221f,12 },//10990 - Alterac Ram
+    {527.887f,-477.223f,62.3559f,0.170935f,12 },//10990 - Alterac Ram
+    {389.144f,-346.508f,-30.334f,4.14117f,12 },//10990 - Alterac Ram
+    {108.121f,-322.248f,37.5655f,4.46788f,12 },//10990 - Alterac Ram
+    {507.479f,-67.9403f,10.3571f,3.26304f,12 },//10990 - Alterac Ram
+    {329.071f,-185.016f,-29.1542f,0.356943f,12 },//10990 - Alterac Ram
+    {252.449f,-422.313f,35.1404f,4.53771f,12 },//10990 - Alterac Ram
+    {358.882f,-118.061f,-24.9119f,2.29257f,12 },//10990 - Alterac Ram
+    {487.151f,-174.229f,14.7558f,4.73192f,12 },//10990 - Alterac Ram
+    {449.652f,-123.561f,6.14273f,6.12029f,12 },//10990 - Alterac Ram
+    {272.419f,-261.802f,-41.8835f,3.66559f,12 },//10990 - Alterac Ram
+    {359.021f,-210.954f,-29.3483f,4.31339f,12 },//10990 - Alterac Ram
+    {450.598f,-318.048f,-37.7548f,0.655219f,12 },//10990 - Alterac Ram
+    {509.333f,-218.2f,3.05439f,3.66292f,12 },//10990 - Alterac Ram
+    {485.771f,-223.613f,-1.53f,2.04862f,12 },//10990 - Alterac Ram
+    {486.636f,-452.172f,39.6592f,2.3341f,12 },//10990 - Alterac Ram
+    {702.783f,-257.494f,25.9777f,1.68329f,12 },//10990 - Alterac Ram
+    {460.942f,-199.263f,-6.0149f,0.380506f,12 },//10990 - Alterac Ram
+    {483.108f,-115.307f,10.1056f,3.69701f,12 },//10990 - Alterac Ram
+    {471.601f,-154.174f,14.0702f,5.5807f,12 },//10990 - Alterac Ram
+    {213.938f,-420.793f,41.2549f,5.71394f,12 },//10990 - Alterac Ram
+    {289.387f,-294.685f,-33.9073f,0.555494f,12 },//10990 - Alterac Ram
+    {155.649f,-402.891f,43.3915f,5.94838f,12 },//10990 - Alterac Ram
+    {517.184f,-295.105f,-9.78195f,6.05668f,12 },//10990 - Alterac Ram
+    {102.334f,-332.165f,38.9812f,3.31445f,12 },//10990 - Alterac Ram
+    {320.244f,-107.793f,-42.6357f,-1.00311f,12 },//10990 - Alterac Ram
+    {217.976f,110.774f,15.7603f,4.56793f,13 },//11675 - Snowblind Windcaller
+    {269.872f,6.66684f,20.7592f,0.381212f,13 },//11675 - Snowblind Windcaller
+    {313.528f,-319.041f,-27.2373f,0.554098f,13 },//11675 - Snowblind Windcaller
+    {435.441f,-39.9289f,-0.169651f,0.549454f,13 },//11675 - Snowblind Windcaller
+    {315.115f,-317.62f,-29.1123f,0.90111f,13 },//11675 - Snowblind Windcaller
+    {428.091f,-122.731f,3.40332f,6.05901f,14 },//11678 - Snowblind Ambusher
+    {235.05f,85.5705f,18.3079f,-0.914255f,14 },//11678 - Snowblind Ambusher
+    {-1553.04f,-344.342f,64.4163f,6.09933f,15 },//11839 - Wildpaw Brute
+    {-545.23f,-165.35f,57.7886f,3.01145f,16 },//11947 - Captain Galvangar
+    {722.43f,-10.9982f,50.7046f,3.42085f,17 },//11948 - Vanndar Stormpike
+    {-57.7891f,-286.597f,15.6479f,6.02139f,18 },//11949 - Captain Balinda Stonehearth
+    {930.498f,-520.755f,93.7334f,1.8326f,19 },//11997 - Stormpike Herald
+    {-776.092f,-345.161f,67.4092f,1.89257f,20 },//12051 - Frostwolf Legionnaire
+    {-1224.63f,-308.144f,65.0087f,4.01139f,20 },//12051 - Frostwolf Legionnaire
+    {-713.039f,-442.515f,82.8638f,0.68724f,20 },//12051 - Frostwolf Legionnaire
+    {-711.783f,-444.061f,82.7039f,0.683494f,20 },//12051 - Frostwolf Legionnaire
+    {587.633f,-45.9816f,37.5438f,5.81195f,21 },//12096 - Stormpike Quartermaster
+    {-1293.79f,-194.407f,72.4398f,5.84685f,22 },//12097 - Frostwolf Quartermaster
+    {446.163f,-377.119f,-1.12725f,0.209526f,23 },//12127 - Stormpike Guardsman
+    {549.348f,-399.254f,53.3537f,3.24729f,23 },//12127 - Stormpike Guardsman
+    {549.801f,-401.217f,53.8305f,3.24729f,23 },//12127 - Stormpike Guardsman
+    {192.704f,-406.874f,42.9183f,6.10696f,23 },//12127 - Stormpike Guardsman
+    {441.305f,-435.765f,28.2385f,2.14472f,23 },//12127 - Stormpike Guardsman
+    {192.982f,-404.891f,43.0132f,6.1061f,23 },//12127 - Stormpike Guardsman
+    {355.342f,-391.989f,-0.486707f,3.00643f,23 },//12127 - Stormpike Guardsman
+    {446.035f,-375.104f,-1.12725f,0.21033f,23 },//12127 - Stormpike Guardsman
+    {697.864f,-433.238f,62.7914f,1.65776f,23 },//12127 - Stormpike Guardsman
+    {610.74f,-331.585f,30.8021f,5.14253f,23 },//12127 - Stormpike Guardsman
+    {609.815f,-329.775f,30.9271f,-2.38829f,23 },//12127 - Stormpike Guardsman
+    {695.874f,-433.434f,62.8543f,1.65776f,23 },//12127 - Stormpike Guardsman
+    {443.337f,-435.283f,28.6842f,2.13768f,23 },//12127 - Stormpike Guardsman
+    {-1251.5f,-316.327f,62.6565f,5.02655f,24 },//13176 - Smith Regzar
+    {-1332.0f,-331.243f,91.2631f,1.50098f,25 },//13179 - Wing Commander Guse
+    {569.983f,-94.9992f,38.0325f,1.39626f,26 },//13216 - Gaelden Hammersmith
+    {-1244.92f,-308.916f,63.2525f,1.62316f,27 },//13218 - Grunnda Wolfheart
+    {-1319.56f,-342.675f,60.3404f,1.20428f,28 },//13236 - Primalist Thurloga
+    {647.61f,-61.1548f,41.7405f,4.24115f,29 },//13257 - Murgot Deepforge
+    {-1321.64f,-343.73f,60.4833f,1.01229f,30 },//13284 - Frostwolf Shaman
+    {-1317.61f,-342.853f,60.3726f,2.47837f,30 },//13284 - Frostwolf Shaman
+    {-1319.31f,-344.475f,60.3825f,1.72788f,30 },//13284 - Frostwolf Shaman
+    {569.963f,-42.0218f,37.7581f,4.27606f,31 },//13438 - Wing Commander Slidore
+    {729.2f,-78.812f,51.6335f,3.97935f,32 },//13442 - Arch Druid Renferal
+    {729.118f,-82.8713f,51.6335f,2.53073f,33 },//13443 - Druid of the Grove
+    {725.554f,-79.4973f,51.6335f,5.27089f,33 },//13443 - Druid of the Grove
+    {724.768f,-84.1642f,51.6335f,0.733038f,33 },//13443 - Druid of the Grove
+    {596.68f,-83.0633f,39.0051f,6.24828f,34 },//13447 - Corporal Noreg Stormpike
+    {600.032f,-2.92475f,42.0788f,5.00909f,35 },//13577 - Stormpike Ram Rider Commander
+    {610.239f,-21.8454f,43.272f,4.90438f,36 },//13617 - Stormpike Stable Master
+    {613.422f,-150.764f,33.4517f,5.55015f,37 },//13797 - Mountaineer Boombellow
+    {-1213.91f,-370.619f,56.4455f,0.837758f,38 },//13798 - Jotek
+    {704.35f,-22.9071f,50.2187f,0.785398f,39 },//13816 - Prospector Stonehewer
+    {-1271.24f,-335.766f,62.3971f,5.75959f,40 },//14185 - Najak Hexxen
+    {-1268.64f,-332.688f,62.6171f,5.28835f,41 },//14186 - Ravak Grimtotem
+    {648.363f,-65.2233f,41.7405f,3.12414f,42 },//14187 - Athramanis
+    {648.238f,-67.8931f,41.7405f,2.60054f,43 },//14188 - Dirk Swindle
+    {-1223.44f,-309.833f,64.9331f,4.0131f,44 },//14282 - Frostwolf Bloodhound
+    {-1226.4f,-307.136f,64.9706f,4.0145f,44 },//14282 - Frostwolf Bloodhound
+    {356.001f,-389.969f,-0.438796f,3.0334f,45 },//14283 - Stormpike Owl
+    {355.835f,-394.005f,-0.60149f,3.02498f,45 },//14283 - Stormpike Owl
+    {882.266f,-496.378f,96.7707f,4.83248f,45 },//14283 - Stormpike Owl
+    {878.649f,-495.917f,96.6171f,4.67693f,45 },//14283 - Stormpike Owl
+    {932.851f,-511.017f,93.6748f,3.61004f,45 },//14283 - Stormpike Owl
+    {935.806f,-513.983f,93.7436f,3.61788f,45 },//14283 - Stormpike Owl
+    {947.412f,-509.982f,95.1098f,2.82743f,46 },//14284 - Stormpike Battleguard
+    {934.557f,-512.395f,93.662f,3.61004f,46 },//14284 - Stormpike Battleguard
+    {939.42f,-502.777f,94.5887f,5.14872f,46 },//14284 - Stormpike Battleguard
+    {854.276f,-494.241f,96.8017f,5.44543f,46 },//14284 - Stormpike Battleguard
+    {776.621f,-487.775f,99.4049f,3.50811f,46 },//14284 - Stormpike Battleguard
+    {880.169f,-495.699f,96.6204f,4.8325f,46 },//14284 - Stormpike Battleguard
+    {773.651f,-497.482f,99.0408f,2.11185f,46 },//14284 - Stormpike Battleguard
+    {949.1f,-506.913f,95.4237f,3.31613f,46 },//14284 - Stormpike Battleguard
+    {-1370.9f,-219.793f,98.4258f,5.04381f,47}, //drek thar
+
+};
+
+const uint32 BG_AV_StaticCreatureInfo[51][4] = {
+    { 2225, 1215, 55, 55 }, //Zora Guthrek
+    { 3343, 1215, 55, 55 }, //Grelkor
+    { 3625, 1215, 55, 55 }, //Rarck
+    { 4255, 1217, 55, 55 }, //Brogus Thunderbrew
+    { 4257, 1217, 55, 55 }, //Lana Thunderbrew
+    { 5134, 1217, 55, 55 }, //Jonivera Farmountain
+    { 5135, 1217, 55, 55 }, //Svalbrad Farmountain
+    { 5139, 1217, 55, 55 }, //Kurdrum Barleybeard
+    { 10364, 1215, 55, 55 }, //Yaelika Farclaw
+    { 10367, 1215, 55, 55 }, //Shrye Ragefist
+    { 10981, 38, 50, 51 }, //Frostwolf
+    { 10986, 514, 52, 53 }, //Snowblind Harpy
+    { 10990, 1274, 50, 51 }, //Alterac Ram
+    { 11675, 514, 53, 53 }, //Snowblind Windcaller
+    { 11678, 14, 52, 53 }, //Snowblind Ambusher
+    { 11839, 39, 56, 56 }, //Wildpaw Brute
+    { 11947, 1214, 61, 61 }, //Captain Galvangar --TODO: doubled
+    { 11948, 1216, 63, 63 }, //Vanndar Stormpike
+    { 11949, 1216, 61, 61 }, //Captain Balinda Stonehearth
+    { 11997, 1334, 60, 60 }, //Stormpike Herald
+    { 12051, 1214, 57, 57 }, //Frostwolf Legionnaire
+    { 12096, 1217, 55, 55 }, //Stormpike Quartermaster
+    { 12097, 1215, 55, 55 }, //Frostwolf Quartermaster
+    { 12127, 1216, 57, 57 }, //Stormpike Guardsman
+    { 13176, 1215, 60, 60 }, //Smith Regzar
+    { 13179, 1215, 59, 59 }, //Wing Commander Guse
+    { 13216, 1217, 58, 58 }, //Gaelden Hammersmith
+    { 13218, 1215, 58, 58 }, //Grunnda Wolfheart
+    { 13236, 1214, 60, 60 }, //Primalist Thurloga
+    { 13257, 1216, 60, 60 }, //Murgot Deepforge
+    { 13284, 1214, 58, 58 }, //Frostwolf Shaman
+    { 13438, 1217, 58, 58 }, //Wing Commander Slidore
+    { 13442, 1216, 60, 60 }, //Arch Druid Renferal
+    { 13443, 1216, 60, 60 }, //Druid of the Grove
+    { 13447, 1216, 58, 58 }, //Corporal Noreg Stormpike
+    { 13577, 1216, 60, 60 }, //Stormpike Ram Rider Commander
+    { 13617, 1216, 60, 60 }, //Stormpike Stable Master
+    { 13797, 32, 60, 61 }, //Mountaineer Boombellow
+    { 13798, 1214, 60, 61 }, //Jotek
+    { 13816, 1216, 61, 61 }, //Prospector Stonehewer
+    { 14185, 877, 59, 59 }, //Najak Hexxen
+    { 14186, 105, 60, 60 }, //Ravak Grimtotem
+    { 14187, 1594, 60, 60 }, //Athramanis
+    { 14188, 57, 59, 59 }, //Dirk Swindle
+    { 14282, 1214, 53, 54 }, //Frostwolf Bloodhound
+    { 14283, 1216, 53, 54 }, //Stormpike Owl
+    { 14284, 1216, 61, 61 }, //Stormpike Battleguard
+    { 11946, 1214, 63, 63 }, //Drek'Thar //TODO: make the levels right (boss=0 maybe)
+    { 11948, 1216, 63, 63 }, //Vanndar Stormpike
+    { 11947, 1214, 61, 61 }, //Captain Galvangar
+    { 11949, 1216, 61, 61 } //Captain Balinda Stonehearth
+};
+
+enum BG_AV_Graveyards
+{
+    AV_GRAVE_STORM_AID         = 751,
+    AV_GRAVE_STORM_GRAVE       = 689,
+    AV_GRAVE_STONE_GRAVE       = 729,
+    AV_GRAVE_SNOWFALL          = 169,
+    AV_GRAVE_ICE_GRAVE         = 749,
+    AV_GRAVE_FROSTWOLF         = 690,
+    AV_GRAVE_FROST_HUT         = 750,
+    AV_GRAVE_MAIN_ALLIANCE     = 611,
+    AV_GRAVE_MAIN_HORDE        = 610
+};
+
+
+
+const uint32 BG_AV_GraveyardIds[9]= {
+  AV_GRAVE_STORM_AID,
+  AV_GRAVE_STORM_GRAVE,
+  AV_GRAVE_STONE_GRAVE,
+  AV_GRAVE_SNOWFALL,
+  AV_GRAVE_ICE_GRAVE,
+  AV_GRAVE_FROSTWOLF,
+  AV_GRAVE_FROST_HUT,
+  AV_GRAVE_MAIN_ALLIANCE,
+  AV_GRAVE_MAIN_HORDE
+};
+
+enum BG_AV_BUFF
+{ //TODO add all other buffs here
+    AV_BUFF_ARMOR = 21163,
+    AV_BUFF_A_CAPTAIN = 23693, //the buff which the alliance captain does
+    AV_BUFF_H_CAPTAIN = 22751 //the buff which the horde captain does
+};
+enum BG_AV_States
+{
+    POINT_NEUTRAL              =  0,
+    POINT_ASSAULTED            =  1,
+    POINT_DESTROYED            =  2,
+    POINT_CONTROLED            =  3
+};
+
+enum BG_AV_WorldStates
+{
+    AV_Alliance_Score               = 3127,
+    AV_Horde_Score                  = 3128,
+    AV_SHOW_H_SCORE                 = 3133,
+    AV_SHOW_A_SCORE                 = 3134,
+
+/*
+    //the comments behind the state shows which icon overlaps the other.. but is, until now, unused and maybe not a good solution (but give few performance (: )
+
+// Graves
+
+    // Alliance
+    //Stormpike first aid station
+    AV_AID_A_C                      = 1325,
+    AV_AID_A_A                      = 1326,
+    AV_AID_H_C                      = 1327,
+    AV_AID_H_A                      = 1328,
+    //Stormpike Graveyard
+    AV_PIKEGRAVE_A_C                = 1333,
+    AV_PIKEGRAVE_A_A                = 1335,
+    AV_PIKEGRAVE_H_C                = 1334,
+    AV_PIKEGRAVE_H_A                = 1336,
+    //Stoneheart Grave
+    AV_STONEHEART_A_C               = 1302,
+    AV_STONEHEART_A_A               = 1304, //over hc
+    AV_STONEHEART_H_C               = 1301, //over ac
+    AV_STONEHEART_H_A               = 1303, //over aa
+    //Neutral
+    //Snowfall Grave
+*/
+    AV_SNOWFALL_N                   = 1966, //over aa
+/*
+    AV_SNOWFALL_A_C                 = 1341, //over hc
+    AV_SNOWFALL_A_A                 = 1343, //over ha
+    AV_SNOWFALL_H_C                 = 1342,
+    AV_SNOWFALL_H_A                 = 1344, //over ac
+    //Horde
+    //Iceblood grave
+    AV_ICEBLOOD_A_C                 = 1346, //over hc
+    AV_ICEBLOOD_A_A                 = 1348, //over ac
+    AV_ICEBLOOD_H_C                 = 1347,
+    AV_ICEBLOOD_H_A                 = 1349, //over aa
+    //Frostwolf Grave
+    AV_FROSTWOLF_A_C                = 1337, //over hc
+    AV_FROSTWOLF_A_A                = 1339, //over ac
+    AV_FROSTWOLF_H_C                = 1338,
+    AV_FROSTWOLF_H_A                = 1340, //over aa
+    //Frostwolf Hut
+    AV_FROSTWOLFHUT_A_C             = 1329, //over hc
+    AV_FROSTWOLFHUT_A_A             = 1331, //over ha
+    AV_FROSTWOLFHUT_H_C             = 1330,
+    AV_FROSTWOLFHUT_H_A             = 1332, //over ac
+
+
+//Towers
+    //Alliance
+    //Dunbaldar South Bunker
+    AV_DUNS_CONTROLLED              = 1361,
+    AV_DUNS_DESTROYED               = 1370,
+    AV_DUNS_ASSAULTED               = 1378,
+    //Dunbaldar North Bunker
+    AV_DUNN_CONTROLLED              = 1362,
+    AV_DUNN_DESTROYED               = 1371,
+    AV_DUNN_ASSAULTED               = 1379,
+    //Icewing Bunker
+    AV_ICEWING_CONTROLLED           = 1363,
+    AV_ICEWING_DESTROYED            = 1372,
+    AV_ICEWING_ASSAULTED            = 1380,
+    //Stoneheart Bunker
+    AV_STONEH_CONTROLLED            = 1364,
+    AV_STONEH_DESTROYED             = 1373,
+    AV_STONEH_ASSAULTED             = 1381,
+    //Horde
+    //Iceblood Tower
+    AV_ICEBLOOD_CONTROLLED          = 1385,
+    AV_ICEBLOOD_DESTROYED           = 1368,
+    AV_ICEBLOOD_ASSAULTED           = 1390,
+    //Tower Point
+    AV_TOWERPOINT_CONTROLLED        = 1384,
+    AV_TOWERPOINT_DESTROYED         = 1367, //goes over controlled
+    AV_TOWERPOINT_ASSAULTED         = 1389, //goes over destroyed
+    //Frostwolf West
+    AV_FROSTWOLFW_CONTROLLED        = 1382,
+    AV_FROSTWOLFW_DESTROYED         = 1365, //over controlled
+    AV_FROSTWOLFW_ASSAULTED         = 1387, //over destroyed
+    //Frostwolf East
+    AV_FROSTWOLFE_CONTROLLED        = 1383,
+    AV_FROSTWOLFE_DESTROYED         = 1366,
+    AV_FROSTWOLFE_ASSAULTED         = 1388,
+
+//mines
+
+    AV_N_MINE_N              = 1360,
+    AV_N_MINE_A              = 1358,
+    AV_N_MINE_H              = 1359,
+
+    AV_S_MINE_N                     = 1357,
+    AV_S_MINE_A                     = 1355,
+    AV_S_MINE_H                     = 1356,
+
+//towers assaulted by own team (unused)
+    AV_STONEH_UNUSED                = 1377,
+    AV_ICEWING_UNUSED               = 1376,
+    AV_DUNS_UNUSED                  = 1375,
+    AV_DUNN_UNUSED                  = 1374,
+
+    AV_ICEBLOOD_UNUSED              = 1395,
+    AV_TOWERPOINT_UNUSED            = 1394,
+    AV_FROSTWOLFE_UNUSED            = 1393,
+    AV_FROSTWOLFW_UNUSED            = 1392
+*/
+
+};
+
+//alliance_control neutral_control horde_control
+const uint32 BG_AV_MineWorldStates[2][3] = {
+    {1358, 1360,1359},
+    {1355, 1357,1356}
+};
+
+
+//alliance_control alliance_assault h_control h_assault
+const uint32 BG_AV_NodeWorldStates[16][4] = {
+    //Stormpike first aid station
+    {1325, 1326,1327,1328},
+    //Stormpike Graveyard
+    {1333,1335,1334,1336},
+    //Stoneheart Grave
+    {1302,1304,1301,1303},
+    //Snowfall Grave
+    {1341,1343,1342,1344},
+    //Iceblood grave
+    {1346,1348,1347,1349},
+    //Frostwolf Grave
+    {1337,1339,1338,1340},
+    //Frostwolf Hut
+    {1329,1331,1330,1332},
+    //Dunbaldar South Bunker
+    {1361,1375,1370,1378},
+    //Dunbaldar North Bunker
+    {1362,1374,1371,1379},
+    //Icewing Bunker
+    {1363,1376,1372,1380},
+    //Stoneheart Bunker
+    {1364,1377,1373,1381},
+    //Iceblood Tower
+    {1368,1390,1385,1395},
+    //Tower Point
+    {1367,1389,1384,1394},
+    //Frostwolf East
+    {1366,1388,1383,1393},
+    //Frostwolf West
+    {1365,1387,1382,1392},
+};
+
+enum BG_AV_QuestIds
+{
+    AV_QUEST_A_SCRAPS1      = 7223,
+    AV_QUEST_A_SCRAPS2      = 6781,
+    AV_QUEST_H_SCRAPS1      = 7224,
+    AV_QUEST_H_SCRAPS2      = 6741,
+    AV_QUEST_A_COMMANDER1   = 6942, //soldier
+    AV_QUEST_H_COMMANDER1   = 6825,
+    AV_QUEST_A_COMMANDER2   = 6941, //leutnant
+    AV_QUEST_H_COMMANDER2   = 6826,
+    AV_QUEST_A_COMMANDER3   = 6943, //commander
+    AV_QUEST_H_COMMANDER3   = 6827,
+    AV_QUEST_A_BOSS1        = 7386, // 5 cristal/blood
+    AV_QUEST_H_BOSS1        = 7385,
+    AV_QUEST_A_BOSS2        = 6881, // 1
+    AV_QUEST_H_BOSS2        = 6801,
+    AV_QUEST_A_NEAR_MINE    = 5892, //the mine near start location of team
+    AV_QUEST_H_NEAR_MINE    = 5893,
+    AV_QUEST_A_OTHER_MINE   = 6982, //the other mine ;)
+    AV_QUEST_H_OTHER_MINE   = 6985,
+    AV_QUEST_A_RIDER_HIDE   = 7026,
+    AV_QUEST_H_RIDER_HIDE   = 7002,
+    AV_QUEST_A_RIDER_TAME   = 7027,
+    AV_QUEST_H_RIDER_TAME   = 7001
+};
+
+struct BG_AV_NodeInfo
+{
+    uint16       TotalOwner;
+    uint16       Owner;
+    uint16       PrevOwner;
+    BG_AV_States State;
+    BG_AV_States PrevState;
+    int          Timer;
+    bool         Tower;
+};
+
+inline BG_AV_Nodes &operator++(BG_AV_Nodes &i){ return i = BG_AV_Nodes(i + 1); }
+
 class BattleGroundAVScore : public BattleGroundScore
 {
     public:
@@ -49,11 +1502,74 @@ class BattleGroundAV : public BattleGround
 
         void RemovePlayer(Player *plr,uint64 guid);
         void HandleAreaTrigger(Player *Source, uint32 Trigger);
-        //bool SetupBattleGround();
+        bool SetupBattleGround();
+        virtual void ResetBGSubclass();
 
-        /* Scorekeeping */
-        void UpdatePlayerScore(Player *Source, uint32 type, uint32 value);
+        /*general stuff*/
+        void UpdateScore(uint16 team, int16 points);
+       void UpdatePlayerScore(Player *Source, uint32 type, uint32 value);
+
+        /*handlestuff*/ //these are functions which get called from extern
+        virtual void EventPlayerClickedOnFlag(Player *source, GameObject* target_obj);
+        void HandleKillPlayer(Player* player, Player *killer);
+        void HandleKillUnit(Creature *unit, Player *killer);
+        void HandleQuestComplete(uint32 questid, Player *player);
+        bool PlayerCanDoMineQuest(int32 GOId,uint32 team);
+
+
+
+        virtual WorldSafeLocsEntry const* GetClosestGraveYard(float x, float y, float z, uint32 team);
 
     private:
+        /* Nodes occupying */
+        void EventPlayerAssaultsPoint(Player* player, uint32 object);
+        void EventPlayerDefendsPoint(Player* player, uint32 object);
+        void EventPlayerDestroyedPoint(BG_AV_Nodes node);
+
+        void AssaultNode(BG_AV_Nodes node,uint16 team);
+        void DestroyNode(BG_AV_Nodes node);
+        void InitNode(BG_AV_Nodes node, uint16 team, bool tower);
+        void DefendNode(BG_AV_Nodes node, uint16 team);
+
+        void PopulateNode(BG_AV_Nodes node);
+        void DePopulateNode(BG_AV_Nodes node);
+
+        const BG_AV_Nodes GetNodeThroughObject(uint32 object);
+        const uint32 GetObjectThroughNode(BG_AV_Nodes node);
+        const char* GetNodeName(BG_AV_Nodes node);
+        const bool IsTower(BG_AV_Nodes node) {   return m_Nodes[node].Tower; }
+
+
+        /*mine*/
+        void ChangeMineOwner(uint8 mine, uint32 team, bool initial=false);
+
+        /*worldstates*/
+        void FillInitialWorldStates(WorldPacket& data);
+        const uint8 GetWorldStateType(uint8 state, uint16 team);
+        void SendMineWorldStates(uint32 mine);
+        void UpdateNodeWorldState(BG_AV_Nodes node);
+
+        /*general */
+        Creature* AddAVCreature(uint8 cinfoid, uint16 type);
+        const uint16 GetBonusHonor(uint8 kills); //TODO remove this when mangos handles this right
+
+        /*variables */
+        int32 m_Team_Scores[2];
+        uint32 m_Team_QuestStatus[2][9]; //[x][y] x=team y=questcounter
+
+        BG_AV_NodeInfo m_Nodes[BG_AV_NODES_MAX];
+
+        uint32 m_Mine_Owner[2];
+        uint32 m_Mine_PrevOwner[2]; //only for worldstates needed
+        int32 m_Mine_Timer; //ticks for both teams
+        uint32 m_Mine_Reclaim_Timer[2];
+        uint32 m_CaptainBuffTimer[2];
+        bool m_CaptainAlive[2];
+
+        uint8 m_MaxLevel; //TODO remove this when battleground-getmaxlevel() returns something usefull
+        bool m_IsInformedNearVictory[2];
+
+
 };
+
 #endif
diff --git a/src/game/BattleGroundBE.cpp b/src/game/BattleGroundBE.cpp
index dcf9943..a8fedd9 100644
--- a/src/game/BattleGroundBE.cpp
+++ b/src/game/BattleGroundBE.cpp
@@ -47,6 +47,12 @@ void BattleGroundBE::Update(time_t diff)
         if (!(m_Events & 0x01))
         {
             m_Events |= 0x01;
+            // setup here, only when at least one player has ported to the map
+            if(!SetupBattleGround())
+            {
+                EndNow();
+                return;
+            }
             for(uint32 i = BG_BE_OBJECT_DOOR_1; i <= BG_BE_OBJECT_DOOR_4; i++)
                 SpawnBGObject(i, RESPAWN_IMMEDIATELY);
 
@@ -86,6 +92,11 @@ void BattleGroundBE::Update(time_t diff)
             for(BattleGroundPlayerMap::const_iterator itr = GetPlayers().begin(); itr != GetPlayers().end(); ++itr)
                 if(Player *plr = objmgr.GetPlayer(itr->first))
                     plr->RemoveAurasDueToSpell(SPELL_ARENA_PREPARATION);
+
+            if(!GetPlayersCountByTeam(ALLIANCE) && GetPlayersCountByTeam(HORDE))
+                EndBattleGround(HORDE);
+            else if(GetPlayersCountByTeam(ALLIANCE) && !GetPlayersCountByTeam(HORDE))
+                EndBattleGround(ALLIANCE);
         }
     }
 
@@ -102,11 +113,23 @@ void BattleGroundBE::AddPlayer(Player *plr)
     BattleGroundBEScore* sc = new BattleGroundBEScore;
 
     m_PlayerScores[plr->GetGUID()] = sc;
+
+    UpdateWorldState(0x9f1, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0x9f0, GetAlivePlayersCountByTeam(HORDE));
 }
 
 void BattleGroundBE::RemovePlayer(Player *plr, uint64 guid)
 {
+    if(GetStatus() == STATUS_WAIT_LEAVE)
+        return;
+
+    UpdateWorldState(0x9f1, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0x9f0, GetAlivePlayersCountByTeam(HORDE));
 
+    if(!GetAlivePlayersCountByTeam(ALLIANCE) && GetPlayersCountByTeam(HORDE))
+        EndBattleGround(HORDE);
+    else if(GetPlayersCountByTeam(ALLIANCE) && !GetAlivePlayersCountByTeam(HORDE))
+        EndBattleGround(ALLIANCE);
 }
 
 void BattleGroundBE::HandleKillPlayer(Player *player, Player *killer)
@@ -120,19 +143,29 @@ void BattleGroundBE::HandleKillPlayer(Player *player, Player *killer)
         return;
     }
 
-    BattleGround::HandleKillPlayer(player, killer);
+    BattleGround::HandleKillPlayer(player,killer);
 
-    uint32 killer_team_index = GetTeamIndexByTeamId(killer->GetTeam());
+    UpdateWorldState(0x9f1, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0x9f0, GetAlivePlayersCountByTeam(HORDE));
 
-    ++m_TeamKills[killer_team_index];                       // add kills to killer's team
-
-    if(m_TeamKills[killer_team_index] >= GetPlayersCountByTeam(player->GetTeam()))
+    if(!GetAlivePlayersCountByTeam(ALLIANCE))
+    {
+        // all opponents killed
+        EndBattleGround(HORDE);
+    }
+    else if(!GetAlivePlayersCountByTeam(HORDE))
     {
         // all opponents killed
-        EndBattleGround(killer->GetTeam());
+        EndBattleGround(ALLIANCE);
     }
 }
 
+bool BattleGroundBE::HandlePlayerUnderMap(Player *player)
+{
+    player->TeleportTo(GetMapId(),6238.930176,262.963470,0.889519,player->GetOrientation(),false);
+    return true;
+}
+
 void BattleGroundBE::HandleAreaTrigger(Player *Source, uint32 Trigger)
 {
     // this is wrong way to implement these things. On official it done by gameobject spell cast.
@@ -159,10 +192,16 @@ void BattleGroundBE::HandleAreaTrigger(Player *Source, uint32 Trigger)
     //    HandleTriggerBuff(buff_guid,Source);
 }
 
+void BattleGroundBE::FillInitialWorldStates(WorldPacket &data)
+{
+    data << uint32(0x9f1) << uint32(GetAlivePlayersCountByTeam(ALLIANCE));           // 7
+    data << uint32(0x9f0) << uint32(GetAlivePlayersCountByTeam(HORDE));           // 8
+    data << uint32(0x9f3) << uint32(1);           // 9
+}
+
 void BattleGroundBE::ResetBGSubclass()
 {
-    m_TeamKills[BG_TEAM_ALLIANCE] = 0;
-    m_TeamKills[BG_TEAM_HORDE]    = 0;
+
 }
 
 bool BattleGroundBE::SetupBattleGround()
diff --git a/src/game/BattleGroundBE.h b/src/game/BattleGroundBE.h
index f74f0a6..df46efb 100644
--- a/src/game/BattleGroundBE.h
+++ b/src/game/BattleGroundBE.h
@@ -64,12 +64,11 @@ class BattleGroundBE : public BattleGround
         void HandleAreaTrigger(Player *Source, uint32 Trigger);
         bool SetupBattleGround();
         void ResetBGSubclass();
+        virtual void FillInitialWorldStates(WorldPacket &d);
         void HandleKillPlayer(Player* player, Player *killer);
+        bool HandlePlayerUnderMap(Player * plr);
 
         /* Scorekeeping */
         void UpdatePlayerScore(Player *Source, uint32 type, uint32 value);
-
-    private:
-        uint32 m_TeamKills[2];                              // count of kills for each team
 };
 #endif
diff --git a/src/game/BattleGroundEY.cpp b/src/game/BattleGroundEY.cpp
index 165b1cf..45e674d 100644
--- a/src/game/BattleGroundEY.cpp
+++ b/src/game/BattleGroundEY.cpp
@@ -54,9 +54,18 @@ void BattleGroundEY::Update(time_t diff)
         {
             m_Events |= 0x01;
 
+            // setup here, only when at least one player has ported to the map
+            if(!SetupBattleGround())
+            {
+                EndNow();
+                return;
+            }
+
             SpawnBGObject(BG_EY_OBJECT_DOOR_A, RESPAWN_IMMEDIATELY);
             SpawnBGObject(BG_EY_OBJECT_DOOR_H, RESPAWN_IMMEDIATELY);
 
+//            SpawnBGCreature(EY_SPIRIT_MAIN_ALLIANCE, RESPAWN_IMMEDIATELY);
+//            SpawnBGCreature(EY_SPIRIT_MAIN_HORDE, RESPAWN_IMMEDIATELY);
             for(uint32 i = BG_EY_OBJECT_A_BANNER_FEL_REALVER_CENTER; i < BG_EY_OBJECT_MAX; ++i)
                 SpawnBGObject(i, RESPAWN_ONE_DAY);
 
@@ -572,7 +581,17 @@ void BattleGroundEY::HandleKillPlayer(Player *player, Player *killer)
 
 void BattleGroundEY::EventPlayerDroppedFlag(Player *Source)
 {
-    // Drop allowed in any BG state
+    if(GetStatus() != STATUS_IN_PROGRESS)
+    {
+        // if not running, do not cast things at the dropper player, neither send unnecessary messages
+        // just take off the aura
+        if(IsFlagPickedup() && GetFlagPickerGUID() == Source->GetGUID())
+        {
+            SetFlagPicker(0);
+            Source->RemoveAurasDueToSpell(BG_EY_NETHERSTORM_FLAG_SPELL);
+        }
+        return;
+    }
 
     if(!IsFlagPickedup())
         return;
@@ -743,6 +762,8 @@ void BattleGroundEY::EventTeamCapturedPoint(Player *Source, uint32 Point)
     if(!sg || !AddSpiritGuide(Point, sg->x, sg->y, sg->z, 3.124139f, Team))
         sLog.outError("BatteGroundEY: Failed to spawn spirit guide! point: %u, team: u, graveyard_id: %u", Point, Team, m_CapturingPointTypes[Point].GraveYardId);
 
+//    SpawnBGCreature(Point,RESPAWN_IMMEDIATELY);
+
     UpdatePointsIcons(Team, Point);
     UpdatePointsCount(Team);
 }
diff --git a/src/game/BattleGroundHandler.cpp b/src/game/BattleGroundHandler.cpp
index e26ed01..8fe600d 100644
--- a/src/game/BattleGroundHandler.cpp
+++ b/src/game/BattleGroundHandler.cpp
@@ -26,9 +26,11 @@
 #include "MapManager.h"
 #include "ObjectAccessor.h"
 #include "Object.h"
+#include "Chat.h"
 #include "BattleGroundMgr.h"
 #include "BattleGroundWS.h"
 #include "BattleGround.h"
+#include "ArenaTeam.h"
 #include "Language.h"
 
 void WorldSession::HandleBattleGroundHelloOpcode( WorldPacket & recv_data )
@@ -76,16 +78,23 @@ void WorldSession::HandleBattleGroundJoinOpcode( WorldPacket & recv_data )
     uint32 bgTypeId;
     uint32 instanceId;
     uint8 joinAsGroup;
+    Group * grp;
 
     recv_data >> guid;                                      // battlemaster guid
     recv_data >> bgTypeId;                                  // battleground type id (DBC id)
     recv_data >> instanceId;                                // instance id, 0 if First Available selected
     recv_data >> joinAsGroup;                               // join as group
 
-    sLog.outDebug( "WORLD: Recvd CMSG_BATTLEMASTER_JOIN Message from: " I64FMT " for BG (Type: %u)", guid, bgTypeId);
-
-    if(bgTypeId >= MAX_BATTLEGROUND_TYPES)                  // cheating?
+    if(bgTypeId >= MAX_BATTLEGROUND_TYPES)
+    {
+        sLog.outError("Battleground: invalid bgtype received. possible cheater? player guid %u",_player->GetGUIDLow());
         return;
+    }
+
+    sLog.outDebug( "WORLD: Recvd CMSG_BATTLEMASTER_JOIN Message from: " I64FMT, guid);
+
+    // can do this, since it's battleground, not arena
+    uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bgTypeId, 0);
 
     // ignore if we already in BG or BG queue
     if(_player->InBattleGround())
@@ -98,74 +107,150 @@ void WorldSession::HandleBattleGroundJoinOpcode( WorldPacket & recv_data )
     if(!unit->isBattleMaster())                             // it's not battlemaster
         return;
 
-    // check Deserter debuff
-    if( !_player->CanJoinToBattleground() )
+    // get bg instance or bg template if instance not found
+    BattleGround * bg = 0;
+    if(instanceId)
+        BattleGround *bg = sBattleGroundMgr.GetBattleGround(instanceId);
+
+    if(!bg && !(bg = sBattleGroundMgr.GetBattleGroundTemplate(bgTypeId)))
     {
-        WorldPacket data(SMSG_GROUP_JOINED_BATTLEGROUND, 4);
-        data << (uint32) 0xFFFFFFFE;
-        _player->GetSession()->SendPacket(&data);
+        sLog.outError("Battleground: no available bg / template found");
         return;
     }
 
-    // check existence
-    BattleGround *bg = sBattleGroundMgr.GetBattleGround(bgTypeId);
-    if(!bg)
-        return;
-
-    if(joinAsGroup && _player->GetGroup())
+    // check queueing conditions
+    if(!joinAsGroup)
     {
-        Group *grp = _player->GetGroup();
-        for(GroupReference *itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
+        // check Deserter debuff
+        if( !_player->CanJoinToBattleground() )
         {
-            Player *member = itr->getSource();
-            if(!member) continue;
-
-            if( !member->CanJoinToBattleground() )
+            WorldPacket data(SMSG_GROUP_JOINED_BATTLEGROUND, 4);
+            data << (uint32) 0xFFFFFFFE;
+            _player->GetSession()->SendPacket(&data);
+            return;
+        }
+        // check if already in queue
+        if (_player->GetBattleGroundQueueIndex(bgQueueTypeId) < PLAYER_MAX_BATTLEGROUND_QUEUES)
+            //player is already in this queue
+            return;
+        // check if has free queue slots
+        if(!_player->HasFreeBattleGroundQueueId())
+            return;
+    }
+    else
+    {
+        grp = _player->GetGroup();
+        // no group found, error
+        if(!grp)
+            return;
+        uint32 err = grp->CanJoinBattleGroundQueue(bgTypeId, bgQueueTypeId, 0, bg->GetMaxPlayersPerTeam(), false, 0);
+        switch(err)
+        {
+            // TODO: add error-based feedback to players in all cases
+        case BG_JOIN_ERR_GROUP_TOO_MANY:
             {
-                WorldPacket data(SMSG_GROUP_JOINED_BATTLEGROUND, 4);
-                data << (uint32) 0xFFFFFFFE;
-                _player->GetSession()->SendPacket(&data);
-                continue;
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_TOO_LARGE), NULL);
+            SendPacket(&data);
             }
-            if (member->InBattleGroundQueueForBattleGroundType(bgTypeId))
-                //player is already in this queue
-                continue;
-
+            return;
+            break;
+        case BG_JOIN_ERR_OFFLINE_MEMBER:
+            {
             WorldPacket data;
-                                                            // add to queue
-            uint32 queueSlot = member->AddBattleGroundQueueId(bgTypeId);
-            if (queueSlot == PLAYER_MAX_BATTLEGROUND_QUEUES)
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_OFFLINE_MEMBER), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_MIXED_FACTION:
             {
-                // fill data packet
-                //member->GetSession()->SendPacket(data);
-                continue;
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_MIXED_FACTION), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_MIXED_LEVELS:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_MIXED_LEVELS), NULL);
+            SendPacket(&data);
             }
+            return;
+            break;
+        case BG_JOIN_ERR_GROUP_MEMBER_ALREADY_IN_QUEUE:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_MEMBER_ALREADY_IN_QUEUE), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_GROUP_DESERTER:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_MEMBER_DESERTER), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_ALL_QUEUES_USED:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_MEMBER_NO_FREE_QUEUE_SLOTS), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+            // all ok, can join
+        case BG_JOIN_ERR_OK:
+            break;
+            // these aren't possible outcomes in bgs 
+        case BG_JOIN_ERR_GROUP_NOT_ENOUGH:
+        case BG_JOIN_ERR_MIXED_ARENATEAM:
+            return;
+            break;
+            // not the above? shouldn't happen, don't let join
+        default:
+            return;
+            break;
+        };
+    }
+
+    // if we're here, then the conditions to join a bg are met. We can proceed in joining.
+
+    // _player->GetGroup() was already checked, grp is already initialized
+    if(joinAsGroup /* && _player->GetGroup()*/)
+    {
+        sLog.outDebug("Battleground: the following players are joining as group:");
+        GroupQueueInfo * ginfo = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddGroup(_player, bgTypeId, 0, false, 0);
+        for(GroupReference *itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player *member = itr->getSource();
+            if(!member) continue;   // this should never happen
+
+            uint32 queueSlot = member->AddBattleGroundQueueId(bgQueueTypeId);           // add to queue
 
             // store entry point coords (same as leader entry point)
             member->SetBattleGroundEntryPoint(_player->GetMapId(),_player->GetPositionX(),_player->GetPositionY(),_player->GetPositionZ(),_player->GetOrientation());
 
+            WorldPacket data;
                                                             // send status packet (in queue)
             sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, member->GetTeam(), queueSlot, STATUS_WAIT_QUEUE, 0, 0);
             member->GetSession()->SendPacket(&data);
             sBattleGroundMgr.BuildGroupJoinedBattlegroundPacket(&data, bgTypeId);
             member->GetSession()->SendPacket(&data);
-            sBattleGroundMgr.m_BattleGroundQueues[bgTypeId].AddPlayer(member, bgTypeId);
+            sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddPlayer(member, ginfo);
+            sLog.outDebug("Battleground: player joined queue for bg queue type %u bg type %u: GUID %u, NAME %s",bgQueueTypeId,bgTypeId,member->GetGUIDLow(), member->GetName());
         }
+        sLog.outDebug("Battleground: group end");
+        sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].Update(bgTypeId, _player->GetBattleGroundQueueIdFromLevel());
     }
     else
     {
-        if (_player->InBattleGroundQueueForBattleGroundType(bgTypeId))
-            //player is already in this queue
-            return;
-        uint32 queueSlot = _player->AddBattleGroundQueueId(bgTypeId);
-        if (queueSlot == PLAYER_MAX_BATTLEGROUND_QUEUES)
-        {
-            WorldPacket data;
-            // fill data packet
-            //SendPacket(data);
-            return;
-        }
-
+        // already checked if queueSlot is valid, now just get it
+        uint32 queueSlot = _player->AddBattleGroundQueueId(bgQueueTypeId);
         // store entry point coords
         _player->SetBattleGroundEntryPoint(_player->GetMapId(),_player->GetPositionX(),_player->GetPositionY(),_player->GetPositionZ(),_player->GetOrientation());
 
@@ -173,7 +258,11 @@ void WorldSession::HandleBattleGroundJoinOpcode( WorldPacket & recv_data )
                                                             // send status packet (in queue)
         sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), queueSlot, STATUS_WAIT_QUEUE, 0, 0);
         SendPacket(&data);
-        sBattleGroundMgr.m_BattleGroundQueues[bgTypeId].AddPlayer(_player, bgTypeId);
+
+        GroupQueueInfo * ginfo = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddGroup(_player, bgTypeId, 0, false, 0);
+        sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddPlayer(_player, ginfo);
+        sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].Update(bgTypeId, _player->GetBattleGroundQueueIdFromLevel());
+        sLog.outDebug("Battleground: player joined queue for bg queue type %u bg type %u: GUID %u, NAME %s",bgQueueTypeId,bgTypeId,_player->GetGUIDLow(), _player->GetName());
     }
 }
 
@@ -247,12 +336,11 @@ void WorldSession::HandleBattleGroundListOpcode( WorldPacket &recv_data )
     uint32 bgTypeId;
     recv_data >> bgTypeId;                                  // id from DBC
 
-    if(bgTypeId >= MAX_BATTLEGROUND_TYPES)                  // cheating?
-        return;
-
-    // can't be received if player not in BG queue
-    if(!_player->InBattleGroundQueueForBattleGroundType(bgTypeId))
+    if(bgTypeId >= MAX_BATTLEGROUND_TYPES)
+    {
+        sLog.outError("Battleground: invalid bgtype received.");
         return;
+    }
 
     BattlemasterListEntry const* bl = sBattlemasterListStore.LookupEntry(bgTypeId);
 
@@ -270,80 +358,186 @@ void WorldSession::HandleBattleGroundPlayerPortOpcode( WorldPacket &recv_data )
 
     sLog.outDebug( "WORLD: Recvd CMSG_BATTLEFIELD_PORT Message");
 
-    uint8 unk1;
+    uint8 type;                                             // arenatype if arena
     uint8 unk2;                                             // unk, can be 0x0 (may be if was invited?) and 0x1
+    uint32 instanceId;                                      
     uint32 bgTypeId;                                        // type id from dbc
     uint16 unk;                                             // 0x1F90 constant?
     uint8 action;                                           // enter battle 0x1, leave queue 0x0
 
-    recv_data >> unk1 >> unk2 >> bgTypeId >> unk >> action;
+    recv_data >> type >> unk2 >> bgTypeId >> unk >> action;
 
-    if(bgTypeId >= MAX_BATTLEGROUND_TYPES)                  // cheating?
-        return;
+    if(bgTypeId >= MAX_BATTLEGROUND_TYPES)
+    {
+        sLog.outError("Battleground: invalid bgtype received.");
+        // update battleground slots for the player to fix his UI and sent data.
+        // this is a HACK, I don't know why the client starts sending invalid packets in the first place.
+        // it usually happens with extremely high latency (if debugging / stepping in the code for example)
+        if(_player->InBattleGroundQueue())
+        {
+            // update all queues, send invitation info if player is invited, queue info if queued
+            for (uint32 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
+            {
+                uint32 queue_id = _player->GetBattleGroundQueueId(i);
+                if(!queue_id)
+                    continue;
+                BattleGroundQueue::QueuedPlayersMap::iterator itrPlayerStatus = sBattleGroundMgr.m_BattleGroundQueues[queue_id].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].find(_player->GetGUID());
+                // if the player is not in queue, contine
+                if(itrPlayerStatus == sBattleGroundMgr.m_BattleGroundQueues[queue_id].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].end())
+                    continue;
 
-    if(!_player->InBattleGroundQueueForBattleGroundType(bgTypeId))
-        return;
+                // no group information, this should never happen
+                if(!itrPlayerStatus->second.GroupInfo)
+                    continue;
 
-    BattleGround *bg = sBattleGroundMgr.GetBattleGround(bgTypeId);
-    if(!bg)
-        return;
+                BattleGround * bg = NULL;
 
-    uint32 queueSlot = 0;
-    WorldPacket data;
-    switch(action)
-    {
-        case 1:                                             // port to battleground
-            // cheating?
-            if(!_player->IsInvitedForBattleGroundType(bgTypeId))
-                return;
+                // get possibly needed data from groupinfo
+                bgTypeId = itrPlayerStatus->second.GroupInfo->BgTypeId;
+                uint8 arenatype = itrPlayerStatus->second.GroupInfo->ArenaType;
+                uint8 israted = itrPlayerStatus->second.GroupInfo->IsRated;
+                uint8 status = 0;
 
-            // check if player is not deserter
-            if( !_player->CanJoinToBattleground() )
-            {
-                WorldPacket data2;
-                data2.Initialize(SMSG_GROUP_JOINED_BATTLEGROUND, 4);
-                data2 << (uint32) 0xFFFFFFFE;
-                SendPacket(&data2);
-                return;
-            }
+                
+                if(!itrPlayerStatus->second.GroupInfo->IsInvitedToBGInstanceGUID)
+                {
+                    // not invited to bg, get template
+                    bg = sBattleGroundMgr.GetBattleGroundTemplate(bgTypeId);
+                    status = STATUS_WAIT_QUEUE;
+                }
+                else
+                {
+                    // get the bg we're invited to
+                    BattleGround * bg = sBattleGroundMgr.GetBattleGround(itrPlayerStatus->second.GroupInfo->IsInvitedToBGInstanceGUID);
+                    status = STATUS_WAIT_JOIN;
+                }
 
-            // if the player is dead, resurrect him before teleport
-            if(!_player->isAlive())
-            {
-                _player->ResurrectPlayer(1.0f,false);
-                _player->SpawnCorpseBones();
+                // if bg not found, then continue
+                if(!bg)
+                    continue;
+
+                // don't invite if already in the instance
+                if(_player->InBattleGround() && _player->GetBattleGround() && _player->GetBattleGround()->GetInstanceID() == bg->GetInstanceID())
+                    continue;
+
+                // re - invite player with proper data
+                WorldPacket data;
+                sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, itrPlayerStatus->second.GroupInfo->Team?itrPlayerStatus->second.GroupInfo->Team:_player->GetTeam(), i, status, INVITE_ACCEPT_WAIT_TIME, 0, arenatype, israted);
+                SendPacket(&data);
             }
+        }
+        return;
+    }
 
-            // leave current group
-            _player->RemoveFromGroup();
+    uint32 bgQueueTypeId = 0;
+    // get the bg what we were invited to 
+    BattleGroundQueue::QueuedPlayersMap::iterator itrPlayerStatus;
+    bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bgTypeId,type);
+    itrPlayerStatus = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].find(_player->GetGUID());
 
-            // packet to player about BG status
-            queueSlot = _player->GetBattleGroundQueueIndex(bgTypeId);
-            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), queueSlot, STATUS_IN_PROGRESS, 0, bg->GetStartTime());
-            _player->GetSession()->SendPacket(&data);
+    if(itrPlayerStatus == sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].end())
+    {
+        sLog.outError("Battleground: itrplayerstatus not found.");
+        return;
+    }
+    instanceId = itrPlayerStatus->second.GroupInfo->IsInvitedToBGInstanceGUID;
 
-            // remove battleground queue status from BGmgr
-            sBattleGroundMgr.m_BattleGroundQueues[bgTypeId].RemovePlayer(_player->GetGUID(), false);
+    // if action == 1, then instanceId is _required_
+    if(!instanceId && action == 1)
+    {
+        sLog.outError("Battleground: instance not found.");
+        return;
+    }
 
-            // this is still needed here if battleground "jumping" shouldn't add deserter debuff
-            // also this required to prevent stuck at old battleground after SetBattleGroundId set to new
-            if (BattleGround *currentBg = _player->GetBattleGround())
-                currentBg->RemovePlayerAtLeave(_player->GetGUID(), false, true);
+    BattleGround *bg = sBattleGroundMgr.GetBattleGround(instanceId);
 
-            _player->SetBattleGroundId(bg->GetTypeID());
-            sBattleGroundMgr.SendToBattleGround(_player, bgTypeId);
-            bg->AddPlayer(_player);
-            break;
-        case 0:                                             // leave queue
-            queueSlot = _player->GetBattleGroundQueueIndex(bgTypeId);
-            _player->RemoveBattleGroundQueueId(bgTypeId);   // must be called this way, because if you move this call to queue->removeplayer, it causes bugs
-            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), queueSlot, STATUS_NONE, 0, 0);
-            sBattleGroundMgr.m_BattleGroundQueues[bgTypeId].RemovePlayer(_player->GetGUID(), true);
-            SendPacket(&data);
-            break;
-        default:
-            sLog.outError("Battleground port: unknown action %u", action);
-            break;
+    // bg template might and must be used in case of leaving queue, when instance is not created yet
+    if(!bg && action == 0)
+        bg = sBattleGroundMgr.GetBattleGroundTemplate(bgTypeId);
+
+    if(!bg)
+    {
+        sLog.outError("Battleground: bg not found.");
+        return;
+    }
+
+    bgTypeId = bg->GetTypeID();
+
+    if(_player->InBattleGroundQueue())
+    {
+        uint32 queueSlot = 0;
+        uint32 team = 0;
+        uint32 arenatype = 0;
+        uint32 israted = 0;
+        uint32 rating = 0;
+        // get the team info from the queue
+        BattleGroundQueue::QueuedPlayersMap::iterator pitr = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].find(_player->GetGUID());
+        if(pitr !=sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].end()
+            && pitr->second.GroupInfo )
+        {
+            team = pitr->second.GroupInfo->Team;
+            arenatype = pitr->second.GroupInfo->ArenaType;
+            israted = pitr->second.GroupInfo->IsRated;
+            rating = pitr->second.GroupInfo->ArenaTeamRating;
+        }
+        else
+        {
+            sLog.outError("Battleground: Invalid player queue info!");
+            return;
+        }
+        WorldPacket data;
+        switch(action)
+        {
+            case 1:                                     // port to battleground
+                if(!_player->IsInvitedForBattleGroundQueueType(bgQueueTypeId))
+                    return;                                     // cheating?
+                // resurrect the player
+                if(!_player->isAlive())
+                {
+                    _player->ResurrectPlayer(1.0f,false);
+                    _player->SpawnCorpseBones();
+                }
+                // stop taxi flight at port
+                if(_player->isInFlight())
+                {
+                    _player->GetMotionMaster()->MovementExpired();
+                    _player->m_taxi.ClearTaxiDestinations();
+                }
+                _player->RemoveFromGroup();
+                queueSlot = _player->GetBattleGroundQueueIndex(bgQueueTypeId);
+                sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), queueSlot, STATUS_IN_PROGRESS, 0, bg->GetStartTime());
+                _player->GetSession()->SendPacket(&data);
+                // remove battleground queue status from BGmgr
+                sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].RemovePlayer(_player->GetGUID(), false);
+                // this is still needed here if battleground "jumping" shouldn't add deserter debuff
+                // also this required to prevent stuck at old battleground after SetBattleGroundId set to new
+                if( BattleGround *currentBg = _player->GetBattleGround() )
+                    currentBg->RemovePlayerAtLeave(_player->GetGUID(), false, true);
+
+                // set the destination instance id
+                _player->SetBattleGroundId(bg->GetInstanceID());
+                // set the destination team
+                _player->SetBGTeam(team);
+                // bg->HandleBeforeTeleportToBattleGround(_player);
+                sBattleGroundMgr.SendToBattleGround(_player, instanceId);
+                // add only in HandleMoveWorldPortAck()
+                // bg->AddPlayer(_player,team);
+                sLog.outDebug("Battleground: player %s (%u) joined battle for bg %u, bgtype %u, queue type %u.",_player->GetName(),_player->GetGUIDLow(),bg->GetInstanceID(),bg->GetTypeID(),bgQueueTypeId);
+                break;
+            case 0:                                     // leave queue
+                queueSlot = _player->GetBattleGroundQueueIndex(bgQueueTypeId);
+                _player->RemoveBattleGroundQueueId(bgQueueTypeId); // must be called this way, because if you move this call to queue->removeplayer, it causes bugs
+                sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), queueSlot, STATUS_NONE, 0, 0);
+                sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].RemovePlayer(_player->GetGUID(), true);
+                // player left queue, we should update it, maybe now his group fits in
+                sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].Update(bgTypeId,_player->GetBattleGroundQueueIdFromLevel(),arenatype,israted,rating);
+                SendPacket(&data);
+                sLog.outDebug("Battleground: player %s (%u) left queue for bgtype %u, queue type %u.",_player->GetName(),_player->GetGUIDLow(),bg->GetTypeID(),bgQueueTypeId);
+                break;
+            default:
+                sLog.outError("Battleground port: unknown action %u", action);
+                break;
+        }
     }
 }
 
@@ -384,7 +578,8 @@ void WorldSession::HandleBattlefieldStatusOpcode( WorldPacket & /*recv_data*/ )
         BattleGround *bg = _player->GetBattleGround();
         if(bg)
         {
-            uint32 queueSlot = _player->GetBattleGroundQueueIndex(bg->GetTypeID());
+            uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bg->GetTypeID(), bg->GetArenaType());
+            uint32 queueSlot = _player->GetBattleGroundQueueIndex(bgQueueTypeId);
             if((bg->GetStatus() <= STATUS_IN_PROGRESS))
             {
                 sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), queueSlot, STATUS_IN_PROGRESS, 0, bg->GetStartTime());
@@ -392,15 +587,25 @@ void WorldSession::HandleBattlefieldStatusOpcode( WorldPacket & /*recv_data*/ )
             }
             for (uint32 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
             {
-                uint32 queue_id = _player->GetBattleGroundQueueId(i);
-                if (i == queueSlot || !queue_id)
+                uint32 queue_id = _player->GetBattleGroundQueueId(i);       // battlegroundqueueid stores the type id, not the instance id, so this is definitely wrong
+                uint8 arenatype = sBattleGroundMgr.BGArenaType(queue_id);
+                uint8 isRated = 0;
+                if (i == queueSlot || !queue_id)                            // we need to get the instance ids
+                    continue;
+                BattleGroundQueue::QueuedPlayersMap::iterator itrPlayerStatus = sBattleGroundMgr.m_BattleGroundQueues[queue_id].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].find(_player->GetGUID());
+                if(itrPlayerStatus == sBattleGroundMgr.m_BattleGroundQueues[queue_id].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].end())
                     continue;
-                BattleGround *bg2 = sBattleGroundMgr.GetBattleGround(queue_id);
+                if(itrPlayerStatus->second.GroupInfo)
+                {
+                    arenatype = itrPlayerStatus->second.GroupInfo->ArenaType;
+                    isRated = itrPlayerStatus->second.GroupInfo->IsRated;
+                }
+                BattleGround *bg2 = sBattleGroundMgr.GetBattleGroundTemplate(sBattleGroundMgr.BGTemplateId(queue_id)); //  try this
                 if(bg2)
                 {
                     //in this call is small bug, this call should be filled by player's waiting time in queue
                     //this call nulls all timers for client :
-                    sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg2, _player->GetTeam(), i, STATUS_WAIT_QUEUE, 0, 0);
+                    sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg2, _player->GetTeam(), i, STATUS_WAIT_QUEUE, 0, 0,arenatype,isRated);
                     SendPacket(&data);
                 }
             }
@@ -411,16 +616,36 @@ void WorldSession::HandleBattlefieldStatusOpcode( WorldPacket & /*recv_data*/ )
         // we should update all queues? .. i'm not sure if this code is correct
         for (uint32 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
         {
-            if(uint32 queue_id = _player->GetBattleGroundQueueId(i))
+            uint32 queue_id = _player->GetBattleGroundQueueId(i);
+            if(!queue_id)
+                continue;
+            uint32 bgTypeId = sBattleGroundMgr.BGTemplateId(queue_id);
+            uint8 arenatype = sBattleGroundMgr.BGArenaType(queue_id);
+            uint8 isRated = 0;
+            BattleGround *bg = sBattleGroundMgr.GetBattleGroundTemplate(bgTypeId);
+            BattleGroundQueue::QueuedPlayersMap::iterator itrPlayerStatus = sBattleGroundMgr.m_BattleGroundQueues[queue_id].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].find(_player->GetGUID());
+            if(itrPlayerStatus == sBattleGroundMgr.m_BattleGroundQueues[queue_id].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].end())
+                continue;
+            if(itrPlayerStatus->second.GroupInfo)
             {
-                if(BattleGround *bg = sBattleGroundMgr.GetBattleGround(queue_id))
-                {
-                    sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), i, STATUS_WAIT_QUEUE, 0, 0);
-                    SendPacket(&data);
-                }
+                arenatype = itrPlayerStatus->second.GroupInfo->ArenaType;
+                isRated = itrPlayerStatus->second.GroupInfo->IsRated;
+            }
+            if(bg && queue_id)
+            {
+                sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), i, STATUS_WAIT_QUEUE, 0, 0, arenatype, isRated);
+                SendPacket(&data);
             }
         }
     }
+/*    else              // not sure if it needed...
+    {
+        for (uint32 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
+        {
+            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, NULL, _player->GetTeam(),i , STATUS_NONE, 0, 0);
+            SendPacket(&data);
+        }
+    }*/
 }
 
 void WorldSession::HandleAreaSpiritHealerQueryOpcode( WorldPacket & recv_data )
@@ -480,16 +705,12 @@ void WorldSession::HandleBattleGroundArenaJoin( WorldPacket & recv_data )
     if(_player->InBattleGround())
         return;
 
-    for(int qId = 0; qId < PLAYER_MAX_BATTLEGROUND_QUEUES; ++qId)
-    {
-        if(_player->GetBattleGroundQueueId(qId) != 0)
-            return;
-    }
-
     uint64 guid;                                            // arena Battlemaster guid
     uint8 type;                                             // 2v2, 3v3 or 5v5
     uint8 asGroup;                                          // asGroup
     uint8 isRated;                                          // isRated
+    Group * grp;
+
     recv_data >> guid >> type >> asGroup >> isRated;
 
     Creature *unit = ObjectAccessor::GetCreature(*_player, guid);
@@ -500,6 +721,7 @@ void WorldSession::HandleBattleGroundArenaJoin( WorldPacket & recv_data )
         return;
 
     uint8 arenatype = 0;
+    uint32 arenaRating = 0;
 
     switch(type)
     {
@@ -517,88 +739,196 @@ void WorldSession::HandleBattleGroundArenaJoin( WorldPacket & recv_data )
             return;
     }
 
-    if(isRated && !_player->GetArenaTeamId(type))           // player not in arena team of that size
+    //check existance
+    BattleGround* bg = NULL;
+    if( !(bg = sBattleGroundMgr.GetBattleGroundTemplate(BATTLEGROUND_AA)) )
     {
-        _player->GetSession()->SendNotInArenaTeamPacket(arenatype);
+        sLog.outError("Battleground: template bg (all arenas) not found");     
         return;
     }
 
-    if(asGroup && !_player->GetGroup())                     // player not in group
-        return;
+    uint8 bgTypeId = bg->GetTypeID();
+    uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bgTypeId, arenatype);
 
-    // check existence
-    BattleGround *bg = sBattleGroundMgr.GetBattleGround(BATTLEGROUND_AA);
-    if(!bg)
-        return;
+    // check queueing conditions
+    if(!asGroup)
+    {
+        // check if already in queue
+        if (_player->GetBattleGroundQueueIndex(bgQueueTypeId) < PLAYER_MAX_BATTLEGROUND_QUEUES)
+            //player is already in this queue
+            return;
+        // check if has free queue slots
+        if(!_player->HasFreeBattleGroundQueueId())
+            return;
+    }
+    else
+    {
+        grp = _player->GetGroup();
+        // no group found, error
+        if(!grp)
+            return;
+        uint32 err = grp->CanJoinBattleGroundQueue(bgTypeId, bgQueueTypeId, arenatype, arenatype, (bool)isRated, type);
+        switch(err)
+        {
+            // TODO: add error-based feedback to players in all cases
+        case BG_JOIN_ERR_GROUP_TOO_MANY:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_ARENA_GROUP_TOO_LARGE), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_GROUP_NOT_ENOUGH:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_ARENA_NOT_ENOUGH_PLAYERS), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_MIXED_ARENATEAM:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_ARENA_YOUR_TEAM_ONLY), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_OFFLINE_MEMBER:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_OFFLINE_MEMBER), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_MIXED_FACTION:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_MIXED_FACTION), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_MIXED_LEVELS:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_MIXED_LEVELS), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_GROUP_MEMBER_ALREADY_IN_QUEUE:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_MEMBER_ALREADY_IN_QUEUE), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_GROUP_DESERTER:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_MEMBER_DESERTER), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+        case BG_JOIN_ERR_ALL_QUEUES_USED:
+            {
+            WorldPacket data;
+            ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_BG_SYSTEM_NEUTRAL, LANG_UNIVERSAL, NULL, 0, GetMangosString(LANG_BG_GROUP_MEMBER_NO_FREE_QUEUE_SLOTS), NULL);
+            SendPacket(&data);
+            }
+            return;
+            break;
+            // all ok, can join
+        case BG_JOIN_ERR_OK:
+            break;
+            // not the above? shouldn't happen, don't let join
+        default:
+            return;
+            break;
+        };
+    }
 
-    bg->SetArenaType(arenatype);
-    bg->SetRated(isRated);
+    uint32 ateamId = 0;
 
-    if(asGroup && _player->GetGroup())
+    if(isRated)           
     {
-        Group *grp = _player->GetGroup();
+        ateamId = _player->GetArenaTeamId(type);
+        // check real arenateam existence only here (if it was moved to group->CanJoin .. () then we would ahve to get it twice)
+        ArenaTeam * at = objmgr.GetArenaTeamById(ateamId);
+        if(!at)
+        {
+            _player->GetSession()->SendNotInArenaTeamPacket(arenatype);
+            return;
+        }
+        // get the team rating for queueing
+        arenaRating = at->GetRating();
+        // the arenateam id must match for everyone in the group
+        // get the personal ratings for queueing
+        uint32 avg_pers_rating = 0;
         for(GroupReference *itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
         {
             Player *member = itr->getSource();
-            if(!member) continue;
 
-            /*if (!member->CanJoinToBattleground())
-                //player has deserter aura .. do nothing
-            */
+            // calc avg personal rating
+            avg_pers_rating += member->GetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (type*6) + 5);
+        }
 
-            if (member->InBattleGroundQueueForBattleGroundType(BATTLEGROUND_AA))
-                //player is already in this queue
-                continue;
+        if( arenatype )
+            avg_pers_rating /= arenatype;
 
-                                                            // add to queue
-            uint32 queueSlot = member->AddBattleGroundQueueId(BATTLEGROUND_AA);
-            if (queueSlot == PLAYER_MAX_BATTLEGROUND_QUEUES)
-            {
-                WorldPacket data;
-                //fill data
-                //member->GetSession()->SendPacket(data);
-                continue;
-            }
+        // if avg personal rating is more than 150 points below the teams rating, the team will be queued against an opponent matching or similar to the average personal rating 
+        if(avg_pers_rating + 150 < arenaRating)
+            arenaRating = avg_pers_rating;
+    }
+
+    if(asGroup)
+    {
+        GroupQueueInfo * ginfo = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddGroup(_player, bgTypeId, arenatype, isRated, arenaRating, ateamId);
+        sLog.outDebug("Battleground: arena join as group start");
+        if(isRated)
+            sLog.outDebug("Battleground: arena team id %u, leader %s queued with rating %u for type %u",_player->GetArenaTeamId(type),_player->GetName(),arenaRating,arenatype);
+        for(GroupReference *itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player *member = itr->getSource();
+            if(!member) continue;
+
+            uint32 queueSlot = member->AddBattleGroundQueueId(bgQueueTypeId);// add to queue
 
             // store entry point coords (same as leader entry point)
             member->SetBattleGroundEntryPoint(_player->GetMapId(),_player->GetPositionX(),_player->GetPositionY(),_player->GetPositionZ(),_player->GetOrientation());
 
             WorldPacket data;
             // send status packet (in queue)
-            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, member->GetTeam(), queueSlot, STATUS_WAIT_QUEUE, 0, 0);
+            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, member->GetTeam(), queueSlot, STATUS_WAIT_QUEUE, 0, 0, arenatype, isRated);
             member->GetSession()->SendPacket(&data);
-            sBattleGroundMgr.BuildGroupJoinedBattlegroundPacket(&data, BATTLEGROUND_AA);
+            sBattleGroundMgr.BuildGroupJoinedBattlegroundPacket(&data, bgTypeId);
             member->GetSession()->SendPacket(&data);
-            sBattleGroundMgr.m_BattleGroundQueues[BATTLEGROUND_AA].AddPlayer(member, BATTLEGROUND_AA);
+            sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddPlayer(member, ginfo);
+            sLog.outDebug("Battleground: player joined queue for arena as group bg queue type %u bg type %u: GUID %u, NAME %s",bgQueueTypeId,bgTypeId,member->GetGUIDLow(), member->GetName());
         }
+        sLog.outDebug("Battleground: arena join as group end");
+        sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].Update(bgTypeId, _player->GetBattleGroundQueueIdFromLevel(), arenatype, isRated, arenaRating);
     }
     else
     {
-        /*if (!member->CanJoinToBattleground())
-            //player has deserter aura .. do nothing
-        */
-
-        if (_player->InBattleGroundQueueForBattleGroundType(BATTLEGROUND_AA))
-            //player is already in this queue
-            return;
-
-        uint32 queueSlot = _player->AddBattleGroundQueueId(BATTLEGROUND_AA);
-        if (queueSlot == PLAYER_MAX_BATTLEGROUND_QUEUES)
-        {
-            WorldPacket data;
-            //fill data (player is in 3 queues already)
-            //SendPacket(data);
-            return;
-        }
+        uint32 queueSlot = _player->AddBattleGroundQueueId(bgQueueTypeId);
 
         // store entry point coords
         _player->SetBattleGroundEntryPoint(_player->GetMapId(),_player->GetPositionX(),_player->GetPositionY(),_player->GetPositionZ(),_player->GetOrientation());
 
         WorldPacket data;
         // send status packet (in queue)
-        sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), queueSlot, STATUS_WAIT_QUEUE, 0, 0);
+        sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), queueSlot, STATUS_WAIT_QUEUE, 0, 0, arenatype, isRated);
         SendPacket(&data);
-        sBattleGroundMgr.m_BattleGroundQueues[BATTLEGROUND_AA].AddPlayer(_player, BATTLEGROUND_AA);
+        GroupQueueInfo * ginfo = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddGroup(_player, bgTypeId, arenatype, isRated, arenaRating);
+        sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddPlayer(_player, ginfo);
+        sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].Update(bgTypeId, _player->GetBattleGroundQueueIdFromLevel(), arenatype, isRated, arenaRating);
+        sLog.outDebug("Battleground: player joined queue for arena, skirmish, bg queue type %u bg type %u: GUID %u, NAME %s",bgQueueTypeId,bgTypeId,_player->GetGUIDLow(), _player->GetName());
     }
 }
 
diff --git a/src/game/BattleGroundMgr.cpp b/src/game/BattleGroundMgr.cpp
index 5bd23ce..3d83be3 100644
--- a/src/game/BattleGroundMgr.cpp
+++ b/src/game/BattleGroundMgr.cpp
@@ -30,10 +30,13 @@
 #include "SharedDefines.h"
 #include "Policies/SingletonImp.h"
 #include "MapManager.h"
+#include "Map.h"
+#include "MapInstanced.h"
 #include "ObjectMgr.h"
 #include "ProgressBar.h"
 #include "World.h"
 #include "Chat.h"
+#include "ArenaTeam.h"
 
 INSTANTIATE_SINGLETON_1( BattleGroundMgr );
 
@@ -44,12 +47,12 @@ INSTANTIATE_SINGLETON_1( BattleGroundMgr );
 BattleGroundQueue::BattleGroundQueue()
 {
     //queues are empty, we don't have to call clear()
-    for (int i = 0; i < MAX_BATTLEGROUND_QUEUES; i++)
+/*    for (int i = 0; i < MAX_BATTLEGROUND_QUEUES; i++)
     {
-        m_QueuedPlayers[i].Horde = 0;
-        m_QueuedPlayers[i].Alliance = 0;
+        //m_QueuedPlayers[i].Horde = 0;
+        //m_QueuedPlayers[i].Alliance = 0;
         //m_QueuedPlayers[i].AverageTime = 0;
-    }
+    }*/
 }
 
 BattleGroundQueue::~BattleGroundQueue()
@@ -57,31 +60,191 @@ BattleGroundQueue::~BattleGroundQueue()
     for (int i = 0; i < MAX_BATTLEGROUND_QUEUES; i++)
     {
         m_QueuedPlayers[i].clear();
+        for(QueuedGroupsList::iterator itr = m_QueuedGroups[i].begin(); itr!= m_QueuedGroups[i].end(); ++itr)
+        {
+            delete (*itr);
+        }
+        m_QueuedGroups[i].clear();
+    }
+}
+
+// initialize eligible groups from the given source matching the given specifications
+void BattleGroundQueue::EligibleGroups::Init(BattleGroundQueue::QueuedGroupsList *source, uint32 BgTypeId, uint32 side, uint32 MaxPlayers, uint8 ArenaType, bool IsRated, uint32 MinRating, uint32 MaxRating, uint32 DisregardTime, uint32 excludeTeam)
+{
+    // clear from prev initialization
+    clear();
+    BattleGroundQueue::QueuedGroupsList::iterator itr, next;
+    // iterate through the source
+    for(itr = source->begin(); itr!= source->end(); itr = next)
+    {
+        next = itr;
+        ++next;
+        if( (*itr)->BgTypeId == BgTypeId &&     // bg type must match
+            (*itr)->ArenaType == ArenaType &&   // arena type must match
+            (*itr)->IsRated == IsRated &&       // israted must match
+            (*itr)->IsInvitedToBGInstanceGUID == 0 && // leave out already invited groups
+            (*itr)->Team == side &&             // match side
+            (*itr)->Players.size() <= MaxPlayers &&   // the group must fit in the bg
+            ( !excludeTeam || (*itr)->ArenaTeamId != excludeTeam ) && // if excludeTeam is specified, leave out those arena team ids
+            ( !IsRated || (*itr)->Players.size() == MaxPlayers ) &&   // if rated, then pass only if the player count is exact NEEDS TESTING! (but now this should never happen)
+            (  (*itr)->JoinTime <= DisregardTime              // pass if disregard time is greater than join time
+               || (*itr)->ArenaTeamRating == 0                 // pass if no rating info
+               || ( (*itr)->ArenaTeamRating >= MinRating       // pass if matches the rating range
+                     && (*itr)->ArenaTeamRating <= MaxRating ) ) )   
+        {
+            // the group matches the conditions
+            // insert it in order of groupsize, and join time
+            uint32 size = (*itr)->Players.size();
+            uint32 jointime = (*itr)->JoinTime;
+            bool inserted = false;
+
+            for(std::list<GroupQueueInfo *>::iterator elig_itr = begin(); elig_itr != end(); ++elig_itr)
+            {
+                // if the next one's size is smaller, then insert
+                // also insert if the next one's size is equal, but it joined the queue later
+                if( ((*elig_itr)->Players.size()<size) ||
+                    ((*elig_itr)->Players.size() == size && (*elig_itr)->JoinTime > jointime) )
+                {
+                    insert(elig_itr,(*itr));
+                    inserted = true;
+                    break;
+                }
+            }
+            // if not inserted -> this is the smallest group -> push_back
+            if(!inserted)
+            {
+                push_back((*itr));
+            }
+        }
+    }
+}
+
+// remove group from eligible groups
+// used when building selection pools
+void BattleGroundQueue::EligibleGroups::RemoveGroup(GroupQueueInfo * ginfo)
+{
+    for(std::list<GroupQueueInfo *>::iterator itr = begin(); itr != end(); ++itr)
+    {
+        if((*itr)==ginfo)
+        {
+            erase(itr);
+            return;
+        }
+    }
+}
+
+// selection pool initialization, used to clean up from prev selection
+void BattleGroundQueue::SelectionPool::Init()
+{
+    SelectedGroups.clear();
+    MaxGroup = 0;
+    PlayerCount = 0;
+}
+
+// get the maximal group from the selection pool
+// used when building the pool, and have to remove the largest
+GroupQueueInfo * BattleGroundQueue::SelectionPool::GetMaximalGroup()
+{
+    if(SelectedGroups.empty())
+    {
+        sLog.outError("Getting max group when selection pool is empty, this should never happen.");
+        MaxGroup = NULL;
+        return 0;
     }
+    // actually select the max group if it's not set
+    if(MaxGroup==0 && !SelectedGroups.empty())
+    {
+        uint32 max_size = 0;
+        for(std::list<GroupQueueInfo *>::iterator itr = SelectedGroups.begin(); itr != SelectedGroups.end(); ++itr)
+        {
+            if(max_size<(*itr)->Players.size())
+            {
+                MaxGroup =(*itr);
+                max_size = MaxGroup->Players.size();
+            }
+        }
+    }
+    return MaxGroup;
 }
 
-void BattleGroundQueue::AddPlayer(Player *plr, uint32 bgTypeId)
+// remove group info from selection pool
+// used when building selection pools and have to remove maximal group
+void BattleGroundQueue::SelectionPool::RemoveGroup(GroupQueueInfo *ginfo)
+{
+    // uninitiate max group info if needed
+    if(MaxGroup == ginfo)
+        MaxGroup = 0;
+    // find what to remove
+    for(std::list<GroupQueueInfo *>::iterator itr = SelectedGroups.begin(); itr != SelectedGroups.end(); ++itr)
+    {
+        if((*itr)==ginfo)
+        {
+            SelectedGroups.erase(itr);
+            // decrease selected players count
+            PlayerCount -= ginfo->Players.size();
+            return;
+        }
+    }
+}
+
+// add group to selection
+// used when building selection pools
+void BattleGroundQueue::SelectionPool::AddGroup(GroupQueueInfo * ginfo)
+{
+    SelectedGroups.push_back(ginfo);
+    // increase selected players count
+    PlayerCount+=ginfo->Players.size();
+    if(!MaxGroup || ginfo->Players.size() > MaxGroup->Players.size())
+    {
+        // update max group info if needed
+        MaxGroup = ginfo;
+    }
+}
+
+// add group to bg queue with the given leader and bg specifications
+GroupQueueInfo * BattleGroundQueue::AddGroup(Player *leader, uint32 BgTypeId, uint8 ArenaType, bool isRated, uint32 arenaRating, uint32 arenateamid)
+{
+    uint32 queue_id = leader->GetBattleGroundQueueIdFromLevel();
+
+    // create new ginfo
+    // cannot use the method like in addplayer, because that could modify an in-queue group's stats
+    // (e.g. leader leaving queue then joining as individual again)
+    GroupQueueInfo* ginfo = new GroupQueueInfo;
+    ginfo->BgTypeId                  = BgTypeId;
+    ginfo->ArenaType                 = ArenaType;
+    ginfo->ArenaTeamId               = arenateamid;
+    ginfo->IsRated                   = isRated;
+    ginfo->IsInvitedToBGInstanceGUID = 0;                       // maybe this should be modifiable by function arguments to enable selection of running instances?
+    ginfo->JoinTime                  = getMSTime();
+    ginfo->Team                      = leader->GetTeam();
+
+    if(sBattleGroundMgr.GetMaxRatingDifference())               // if max difference is set, then store rating info for queue
+        ginfo->ArenaTeamRating       = arenaRating;
+    else
+        ginfo->ArenaTeamRating       = 0;                       // don't if it doesn't matter
+
+    ginfo->Players.clear();
+
+    m_QueuedGroups[queue_id].push_back(ginfo);
+
+    // return ginfo, because it is needed to add players to this group info
+    return ginfo;
+}
+
+void BattleGroundQueue::AddPlayer(Player *plr, GroupQueueInfo *ginfo)
 {
     uint32 queue_id = plr->GetBattleGroundQueueIdFromLevel();
 
     //if player isn't in queue, he is added, if already is, then values are overwritten, no memory leak
     PlayerQueueInfo& info = m_QueuedPlayers[queue_id][plr->GetGUID()];
     info.InviteTime                 = 0;
-    info.IsInvitedToBGInstanceGUID  = 0;
     info.LastInviteTime             = 0;
     info.LastOnlineTime             = getMSTime();
-    info.Team                       = plr->GetTeam();
-
-    //add player to waiting order queue
-    m_PlayersSortedByWaitTime[queue_id].push_back(plr->GetGUID());
-
-    if(plr->GetTeam() == ALLIANCE)
-        ++m_QueuedPlayers[queue_id].Alliance;
-    else
-        ++m_QueuedPlayers[queue_id].Horde;
-
-    this->Update(bgTypeId, queue_id);
+    info.GroupInfo                  = ginfo;
 
+    // add the pinfo to ginfo's list
+    ginfo->Players[plr->GetGUID()]  = &info;
+/*
     if( sWorld.getConfig(CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_ENABLE) )
     {
         BattleGround* bg = sBattleGroundMgr.GetBattleGround(bgTypeId);
@@ -111,7 +274,8 @@ void BattleGroundQueue::AddPlayer(Player *plr, uint32 bgTypeId)
             sWorld.SendWorldText(LANG_BG_QUEUE_ANNOUNCE_WORLD,
                 bgName, q_min_level, q_max_level, qAlliance, MinPlayers - qAlliance, qHorde, MinPlayers - qHorde);
         }
-    }
+
+    }*/
 }
 
 void BattleGroundQueue::RemovePlayer(uint64 guid, bool decreaseInvitedCount)
@@ -120,11 +284,22 @@ void BattleGroundQueue::RemovePlayer(uint64 guid, bool decreaseInvitedCount)
 
     uint32 queue_id = 0;
     QueuedPlayersMap::iterator itr;
+    GroupQueueInfo * group;
+    QueuedGroupsList::iterator group_itr;
     bool IsSet = false;
-    if(!plr)
-    {                                                       //player is offline, we need to find him somewhere in queues
-        /// there is something wrong if this code is run, because we have in queue only online players!
-        sLog.outError("Battleground: removing offline player from BG queue - this might not happen, but it should not cause crash");
+    if(plr)
+    {
+        queue_id = plr->GetBattleGroundQueueIdFromLevel();
+
+        itr = m_QueuedPlayers[queue_id].find(guid);
+        if(itr != m_QueuedPlayers[queue_id].end())
+            IsSet = true;
+    }
+
+    if(!IsSet)
+    {                                                       
+        // either player is offline, or he levelled up to another queue category
+        // sLog.outError("Battleground: removing offline player from BG queue - this might not happen, but it should not cause crash");
         for (uint32 i = 0; i < MAX_BATTLEGROUND_QUEUES; i++)
         {
             itr = m_QueuedPlayers[i].find(guid);
@@ -136,44 +311,248 @@ void BattleGroundQueue::RemovePlayer(uint64 guid, bool decreaseInvitedCount)
             }
         }
     }
-    else
-    {                                                       //player is online, we have his level, so we can find exact queue from his level
-        queue_id = plr->GetBattleGroundQueueIdFromLevel();
-        itr = m_QueuedPlayers[queue_id].find(guid);
-        IsSet = true;
+
+    // couldn't find the player in bg queue, return
+    if(!IsSet)
+    {
+        sLog.outError("Battleground: couldn't find player to remove.");
+        return;
     }
 
-    //all variables are set, so remove player
-    //remove player from time queue
-    m_PlayersSortedByWaitTime[queue_id].remove(guid);
+    group = itr->second.GroupInfo;
 
-    if (IsSet && itr != m_QueuedPlayers[queue_id].end())
+    for(group_itr=m_QueuedGroups[queue_id].begin(); group_itr != m_QueuedGroups[queue_id].end(); ++group_itr)
     {
-        if (!itr->second.IsInvitedToBGInstanceGUID)
-        {
-            if(itr->second.Team == ALLIANCE)
-                --m_QueuedPlayers[queue_id].Alliance;
-            else
-                --m_QueuedPlayers[queue_id].Horde;
-        }
-        else
+        if(group == (GroupQueueInfo*)(*group_itr))
+            break;
+    }
+
+    // variables are set (what about leveling up when in queue????)
+    // remove player from group
+    // if only player there, remove group
+
+    // remove player queue info from group queue info
+    std::map<uint64, PlayerQueueInfo*>::iterator pitr = group->Players.find(guid);
+
+    if(pitr != group->Players.end())
+        group->Players.erase(pitr);
+
+    // check for iterator correctness
+    if (group_itr != m_QueuedGroups[queue_id].end() && itr != m_QueuedPlayers[queue_id].end())
+    {
+        // used when player left the queue, NOT used when porting to bg
+        if (decreaseInvitedCount)
         {
-            if (decreaseInvitedCount)
+            // if invited to bg, and should decrease invited count, then do it
+            if(group->IsInvitedToBGInstanceGUID)
             {
-                BattleGround* bg = sBattleGroundMgr.GetBattleGround(itr->second.IsInvitedToBGInstanceGUID);
+                BattleGround* bg = sBattleGroundMgr.GetBattleGround(group->IsInvitedToBGInstanceGUID);
                 if (bg)
-                    bg->DecreaseInvitedCount(itr->second.Team);
+                    bg->DecreaseInvitedCount(group->Team);
+                if (bg && !bg->GetPlayersSize() && !bg->GetInvitedCount(ALLIANCE) && !bg->GetInvitedCount(HORDE))
+                {
+                    // no more players on battleground, set delete it
+                    bg->SetDeleteThis();
+                }
             }
+            // update the join queue, maybe now the player's group fits in a queue!
+            // not yet implemented (should store bgTypeId in group queue info?)
         }
+        // remove player queue info
         m_QueuedPlayers[queue_id].erase(itr);
+        // remove group queue info if needed
+        if(group->Players.empty())
+        {
+            m_QueuedGroups[queue_id].erase(group_itr);
+            delete group;
+        }
+        // NEEDS TESTING!
+        // group wasn't empty, so it wasn't deleted, and player have left a rated queue -> everyone from the group should leave too
+        // don't remove recursively if already invited to bg!
+        else if(!group->IsInvitedToBGInstanceGUID && decreaseInvitedCount && group->IsRated)
+        {
+            // remove next player, this is recursive
+            // first send removal information
+            if(Player *plr2 = objmgr.GetPlayer(group->Players.begin()->first))
+            {
+                BattleGround * bg = sBattleGroundMgr.GetBattleGroundTemplate(group->BgTypeId);
+                uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(group->BgTypeId,group->ArenaType);
+                uint32 queueSlot = plr2->GetBattleGroundQueueIndex(bgQueueTypeId);
+                plr2->RemoveBattleGroundQueueId(bgQueueTypeId); // must be called this way, because if you move this call to queue->removeplayer, it causes bugs
+                WorldPacket data;
+                sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, plr2->GetTeam(), queueSlot, STATUS_NONE, 0, 0);
+                plr2->GetSession()->SendPacket(&data);
+            }
+            // then actually delete, this may delete the group as well!
+            RemovePlayer(group->Players.begin()->first,decreaseInvitedCount);
+        }
+    }
+}
+
+bool BattleGroundQueue::InviteGroupToBG(GroupQueueInfo * ginfo, BattleGround * bg, uint32 side)
+{
+    // set side if needed
+    if(side)
+        ginfo->Team = side;
+
+    if(!ginfo->IsInvitedToBGInstanceGUID)
+    {
+        // not yet invited
+        // set invitation
+        ginfo->IsInvitedToBGInstanceGUID = bg->GetInstanceID();
+        uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bg->GetTypeID(), bg->GetArenaType());
+        // loop through the players
+        for(std::map<uint64,PlayerQueueInfo*>::iterator itr = ginfo->Players.begin(); itr != ginfo->Players.end(); ++itr)
+        {
+            // set status
+            itr->second->InviteTime = getMSTime();
+            itr->second->LastInviteTime = getMSTime();
+
+            // get the player
+            Player* plr = objmgr.GetPlayer(itr->first);
+            // if offline, skip him
+            if(!plr)
+                continue;
+
+            // invite the player
+            sBattleGroundMgr.InvitePlayer(plr, bg->GetInstanceID(),ginfo->Team);
+
+            WorldPacket data;
+
+            uint32 queueSlot = plr->GetBattleGroundQueueIndex(bgQueueTypeId);
+
+            sLog.outDebug("Battleground: invited plr %s (%u) to BG instance %u queueindex %u bgtype %u, I can't help it if they don't press the enter battle button.",plr->GetName(),plr->GetGUIDLow(),bg->GetInstanceID(),queueSlot,bg->GetTypeID());
+
+            // send status packet
+            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, side?side:plr->GetTeam(), queueSlot, STATUS_WAIT_JOIN, INVITE_ACCEPT_WAIT_TIME, 0);
+            plr->GetSession()->SendPacket(&data);
+        }
+        return true;
+    }
+
+    return false;
+}
+
+// this function is responsible for the selection of queued groups when trying to create new battlegrounds
+bool BattleGroundQueue::BuildSelectionPool(uint32 bgTypeId, uint32 queue_id, uint32 MinPlayers, uint32 MaxPlayers,  SelectionPoolBuildMode mode, uint8 ArenaType, bool isRated, uint32 MinRating, uint32 MaxRating, uint32 DisregardTime, uint32 excludeTeam)
+{
+    uint32 side;
+    switch(mode)
+    {
+    case NORMAL_ALLIANCE:
+    case ONESIDE_ALLIANCE_TEAM1:
+    case ONESIDE_ALLIANCE_TEAM2:
+        side = ALLIANCE;
+        break;
+    case NORMAL_HORDE:
+    case ONESIDE_HORDE_TEAM1:
+    case ONESIDE_HORDE_TEAM2:
+        side = HORDE;
+        break;
+    default:
+        //unknown mode, return false
+        sLog.outDebug("Battleground: unknown selection pool build mode, returning...");
+        return false;
+        break;
+    }
+
+    // inititate the groups eligible to create the bg
+    m_EligibleGroups.Init(&(m_QueuedGroups[queue_id]), bgTypeId, side, MaxPlayers, ArenaType, isRated, MinRating, MaxRating, DisregardTime, excludeTeam);
+    // init the selected groups (clear)
+    m_SelectionPools[mode].Init();
+    while(!(m_EligibleGroups.empty()))
+    {
+        sLog.outDebug("m_EligibleGroups is not empty, continue building selection pool");
+        // in decreasing group size, add groups to join if they fit in the MaxPlayersPerTeam players
+        for(EligibleGroups::iterator itr= m_EligibleGroups.begin(); itr!=m_EligibleGroups.end(); ++itr)
+        {
+            // get the maximal not yet checked group
+            GroupQueueInfo * MaxGroup = (*itr);
+            // if it fits in the maxplayer size, add it
+            if( (m_SelectionPools[mode].GetPlayerCount() + MaxGroup->Players.size()) <= MaxPlayers )
+            {
+                m_SelectionPools[mode].AddGroup(MaxGroup);
+            }
+        }
+        if(m_SelectionPools[mode].GetPlayerCount()>=MinPlayers)
+        {
+            // the selection pool is set, return
+            sLog.outDebug("pool build succeeded, return true");
+            return true;
+        }
+        // if the selection pool's not set, then remove the group with the highest player count, and try again with the rest.
+        GroupQueueInfo * MaxGroup = m_SelectionPools[mode].GetMaximalGroup();
+        m_EligibleGroups.RemoveGroup(MaxGroup);
+        m_SelectionPools[mode].RemoveGroup(MaxGroup);
+    }
+    // failed to build a selection pool matching the given values
+    return false;
+}
+
+// used to remove the Enter Battle window if the battle has already, but someone still has it
+// (this can happen in arenas mainly, since the preparation is shorter than the timer for the bgqueueremove event
+void BattleGroundQueue::BGEndedRemoveInvites(BattleGround *bg)
+{
+    uint32 queue_id = bg->GetQueueType();
+    uint32 bgInstanceId = bg->GetInstanceID();
+    uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bg->GetTypeID(), bg->GetArenaType());
+    QueuedGroupsList::iterator itr, next;
+    for(itr = m_QueuedGroups[queue_id].begin(); itr != m_QueuedGroups[queue_id].end(); itr = next)
+    {
+        // must do this way, because the groupinfo will be deleted when all playerinfos are removed
+        GroupQueueInfo * ginfo = (*itr);
+        next = itr;
+        ++next;
+        // if group was invited to this bg instance, then remove all references
+        if(ginfo->IsInvitedToBGInstanceGUID == bgInstanceId)
+        {
+            // after removing this much playerinfos, the ginfo will be deleted, so we'll use a for loop
+            uint32 to_remove = ginfo->Players.size();
+            uint32 team = ginfo->Team;
+            for(int i = 0; i < to_remove; ++i)
+            {
+                // always remove the first one in the group
+                std::map<uint64, PlayerQueueInfo * >::iterator itr2 = ginfo->Players.begin();
+                if(itr2 == ginfo->Players.end())
+                {
+                    sLog.outError("Empty Players in ginfo, this should never happen!");
+                    return;
+                }
+
+                // get the player
+                Player * plr = objmgr.GetPlayer(itr2->first);
+                if(!plr)
+                {
+                    sLog.outError("Player offline when trying to remove from GroupQueueInfo, this should never happen.");
+                    continue;
+                }
+
+                // get the queueslot
+                uint32 queueSlot = plr->GetBattleGroundQueueIndex(bgQueueTypeId);
+                if (queueSlot < PLAYER_MAX_BATTLEGROUND_QUEUES) // player is in queue
+                {
+                    plr->RemoveBattleGroundQueueId(bgQueueTypeId);
+                    // remove player from queue, this might delete the ginfo as well! don't use that pointer after this!
+                    RemovePlayer(itr2->first, true);
+                    // this is probably unneeded, since this player was already invited -> does not fit when initing eligible groups
+                    // but updateing the queue can't hurt
+                    Update(bgQueueTypeId, bg->GetQueueType());
+                    // send info to client
+                    WorldPacket data;
+                    sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, team, queueSlot, STATUS_NONE, 0, 0);
+                    plr->GetSession()->SendPacket(&data);
+                }
+            }
+        }
     }
 }
 
 /*
-this method is called when player is inserted, or removed from BG Queue - there is only one player's status changed, so we don't use while(true) cycles to invite whole queue
-add method calls this by itself, the remove method could works in other way, so you have to call this method from other code after calling remove method
+this method is called when group is inserted, or player / group is removed from BG Queue - there is only one player's status changed, so we don't use while(true) cycles to invite whole queue
+it must be called after fully adding the members of a group to ensure group joining
+should be called after removeplayer functions in some cases
 */
-void BattleGroundQueue::Update(uint32 bgTypeId, uint32 queue_id)
+void BattleGroundQueue::Update(uint32 bgTypeId, uint32 queue_id, uint8 arenatype, bool isRated, uint32 arenaRating)
 {
     if (queue_id >= MAX_BATTLEGROUND_QUEUES)
     {
@@ -183,157 +562,333 @@ void BattleGroundQueue::Update(uint32 bgTypeId, uint32 queue_id)
     }
 
     //if no players in queue ... do nothing
-    if (this->m_QueuedPlayers[queue_id].Alliance == 0 && this->m_QueuedPlayers[queue_id].Horde == 0)
+    if (this->m_QueuedGroups[queue_id].size() == 0)
         return;
 
+    uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bgTypeId, arenatype);
+
     //battleground with free slot for player should be always the last in this queue
-    for (BGFreeSlotQueueType::iterator itr = sBattleGroundMgr.BGFreeSlotQueue[bgTypeId].begin(); itr != sBattleGroundMgr.BGFreeSlotQueue[bgTypeId].end(); ++itr)
+    BGFreeSlotQueueType::iterator itr, next;
+    for (itr = sBattleGroundMgr.BGFreeSlotQueue[bgTypeId].begin(); itr != sBattleGroundMgr.BGFreeSlotQueue[bgTypeId].end(); itr = next)
     {
+        next = itr;
+        ++next;
         // battleground is running, so if:
         // DO NOT allow queue manager to invite new player to running arena
-        if ((*itr)->isBattleGround() && (*itr)->GetQueueType() == queue_id && (*itr)->GetStatus() > STATUS_WAIT_QUEUE && (*itr)->GetStatus() < STATUS_WAIT_LEAVE)
+        if ((*itr)->isBattleGround() && (*itr)->GetTypeID() == bgTypeId && (*itr)->GetQueueType() == queue_id && (*itr)->GetStatus() > STATUS_WAIT_QUEUE && (*itr)->GetStatus() < STATUS_WAIT_LEAVE)
         {
             //we must check both teams
             BattleGround* bg = *itr; //we have to store battleground pointer here, because when battleground is full, it is removed from free queue (not yet implemented!!)
             // and iterator is invalid
 
-            //check if there are some players in queue
-            if (m_QueuedPlayers[queue_id].Alliance > 0 || m_QueuedPlayers[queue_id].Horde > 0)
+            for(QueuedGroupsList::iterator itr = m_QueuedGroups[queue_id].begin(); itr != m_QueuedGroups[queue_id].end(); ++itr)
             {
-                for (PlayerGuidsSortedByTimeQueue::iterator itr2 = m_PlayersSortedByWaitTime[queue_id].begin(); itr2 != m_PlayersSortedByWaitTime[queue_id].end();)
+                // did the group join for this bg type?
+                if((*itr)->BgTypeId != bgTypeId)
+                    continue;
+                // if so, check if fits in
+                if(bg->GetFreeSlotsForTeam((*itr)->Team) >= (*itr)->Players.size())
                 {
-                    Player* plr = objmgr.GetPlayer(*itr2);
-                    if (!plr)
-                    {
-                        //something is wrong!, kick player from queue
-                        sLog.outError("BATTLEGROUND: problem with inviting offline player to Battleground queue .... pls report bug");
-                        uint64 oldval = *itr2;
-                        itr2 = m_PlayersSortedByWaitTime[queue_id].erase(itr2);
-                        RemovePlayer(oldval, true);
-                        continue;
-                    }
-
-                    // player will be invited, if in bg there is a free slot for him
-                    if (bg->HasFreeSlotsForTeam(plr->GetTeam()))
-                    {
-                        // iterator to player's queue status
-                        QueuedPlayersMap::iterator itrPlayerStatus = m_QueuedPlayers[queue_id].find(*itr2);
-
-                        // remove him from time queue
-                        itr2 = m_PlayersSortedByWaitTime[queue_id].erase(itr2);
-
-                        // only check to be sure ... but this condition shouldn't be true (if it is true, then there is a bug somewhere and pls report it)
-                        if (itrPlayerStatus == m_QueuedPlayers[queue_id].end())
-                            continue;
-
-                        // check if player is not already invited
-                        if (!itrPlayerStatus->second.IsInvitedToBGInstanceGUID)
-                        {
-                            itrPlayerStatus->second.IsInvitedToBGInstanceGUID = bg->GetInstanceID();
-                            itrPlayerStatus->second.InviteTime = getMSTime();
-                            itrPlayerStatus->second.LastInviteTime = getMSTime();
-                            if(itrPlayerStatus->second.Team == ALLIANCE)
-                                --m_QueuedPlayers[queue_id].Alliance;
-                            else
-                                --m_QueuedPlayers[queue_id].Horde;
-                            sBattleGroundMgr.InvitePlayer(plr, bg->GetInstanceID());
-
-                            WorldPacket data;
-                            uint32 queueSlot = plr->GetBattleGroundQueueIndex(bgTypeId);
-                            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, plr->GetTeam(), queueSlot, STATUS_WAIT_JOIN, INVITE_ACCEPT_WAIT_TIME, 0);
-                            plr->GetSession()->SendPacket(&data);
-                        }
-                    }
-                    else
-                        ++itr2;
-
-                    //if battleground is FULL, then it is removed from free slot queue - not yet implemented!
-                    if (!bg->HasFreeSlots())
-                    {
-                        //if bg is full, there is no need to invite other players, so break
-                        break;
-                        //remove BG from BGFreeSlotQueue - not used now, in this system we don't remove BGs from free queue
-                        //bg->RemoveFromBGFreeSlotQueue() --- do not uncomment this - not yet implemented
-                    }
+                    // if group fits in, invite it
+                    InviteGroupToBG((*itr),bg,(*itr)->Team);
                 }
             }
+
+            if (!bg->HasFreeSlots())
+            {
+                //remove BG from BGFreeSlotQueue
+                bg->RemoveFromBGFreeSlotQueue();
+            }
         }
     }
 
-    /* THIS IS A CASE THAT IN QUEUE THERE IS ENOUGHT PLAYERS TO START NEW BG */
-    //itr->end is the last BG - template, which is not already started!
+    // finished iterating through the bgs with free slots, maybe we need to create a new bg
 
-    /* here will be a most of change, when we create battlegrounds instantiated */
-    /* if (there is enough players to start new BG)
-        Battleground* newbg = sBattleGroundMgr.CreateNewBattleGround(bgTypeId)
-        - that function will use the COPY constructor on BattleGround class ( in bg manager we should have one battleground as a template
-            (battleground template will be used only to create new BGs, it will be an instance of BG class, but it won't ever start) */
-
-    /* following code is working with current Battleground system and it should be removed, when BGs will work like instances */
-    BattleGround* bg2 = sBattleGroundMgr.GetBattleGround(bgTypeId);
-    if (bg2->GetQueueType() != MAX_BATTLEGROUND_QUEUES || bg2->GetStatus() != STATUS_WAIT_QUEUE)
+    BattleGround * bg_template = sBattleGroundMgr.GetBattleGroundTemplate(bgTypeId);
+    if(!bg_template)
+    {
+        sLog.outError("Battleground: Update: bg template not found for %u", bgTypeId);
         return;
-    if (m_QueuedPlayers[queue_id].Alliance >= bg2->GetMinPlayersPerTeam() && m_QueuedPlayers[queue_id].Horde >= bg2->GetMinPlayersPerTeam())
+    }
+
+    // get the min. players per team, properly for larger arenas as well. (must have full teams for arena matches!)
+    uint32 MinPlayersPerTeam = bg_template->GetMinPlayersPerTeam();
+    uint32 MaxPlayersPerTeam = bg_template->GetMaxPlayersPerTeam();
+    if(bg_template->isArena())
     {
-        bg2->SetStatus(STATUS_WAIT_JOIN);
-        bg2->SetQueueType(queue_id);
+        if(sBattleGroundMgr.isArenaTesting())
+        {
+            MaxPlayersPerTeam = 1;
+            MinPlayersPerTeam = 1;
+        }
+        else
+        {
+            switch(arenatype)
+            {
+            case ARENA_TYPE_2v2:
+                MaxPlayersPerTeam = 2;
+                MinPlayersPerTeam = 2;
+                break;
+            case ARENA_TYPE_3v3:
+                MaxPlayersPerTeam = 3;
+                MinPlayersPerTeam = 3;
+                break;
+            case ARENA_TYPE_5v5:
+                MaxPlayersPerTeam = 5;
+                MinPlayersPerTeam = 5;
+                break;
+            }
+        }
+    }
+
+    // found out the minimum and maximum ratings the newly added team should battle against
+    // arenaRating is the rating of the latest joined team
+    uint32 arenaMinRating = (arenaRating <= sBattleGroundMgr.GetMaxRatingDifference()) ? 0 : arenaRating - sBattleGroundMgr.GetMaxRatingDifference();
+    // if no rating is specified, set maxrating to 0
+    uint32 arenaMaxRating = (arenaRating == 0)? 0 : arenaRating + sBattleGroundMgr.GetMaxRatingDifference();
+    uint32 discardTime = 0;
+    // if max rating difference is set and the time past since server startup is greater than the rating discard time
+    // (after what time the ratings aren't taken into account when making teams) then 
+    // the discard time is current_time - time_to_discard, teams that joined after that, will have their ratings taken into account
+    // else leave the discard time on 0, this way all ratings will be discarded
+    if(sBattleGroundMgr.GetMaxRatingDifference() && getMSTime() >= sBattleGroundMgr.GetRatingDiscardTimer())
+        discardTime = getMSTime() - sBattleGroundMgr.GetRatingDiscardTimer();
+
+    // try to build the selection pools
+    bool bAllyOK = BuildSelectionPool(bgTypeId, queue_id, MinPlayersPerTeam, MaxPlayersPerTeam, NORMAL_ALLIANCE, arenatype, isRated, arenaMinRating, arenaMaxRating, discardTime);
+    if(bAllyOK)
+        sLog.outDebug("Battleground: ally pool succesfully build");
+    else
+        sLog.outDebug("Battleground: ally pool wasn't created");
+    bool bHordeOK = BuildSelectionPool(bgTypeId, queue_id, MinPlayersPerTeam, MaxPlayersPerTeam, NORMAL_HORDE, arenatype, isRated, arenaMinRating, arenaMaxRating, discardTime);
+    if(bHordeOK)
+        sLog.outDebug("Battleground: horde pool succesfully built");
+    else
+        sLog.outDebug("Battleground: horde pool wasn't created");
 
-        for (PlayerGuidsSortedByTimeQueue::iterator itr2 = m_PlayersSortedByWaitTime[queue_id].begin(); itr2 != m_PlayersSortedByWaitTime[queue_id].end();)
+    // if selection pools are ready, create the new bg
+    if (bAllyOK && bHordeOK)
+    {
+        BattleGround * bg2 = 0;
+        // special handling for arenas
+        if(bg_template->isArena())
         {
-            Player* plr = objmgr.GetPlayer(*itr2);
-            if (!plr)
+            // Find a random arena, that can be created
+            uint8 arenas[] = {BATTLEGROUND_NA, BATTLEGROUND_BE, BATTLEGROUND_RL};
+            uint32 arena_num = urand(0,2);
+            if( !(bg2 = sBattleGroundMgr.CreateNewBattleGround(arenas[arena_num%3])) &&
+                !(bg2 = sBattleGroundMgr.CreateNewBattleGround(arenas[(arena_num+1)%3])) &&
+                !(bg2 = sBattleGroundMgr.CreateNewBattleGround(arenas[(arena_num+2)%3])) )
             {
-                //something is wrong!, kick player from queue
-                sLog.outError("BATTLEGROUND: problem with inviting offline player to Battleground queue .... pls report bug");
-                uint64 oldval = *itr2;
-                itr2 = m_PlayersSortedByWaitTime[queue_id].erase(itr2);
-                RemovePlayer(oldval, true);
-                continue;
+                sLog.outError("Battleground: couldn't create arena");
+                return;
             }
 
-            /* TODO: (i'm not sure this code will be useful:
-            here should be some condition like if (bg2->isArena() && bg2->isRated())
+            // set the MaxPlayersPerTeam values based on arenatype
+            // setting the min player values isn't needed, since we won't be using that value later on.
+            if(sBattleGroundMgr.isArenaTesting())
             {
-                invite players from 1 certain group on each faction to play arena match
-            } else if ....and existing code
-            */
-            // player will be invited, if in bg there is a free slot for him
-            if (bg2->HasFreeSlotsForTeam(plr->GetTeam()))
+                bg2->SetMaxPlayersPerTeam(1);
+                bg2->SetMaxPlayers(2);
+            }
+            else
             {
-                // iterator to player's queue status
-                QueuedPlayersMap::iterator itrPlayerStatus = m_QueuedPlayers[queue_id].find(*itr2);
+                switch(arenatype)
+                {
+                case ARENA_TYPE_2v2:
+                    bg2->SetMaxPlayersPerTeam(2);
+                    bg2->SetMaxPlayers(4);
+                    break;
+                case ARENA_TYPE_3v3:
+                    bg2->SetMaxPlayersPerTeam(3);
+                    bg2->SetMaxPlayers(6);
+                    break;
+                case ARENA_TYPE_5v5:
+                    bg2->SetMaxPlayersPerTeam(5);
+                    bg2->SetMaxPlayers(10);
+                    break;
+                default:
+                    break;
+                }
+            }
+        }
+        else
+        {
+            // create new battleground
+            bg2 = sBattleGroundMgr.CreateNewBattleGround(bgTypeId);
+        }
 
-                // remove him from time queue
-                itr2 = m_PlayersSortedByWaitTime[queue_id].erase(itr2);
+        if(!bg2)
+        {
+            sLog.outError("Battleground: couldn't create bg %u",bgTypeId);
+            return;
+        }
 
-                // only check to be sure ... but this condition shouldn't be true (if it is true, then there is a bug somewhere and report it)
-                if (itrPlayerStatus == m_QueuedPlayers[queue_id].end())
-                    continue;
+        // start the joining of the bg
+        bg2->SetStatus(STATUS_WAIT_JOIN);
+        bg2->SetQueueType(queue_id);
+        // initialize arena / rating info
+        bg2->SetArenaType(arenatype);
+        // set rating
+        bg2->SetRated(isRated);
 
-                //check if player is not already invited
-                if (!itrPlayerStatus->second.IsInvitedToBGInstanceGUID)
-                {
-                    itrPlayerStatus->second.IsInvitedToBGInstanceGUID = bg2->GetInstanceID();
-                    itrPlayerStatus->second.InviteTime = getMSTime();
-                    itrPlayerStatus->second.LastInviteTime = getMSTime();
+        std::list<GroupQueueInfo* >::iterator itr;
 
-                    if(itrPlayerStatus->second.Team == ALLIANCE)
-                        --m_QueuedPlayers[queue_id].Alliance;
-                    else
-                        --m_QueuedPlayers[queue_id].Horde;
+        // invite groups from horde selection pool
+        for(itr = m_SelectionPools[NORMAL_HORDE].SelectedGroups.begin(); itr != m_SelectionPools[NORMAL_HORDE].SelectedGroups.end(); ++itr)
+        {
+            InviteGroupToBG((*itr),bg2,HORDE);
+        }
 
-                    sBattleGroundMgr.InvitePlayer(plr, bg2->GetInstanceID());
+        // invite groups from ally selection pools
+        for(itr = m_SelectionPools[NORMAL_ALLIANCE].SelectedGroups.begin(); itr != m_SelectionPools[NORMAL_ALLIANCE].SelectedGroups.end(); ++itr)
+        {
+            InviteGroupToBG((*itr),bg2,ALLIANCE);
+        }
 
-                    WorldPacket data;
-                    uint32 queueSlot = plr->GetBattleGroundQueueIndex(bgTypeId);
-                    sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg2, plr->GetTeam(), queueSlot, STATUS_WAIT_JOIN, INVITE_ACCEPT_WAIT_TIME, 0);
-                    plr->GetSession()->SendPacket(&data);
+        // start the battleground
+        bg2->StartBattleGround();
+    }
+
+    // there weren't enough players for a "normal" match
+    // if arena, enable horde versus horde or alliance versus alliance teams here
+
+    else if(bg_template->isArena())
+    {
+        bool bOneSideHordeTeam1 = false, bOneSideHordeTeam2 = false;
+        bool bOneSideAllyTeam1 = false, bOneSideAllyTeam2 = false;
+        bOneSideHordeTeam1 = BuildSelectionPool(bgTypeId, queue_id,MaxPlayersPerTeam,MaxPlayersPerTeam,ONESIDE_HORDE_TEAM1,arenatype, isRated, arenaMinRating, arenaMaxRating, discardTime);
+        if(bOneSideHordeTeam1)
+        {
+            // one team has been selected, find out if other can be selected too
+            std::list<GroupQueueInfo* >::iterator itr;
+            // temporarily change the team side to enable building the next pool excluding the already selected groups
+            for(itr = m_SelectionPools[ONESIDE_HORDE_TEAM1].SelectedGroups.begin(); itr != m_SelectionPools[ONESIDE_HORDE_TEAM1].SelectedGroups.end(); ++itr)
+                (*itr)->Team=ALLIANCE;
+
+            bOneSideHordeTeam2 = BuildSelectionPool(bgTypeId, queue_id,MaxPlayersPerTeam,MaxPlayersPerTeam,ONESIDE_HORDE_TEAM2,arenatype, isRated, arenaMinRating, arenaMaxRating, discardTime, (*(m_SelectionPools[ONESIDE_HORDE_TEAM1].SelectedGroups.begin()))->ArenaTeamId);
+
+            // change back the team to horde
+            for(itr = m_SelectionPools[ONESIDE_HORDE_TEAM1].SelectedGroups.begin(); itr != m_SelectionPools[ONESIDE_HORDE_TEAM1].SelectedGroups.end(); ++itr)
+                (*itr)->Team=HORDE;
+
+            if(!bOneSideHordeTeam2)
+                bOneSideHordeTeam1 = false;
+        }
+        if(!bOneSideHordeTeam1)
+        {
+            // check for one sided ally
+            bOneSideAllyTeam1 = BuildSelectionPool(bgTypeId, queue_id,MaxPlayersPerTeam,MaxPlayersPerTeam,ONESIDE_ALLIANCE_TEAM1,arenatype, isRated, arenaMinRating, arenaMaxRating, discardTime);
+            if(bOneSideAllyTeam1)
+            {
+                // one team has been selected, find out if other can be selected too
+                std::list<GroupQueueInfo* >::iterator itr;
+                // temporarily change the team side to enable building the next pool excluding the already selected groups
+                for(itr = m_SelectionPools[ONESIDE_ALLIANCE_TEAM1].SelectedGroups.begin(); itr != m_SelectionPools[ONESIDE_ALLIANCE_TEAM1].SelectedGroups.end(); ++itr)
+                    (*itr)->Team=HORDE;
+
+                bOneSideAllyTeam2 = BuildSelectionPool(bgTypeId, queue_id,MaxPlayersPerTeam,MaxPlayersPerTeam,ONESIDE_ALLIANCE_TEAM2,arenatype, isRated, arenaMinRating, arenaMaxRating, discardTime,(*(m_SelectionPools[ONESIDE_ALLIANCE_TEAM1].SelectedGroups.begin()))->ArenaTeamId);
+
+                // change back the team to ally
+                for(itr = m_SelectionPools[ONESIDE_ALLIANCE_TEAM1].SelectedGroups.begin(); itr != m_SelectionPools[ONESIDE_ALLIANCE_TEAM1].SelectedGroups.end(); ++itr)
+                    (*itr)->Team=ALLIANCE;
+            }
+
+            if(!bOneSideAllyTeam2)
+                bOneSideAllyTeam1 = false;
+        }
+        // 1-sided BuildSelectionPool() will work, because the MinPlayersPerTeam == MaxPlayersPerTeam in every arena!!!!
+        if( (bOneSideHordeTeam1 && bOneSideHordeTeam2) ||
+            (bOneSideAllyTeam1 && bOneSideAllyTeam2) )
+        {
+            // which side has enough players?
+            uint32 side = 0;
+            SelectionPoolBuildMode mode1, mode2;
+            // find out what pools are we using
+            if(bOneSideAllyTeam1 && bOneSideAllyTeam2)
+            {
+                side = ALLIANCE;
+                mode1 = ONESIDE_ALLIANCE_TEAM1;
+                mode2 = ONESIDE_ALLIANCE_TEAM2;
+            }
+            else
+            {
+                side = HORDE;
+                mode1 = ONESIDE_HORDE_TEAM1;
+                mode2 = ONESIDE_HORDE_TEAM2;
+            }
+
+            // create random arena
+            uint8 arenas[] = {BATTLEGROUND_NA, BATTLEGROUND_BE, BATTLEGROUND_RL};
+            uint32 arena_num = urand(0,2);
+            BattleGround* bg2 = NULL;
+            if( !(bg2 = sBattleGroundMgr.CreateNewBattleGround(arenas[arena_num%3])) &&
+                !(bg2 = sBattleGroundMgr.CreateNewBattleGround(arenas[(arena_num+1)%3])) &&
+                !(bg2 = sBattleGroundMgr.CreateNewBattleGround(arenas[(arena_num+2)%3])) )
+            {
+                sLog.outError("Could not create arena.");
+                return;
+            }
+
+            sLog.outDebug("Battleground: One-faction arena created.");
+            // init stats
+            if(sBattleGroundMgr.isArenaTesting())
+            {
+                bg2->SetMaxPlayersPerTeam(1);
+                bg2->SetMaxPlayers(2);
+            }
+            else
+            {
+                switch(arenatype)
+                {
+                case ARENA_TYPE_2v2:
+                    bg2->SetMaxPlayersPerTeam(2);
+                    bg2->SetMaxPlayers(4);
+                    break;
+                case ARENA_TYPE_3v3:
+                    bg2->SetMaxPlayersPerTeam(3);
+                    bg2->SetMaxPlayers(6);
+                    break;
+                case ARENA_TYPE_5v5:
+                    bg2->SetMaxPlayersPerTeam(5);
+                    bg2->SetMaxPlayers(10);
+                    break;
+                default:
+                    break;
                 }
             }
+
+            bg2->SetRated(isRated);
+
+            // assigned team of the other group
+            uint32 other_side;
+            if(side == ALLIANCE)
+                other_side = HORDE;
             else
-                ++itr2;
+                other_side = ALLIANCE;
+
+            // start the joining of the bg
+            bg2->SetStatus(STATUS_WAIT_JOIN);
+            bg2->SetQueueType(queue_id);
+            // initialize arena / rating info
+            bg2->SetArenaType(arenatype);
+
+            std::list<GroupQueueInfo* >::iterator itr;
+
+            // invite players from the first group as horde players (actually green team)
+            for(itr = m_SelectionPools[mode1].SelectedGroups.begin(); itr != m_SelectionPools[mode1].SelectedGroups.end(); ++itr)
+            {
+                InviteGroupToBG((*itr),bg2,HORDE);
+            }
+
+            // invite players from the second group as ally players (actually gold team)
+            for(itr = m_SelectionPools[mode2].SelectedGroups.begin(); itr != m_SelectionPools[mode2].SelectedGroups.end(); ++itr)
+            {
+                InviteGroupToBG((*itr),bg2,ALLIANCE);
+            }
+
+            bg2->StartBattleGround();
         }
-        bg2->StartBattleGround();
     }
 }
 
@@ -361,14 +916,19 @@ bool BGQueueInviteEvent::Execute(uint64 /*e_time*/, uint32 p_time)
     uint32 queueSlot = plr->GetBattleGroundQueueIndex(bg->GetTypeID());
     if (queueSlot < PLAYER_MAX_BATTLEGROUND_QUEUES)         // player is in queue
     {
-        // check if player is invited to this bg ... this check must be here, because when player leaves queue and joins another, it would cause a problems
-        BattleGroundQueue::QueuedPlayersMap const& qpMap = sBattleGroundMgr.m_BattleGroundQueues[bg->GetTypeID()].m_QueuedPlayers[plr->GetBattleGroundQueueIdFromLevel()];
-        BattleGroundQueue::QueuedPlayersMap::const_iterator qItr = qpMap.find(m_PlayerGuid);
-        if (qItr != qpMap.end() && qItr->second.IsInvitedToBGInstanceGUID == m_BgInstanceGUID)
+        uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bg->GetTypeID(), bg->GetArenaType());
+        uint32 queueSlot = plr->GetBattleGroundQueueIndex(bgQueueTypeId);
+        if (queueSlot < PLAYER_MAX_BATTLEGROUND_QUEUES) // player is in queue
         {
-            WorldPacket data;
-            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, plr->GetTeam(), queueSlot, STATUS_WAIT_JOIN, INVITE_ACCEPT_WAIT_TIME/2, 0);
-            plr->GetSession()->SendPacket(&data);
+            // check if player is invited to this bg ... this check must be here, because when player leaves queue and joins another, it would cause a problems
+            BattleGroundQueue::QueuedPlayersMap const& qpMap = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].m_QueuedPlayers[plr->GetBattleGroundQueueIdFromLevel()];
+            BattleGroundQueue::QueuedPlayersMap::const_iterator qItr = qpMap.find(m_PlayerGuid);
+            if (qItr != qpMap.end() && qItr->second.GroupInfo->IsInvitedToBGInstanceGUID == m_BgInstanceGUID)
+            {
+                WorldPacket data;
+                sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, qItr->second.GroupInfo->Team, queueSlot, STATUS_WAIT_JOIN, INVITE_ACCEPT_WAIT_TIME/2, 0);
+                plr->GetSession()->SendPacket(&data);
+            }
         }
     }
     return true;                                            //event will be deleted
@@ -396,23 +956,26 @@ bool BGQueueRemoveEvent::Execute(uint64 /*e_time*/, uint32 /*p_time*/)
     if (!bg)
         return true;
 
-    uint32 queueSlot = plr->GetBattleGroundQueueIndex(bg->GetTypeID());
-    if (queueSlot < PLAYER_MAX_BATTLEGROUND_QUEUES)         // player is in queue (base at player data
+    sLog.outDebug("Battleground: removing player %u from bg queue for instance %u because of not pressing enter battle in time.",plr->GetGUIDLow(),m_BgInstanceGUID);
+
+    uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bg->GetTypeID(), bg->GetArenaType());
+    uint32 queueSlot = plr->GetBattleGroundQueueIndex(bgQueueTypeId);
+    if (queueSlot < PLAYER_MAX_BATTLEGROUND_QUEUES) // player is in queue
     {
         // check if player is invited to this bg ... this check must be here, because when player leaves queue and joins another, it would cause a problems
-        BattleGroundQueue::QueuedPlayersMap const& qpMap = sBattleGroundMgr.m_BattleGroundQueues[bg->GetTypeID()].m_QueuedPlayers[plr->GetBattleGroundQueueIdFromLevel()];
-        BattleGroundQueue::QueuedPlayersMap::const_iterator qItr = qpMap.find(m_PlayerGuid);
-        if (qItr!=qpMap.end() && qItr->second.IsInvitedToBGInstanceGUID == m_BgInstanceGUID)
+        BattleGroundQueue::QueuedPlayersMap::iterator qMapItr = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].m_QueuedPlayers[plr->GetBattleGroundQueueIdFromLevel()].find(m_PlayerGuid);
+        if (qMapItr != sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].m_QueuedPlayers[plr->GetBattleGroundQueueIdFromLevel()].end() && qMapItr->second.GroupInfo && qMapItr->second.GroupInfo->IsInvitedToBGInstanceGUID == m_BgInstanceGUID)
         {
-            plr->RemoveBattleGroundQueueId(bg->GetTypeID());
-            sBattleGroundMgr.m_BattleGroundQueues[bg->GetTypeID()].RemovePlayer(m_PlayerGuid, true);
-            sBattleGroundMgr.m_BattleGroundQueues[bg->GetTypeID()].Update(bg->GetTypeID(), bg->GetQueueType());
-
+            plr->RemoveBattleGroundQueueId(bgQueueTypeId);
+            sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].RemovePlayer(m_PlayerGuid, true);
+            sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].Update(bgQueueTypeId, bg->GetQueueType());
             WorldPacket data;
-            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, plr->GetTeam(), queueSlot, STATUS_NONE, 0, 0);
+            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, m_PlayersTeam, queueSlot, STATUS_NONE, 0, 0);
             plr->GetSession()->SendPacket(&data);
         }
     }
+    else
+        sLog.outDebug("Battleground: Player was already removed from queue");
 
     //event will be deleted
     return true;
@@ -431,22 +994,80 @@ void BGQueueRemoveEvent::Abort(uint64 /*e_time*/)
 BattleGroundMgr::BattleGroundMgr()
 {
     m_BattleGrounds.clear();
+    m_AutoDistributePoints = (bool)sWorld.getConfig(CONFIG_ARENA_AUTO_DISTRIBUTE_POINTS);
+    m_MaxRatingDifference = sWorld.getConfig(CONFIG_ARENA_MAX_RATING_DIFFERENCE);
+    m_RatingDiscardTimer = sWorld.getConfig(CONFIG_ARENA_RATING_DISCARD_TIMER);
+    m_PrematureFinishTimer = sWorld.getConfig(CONFIG_BATTLEGROUND_PREMATURE_FINISH_TIMER);
+    m_NextRatingDiscardUpdate = m_RatingDiscardTimer;
+    m_AutoDistributionTimeChecker = 0;
+    m_ArenaTesting = false;
 }
 
 BattleGroundMgr::~BattleGroundMgr()
 {
-    for(std::map<uint32, BattleGround*>::iterator itr = m_BattleGrounds.begin(); itr != m_BattleGrounds.end(); ++itr)
-        delete itr->second;
+    BattleGroundSet::iterator itr, next;
+    for(itr = m_BattleGrounds.begin(); itr != m_BattleGrounds.end(); itr = next)
+    {
+        next = itr;
+        ++next;
+        BattleGround * bg = itr->second;
+        m_BattleGrounds.erase(itr);
+        delete bg;
+    }
     m_BattleGrounds.clear();
 }
 
+// used to update running battlegrounds, and delete finished ones
 void BattleGroundMgr::Update(time_t diff)
 {
-    for(BattleGroundSet::iterator itr = m_BattleGrounds.begin(); itr != m_BattleGrounds.end(); ++itr)
+    BattleGroundSet::iterator itr, next;
+    for(itr = m_BattleGrounds.begin(); itr != m_BattleGrounds.end(); itr = next)
+    {
+        next = itr;
+        ++next;
         itr->second->Update(diff);
+        // use the SetDeleteThis variable
+        // direct deletion caused crashes
+        if(itr->second->m_SetDeleteThis)
+        {
+            BattleGround * bg = itr->second;
+            m_BattleGrounds.erase(itr);
+            delete bg;
+        }
+    }
+    // if rating difference counts, maybe force-update queues
+    if(m_MaxRatingDifference)
+    {
+        // it's time to force update
+        if(m_NextRatingDiscardUpdate < diff)
+        {
+            // forced update for level 70 rated arenas
+            m_BattleGroundQueues[BATTLEGROUND_QUEUE_2v2].Update(BATTLEGROUND_AA,6,ARENA_TYPE_2v2,true,0);
+            m_BattleGroundQueues[BATTLEGROUND_QUEUE_3v3].Update(BATTLEGROUND_AA,6,ARENA_TYPE_3v3,true,0);
+            m_BattleGroundQueues[BATTLEGROUND_QUEUE_5v5].Update(BATTLEGROUND_AA,6,ARENA_TYPE_5v5,true,0);
+            m_NextRatingDiscardUpdate = m_RatingDiscardTimer;
+        } 
+        else 
+            m_NextRatingDiscardUpdate -= diff;
+    }
+    if(m_AutoDistributePoints)
+    {
+        if(m_AutoDistributionTimeChecker < diff)
+        {
+            if(time(NULL) > m_NextAutoDistributionTime)
+            {
+                DistributeArenaPoints();
+                m_NextAutoDistributionTime = time(NULL) + BATTLEGROUND_ARENA_POINT_DISTRIBUTION_DAY * sWorld.getConfig(CONFIG_ARENA_AUTO_DISTRIBUTE_INTERVAL_DAYS);
+                CharacterDatabase.PExecute("UPDATE saved_variables SET NextArenaPointDistributionTime = FROM_UNIXTIME('"I64FMTD"')",(uint64)m_NextAutoDistributionTime);
+            }
+            m_AutoDistributionTimeChecker = 600000; // check 10 minutes
+        }
+        else
+            m_AutoDistributionTimeChecker -= diff;
+    }
 }
 
-void BattleGroundMgr::BuildBattleGroundStatusPacket(WorldPacket *data, BattleGround *bg, uint32 team, uint8 QueueSlot, uint8 StatusID, uint32 Time1, uint32 Time2)
+void BattleGroundMgr::BuildBattleGroundStatusPacket(WorldPacket *data, BattleGround *bg, uint32 team, uint8 QueueSlot, uint8 StatusID, uint32 Time1, uint32 Time2, uint32 arenatype, uint8 israted)
 {
     // we can be in 3 queues in same time...
     if(StatusID == 0)
@@ -460,10 +1081,55 @@ void BattleGroundMgr::BuildBattleGroundStatusPacket(WorldPacket *data, BattleGro
     data->Initialize(SMSG_BATTLEFIELD_STATUS, (4+1+1+4+2+4+1+4+4+4));
     *data << uint32(QueueSlot);                             // queue id (0...2) - player can be in 3 queues in time
     // uint64 in client
-    *data << uint64( uint64(bg->GetArenaType()) | (uint64(0x0D) << 8) | (uint64(bg->GetTypeID()) << 16) | (uint64(0x1F90) << 48) );
+    *data << uint64( uint64(arenatype ? arenatype : bg->GetArenaType()) | (uint64(0x0D) << 8) | (uint64(bg->GetTypeID()) << 16) | (uint64(0x1F90) << 48) );
     *data << uint32(0);                                     // unknown
     // alliance/horde for BG and skirmish/rated for Arenas
-    *data << uint8(bg->isArena() ? (bg->isRated() ? 1 : 0) : bg->GetTeamIndexByTeamId(team));
+    *data << uint8(bg->isArena() ? ( israted ? israted : bg->isRated() ) : bg->GetTeamIndexByTeamId(team));
+/*    *data << uint8(arenatype ? arenatype : bg->GetArenaType());                     // team type (0=BG, 2=2x2, 3=3x3, 5=5x5), for arenas    // NOT PROPER VALUE IF ARENA ISN'T RUNNING YET!!!!
+    switch(bg->GetTypeID())                                 // value depends on bg id
+    {
+        case BATTLEGROUND_AV:
+            *data << uint8(1);
+            break;
+        case BATTLEGROUND_WS:
+            *data << uint8(2);
+            break;
+        case BATTLEGROUND_AB:
+            *data << uint8(3);
+            break;
+        case BATTLEGROUND_NA:
+            *data << uint8(4);
+            break;
+        case BATTLEGROUND_BE:
+            *data << uint8(5);
+            break;
+        case BATTLEGROUND_AA:
+            *data << uint8(6);
+            break;
+        case BATTLEGROUND_EY:
+            *data << uint8(7);
+            break;
+        case BATTLEGROUND_RL:
+            *data << uint8(8);
+            break;
+        default:                                            // unknown
+            *data << uint8(0);
+            break;
+    }
+
+    if(bg->isArena() && (StatusID == STATUS_WAIT_QUEUE))
+        *data << uint32(BATTLEGROUND_AA);                   // all arenas   I don't think so.
+    else
+    *data << uint32(bg->GetTypeID());                   // BG id from DBC
+
+    *data << uint16(0x1F90);                                // unk value 8080
+    *data << uint32(bg->GetInstanceID());                   // instance id
+
+    if(bg->isBattleGround())
+        *data << uint8(bg->GetTeamIndexByTeamId(team));     // team
+    else
+        *data << uint8(israted?israted:bg->isRated());                      // is rated battle
+*/
     *data << uint32(StatusID);                              // status
     switch(StatusID)
     {
@@ -493,13 +1159,24 @@ void BattleGroundMgr::BuildPvpLogDataPacket(WorldPacket *data, BattleGround *bg)
                                                             // last check on 2.4.1
     data->Initialize(MSG_PVP_LOG_DATA, (1+1+4+40*bg->GetPlayerScoresSize()));
     *data << uint8(type);                                   // seems to be type (battleground=0/arena=1)
+
     if(type)                                                // arena
     {
-        for(uint8 i = 0; i < 2; i++)
+        // it seems this must be according to BG_WINNER_A/H and _NOT_ BG_TEAM_A/H
+        for(int i = 1; i >= 0; --i)
         {
-            *data << uint32(3000+1+i);                      // rating change: showed value - 3000
-            *data << uint32(0);                             // 2.4.0, has some to do with rating change...
-            *data << uint8(0);                              // some unknown string
+            *data << uint32(3000-bg->m_ArenaTeamRatingChanges[i]);                      // rating change: showed value - 3000
+            *data << uint32(3999);  // huge thanks for TOM_RUS for this!
+            sLog.outDebug("rating change: %d", bg->m_ArenaTeamRatingChanges[i]);
+        }
+        for(int i = 1; i >= 0; --i)
+        {
+            uint32 at_id = bg->m_ArenaTeamIds[i];
+            ArenaTeam * at = objmgr.GetArenaTeamById(at_id);
+            if(at)
+                *data << at->GetName();
+            else//*/
+                *data << (uint8)0;
         }
     }
 
@@ -519,32 +1196,35 @@ void BattleGroundMgr::BuildPvpLogDataPacket(WorldPacket *data, BattleGround *bg)
     {
         *data << (uint64)itr->first;
         *data << (int32)itr->second->KillingBlows;
-        if(type)
+        Player *plr = objmgr.GetPlayer(itr->first);
+        uint32 team = bg->GetPlayerTeam(itr->first);
+        if(!team && plr) team = plr->GetTeam();
+        if(type == 0)
+        {
+            *data << (int32)itr->second->HonorableKills;
+            *data << (int32)itr->second->Deaths;
+            *data << (int32)(itr->second->BonusHonor);
+        }
+        else
         {
-            // this value is team (green/gold)?
             // that part probably wrong
-            Player *plr = objmgr.GetPlayer(itr->first);
             if(plr)
             {
-                if(plr->GetTeam() == HORDE)
+                if(team == HORDE)
                     *data << uint8(0);
-                else if(plr->GetTeam() == ALLIANCE)
+                else if(team == ALLIANCE)
+                {
                     *data << uint8(1);
+                }
                 else
                     *data << uint8(0);
             }
             else
                 *data << uint8(0);
         }
-        else
-        {
-            *data << (int32)itr->second->HonorableKills;
-            *data << (int32)itr->second->Deaths;
-            *data << (int32)itr->second->BonusHonor;        // bonus honor
-        }
-        *data << (int32)itr->second->DamageDone;            // damage done
-        *data << (int32)itr->second->HealingDone;           // healing done
-        switch(bg->GetTypeID())                             // battleground specific things
+        *data << (int32)itr->second->DamageDone;             // damage done
+        *data << (int32)itr->second->HealingDone;            // healing done
+        switch(bg->GetTypeID())                              // battleground specific things
         {
             case BATTLEGROUND_AV:
                 *data << (uint32)0x00000005;                // count of next fields
@@ -622,23 +1302,120 @@ void BattleGroundMgr::BuildPlayerJoinedBattleGroundPacket(WorldPacket *data, Pla
     *data << uint64(plr->GetGUID());
 }
 
-void BattleGroundMgr::InvitePlayer(Player* plr, uint32 bgInstanceGUID)
+void BattleGroundMgr::InvitePlayer(Player* plr, uint32 bgInstanceGUID, uint32 team)
 {
     // set invited player counters:
     BattleGround* bg = this->GetBattleGround(bgInstanceGUID);
     if(!bg)
         return;
+    bg->IncreaseInvitedCount(team);
+    
+    plr->SetInviteForBattleGroundQueueType(BGQueueTypeId(bg->GetTypeID(),bg->GetArenaType()), bgInstanceGUID);
+
+    // set the arena teams for rated matches
+    if(bg->isArena() && bg->isRated())
+    {
+        switch(bg->GetArenaType())
+        {
+        case ARENA_TYPE_2v2:
+            bg->SetArenaTeamIdForTeam(team, plr->GetArenaTeamId(0));
+            break;
+        case ARENA_TYPE_3v3:
+            bg->SetArenaTeamIdForTeam(team, plr->GetArenaTeamId(1));
+            break;
+        case ARENA_TYPE_5v5:
+            bg->SetArenaTeamIdForTeam(team, plr->GetArenaTeamId(2));
+            break;
+        default:
+            break;
+        }
+    }
 
-    bg->IncreaseInvitedCount(plr->GetTeam());
-    plr->SetInviteForBattleGroundType(bg->GetTypeID());
     // create invite events:
     //add events to player's counters ---- this is not good way - there should be something like global event processor, where we should add those events
     BGQueueInviteEvent* inviteEvent = new BGQueueInviteEvent(plr->GetGUID(), bgInstanceGUID);
     plr->m_Events.AddEvent(inviteEvent, plr->m_Events.CalculateTime(INVITE_ACCEPT_WAIT_TIME/2));
-    BGQueueRemoveEvent* removeEvent = new BGQueueRemoveEvent(plr->GetGUID(), bgInstanceGUID, plr->GetTeam());
+    BGQueueRemoveEvent* removeEvent = new BGQueueRemoveEvent(plr->GetGUID(), bgInstanceGUID, team);
     plr->m_Events.AddEvent(removeEvent, plr->m_Events.CalculateTime(INVITE_ACCEPT_WAIT_TIME));
 }
 
+BattleGround * BattleGroundMgr::GetBattleGroundTemplate(uint32 bgTypeId)
+{
+    return BGFreeSlotQueue[bgTypeId].empty() ? NULL : BGFreeSlotQueue[bgTypeId].back();
+}
+
+// create a new battleground that will really be used to play
+BattleGround * BattleGroundMgr::CreateNewBattleGround(uint32 bgTypeId)
+{
+    BattleGround *bg = NULL;
+
+    // get the template BG
+    BattleGround *bg_template = GetBattleGroundTemplate(bgTypeId);
+
+    if(!bg_template)
+    {
+        sLog.outError("BattleGround: CreateNewBattleGround - bg template not found for %u", bgTypeId);
+        return 0;
+    }
+    
+    // create a copy of the BG template
+    switch(bgTypeId)
+    {
+        case BATTLEGROUND_AV: 
+            bg = new BattleGroundAV(*(BattleGroundAV*)bg_template); 
+            break;
+        case BATTLEGROUND_WS: 
+            bg = new BattleGroundWS(*(BattleGroundWS*)bg_template); 
+            break;
+        case BATTLEGROUND_AB: 
+            bg = new BattleGroundAB(*(BattleGroundAB*)bg_template); 
+            break;
+        case BATTLEGROUND_NA: 
+            bg = new BattleGroundNA(*(BattleGroundNA*)bg_template); 
+            break;
+        case BATTLEGROUND_BE: 
+            bg = new BattleGroundBE(*(BattleGroundBE*)bg_template); 
+            break;
+        case BATTLEGROUND_AA: 
+            bg = new BattleGroundAA(*(BattleGroundAA*)bg_template); 
+            break;
+        case BATTLEGROUND_EY: 
+            bg = new BattleGroundEY(*(BattleGroundEY*)bg_template); 
+            break;
+        case BATTLEGROUND_RL: 
+            bg = new BattleGroundRL(*(BattleGroundRL*)bg_template); 
+            break;
+        default:
+            //bg = new BattleGround;   
+            return 0;
+            break;             // placeholder for non implemented BG
+    }
+
+    // generate a new instance id
+    bg->SetInstanceID(MapManager::Instance().GenerateInstanceId()); // set instance id
+
+    // reset the new bg (set status to status_wait_queue from status_none)
+    bg->Reset();
+
+    /*   will be setup in BG::Update() when the first player is ported in
+    if(!(bg->SetupBattleGround()))
+    {
+        sLog.outError("BattleGround: CreateNewBattleGround: SetupBattleGround failed for bg %u", bgTypeId);
+        delete bg;
+        return 0;
+    }
+    */
+
+    // add BG to free slot queue
+    bg->AddToBGFreeSlotQueue();
+
+    // add bg to update list
+    AddBattleGround(bg->GetInstanceID(), bg);
+
+    return bg;
+}
+
+// used to create the BG templates
 uint32 BattleGroundMgr::CreateBattleGround(uint32 bgTypeId, uint32 MinPlayersPerTeam, uint32 MaxPlayersPerTeam, uint32 LevelMin, uint32 LevelMax, char* BattleGroundName, uint32 MapID, float Team1StartLocX, float Team1StartLocY, float Team1StartLocZ, float Team1StartLocO, float Team2StartLocX, float Team2StartLocY, float Team2StartLocZ, float Team2StartLocO)
 {
     // Create the BG
@@ -658,12 +1435,8 @@ uint32 BattleGroundMgr::CreateBattleGround(uint32 bgTypeId, uint32 MinPlayersPer
     }
 
     bg->SetMapId(MapID);
+
     bg->Reset();
-    if(!bg->SetupBattleGround())
-    {
-        delete bg;
-        return 0;
-    }
 
     BattlemasterListEntry const *bl = sBattlemasterListStore.LookupEntry(bgTypeId);
     //in previous method is checked if exists entry in sBattlemasterListStore, so no check needed
@@ -673,7 +1446,7 @@ uint32 BattleGroundMgr::CreateBattleGround(uint32 bgTypeId, uint32 MinPlayersPer
     }
 
     bg->SetTypeID(bgTypeId);
-    bg->SetInstanceID(bgTypeId);                            // temporary
+    bg->SetInstanceID(0);                               // template bg, instance id is 0
     bg->SetMinPlayersPerTeam(MinPlayersPerTeam);
     bg->SetMaxPlayersPerTeam(MaxPlayersPerTeam);
     bg->SetMinPlayers(MinPlayersPerTeam*2);
@@ -682,12 +1455,14 @@ uint32 BattleGroundMgr::CreateBattleGround(uint32 bgTypeId, uint32 MinPlayersPer
     bg->SetTeamStartLoc(ALLIANCE, Team1StartLocX, Team1StartLocY, Team1StartLocZ, Team1StartLocO);
     bg->SetTeamStartLoc(HORDE,    Team2StartLocX, Team2StartLocY, Team2StartLocZ, Team2StartLocO);
     bg->SetLevelRange(LevelMin, LevelMax);
-    //add BaggleGround instance to FreeSlotQueue
+
+    //add BattleGround instance to FreeSlotQueue (.back() will return the template!)
     bg->AddToBGFreeSlotQueue();
 
-    AddBattleGround(bg->GetInstanceID(), bg);
-    //sLog.outDetail("BattleGroundMgr: Created new battleground: %u %s (Map %u, %u players per team, Levels %u-%u)", bg_TypeID, bg->m_Name, bg->m_MapId, bg->m_MaxPlayersPerTeam, bg->m_LevelMin, bg->m_LevelMax);
-    return bg->GetInstanceID();
+    // do NOT add to update list, since this is a template battleground!
+
+    // return some not-null value, bgTypeId is good enough for me
+    return bgTypeId; 
 }
 
 void BattleGroundMgr::CreateInitialBattleGrounds()
@@ -807,6 +1582,90 @@ void BattleGroundMgr::CreateInitialBattleGrounds()
     sLog.outString( ">> Loaded %u battlegrounds", count );
 }
 
+void BattleGroundMgr::InitAutomaticArenaPointDistribution()
+{
+    if(m_AutoDistributePoints)
+    {
+        sLog.outDebug("Initializing Automatic Arena Point Distribution");
+        QueryResult * result = CharacterDatabase.Query("SELECT UNIX_TIMESTAMP(NextArenaPointDistributionTime) FROM saved_variables");
+        if(!result)
+        {
+            sLog.outDebug("Battleground: Next arena point distribution time not found in SavedVariables, reseting it now."); 
+            m_NextAutoDistributionTime = time(NULL) + BATTLEGROUND_ARENA_POINT_DISTRIBUTION_DAY * sWorld.getConfig(CONFIG_ARENA_AUTO_DISTRIBUTE_INTERVAL_DAYS);
+            CharacterDatabase.PExecute("INSERT INTO saved_variables (NextArenaPointDistributionTime) VALUES ( FROM_UNIXTIME('"I64FMTD"') )",(uint64)m_NextAutoDistributionTime);
+        }
+        else
+        {
+            m_NextAutoDistributionTime = (*result)[0].GetUInt64();
+            delete result;
+        }
+        sLog.outDebug("Automatic Arena Point Distribution initialized.");
+    }
+}
+
+void BattleGroundMgr::DistributeArenaPoints()
+{
+    // used to distribute arena points based on last week's stats
+    sWorld.SendGlobalText("Flushing Arena points based on team ratings, this may take a few minutes. Please stand by...", NULL);
+
+    sWorld.SendGlobalText("Distributing arena points to players...", NULL);
+
+    CharacterDatabase.BeginTransaction();
+    // direct execute, because of the later GetUInt32ValueFromDB() calls
+                                                                                                                                        // 1                                                                                               2                                                          3                                                 4                                                                                                                                      5                                                                              6                                                         7                                                 8                                                                                                                                  9                                                                                    10                                                 1                           2                              3                        4                                        5                                      6                        7                              8                       9                                             10
+    CharacterDatabase.DirectPExecute("UPDATE characters b, arena_team_member a SET b.data = CONCAT( SUBSTRING_INDEX(b.data, ' ', '%u'),' ', CAST( IF ( ((CAST( SUBSTRING( b.data FROM (CHAR_LENGTH(SUBSTRING_INDEX(b.data,' ','%u')) + 2) FOR (CHAR_LENGTH(SUBSTRING_INDEX(b.data,' ','%u')) - CHAR_LENGTH(SUBSTRING_INDEX(b.data,' ','%u')) - 1) ) AS UNSIGNED) + (SELECT MAX(c.points_to_add) FROM arena_team_member c WHERE c.guid = b.guid GROUP BY c.guid) ) < '%u'), CAST(SUBSTRING(b.data FROM (CHAR_LENGTH(SUBSTRING_INDEX(b.data,' ','%u')) + 2) FOR (CHAR_LENGTH(SUBSTRING_INDEX(b.data,' ','%u')) - CHAR_LENGTH(SUBSTRING_INDEX(b.data,' ','%u')) - 1) ) AS UNSIGNED) + (SELECT MAX(d.points_to_add) FROM arena_team_member d WHERE d.guid = b.guid GROUP BY d.guid), '%u') AS CHAR),' ',SUBSTRING(b.data FROM (CHAR_LENGTH(SUBSTRING_INDEX(b.data,' ','%u')) + 2))) WHERE b.guid = a.guid",PLAYER_FIELD_ARENA_CURRENCY, PLAYER_FIELD_ARENA_CURRENCY, PLAYER_FIELD_ARENA_CURRENCY+1, PLAYER_FIELD_ARENA_CURRENCY, sWorld.getConfig(CONFIG_MAX_ARENA_POINTS),PLAYER_FIELD_ARENA_CURRENCY, PLAYER_FIELD_ARENA_CURRENCY+1, PLAYER_FIELD_ARENA_CURRENCY, sWorld.getConfig(CONFIG_MAX_ARENA_POINTS), PLAYER_FIELD_ARENA_CURRENCY+1);
+    for(int i=0; i<3; ++i)
+    {
+        // reset weekly played matches
+        uint32 position = PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 6 * i + 2;
+        CharacterDatabase.DirectPExecute("UPDATE characters SET data = CONCAT( SUBSTRING_INDEX(data,' ','%u'),' ','0',' ',SUBSTRING(data FROM (CHAR_LENGTH(SUBSTRING_INDEX(data,' ','%u')) + 2)))",position, position + 1);
+    }
+    CharacterDatabase.DirectExecute("UPDATE arena_team_member SET points_to_add = '0', played_week = '0', wons_week = '0'");
+    CharacterDatabase.DirectExecute("UPDATE arena_team_stats SET games = '0', wins = '0'");
+    CharacterDatabase.CommitTransaction();
+
+    sWorld.SendGlobalText("Finished distributing arena points to players. Now set the new points in online players' data blob, this will send them update packets as well...", NULL);
+
+    QueryResult *result = CharacterDatabase.PQuery("SELECT guid, data FROM characters WHERE online = '1'");
+    if( result )
+    {
+        do
+        {
+            Field *fields = result->Fetch();
+
+            uint32 guid = fields[0].GetUInt32();
+            if(Player * pl = objmgr.GetPlayer(MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER)))
+            {
+                Tokens data = StrSplit(fields[1].GetCppString(), " ");
+                // update arena currency
+                pl->SetUInt32Value(PLAYER_FIELD_ARENA_CURRENCY, Player::GetUInt32ValueFromArray(data, PLAYER_FIELD_ARENA_CURRENCY));
+                // reset played this week count for all teams
+                for(int i= 0; i < 3; ++i)
+                    pl->SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 6 * i + 2, 0);
+            }
+
+        } while (result->NextRow());
+
+        delete result;
+    }
+
+    sWorld.SendGlobalText("Finished setting arena points for online players.", NULL);
+
+    sWorld.SendGlobalText("Modifying played count, arena points etc. for loaded arena teams, sending updated stats to online players...", NULL);
+    for(ObjectMgr::ArenaTeamSet::iterator titr = objmgr.GetArenaTeamSetBegin(); titr != objmgr.GetArenaTeamSetEnd(); ++titr)
+    {
+        if(ArenaTeam * at = (*titr))
+        {
+            at->FinishWeek();   // set played this week etc values to 0 in memory, too
+            // at->SaveToDB(); // no need, the modified values are already saved above
+            at->NotifyStatsChanged();  // notify the players of the changes
+        }
+    }
+    sWorld.SendGlobalText("Modification done.", NULL);
+
+    sWorld.SendGlobalText("Done flushing Arena points.", NULL);
+}
+
 void BattleGroundMgr::BuildBattleGroundListPacket(WorldPacket *data, uint64 guid, Player* plr, uint32 bgTypeId)
 {
     uint32 PlayerLevel = 10;
@@ -842,18 +1701,25 @@ void BattleGroundMgr::BuildBattleGroundListPacket(WorldPacket *data, uint64 guid
     }
 }
 
-void BattleGroundMgr::SendToBattleGround(Player *pl, uint32 bgTypeId)
+void BattleGroundMgr::SendToBattleGround(Player *pl, uint32 instanceId)
 {
-    BattleGround *bg = GetBattleGround(bgTypeId);
+    BattleGround *bg = GetBattleGround(instanceId);
     if(bg)
     {
         uint32 mapid = bg->GetMapId();
         float x, y, z, O;
-        bg->GetTeamStartLoc(pl->GetTeam(), x, y, z, O);
+        uint32 team = pl->GetBGTeam();
+        if(team==0)
+            team = pl->GetTeam();
+        bg->GetTeamStartLoc(team, x, y, z, O);
 
         sLog.outDetail("BATTLEGROUND: Sending %s to map %u, X %f, Y %f, Z %f, O %f", pl->GetName(), mapid, x, y, z, O);
         pl->TeleportTo(mapid, x, y, z, O);
     }
+    else
+    {
+        sLog.outError("player %u trying to port to non-existent bg instance %u",pl->GetGUIDLow(), instanceId);
+    }
 }
 
 void BattleGroundMgr::SendAreaSpiritHealerQueryOpcode(Player *pl, BattleGround *bg, uint64 guid)
@@ -865,3 +1731,100 @@ void BattleGroundMgr::SendAreaSpiritHealerQueryOpcode(Player *pl, BattleGround *
     data << guid << time_;
     pl->GetSession()->SendPacket(&data);
 }
+
+void BattleGroundMgr::RemoveBattleGround(uint32 instanceID)
+{
+    BattleGroundSet::iterator itr = m_BattleGrounds.find(instanceID);
+    if(itr!=m_BattleGrounds.end())
+        m_BattleGrounds.erase(itr);
+}
+
+bool BattleGroundMgr::IsArenaType(uint32 bgTypeId) const
+{
+    return ( bgTypeId == BATTLEGROUND_AA ||
+        bgTypeId == BATTLEGROUND_BE ||
+        bgTypeId == BATTLEGROUND_NA ||
+        bgTypeId == BATTLEGROUND_RL );
+}
+
+bool BattleGroundMgr::IsBattleGroundType(uint32 bgTypeId) const
+{
+    return !IsArenaType(bgTypeId);
+}
+
+uint32 BattleGroundMgr::BGQueueTypeId(uint32 bgTypeId, uint8 arenaType) const
+{
+    switch(bgTypeId)
+    {
+    case BATTLEGROUND_WS:
+        return BATTLEGROUND_QUEUE_WS;
+    case BATTLEGROUND_AB:
+        return BATTLEGROUND_QUEUE_AB;
+    case BATTLEGROUND_AV:
+        return BATTLEGROUND_QUEUE_AV;
+    case BATTLEGROUND_EY:
+        return BATTLEGROUND_QUEUE_EY;
+    case BATTLEGROUND_AA:
+    case BATTLEGROUND_NA:
+    case BATTLEGROUND_RL:
+    case BATTLEGROUND_BE:
+        switch(arenaType)
+        {
+        case ARENA_TYPE_2v2:
+            return BATTLEGROUND_QUEUE_2v2;
+        case ARENA_TYPE_3v3:
+            return BATTLEGROUND_QUEUE_3v3;
+        case ARENA_TYPE_5v5:
+            return BATTLEGROUND_QUEUE_5v5;
+        default:
+            return 0;
+        }
+    default:
+        return 0;
+    }
+}
+
+uint32 BattleGroundMgr::BGTemplateId(uint32 bgQueueTypeId) const
+{
+    switch(bgQueueTypeId)
+    {
+    case BATTLEGROUND_QUEUE_WS:
+        return BATTLEGROUND_WS;
+    case BATTLEGROUND_QUEUE_AB:
+        return BATTLEGROUND_AB;
+    case BATTLEGROUND_QUEUE_AV:
+        return BATTLEGROUND_AV;
+    case BATTLEGROUND_QUEUE_EY:
+        return BATTLEGROUND_EY;
+    case BATTLEGROUND_QUEUE_2v2:
+    case BATTLEGROUND_QUEUE_3v3:
+    case BATTLEGROUND_QUEUE_5v5:
+        return BATTLEGROUND_AA;
+    default:
+        return 0;
+    }
+}
+
+uint8 BattleGroundMgr::BGArenaType(uint32 bgQueueTypeId) const
+{
+    switch(bgQueueTypeId)
+    {
+    case BATTLEGROUND_QUEUE_2v2:
+        return ARENA_TYPE_2v2;
+    case BATTLEGROUND_QUEUE_3v3:
+        return ARENA_TYPE_3v3;
+    case BATTLEGROUND_QUEUE_5v5:
+        return ARENA_TYPE_5v5;
+    default:
+        return 0;
+    }
+}
+
+void BattleGroundMgr::ToggleArenaTesting()
+{
+    m_ArenaTesting = !m_ArenaTesting;
+    if(m_ArenaTesting)
+        sWorld.SendGlobalText("Arenas are set to 1v1 for debugging. So, don't join as group.", NULL);
+    else
+        sWorld.SendGlobalText("Arenas are set to normal playercount.", NULL);
+}
diff --git a/src/game/BattleGroundMgr.h b/src/game/BattleGroundMgr.h
index 193e5f4..63510ce 100644
--- a/src/game/BattleGroundMgr.h
+++ b/src/game/BattleGroundMgr.h
@@ -34,51 +34,98 @@ typedef std::deque<BattleGround*> BGFreeSlotQueueType;
 
 #define MAX_BATTLEGROUND_TYPES 9                            // each BG type will be in array
 
-struct PlayerQueueInfo
+#define MAX_BATTLEGROUND_QUEUE_TYPES 8
+
+#define BATTLEGROUND_ARENA_POINT_DISTRIBUTION_DAY    86400     // seconds in a day
+
+struct GroupQueueInfo;                                      // type predefinition
+struct PlayerQueueInfo                                      // stores information for players in queue
 {
     uint32  InviteTime;                                     // first invite time
     uint32  LastInviteTime;                                 // last invite time
-    uint32  IsInvitedToBGInstanceGUID;                      // was invited to certain BG
     uint32  LastOnlineTime;                                 // for tracking and removing offline players from queue after 5 minutes
-    uint32  Team;                                           // Player team (ALLIANCE/HORDE)
-    bool IsRated;
-    bool AsGroup;                                           // uint32 GroupId;
-    uint8 ArenaType;
+    GroupQueueInfo * GroupInfo;                             // pointer to the associated groupqueueinfo
 };
 
-struct PlayersCount
+struct GroupQueueInfo                                       // stores information about the group in queue (also used when joined as solo!)
 {
-    uint32 Alliance;
-    uint32 Horde;
-};
-
-template<class _Kty, class _Ty> class bgqueue: public std::map<_Kty, _Ty>
-{
-    public:
-        uint32 Alliance;
-        uint32 Horde;
-        //bool   Ready; // not used now
-        //uint32 AverageTime; //not already implemented (it should be average time in queue for last 10 players)
+    std::map<uint64, PlayerQueueInfo*> Players;             // player queue info map
+    uint32  Team;                                           // Player team (ALLIANCE/HORDE)
+    bool    IsRated;                                        // rated
+    uint32  BgTypeId;                                       // battleground type id
+    uint8   ArenaType;                                      // 2v2, 3v3, 5v5 or 0 when BG
+    uint32  ArenaTeamId;                                    // team id if rated match
+    uint32  JoinTime;                                       // time when group was added
+    uint32  IsInvitedToBGInstanceGUID;                      // was invited to certain BG
+    uint32  ArenaTeamRating;                                // if rated match, inited to the rating of the team
 };
 
+class BattleGround;
 class BattleGroundQueue
 {
     public:
         BattleGroundQueue();
         ~BattleGroundQueue();
-/*
-        uint32 GetType();
-        void SetType(uint32 type);*/
 
-        void Update(uint32 bgTypeId, uint32 queue_id);
+        void Update(uint32 bgTypeId, uint32 queue_id, uint8 arenatype = 0, bool isRated = false, uint32 minRating = 0);
 
-        void AddPlayer(Player *plr, uint32 bgTypeId);
+        GroupQueueInfo * AddGroup(Player * leader, uint32 BgTypeId, uint8 ArenaType, bool isRated, uint32 ArenaRating, uint32 ArenaTeamId = 0);
+        void AddPlayer(Player *plr, GroupQueueInfo *ginfo);
         void RemovePlayer(uint64 guid, bool decreaseInvitedCount);
+        void DecreaseGroupLength(uint32 queueId, uint32 AsGroup);
+        void BGEndedRemoveInvites(BattleGround * bg);
 
-        typedef bgqueue<uint64, PlayerQueueInfo> QueuedPlayersMap;
+        typedef std::map<uint64, PlayerQueueInfo> QueuedPlayersMap;
         QueuedPlayersMap m_QueuedPlayers[MAX_BATTLEGROUND_QUEUES];
-        typedef std::list<uint64> PlayerGuidsSortedByTimeQueue;
-        PlayerGuidsSortedByTimeQueue m_PlayersSortedByWaitTime[MAX_BATTLEGROUND_QUEUES];
+
+        typedef std::list<GroupQueueInfo*> QueuedGroupsList;
+        QueuedGroupsList m_QueuedGroups[MAX_BATTLEGROUND_QUEUES];
+
+        // class to hold pointers to the groups eligible for a specific selection pool building mode
+        class EligibleGroups : public std::list<GroupQueueInfo *>
+        {
+        public:
+            void Init(QueuedGroupsList * source, uint32 BgTypeId, uint32 side, uint32 MaxPlayers, uint8 ArenaType = 0, bool IsRated = false, uint32 MinRating = 0, uint32 MaxRating = 0, uint32 DisregardTime = 0, uint32 excludeTeam = 0);
+            void RemoveGroup(GroupQueueInfo * ginfo);
+        };
+
+        EligibleGroups m_EligibleGroups;
+
+        // class to select and invite groups to bg
+        class SelectionPool
+        {
+        public:
+            void Init();
+            void AddGroup(GroupQueueInfo * group);
+            GroupQueueInfo * GetMaximalGroup();
+            void RemoveGroup(GroupQueueInfo * group);
+            uint32 GetPlayerCount() const {return PlayerCount;}
+        public:
+            std::list<GroupQueueInfo *> SelectedGroups;
+        private:
+            uint32 PlayerCount;
+            GroupQueueInfo * MaxGroup;
+        };
+
+        enum SelectionPoolBuildMode
+        {
+            NORMAL_ALLIANCE,
+            NORMAL_HORDE,
+            ONESIDE_ALLIANCE_TEAM1,
+            ONESIDE_ALLIANCE_TEAM2,
+            ONESIDE_HORDE_TEAM1,
+            ONESIDE_HORDE_TEAM2,
+
+            NUM_SELECTION_POOL_TYPES
+        };
+
+        SelectionPool m_SelectionPools[NUM_SELECTION_POOL_TYPES];
+
+        bool BuildSelectionPool(uint32 bgTypeId, uint32 queue_id, uint32 MinPlayers, uint32 MaxPlayers, SelectionPoolBuildMode mode, uint8 ArenaType = 0, bool isRated = false, uint32 MinRating = 0, uint32 MaxRating = 0, uint32 DisregardTime = 0, uint32 excludeTeam = 0);
+
+    private:
+
+        bool InviteGroupToBG(GroupQueueInfo * ginfo, BattleGround * bg, uint32 side);
 };
 
 /*
@@ -96,7 +143,6 @@ class BGQueueInviteEvent : public BasicEvent
     private:
         uint64 m_PlayerGuid;
         uint32 m_BgInstanceGUID;
-
 };
 
 /*
@@ -116,7 +162,6 @@ class BGQueueRemoveEvent : public BasicEvent
         uint32 m_PlayersTeam;
 };
 
-
 class BattleGroundMgr
 {
     public:
@@ -132,18 +177,18 @@ class BattleGroundMgr
         void BuildGroupJoinedBattlegroundPacket(WorldPacket *data, uint32 bgTypeId);
         void BuildUpdateWorldStatePacket(WorldPacket *data, uint32 field, uint32 value);
         void BuildPvpLogDataPacket(WorldPacket *data, BattleGround *bg);
-        void BuildBattleGroundStatusPacket(WorldPacket *data, BattleGround *bg, uint32 team, uint8 QueueSlot, uint8 StatusID, uint32 Time1, uint32 Time2);
+        void BuildBattleGroundStatusPacket(WorldPacket *data, BattleGround *bg, uint32 team, uint8 QueueSlot, uint8 StatusID, uint32 Time1, uint32 Time2, uint32 arenatype = 0, uint8 israted = 0);
         void BuildPlaySoundPacket(WorldPacket *data, uint32 soundid);
 
         /* Player invitation */
         // called from Queue update, or from Addplayer to queue
-        void InvitePlayer(Player* plr, uint32 bgInstanceGUID);
+        void InvitePlayer(Player* plr, uint32 bgInstanceGUID, uint32 team);
 
         /* Battlegrounds */
         BattleGroundSet::iterator GetBattleGroundsBegin() { return m_BattleGrounds.begin(); };
         BattleGroundSet::iterator GetBattleGroundsEnd() { return m_BattleGrounds.end(); };
 
-        BattleGround* GetBattleGround(uint8 ID)
+        BattleGround* GetBattleGround(uint32 ID)
         {
             BattleGroundSet::iterator i = m_BattleGrounds.find(ID);
             if(i != m_BattleGrounds.end())
@@ -152,9 +197,13 @@ class BattleGroundMgr
                 return NULL;
         };
 
+        BattleGround * GetBattleGroundTemplate(uint32 bgTypeId);
+        BattleGround * CreateNewBattleGround(uint32 bgTypeId);
+
         uint32 CreateBattleGround(uint32 bgTypeId, uint32 MinPlayersPerTeam, uint32 MaxPlayersPerTeam, uint32 LevelMin, uint32 LevelMax, char* BattleGroundName, uint32 MapID, float Team1StartLocX, float Team1StartLocY, float Team1StartLocZ, float Team1StartLocO, float Team2StartLocX, float Team2StartLocY, float Team2StartLocZ, float Team2StartLocO);
 
         inline void AddBattleGround(uint32 ID, BattleGround* BG) { m_BattleGrounds[ID] = BG; };
+        void RemoveBattleGround(uint32 instanceID);
 
         void CreateInitialBattleGrounds();
 
@@ -162,16 +211,39 @@ class BattleGroundMgr
 
         /* Battleground queues */
         //these queues are instantiated when creating BattlegroundMrg
-        BattleGroundQueue m_BattleGroundQueues[MAX_BATTLEGROUND_TYPES]; // public, because we need to access them in BG handler code
+        BattleGroundQueue m_BattleGroundQueues[MAX_BATTLEGROUND_QUEUE_TYPES]; // public, because we need to access them in BG handler code
 
         BGFreeSlotQueueType BGFreeSlotQueue[MAX_BATTLEGROUND_TYPES];
 
         void SendAreaSpiritHealerQueryOpcode(Player *pl, BattleGround *bg, uint64 guid);
 
+        bool IsArenaType(uint32 bgTypeId) const;
+        bool IsBattleGroundType(uint32 bgTypeId) const;
+        uint32 BGQueueTypeId(uint32 bgTypeId, uint8 arenaType) const;
+        uint32 BGTemplateId(uint32 bgQueueTypeId) const;
+        uint8 BGArenaType(uint32 bgQueueTypeId) const;
+
+        uint32 GetMaxRatingDifference() const {return m_MaxRatingDifference;}
+        uint32 GetRatingDiscardTimer() const {return m_RatingDiscardTimer;}
+
+        void InitAutomaticArenaPointDistribution();
+        void DistributeArenaPoints();
+        uint32 GetPrematureFinishTime() const {return m_PrematureFinishTimer;}
+        void ToggleArenaTesting();
+        const bool isArenaTesting() const { return m_ArenaTesting; }
+
     private:
 
         /* Battlegrounds */
         BattleGroundSet m_BattleGrounds;
+        uint32 m_MaxRatingDifference;
+        uint32 m_RatingDiscardTimer;
+        uint32 m_NextRatingDiscardUpdate;
+        bool   m_AutoDistributePoints;
+        uint64 m_NextAutoDistributionTime;
+        uint32 m_AutoDistributionTimeChecker;
+        uint32 m_PrematureFinishTimer;
+        bool   m_ArenaTesting;
 };
 
 #define sBattleGroundMgr MaNGOS::Singleton<BattleGroundMgr>::Instance()
diff --git a/src/game/BattleGroundNA.cpp b/src/game/BattleGroundNA.cpp
index ac4705f..385de12 100644
--- a/src/game/BattleGroundNA.cpp
+++ b/src/game/BattleGroundNA.cpp
@@ -47,6 +47,12 @@ void BattleGroundNA::Update(time_t diff)
         if (!(m_Events & 0x01))
         {
             m_Events |= 0x01;
+            // setup here, only when at least one player has ported to the map
+            if(!SetupBattleGround())
+            {
+                EndNow();
+                return;
+            }
             for(uint32 i = BG_NA_OBJECT_DOOR_1; i <= BG_NA_OBJECT_DOOR_4; i++)
                 SpawnBGObject(i, RESPAWN_IMMEDIATELY);
 
@@ -73,6 +79,9 @@ void BattleGroundNA::Update(time_t diff)
             for(uint32 i = BG_NA_OBJECT_DOOR_1; i <= BG_NA_OBJECT_DOOR_2; i++)
                 DoorOpen(i);
 
+            for(uint32 i = BG_NA_OBJECT_BUFF_1; i <= BG_NA_OBJECT_BUFF_2; i++)
+                SpawnBGObject(i, 60);
+
             SendMessageToAll(LANG_ARENA_BEGUN);
             SetStatus(STATUS_IN_PROGRESS);
             SetStartDelayTime(0);
@@ -80,6 +89,11 @@ void BattleGroundNA::Update(time_t diff)
             for(BattleGroundPlayerMap::const_iterator itr = GetPlayers().begin(); itr != GetPlayers().end(); ++itr)
                 if(Player *plr = objmgr.GetPlayer(itr->first))
                     plr->RemoveAurasDueToSpell(SPELL_ARENA_PREPARATION);
+
+            if(!GetPlayersCountByTeam(ALLIANCE) && GetPlayersCountByTeam(HORDE))
+                EndBattleGround(HORDE);
+            else if(GetPlayersCountByTeam(ALLIANCE) && !GetPlayersCountByTeam(HORDE))
+                EndBattleGround(ALLIANCE);
         }
     }
 
@@ -96,11 +110,23 @@ void BattleGroundNA::AddPlayer(Player *plr)
     BattleGroundNAScore* sc = new BattleGroundNAScore;
 
     m_PlayerScores[plr->GetGUID()] = sc;
+
+    UpdateWorldState(0xa0f, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0xa10, GetAlivePlayersCountByTeam(HORDE));
 }
 
 void BattleGroundNA::RemovePlayer(Player* /*plr*/, uint64 /*guid*/)
 {
+    if(GetStatus() == STATUS_WAIT_LEAVE)
+        return;
+
+    UpdateWorldState(0xa0f, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0xa10, GetAlivePlayersCountByTeam(HORDE));
 
+    if(!GetAlivePlayersCountByTeam(ALLIANCE) && GetPlayersCountByTeam(HORDE))
+        EndBattleGround(HORDE);
+    else if(GetPlayersCountByTeam(ALLIANCE) && !GetAlivePlayersCountByTeam(HORDE))
+        EndBattleGround(ALLIANCE);
 }
 
 void BattleGroundNA::HandleKillPlayer(Player *player, Player *killer)
@@ -114,19 +140,29 @@ void BattleGroundNA::HandleKillPlayer(Player *player, Player *killer)
         return;
     }
 
-    BattleGround::HandleKillPlayer(player, killer);
+    BattleGround::HandleKillPlayer(player,killer);
 
-    uint32 killer_team_index = GetTeamIndexByTeamId(killer->GetTeam());
+    UpdateWorldState(0xa0f, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0xa10, GetAlivePlayersCountByTeam(HORDE));
 
-    ++m_TeamKills[killer_team_index];                       // add kills to killer's team
-
-    if(m_TeamKills[killer_team_index] >= GetPlayersCountByTeam(player->GetTeam()))
+    if(!GetAlivePlayersCountByTeam(ALLIANCE))
+    {
+        // all opponents killed
+        EndBattleGround(HORDE);
+    }
+    else if(!GetAlivePlayersCountByTeam(HORDE))
     {
         // all opponents killed
-        EndBattleGround(killer->GetTeam());
+        EndBattleGround(ALLIANCE);
     }
 }
 
+bool BattleGroundNA::HandlePlayerUnderMap(Player *player)
+{
+    player->TeleportTo(GetMapId(),4055.504395,2919.660645,13.611241,player->GetOrientation(),false);
+    return true;
+}
+
 void BattleGroundNA::HandleAreaTrigger(Player *Source, uint32 Trigger)
 {
     if(GetStatus() != STATUS_IN_PROGRESS)
@@ -149,19 +185,28 @@ void BattleGroundNA::HandleAreaTrigger(Player *Source, uint32 Trigger)
     //    HandleTriggerBuff(buff_guid,Source);
 }
 
+void BattleGroundNA::FillInitialWorldStates(WorldPacket &data)
+{
+    data << uint32(0xa0f) << uint32(GetAlivePlayersCountByTeam(ALLIANCE));           // 7
+    data << uint32(0xa10) << uint32(GetAlivePlayersCountByTeam(HORDE));           // 8
+    data << uint32(0xa11) << uint32(1);           // 9
+}
+
 void BattleGroundNA::ResetBGSubclass()
 {
-    m_TeamKills[BG_TEAM_ALLIANCE] = 0;
-    m_TeamKills[BG_TEAM_HORDE]    = 0;
+
 }
 
 bool BattleGroundNA::SetupBattleGround()
 {
     // gates
-    if(    !AddObject(BG_NA_OBJECT_DOOR_1, BG_NA_OBJECT_TYPE_DOOR_1, 4031.854f, 2966.833f, 12.6462f, -2.648788f, 0, 0, 0.9697962f, -0.2439165f, RESPAWN_IMMEDIATELY)
-        || !AddObject(BG_NA_OBJECT_DOOR_2, BG_NA_OBJECT_TYPE_DOOR_2, 4081.179f, 2874.97f, 12.39171f, 0.4928045f, 0, 0, 0.2439165f, 0.9697962f, RESPAWN_IMMEDIATELY)
-        || !AddObject(BG_NA_OBJECT_DOOR_3, BG_NA_OBJECT_TYPE_DOOR_3, 4023.709f, 2981.777f, 10.70117f, -2.648788f, 0, 0, 0.9697962f, -0.2439165f, RESPAWN_IMMEDIATELY)
-        || !AddObject(BG_NA_OBJECT_DOOR_4, BG_NA_OBJECT_TYPE_DOOR_4, 4090.064f, 2858.438f, 10.23631f, 0.4928045f, 0, 0, 0.2439165f, 0.9697962f, RESPAWN_IMMEDIATELY))
+    if(    !AddObject(BG_NA_OBJECT_DOOR_1, BG_NA_OBJECT_TYPE_DOOR_1, 4031.854, 2966.833, 12.6462, -2.648788, 0, 0, 0.9697962, -0.2439165, RESPAWN_IMMEDIATELY)
+        || !AddObject(BG_NA_OBJECT_DOOR_2, BG_NA_OBJECT_TYPE_DOOR_2, 4081.179, 2874.97, 12.39171, 0.4928045, 0, 0, 0.2439165, 0.9697962, RESPAWN_IMMEDIATELY)
+        || !AddObject(BG_NA_OBJECT_DOOR_3, BG_NA_OBJECT_TYPE_DOOR_3, 4023.709, 2981.777, 10.70117, -2.648788, 0, 0, 0.9697962, -0.2439165, RESPAWN_IMMEDIATELY)
+        || !AddObject(BG_NA_OBJECT_DOOR_4, BG_NA_OBJECT_TYPE_DOOR_4, 4090.064, 2858.438, 10.23631, 0.4928045, 0, 0, 0.2439165, 0.9697962, RESPAWN_IMMEDIATELY)
+    // buffs
+        || !AddObject(BG_NA_OBJECT_BUFF_1, BG_NA_OBJECT_TYPE_BUFF_1, 4009.189941, 2895.250000, 13.052700, -1.448624, 0, 0, 0.6626201, -0.7489557, 120)
+        || !AddObject(BG_NA_OBJECT_BUFF_2, BG_NA_OBJECT_TYPE_BUFF_2, 4103.330078, 2946.350098, 13.051300, -0.06981307, 0, 0, 0.03489945, -0.9993908, 120))
     {
         sLog.outErrorDb("BatteGroundNA: Failed to spawn some object!");
         return false;
diff --git a/src/game/BattleGroundNA.h b/src/game/BattleGroundNA.h
index 723e5b0..a444609 100644
--- a/src/game/BattleGroundNA.h
+++ b/src/game/BattleGroundNA.h
@@ -26,7 +26,9 @@ enum BattleGroundNAObjectTypes
     BG_NA_OBJECT_DOOR_2         = 1,
     BG_NA_OBJECT_DOOR_3         = 2,
     BG_NA_OBJECT_DOOR_4         = 3,
-    BG_NA_OBJECT_MAX            = 4
+    BG_NA_OBJECT_BUFF_1         = 4,
+    BG_NA_OBJECT_BUFF_2         = 5,
+    BG_NA_OBJECT_MAX            = 6
 };
 
 enum BattleGroundNAObjects
@@ -34,7 +36,9 @@ enum BattleGroundNAObjects
     BG_NA_OBJECT_TYPE_DOOR_1    = 183978,
     BG_NA_OBJECT_TYPE_DOOR_2    = 183980,
     BG_NA_OBJECT_TYPE_DOOR_3    = 183977,
-    BG_NA_OBJECT_TYPE_DOOR_4    = 183979
+    BG_NA_OBJECT_TYPE_DOOR_4    = 183979,
+    BG_NA_OBJECT_TYPE_BUFF_1    = 184663,
+    BG_NA_OBJECT_TYPE_BUFF_2    = 184664
 };
 
 class BattleGroundNAScore : public BattleGroundScore
@@ -61,9 +65,8 @@ class BattleGroundNA : public BattleGround
         void HandleAreaTrigger(Player *Source, uint32 Trigger);
         bool SetupBattleGround();
         virtual void ResetBGSubclass();
+        virtual void FillInitialWorldStates(WorldPacket &d);
         void HandleKillPlayer(Player* player, Player *killer);
-
-    private:
-        uint32 m_TeamKills[2];                              // count of kills for each team
+        bool HandlePlayerUnderMap(Player * plr);
 };
 #endif
diff --git a/src/game/BattleGroundRL.cpp b/src/game/BattleGroundRL.cpp
index 130f46a..55c27cf 100644
--- a/src/game/BattleGroundRL.cpp
+++ b/src/game/BattleGroundRL.cpp
@@ -47,6 +47,13 @@ void BattleGroundRL::Update(time_t diff)
         {
             m_Events |= 0x01;
 
+            // setup here, only when at least one player has ported to the map
+            if(!SetupBattleGround())
+            {
+                EndNow();
+                return;
+            }
+
             for(uint32 i = BG_RL_OBJECT_DOOR_1; i <= BG_RL_OBJECT_DOOR_2; i++)
                 SpawnBGObject(i, RESPAWN_IMMEDIATELY);
 
@@ -73,6 +80,9 @@ void BattleGroundRL::Update(time_t diff)
             for(uint32 i = BG_RL_OBJECT_DOOR_1; i <= BG_RL_OBJECT_DOOR_2; i++)
                 DoorOpen(i);
 
+            for(uint32 i = BG_RL_OBJECT_BUFF_1; i <= BG_RL_OBJECT_BUFF_2; i++)
+                SpawnBGObject(i, 60);
+
             SendMessageToAll(LANG_ARENA_BEGUN);
             SetStatus(STATUS_IN_PROGRESS);
             SetStartDelayTime(0);
@@ -80,6 +90,11 @@ void BattleGroundRL::Update(time_t diff)
             for(BattleGroundPlayerMap::const_iterator itr = GetPlayers().begin(); itr != GetPlayers().end(); ++itr)
                 if(Player *plr = objmgr.GetPlayer(itr->first))
                     plr->RemoveAurasDueToSpell(SPELL_ARENA_PREPARATION);
+
+            if(!GetPlayersCountByTeam(ALLIANCE) && GetPlayersCountByTeam(HORDE))
+                EndBattleGround(HORDE);
+            else if(GetPlayersCountByTeam(ALLIANCE) && !GetPlayersCountByTeam(HORDE))
+                EndBattleGround(ALLIANCE);
         }
     }
 
@@ -96,11 +111,23 @@ void BattleGroundRL::AddPlayer(Player *plr)
     BattleGroundRLScore* sc = new BattleGroundRLScore;
 
     m_PlayerScores[plr->GetGUID()] = sc;
+
+    UpdateWorldState(0xbb8, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0xbb9, GetAlivePlayersCountByTeam(HORDE));
 }
 
 void BattleGroundRL::RemovePlayer(Player *plr, uint64 guid)
 {
+    if(GetStatus() == STATUS_WAIT_LEAVE)
+        return;
 
+    UpdateWorldState(0xbb8, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0xbb9, GetAlivePlayersCountByTeam(HORDE));
+
+    if(!GetAlivePlayersCountByTeam(ALLIANCE) && GetPlayersCountByTeam(HORDE))
+        EndBattleGround(HORDE);
+    else if(GetPlayersCountByTeam(ALLIANCE) && !GetAlivePlayersCountByTeam(HORDE))
+        EndBattleGround(ALLIANCE);
 }
 
 void BattleGroundRL::HandleKillPlayer(Player *player, Player *killer)
@@ -114,19 +141,29 @@ void BattleGroundRL::HandleKillPlayer(Player *player, Player *killer)
         return;
     }
 
-    BattleGround::HandleKillPlayer(player, killer);
-
-    uint32 killer_team_index = GetTeamIndexByTeamId(killer->GetTeam());
+    BattleGround::HandleKillPlayer(player,killer);
 
-    ++m_TeamKills[killer_team_index];                       // add kills to killer's team
+    UpdateWorldState(0xbb8, GetAlivePlayersCountByTeam(ALLIANCE));
+    UpdateWorldState(0xbb9, GetAlivePlayersCountByTeam(HORDE));
 
-    if(m_TeamKills[killer_team_index] >= GetPlayersCountByTeam(player->GetTeam()))
+    if(!GetAlivePlayersCountByTeam(ALLIANCE))
+    {
+        // all opponents killed
+        EndBattleGround(HORDE);
+    }
+    else if(!GetAlivePlayersCountByTeam(HORDE))
     {
         // all opponents killed
-        EndBattleGround(killer->GetTeam());
+        EndBattleGround(ALLIANCE);
     }
 }
 
+bool BattleGroundRL::HandlePlayerUnderMap(Player *player)
+{
+    player->TeleportTo(GetMapId(),1285.810547,1667.896851,39.957642,player->GetOrientation(),false);
+    return true;
+}
+
 void BattleGroundRL::HandleAreaTrigger(Player *Source, uint32 Trigger)
 {
     // this is wrong way to implement these things. On official it done by gameobject spell cast.
@@ -150,17 +187,26 @@ void BattleGroundRL::HandleAreaTrigger(Player *Source, uint32 Trigger)
     //    HandleTriggerBuff(buff_guid,Source);
 }
 
+void BattleGroundRL::FillInitialWorldStates(WorldPacket &data)
+{
+    data << uint32(0xbb8) << uint32(GetAlivePlayersCountByTeam(ALLIANCE));           // 7
+    data << uint32(0xbb9) << uint32(GetAlivePlayersCountByTeam(HORDE));           // 8
+    data << uint32(0xbba) << uint32(1);           // 9
+}
+
 void BattleGroundRL::ResetBGSubclass()
 {
-    m_TeamKills[BG_TEAM_ALLIANCE] = 0;
-    m_TeamKills[BG_TEAM_HORDE]    = 0;
+
 }
 
 bool BattleGroundRL::SetupBattleGround()
 {
     // gates
-    if(    !AddObject(BG_RL_OBJECT_DOOR_1, BG_RL_OBJECT_TYPE_DOOR_1, 1293.561f, 1601.938f, 31.60557f, -1.457349f, 0, 0, -0.6658813f, 0.7460576f, RESPAWN_IMMEDIATELY)
-        || !AddObject(BG_RL_OBJECT_DOOR_2, BG_RL_OBJECT_TYPE_DOOR_2, 1278.648f, 1730.557f, 31.60557f, 1.684245f, 0, 0, 0.7460582f, 0.6658807f, RESPAWN_IMMEDIATELY))
+    if(    !AddObject(BG_RL_OBJECT_DOOR_1, BG_RL_OBJECT_TYPE_DOOR_1, 1293.561, 1601.938, 31.60557, -1.457349, 0, 0, -0.6658813, 0.7460576, RESPAWN_IMMEDIATELY)
+        || !AddObject(BG_RL_OBJECT_DOOR_2, BG_RL_OBJECT_TYPE_DOOR_2, 1278.648, 1730.557, 31.60557, 1.684245, 0, 0, 0.7460582, 0.6658807, RESPAWN_IMMEDIATELY)
+    // buffs
+        || !AddObject(BG_RL_OBJECT_BUFF_1, BG_RL_OBJECT_TYPE_BUFF_1, 1328.719971, 1632.719971, 36.730400, -1.448624, 0, 0, 0.6626201, -0.7489557, 120)
+        || !AddObject(BG_RL_OBJECT_BUFF_2, BG_RL_OBJECT_TYPE_BUFF_2, 1243.300049, 1699.170044, 34.872601, -0.06981307, 0, 0, 0.03489945, -0.9993908, 120))
     {
         sLog.outErrorDb("BatteGroundRL: Failed to spawn some object!");
         return false;
diff --git a/src/game/BattleGroundRL.h b/src/game/BattleGroundRL.h
index 0e9a38b..dd000ce 100644
--- a/src/game/BattleGroundRL.h
+++ b/src/game/BattleGroundRL.h
@@ -24,13 +24,17 @@ enum BattleGroundRLObjectTypes
 {
     BG_RL_OBJECT_DOOR_1         = 0,
     BG_RL_OBJECT_DOOR_2         = 1,
-    BG_RL_OBJECT_MAX            = 2
+    BG_RL_OBJECT_BUFF_1         = 2,
+    BG_RL_OBJECT_BUFF_2         = 3,
+    BG_RL_OBJECT_MAX            = 4
 };
 
 enum BattleGroundRLObjects
 {
     BG_RL_OBJECT_TYPE_DOOR_1    = 185918,
-    BG_RL_OBJECT_TYPE_DOOR_2    = 185917
+    BG_RL_OBJECT_TYPE_DOOR_2    = 185917,
+    BG_RL_OBJECT_TYPE_BUFF_1    = 184663,
+    BG_RL_OBJECT_TYPE_BUFF_2    = 184664
 };
 
 class BattleGroundRLScore : public BattleGroundScore
@@ -57,9 +61,8 @@ class BattleGroundRL : public BattleGround
         void HandleAreaTrigger(Player *Source, uint32 Trigger);
         bool SetupBattleGround();
         virtual void ResetBGSubclass();
+        virtual void FillInitialWorldStates(WorldPacket &d);
         void HandleKillPlayer(Player* player, Player *killer);
-
-    private:
-        uint32 m_TeamKills[2];                              // count of kills for each team
+        bool HandlePlayerUnderMap(Player * plr);
 };
 #endif
diff --git a/src/game/BattleGroundWS.cpp b/src/game/BattleGroundWS.cpp
index c482a95..2a3bb23 100644
--- a/src/game/BattleGroundWS.cpp
+++ b/src/game/BattleGroundWS.cpp
@@ -49,6 +49,16 @@ void BattleGroundWS::Update(time_t diff)
         {
             m_Events |= 0x01;
 
+            // setup here, only when at least one player has ported to the map
+            if(!SetupBattleGround())
+            {
+                EndNow();
+                return;
+            }
+
+//            for(uint32 i = WS_SPIRIT_MAIN_ALLIANCE; i <= WS_SPIRIT_MAIN_HORDE; i++)
+//                SpawnBGCreature(i, RESPAWN_IMMEDIATELY);
+
             for(uint32 i = BG_WS_OBJECT_DOOR_A_1; i <= BG_WS_OBJECT_DOOR_H_4; i++)
             {
                 SpawnBGObject(i, RESPAWN_IMMEDIATELY);
@@ -285,7 +295,32 @@ void BattleGroundWS::EventPlayerCapturedFlag(Player *Source)
 
 void BattleGroundWS::EventPlayerDroppedFlag(Player *Source)
 {
-    // Drop allowed in any BG state
+    if(GetStatus() != STATUS_IN_PROGRESS)
+    {
+        // if not running, do not cast things at the dropper player (prevent spawning the "dropped" flag), neither send unnecessary messages
+        // just take off the aura
+        if(Source->GetTeam() == ALLIANCE)
+        {
+            if(!this->IsHordeFlagPickedup())
+                return;
+            if(GetHordeFlagPickerGUID() == Source->GetGUID())
+            {
+                SetHordeFlagPicker(0);
+                Source->RemoveAurasDueToSpell(BG_WS_SPELL_WARSONG_FLAG);
+            }
+        }
+        else
+        {
+            if(!this->IsAllianceFlagPickedup())
+                return;
+            if(GetAllianceFlagPickerGUID() == Source->GetGUID())
+            {
+                SetAllianceFlagPicker(0);
+                Source->RemoveAurasDueToSpell(BG_WS_SPELL_SILVERWING_FLAG);
+            }
+        }
+        return;
+    }
 
     const char *message = "";
     uint8 type = 0;
diff --git a/src/game/CharacterHandler.cpp b/src/game/CharacterHandler.cpp
index ef2fcbf..fd10616 100644
--- a/src/game/CharacterHandler.cpp
+++ b/src/game/CharacterHandler.cpp
@@ -36,6 +36,7 @@
 #include "PlayerDump.h"
 #include "SocialMgr.h"
 #include "Util.h"
+#include "ArenaTeam.h"
 #include "Language.h"
 
 class LoginQueryHolder : public SqlQueryHolder
diff --git a/src/game/Chat.cpp b/src/game/Chat.cpp
index 3389c64..2a4488a 100644
--- a/src/game/Chat.cpp
+++ b/src/game/Chat.cpp
@@ -168,6 +168,7 @@ ChatCommand * ChatHandler::getCommandTable()
         { "Mod32Value",     SEC_ADMINISTRATOR,  false, &ChatHandler::HandleMod32Value,                 "", NULL },
         { "anim",           SEC_GAMEMASTER,     false, &ChatHandler::HandleAnimCommand,                "", NULL },
         { "lootrecipient",  SEC_GAMEMASTER,     false, &ChatHandler::HandleGetLootRecipient,           "", NULL },
+        { "arena",          SEC_ADMINISTRATOR,  false, &ChatHandler::HandleDebugArenaCommand,          "", NULL },
         { NULL,             0,                  false, NULL,                                           "", NULL }
     };
 
@@ -479,6 +480,8 @@ ChatCommand * ChatHandler::getCommandTable()
         { "gps",            SEC_MODERATOR,      false, &ChatHandler::HandleGPSCommand,                 "", NULL },
         { "guid",           SEC_GAMEMASTER,     false, &ChatHandler::HandleGUIDCommand,                "", NULL },
         { "help",           SEC_PLAYER,         true,  &ChatHandler::HandleHelpCommand,                "", NULL },
+        { "ahexpire",       SEC_ADMINISTRATOR,  false, &ChatHandler::HandleAHExpireCommand,            "", NULL },
+        { "ahdelete",       SEC_ADMINISTRATOR,  false, &ChatHandler::HandleAHDeleteCommand,            "", NULL },
         { "itemmove",       SEC_GAMEMASTER,     false, &ChatHandler::HandleItemMoveCommand,            "", NULL },
         { "cooldown",       SEC_ADMINISTRATOR,  false, &ChatHandler::HandleCooldownCommand,            "", NULL },
         { "unlearn",        SEC_ADMINISTRATOR,  false, &ChatHandler::HandleUnLearnCommand,             "", NULL },
@@ -527,6 +530,7 @@ ChatCommand * ChatHandler::getCommandTable()
         { "combatstop",     SEC_GAMEMASTER,     false, &ChatHandler::HandleCombatStopCommand,          "", NULL },
         { "chardelete",     SEC_CONSOLE,        true,  &ChatHandler::HandleCombatStopCommand,          "", NULL },
         { "sendmessage",    SEC_ADMINISTRATOR,  true,  &ChatHandler::HandleSendMessageCommand,         "", NULL },
+        { "flusharenapoints",    SEC_ADMINISTRATOR, false, &ChatHandler::HandleFlushArenaPointsCommand,         "",   NULL },
 
         { NULL,             0,                  false, NULL,                                           "", NULL }
     };
diff --git a/src/game/Chat.h b/src/game/Chat.h
index 8c6f19d..94d2f77 100644
--- a/src/game/Chat.h
+++ b/src/game/Chat.h
@@ -319,6 +319,8 @@ class ChatHandler
         bool HandleLookupSkillCommand(const char* args);
         bool HandleLookupSpellCommand(const char* args);
         bool HandleLookupTeleCommand(const char * args);
+        bool HandleAHExpireCommand(const char * args);
+        bool HandleAHDeleteCommand(const char * args);
 
         bool HandleCooldownCommand(const char* args);
         bool HandleUnLearnCommand(const char* args);
@@ -404,6 +406,7 @@ class ChatHandler
         bool HandleComeToMeCommand(const char *args);
         bool HandleCombatStopCommand(const char *args);
         bool HandleSendMessageCommand(const char * args);
+        bool HandleFlushArenaPointsCommand(const char *args);
 
         //! Development Commands
         bool HandleSetValue(const char* args);
@@ -416,6 +419,7 @@ class ChatHandler
         bool HandleSaveAllCommand(const char* args);
         bool HandleGetItemState(const char * args);
         bool HandleGetLootRecipient(const char * args);
+        bool HandleDebugArenaCommand(const char * args);
 
         Player*   getSelectedPlayer();
         Creature* getSelectedCreature();
diff --git a/src/game/ChatHandler.cpp b/src/game/ChatHandler.cpp
index a6e05aa..9bef693 100644
--- a/src/game/ChatHandler.cpp
+++ b/src/game/ChatHandler.cpp
@@ -18,6 +18,7 @@
 
 #include "Common.h"
 #include "Log.h"
+#include "ChatLog.h"
 #include "WorldPacket.h"
 #include "WorldSession.h"
 #include "World.h"
@@ -159,11 +160,23 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
                 break;
 
             if(type == CHAT_MSG_SAY)
+            {
+                sChatLog.ChatMsg(GetPlayer(), msg, type);
+
                 GetPlayer()->Say(msg, lang);
+            }
             else if(type == CHAT_MSG_EMOTE)
+            {
+                sChatLog.ChatMsg(GetPlayer(), msg, type);
+
                 GetPlayer()->TextEmote(msg);
+            }
             else if(type == CHAT_MSG_YELL)
+            {
+                sChatLog.ChatMsg(GetPlayer(), msg, type);
+
                 GetPlayer()->Yell(msg, lang);
+            }
         } break;
 
         case CHAT_MSG_WHISPER:
@@ -180,6 +193,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.WhisperMsg(GetPlayer(), to, msg);
+
             if(!normalizePlayerName(to))
             {
                 WorldPacket data(SMSG_CHAT_PLAYER_NOT_FOUND, (to.size()+1));
@@ -233,6 +248,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.PartyMsg(GetPlayer(), msg);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group)
                 return;
@@ -260,6 +277,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.GuildMsg(GetPlayer(), msg, false);
+
             if (GetPlayer()->GetGuildId())
             {
                 Guild *guild = objmgr.GetGuildById(GetPlayer()->GetGuildId());
@@ -287,6 +306,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.GuildMsg(GetPlayer(), msg, true);
+
             if (GetPlayer()->GetGuildId())
             {
                 Guild *guild = objmgr.GetGuildById(GetPlayer()->GetGuildId());
@@ -313,6 +334,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.RaidMsg(GetPlayer(), msg, type);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isRaidGroup())
                 return;
@@ -339,6 +362,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.RaidMsg(GetPlayer(), msg, type);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isRaidGroup() || !group->IsLeader(GetPlayer()->GetGUID()))
                 return;
@@ -359,6 +384,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.RaidMsg(GetPlayer(), msg, type);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isRaidGroup() || !(group->IsLeader(GetPlayer()->GetGUID()) || group->IsAssistant(GetPlayer()->GetGUID())))
                 return;
@@ -380,6 +407,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.BattleGroundMsg(GetPlayer(), msg, type);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isRaidGroup())
                 return;
@@ -401,6 +430,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.BattleGroundMsg(GetPlayer(), msg, type);
+
             Group *group = GetPlayer()->GetGroup();
             if(!group || !group->isRaidGroup() || !group->IsLeader(GetPlayer()->GetGUID()))
                 return;
@@ -427,6 +458,8 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if(msg.empty())
                 break;
 
+            sChatLog.ChannelMsg(GetPlayer(), channel, msg);
+
             if(ChannelMgr* cMgr = channelMgr(_player->GetTeam()))
             {
                 if(Channel *chn = cMgr->GetChannel(channel,_player))
diff --git a/src/game/ChatLexicsCutter.cpp b/src/game/ChatLexicsCutter.cpp
new file mode 100644
index 0000000..1c1d555
--- /dev/null
+++ b/src/game/ChatLexicsCutter.cpp
@@ -0,0 +1,274 @@
+/* 
+ * Copyright (C) 2005,2006,2007 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "Common.h"
+#include "ChatLexicsCutter.h"
+
+LexicsCutter::LexicsCutter()
+{
+    InvalidChars = "~`!@#$%^&*()-_+=[{]}|\\;:'\",<.>/?";
+}
+
+bool LexicsCutter::ReadUTF8(std::string& in, std::string& out, unsigned int& pos)
+{
+    if (pos >= in.length()) return false;
+    
+    out = "";
+    unsigned char c = in[pos++];
+    out += c;
+    int toread = trailingBytesForUTF8[(int) c];
+    while ((pos < in.length()) && (toread > 0))
+    {
+        out += in[pos++];
+        toread--;
+    }
+    
+    return true;
+}
+
+std::string LexicsCutter::trim(std::string& s, const std::string& drop)
+{
+    std::string r = s.erase(s.find_last_not_of(drop) + 1);
+    return r.erase(0, r.find_first_not_of(drop));
+}
+
+bool LexicsCutter::Read_Letter_Analogs(std::string& FileName)
+{
+    FILE *ma_file;
+    char line[1024];
+    unsigned int pos;
+    std::string line_s;
+    std::string lchar;
+    std::string lanalog;
+    
+    ma_file = fopen(FileName.c_str(), "rb");
+    
+    while (!feof(ma_file))
+    {
+        line[0] = 0x0;
+        fgets(line, 1020, ma_file);
+
+        // check for UTF8 prefix and comments
+        if (strlen(line) >= 3)
+        {
+            if (line[0] == '\xEF' && line[1] == '\xBB' && line[2] == '\xBF')
+            {
+                strncpy(&line[0], &line[3], strlen(line) - 3);
+            }
+        }
+
+        if (strlen(line) >= 2)
+        {
+            if (line[0] == '/' && line[1] == '/') continue;
+        }
+
+        // check for empty string
+        line_s = line; 
+        line_s = trim(line_s, "\x0A\x0D\x20");
+        if (line_s == "") continue;
+
+        // process line without CR/LF
+        line_s = line; 
+        line_s = trim(line_s, "\x0A\x0D");
+    
+        pos = 0;
+        if (ReadUTF8(line_s, lchar, pos))
+        {
+            // create analogs vector
+            LC_AnalogVector av;
+            while (ReadUTF8(line_s, lanalog, pos))
+            {
+                av.push_back(lanalog);
+            }
+        
+            // store vector in hash map
+            AnalogMap[lchar] = av;
+        }
+    }
+    
+    fclose(ma_file);
+    
+    return true;
+}
+
+bool LexicsCutter::Read_Innormative_Words(std::string& FileName)
+{
+    FILE *ma_file;
+    char line[1024];
+    unsigned int pos;
+    std::string line_s;
+    std::string lchar;
+    
+    ma_file = fopen(FileName.c_str(), "rb");
+    
+    while (!feof(ma_file))
+    {
+        line[0] = 0x0;
+        fgets(line, 1020, ma_file);
+
+        // check for UTF8 prefix and comment
+        if (strlen(line) >= 3)
+        {
+            if (line[0] == '\xEF' && line[1] == '\xBB' && line[2] == '\xBF')
+            {
+                strncpy(&line[0], &line[3], strlen(line) - 3);
+            }
+        }
+
+        if (strlen(line) >= 2)
+        {
+            if (line[0] == '/' && line[1] == '/') continue;
+        }
+
+        // check for empty string
+        line_s = line; 
+        line_s = trim(line_s, "\x0A\x0D\x20");
+        if (line_s == "") continue;
+
+        // process line without CR/LF
+        line_s = line; 
+        line_s = trim(line_s, "\x0A\x0D");
+    
+        // create word vector of vectors
+        LC_WordVector vw;
+        pos = 0;
+        while (ReadUTF8(line_s, lchar, pos))
+        {
+            // create letter set
+            LC_LetterSet vl;
+        
+            // initialize letter set with letter read
+            vl.insert(lchar);
+        
+            // find letter analogs and push them onto the vector
+            LC_AnalogMap::iterator itr = AnalogMap.find(lchar);
+            if (itr != AnalogMap.end())
+            {
+                // analogs present, iterate
+                for (LC_AnalogVector::iterator itr2 = itr->second.begin(); itr2 != itr->second.end(); itr2++)
+                {
+                    vl.insert(*itr2);
+                }
+            }
+        
+            // add letter vector to word vector
+            vw.push_back(vl);
+        }
+
+        // push new word to words list
+        WordList.push_back(vw);
+    }
+    
+    fclose(ma_file);
+    
+    return true;
+}
+
+void LexicsCutter::Map_Innormative_Words()
+{
+    // process all the words in the vector
+    for (unsigned int i = 0; i < WordList.size(); i++)
+    {
+        // parse all analogs in the first word letter
+        for (LC_LetterSet::iterator itr = (*WordList[i].begin()).begin(); itr != (*WordList[i].begin()).end(); itr++)
+        {
+            // map the word to its first letter variants
+            WordMap.insert(std::pair< std::string, unsigned int >(*itr, i));
+        }
+    }
+}
+
+bool LexicsCutter::Compare_Word(std::string& str, unsigned int pos, LC_WordVector word)
+{
+   std::string lchar_prev;
+    std::string lchar;
+
+   // read first letter of the word into lchar_prev
+   ReadUTF8(str, lchar, pos);    
+
+    // okay, here we go, comparing word
+    // first letter is already okay, we do begin from second and go on
+    LC_WordVector::iterator i = word.begin();
+    i++;
+    while (i != word.end())
+    {
+        // get letter from word, return false if the string is shorter
+        if (!ReadUTF8(str, lchar, pos)) return(false);
+        // check, if the letter is in the set
+        LC_LetterSet ls = *i;
+        if (ls.count(lchar) == 0)
+       {
+           // letter is not in set, but we must check, if it is not space or repeat
+           if ( (!(IgnoreMiddleSpaces && (lchar == " "))) &&
+               (!(IgnoreLetterRepeat && (lchar == lchar_prev))) )
+           {
+               // no checks viable
+               return(false);
+           }
+       }
+       else
+       {
+           // next word letter
+           i++;
+       }
+       // set previous string letter to compare if needed (this check can really conserve time)
+       if (IgnoreLetterRepeat) lchar_prev = lchar;
+   }
+    
+    return(true);
+}
+
+bool LexicsCutter::Check_Lexics(std::string& Phrase)
+{
+    std::string lchar;
+    LC_WordMap::iterator i;
+    std::pair< LC_WordMap::iterator, LC_WordMap::iterator > ii;
+
+    if (Phrase.size() == 0) return(false);
+    
+    // first, convert the string, adding spaces and removing invalid characters
+    // also create fast position vector for the new positions
+    std::string str = " ";
+    unsigned int pos = 0;
+    while (ReadUTF8(Phrase, lchar, pos))
+    {
+        if (InvalidChars.find(lchar) == std::string::npos)
+        {
+            str.append(lchar);
+        }
+    }
+    
+    // string prepared, now parse it and scan for all the words
+   unsigned int pos_prev = 0;
+    pos = 0;
+    while (ReadUTF8(str, lchar, pos))
+    {
+        // got character, now try to find wordmap for it
+        ii = WordMap.equal_range(lchar);
+        // iterate over all found words
+        for (i = ii.first; i != ii.second; i++)
+        {
+            // compare word at initial position
+            if (Compare_Word(str, pos_prev, WordList[i->second])) return(true);
+        }
+       // set initial position to the current position
+       pos_prev = pos;
+    }
+    
+    return(false);
+}
diff --git a/src/game/ChatLexicsCutter.h b/src/game/ChatLexicsCutter.h
new file mode 100644
index 0000000..38d636c
--- /dev/null
+++ b/src/game/ChatLexicsCutter.h
@@ -0,0 +1,67 @@
+/* 
+ * Copyright (C) 2005,2006,2007 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef MANGOSSERVER_CHATLEXICSCUTTER_H
+#define MANGOSSERVER_CHATLEXICSCUTTER_H
+
+typedef std::vector< std::string > LC_AnalogVector;
+typedef std::map< std::string, LC_AnalogVector > LC_AnalogMap;
+typedef std::set< std::string > LC_LetterSet;
+typedef std::vector< LC_LetterSet > LC_WordVector;
+typedef std::vector< LC_WordVector > LC_WordList;
+typedef std::multimap< std::string, unsigned int > LC_WordMap;
+
+static int trailingBytesForUTF8[256] = {
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5
+};
+
+class LexicsCutter
+{
+    protected:
+        LC_AnalogMap AnalogMap;
+        LC_WordList WordList;
+        LC_WordMap WordMap;
+
+        std::string InvalidChars;
+
+    public:
+        LexicsCutter();
+
+        static bool ReadUTF8(std::string& in, std::string& out, unsigned int& pos);
+
+        std::string trim(std::string& s, const std::string& drop = " ");
+        bool Read_Letter_Analogs(std::string& FileName);
+        bool Read_Innormative_Words(std::string& FileName);
+        void Map_Innormative_Words();
+        bool Compare_Word(std::string& str, unsigned int pos, LC_WordVector word);
+        bool Check_Lexics(std::string& Phrase);
+        
+        std::vector< std::pair< unsigned int, unsigned int > > Found;
+        bool IgnoreMiddleSpaces;
+        bool IgnoreLetterRepeat;
+};
+
+#endif
+
diff --git a/src/game/ChatLog.cpp b/src/game/ChatLog.cpp
new file mode 100644
index 0000000..ef5e203
--- /dev/null
+++ b/src/game/ChatLog.cpp
@@ -0,0 +1,855 @@
+/* 
+ * Copyright (C) 2005,2006,2007 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "Common.h"
+#include "ChatLexicsCutter.h"
+#include "ChatLog.h"
+#include "Chat.h"
+#include "Group.h"
+#include "Guild.h"
+#include "ObjectMgr.h"
+#include "SpellAuras.h"
+#include "Policies/SingletonImp.h"
+#include "Config/ConfigEnv.h"
+
+INSTANTIATE_SINGLETON_1( ChatLog );
+
+ChatLog::ChatLog()
+{
+    for (int i = 0; i <= CHATLOG_CHAT_TYPES_COUNT - 1; i++)
+    {
+        names[i] = "";
+        files[i] = NULL;
+    }
+    
+    Lexics = NULL;
+    fn_innormative = "";
+    f_innormative = NULL;
+    
+    Initialize();
+}
+
+ChatLog::~ChatLog()
+{
+    // close all files (avoiding double-close)
+    CloseAllFiles();
+
+    if (Lexics)
+    {
+        delete Lexics;
+        Lexics = NULL;
+    }
+}
+
+void ChatLog::Initialize()
+{
+    // determine, if the chat logs are enabled
+    ChatLogEnable = sConfig.GetBoolDefault("ChatLogEnable", false);
+    ChatLogDateSplit = sConfig.GetBoolDefault("ChatLogDateSplit", false);
+    ChatLogUTFHeader = sConfig.GetBoolDefault("ChatLogUTFHeader", false);
+    ChatLogIgnoreUnprintable = sConfig.GetBoolDefault("ChatLogIgnoreUnprintable", false);
+    
+    if (ChatLogEnable)
+    {
+        // read chat log file names
+        names[CHAT_LOG_CHAT] = sConfig.GetStringDefault("ChatLogChatFile", "");
+        names[CHAT_LOG_PARTY] = sConfig.GetStringDefault("ChatLogPartyFile", "");
+        names[CHAT_LOG_GUILD] = sConfig.GetStringDefault("ChatLogGuildFile", "");
+        names[CHAT_LOG_WHISPER] = sConfig.GetStringDefault("ChatLogWhisperFile", "");
+        names[CHAT_LOG_CHANNEL] = sConfig.GetStringDefault("ChatLogChannelFile", "");
+        names[CHAT_LOG_RAID] = sConfig.GetStringDefault("ChatLogRaidFile", "");
+        names[CHAT_LOG_BATTLEGROUND] = sConfig.GetStringDefault("ChatLogBattleGroundFile", "");
+
+        // read screen log flags
+        screenflag[CHAT_LOG_CHAT] = sConfig.GetBoolDefault("ChatLogChatScreen", false);
+        screenflag[CHAT_LOG_PARTY] = sConfig.GetBoolDefault("ChatLogPartyScreen", false);
+        screenflag[CHAT_LOG_GUILD] = sConfig.GetBoolDefault("ChatLogGuildScreen", false);
+        screenflag[CHAT_LOG_WHISPER] = sConfig.GetBoolDefault("ChatLogWhisperScreen", false);
+        screenflag[CHAT_LOG_CHANNEL] = sConfig.GetBoolDefault("ChatLogChannelScreen", false);
+        screenflag[CHAT_LOG_RAID] = sConfig.GetBoolDefault("ChatLogRaidScreen", false);
+        screenflag[CHAT_LOG_BATTLEGROUND] = sConfig.GetBoolDefault("ChatLogBattleGroundScreen", false);
+    }
+
+    // lexics cutter
+    LexicsCutterEnable = sConfig.GetBoolDefault("LexicsCutterEnable", false);
+
+    if (LexicsCutterEnable)
+    {
+        // initialize lexics cutter parameters
+        LexicsCutterInnormativeCut = sConfig.GetBoolDefault("LexicsCutterInnormativeCut", true);
+        LexicsCutterNoActionOnGM = sConfig.GetBoolDefault("LexicsCutterNoActionOnGM", true);
+        LexicsCutterScreenLog = sConfig.GetBoolDefault("LexicsCutterScreenLog", false);
+        LexicsCutterCutReplacement = sConfig.GetStringDefault("LexicsCutterCutReplacement", "&!@^%!^&*!!! [gibberish]");
+        LexicsCutterAction = sConfig.GetIntDefault("LexicsCutterAction", 0);
+        LexicsCutterActionDuration = sConfig.GetIntDefault("LexicsCutterActionDuration", 60000);
+        std::string fn_analogsfile = sConfig.GetStringDefault("LexicsCutterAnalogsFile", "");
+        std::string fn_wordsfile = sConfig.GetStringDefault("LexicsCutterWordsFile", "");
+
+        // read lexics cutter flags
+        cutflag[CHAT_LOG_CHAT] = sConfig.GetBoolDefault("LexicsCutInChat", true);
+        cutflag[CHAT_LOG_PARTY] = sConfig.GetBoolDefault("LexicsCutInParty", true);
+        cutflag[CHAT_LOG_GUILD] = sConfig.GetBoolDefault("LexicsCutInGuild", true);
+        cutflag[CHAT_LOG_WHISPER] = sConfig.GetBoolDefault("LexicsCutInWhisper", true);
+        cutflag[CHAT_LOG_CHANNEL] = sConfig.GetBoolDefault("LexicsCutInChannel", true);
+        cutflag[CHAT_LOG_RAID] = sConfig.GetBoolDefault("LexicsCutInRaid", true);
+        cutflag[CHAT_LOG_BATTLEGROUND] = sConfig.GetBoolDefault("LexicsCutInBattleGround", true);
+
+        if (fn_analogsfile == "" || fn_wordsfile == "")
+        {
+            LexicsCutterEnable = false;
+        }
+        else
+        {
+            // initialize lexics cutter
+            Lexics = new LexicsCutter;
+            if (Lexics) Lexics->Read_Letter_Analogs(fn_analogsfile);
+            if (Lexics) Lexics->Read_Innormative_Words(fn_wordsfile);
+            if (Lexics) Lexics->Map_Innormative_Words();
+
+            // read additional parameters
+            Lexics->IgnoreLetterRepeat = sConfig.GetBoolDefault("LexicsCutterIgnoreRepeats", true);
+            Lexics->IgnoreMiddleSpaces = sConfig.GetBoolDefault("LexicsCutterIgnoreSpaces", true);
+            fn_innormative = sConfig.GetStringDefault("LexicsCutterLogFile", "");
+        }
+    }
+
+    // open all files (with aliasing)
+    OpenAllFiles();
+
+    // write timestamps (init)
+    WriteInitStamps();
+}
+
+bool ChatLog::_ChatCommon(int ChatType, Player *player, std::string &msg)
+{
+    if (LexicsCutterEnable && Lexics && cutflag[ChatType] && Lexics->Check_Lexics(msg)) ChatBadLexicsAction(player, msg);
+
+    if (!ChatLogEnable) return(false);
+
+    if (ChatLogIgnoreUnprintable)
+    {
+        // have to ignore unprintables, verify string by UTF8 here
+        unsigned int pos = 0;
+        std::string lchar;
+        while (LexicsCutter::ReadUTF8(msg, lchar, pos))
+        {
+            if (lchar.size() == 1)
+            {
+                if (lchar[0] < ' ') return(false); // unprintable detected
+            }
+        }
+    }
+
+    return(true);
+}
+        
+void ChatLog::ChatMsg(Player *player, std::string &msg, uint32 type)
+{
+    if (!_ChatCommon(CHAT_LOG_CHAT, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    switch (type)
+    {
+        case CHAT_MSG_EMOTE:
+        log_str.append("{EMOTE} ");
+        break;
+
+        case CHAT_MSG_YELL:
+        log_str.append("{YELL} ");
+        break;
+    }
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("] ");
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_CHAT]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_CHAT])
+    {
+        OutTimestamp(files[CHAT_LOG_CHAT]);
+        fprintf(files[CHAT_LOG_CHAT], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_CHAT]);
+    }
+}
+
+void ChatLog::PartyMsg(Player *player, std::string &msg)
+{
+    if (!_ChatCommon(CHAT_LOG_PARTY, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("]->GROUP:");
+    
+    Group *group = player->GetGroup();
+    if (!group)
+    {
+        log_str.append("[unknown group] ");
+    }
+    else
+    {
+        // obtain group information
+        log_str.append("[");
+
+        uint8 gm_count = group->GetMembersCount();
+        uint8 gm_count_m1 = gm_count - 1;
+        uint64 gm_leader_GUID = group->GetLeaderGUID();
+        Player *gm_member;
+
+        gm_member = objmgr.GetPlayer(gm_leader_GUID);
+        if (gm_member)
+        {
+            log_str.append(gm_member->GetName());
+            log_str.append(",");
+        }
+
+        Group::MemberSlotList g_members = group->GetMemberSlots();
+        
+        for (Group::member_citerator itr = g_members.begin(); itr != g_members.end(); itr++)
+        {
+            if (itr->guid == gm_leader_GUID) continue;
+
+            gm_member = objmgr.GetPlayer(itr->guid);
+            if (gm_member)
+            {
+                log_str.append(itr->name);
+                log_str.append(",");
+            }
+        }
+
+        log_str.erase(log_str.length() - 1);
+        log_str.append("] ");
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+    
+    if (screenflag[CHAT_LOG_PARTY]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_PARTY])
+    {
+        OutTimestamp(files[CHAT_LOG_PARTY]);
+        fprintf(files[CHAT_LOG_PARTY], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_PARTY]);
+    }
+}
+
+void ChatLog::GuildMsg(Player *player, std::string &msg, bool officer)
+{
+    if (!_ChatCommon(CHAT_LOG_GUILD, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append((officer ? "]->GUILD_OFF:" : "]->GUILD:"));
+    
+    if (!player->GetGuildId())
+    {
+        log_str.append("[unknown guild] ");
+    }
+    else
+    {
+        Guild *guild = objmgr.GetGuildById(player->GetGuildId());
+        if (!guild)
+        {
+            log_str.append("[unknown guild] ");
+        }
+        else
+        {
+            // obtain guild information
+            log_str.append("(");
+            log_str.append(guild->GetName());
+            log_str.append(") ");
+        }
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+    
+    if (screenflag[CHAT_LOG_GUILD]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_GUILD])
+    {
+        OutTimestamp(files[CHAT_LOG_GUILD]);
+        fprintf(files[CHAT_LOG_GUILD], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_GUILD]);
+    }
+}
+
+void ChatLog::WhisperMsg(Player *player, std::string &to, std::string &msg)
+{
+    if (!_ChatCommon(CHAT_LOG_WHISPER, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("]->");
+    
+    if (to.size() == 0)
+    {
+        log_str.append("[???] ");
+    }
+    else
+    {
+        normalizePlayerName(to);
+        log_str.append("[");
+        log_str.append(to);
+        log_str.append("] ");
+    }
+    
+    log_str.append(msg);
+
+    log_str.append("\n");
+    
+    if (screenflag[CHAT_LOG_WHISPER]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_WHISPER])
+    {
+        OutTimestamp(files[CHAT_LOG_WHISPER]);
+        fprintf(files[CHAT_LOG_WHISPER], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_WHISPER]);
+    }
+}
+
+void ChatLog::ChannelMsg(Player *player, std::string &channel, std::string &msg)
+{
+    if (!_ChatCommon(CHAT_LOG_CHANNEL, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("]->CHANNEL:");
+    
+    if (channel.size() == 0)
+    {
+        log_str.append("[unknown channel] ");
+    }
+    else
+    {
+        log_str.append("[");
+        log_str.append(channel);
+        log_str.append("] ");
+    }
+    
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_CHANNEL]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_CHANNEL])
+    {
+        OutTimestamp(files[CHAT_LOG_CHANNEL]);
+        fprintf(files[CHAT_LOG_CHANNEL], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_CHANNEL]);
+    }
+}
+
+void ChatLog::RaidMsg(Player *player, std::string &msg, uint32 type)
+{
+    if (!_ChatCommon(CHAT_LOG_RAID, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+
+    switch (type)
+    {
+        case CHAT_MSG_RAID:
+        log_str.append("]->RAID:");
+        break;
+
+        case CHAT_MSG_RAID_LEADER:
+        log_str.append("]->RAID_LEADER:");
+        break;
+
+        case CHAT_MSG_RAID_WARNING:
+        log_str.append("]->RAID_WARN:");
+        break;
+
+        default:
+        log_str.append("]->RAID_UNKNOWN:");
+    }
+    
+    Group *group = player->GetGroup();
+    if (!group)
+    {
+        log_str.append("[unknown raid] ");
+    }
+    else
+    {
+        // obtain group information
+        log_str.append("[");
+
+        uint8 gm_count = group->GetMembersCount();
+        uint8 gm_count_m1 = gm_count - 1;
+        uint64 gm_leader_GUID = group->GetLeaderGUID();
+        Player *gm_member;
+
+        gm_member = objmgr.GetPlayer(gm_leader_GUID);
+        if (gm_member)
+        {
+            log_str.append(gm_member->GetName());
+            log_str.append(",");
+        }
+
+        Group::MemberSlotList g_members = group->GetMemberSlots();
+    
+        for (Group::member_citerator itr = g_members.begin(); itr != g_members.end(); itr++)
+        {
+            if (itr->guid == gm_leader_GUID) continue;
+
+            gm_member = objmgr.GetPlayer(itr->guid);
+            if (gm_member)
+            {
+                log_str.append(itr->name);
+                log_str.append(",");
+            }
+        }
+    
+        log_str.erase(log_str.length() - 1);
+        log_str.append("] ");
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_RAID]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_RAID])
+    {
+        OutTimestamp(files[CHAT_LOG_RAID]);
+        fprintf(files[CHAT_LOG_RAID], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_RAID]);
+    }
+}
+
+void ChatLog::BattleGroundMsg(Player *player, std::string &msg, uint32 type)
+{
+    if (!_ChatCommon(CHAT_LOG_BATTLEGROUND, player, msg)) return;
+
+    CheckDateSwitch();
+
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+
+    switch (type)
+    {
+        case CHAT_MSG_BATTLEGROUND:
+        log_str.append("]->BG:");
+        break;
+
+        case CHAT_MSG_BATTLEGROUND_LEADER:
+        log_str.append("]->BG_LEADER:");
+        break;
+
+        default:
+        log_str.append("]->BG_UNKNOWN:");
+    }
+    
+    Group *group = player->GetGroup();
+    if (!group)
+    {
+        log_str.append("[unknown group] ");
+    }
+    else
+    {
+        // obtain group information
+        log_str.append("[");
+
+        uint8 gm_count = group->GetMembersCount();
+        uint8 gm_count_m1 = gm_count - 1;
+        uint64 gm_leader_GUID = group->GetLeaderGUID();
+        Player *gm_member;
+
+        gm_member = objmgr.GetPlayer(gm_leader_GUID);
+        if (gm_member)
+        {
+            log_str.append(gm_member->GetName());
+            log_str.append(",");
+        }
+
+        Group::MemberSlotList g_members = group->GetMemberSlots();
+    
+        for (Group::member_citerator itr = g_members.begin(); itr != g_members.end(); itr++)
+        {
+            if (itr->guid == gm_leader_GUID) continue;
+
+            gm_member = objmgr.GetPlayer(itr->guid);
+            if (gm_member)
+            {
+                log_str.append(itr->name);
+                log_str.append(",");
+            }
+        }
+    
+        log_str.erase(log_str.length() - 1);
+        log_str.append("] ");
+    }
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (screenflag[CHAT_LOG_BATTLEGROUND]) printf("%s", log_str.c_str());
+    if (files[CHAT_LOG_BATTLEGROUND])
+    {
+        OutTimestamp(files[CHAT_LOG_BATTLEGROUND]);
+        fprintf(files[CHAT_LOG_BATTLEGROUND], "%s", log_str.c_str());
+        fflush(files[CHAT_LOG_BATTLEGROUND]);
+    }
+}
+
+void ChatLog::OpenAllFiles()
+{
+    std::string tempname;
+    char dstr[12];
+
+    if (ChatLogDateSplit)
+    {
+        time_t t = time(NULL);
+        tm* aTm = localtime(&t);
+        sprintf(dstr, "%-4d-%02d-%02d", aTm->tm_year + 1900, aTm->tm_mon + 1, aTm->tm_mday);
+    }
+
+    if (ChatLogEnable)
+    {
+        for (int i = 0; i <= CHATLOG_CHAT_TYPES_COUNT - 1; i++)
+        {
+            if (names[i] != "")
+            {
+                for (int j = i - 1; j >= 0; j--)
+                {
+                    if (names[i] == names[j])
+                    {
+                        files[i] = files[j];
+                        break;
+                    }
+                }
+                if (!files[i])
+                {
+                    tempname = names[i];
+                    if (ChatLogDateSplit)
+                    {
+                        // append date instead of $d if applicable
+                        int dpos = tempname.find("$d");
+                        if (dpos != tempname.npos)
+                        {
+                            tempname.replace(dpos, 2, &dstr[0], 10);
+                        }
+                    }
+                    files[i] = fopen(tempname.c_str(), "a+b");
+                    if (ChatLogUTFHeader && (ftell(files[i]) == 0)) fputs("\xEF\xBB\xBF", files[i]);
+                }
+            }
+        }
+    }
+
+    // initialize innormative log
+    if (LexicsCutterEnable)
+    {
+        if (fn_innormative != "")
+        {
+            tempname = fn_innormative;
+            if (ChatLogDateSplit)
+            {
+                // append date instead of $d if applicable
+                int dpos = tempname.find("$d");
+                if (dpos != tempname.npos)
+                {
+                    tempname.replace(dpos, 2, &dstr[0], 10);
+                }
+            }
+            f_innormative = fopen(tempname.c_str(), "a+b");
+            if (ChatLogUTFHeader && (ftell(f_innormative) == 0)) fputs("\xEF\xBB\xBF", f_innormative);
+        }
+    }
+}
+
+void ChatLog::CloseAllFiles()
+{
+    for (int i = 0; i <= CHATLOG_CHAT_TYPES_COUNT - 1; i++)
+    {
+        if (files[i])
+        {
+            for (int j = i + 1; j <= CHATLOG_CHAT_TYPES_COUNT - 1; j++)
+            {
+                if (files[j] == files[i]) files[j] = NULL;
+            }
+        
+            fclose(files[i]);
+            files[i] = NULL;
+        }
+    }
+
+    if (f_innormative)
+    {
+        fclose(f_innormative);
+        f_innormative = NULL;
+    }
+}
+
+void ChatLog::CheckDateSwitch()
+{
+    if (ChatLogDateSplit)
+    {
+        time_t t = time(NULL);
+        tm* aTm = localtime(&t);
+        if (lastday != aTm->tm_mday)
+        {
+            // date switched
+            CloseAllFiles();
+            OpenAllFiles();
+            WriteInitStamps();
+        }
+    }
+}
+
+void ChatLog::WriteInitStamps()
+{
+    // remember date
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    lastday = aTm->tm_mday;
+
+    if (files[CHAT_LOG_CHAT])
+    {
+        OutTimestamp(files[CHAT_LOG_CHAT]);
+        fprintf(files[CHAT_LOG_CHAT], "%s", "[SYSTEM] Chat Log Initialized\n");
+    }
+    if (files[CHAT_LOG_PARTY])
+    {
+        OutTimestamp(files[CHAT_LOG_PARTY]);
+        fprintf(files[CHAT_LOG_PARTY], "%s", "[SYSTEM] Party Chat Log Initialized\n");
+    }
+    if (files[CHAT_LOG_GUILD])
+    {
+        OutTimestamp(files[CHAT_LOG_GUILD]);
+        fprintf(files[CHAT_LOG_GUILD], "%s", "[SYSTEM] Guild Chat Log Initialized\n");
+    }
+    if (files[CHAT_LOG_WHISPER])
+    {
+        OutTimestamp(files[CHAT_LOG_WHISPER]);
+        fprintf(files[CHAT_LOG_WHISPER], "%s", "[SYSTEM] Whisper Log Initialized\n");
+    }
+    if (files[CHAT_LOG_CHANNEL])
+    {
+        OutTimestamp(files[CHAT_LOG_CHANNEL]);
+        fprintf(files[CHAT_LOG_CHANNEL], "%s", "[SYSTEM] Chat Channels Log Initialized\n");
+    }
+    if (files[CHAT_LOG_RAID])
+    {
+        OutTimestamp(files[CHAT_LOG_RAID]);
+        fprintf(files[CHAT_LOG_RAID], "%s", "[SYSTEM] Raid Party Chat Log Initialized\n");
+    }
+
+    if (f_innormative)
+    {
+        OutTimestamp(f_innormative);
+        fprintf(f_innormative, "%s", "[SYSTEM] Innormative Lexics Log Initialized\n");
+    }
+}
+
+void ChatLog::OutTimestamp(FILE* file)
+{
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    fprintf(file, "%-4d-%02d-%02d %02d:%02d:%02d ", aTm->tm_year + 1900, aTm->tm_mon + 1, aTm->tm_mday, aTm->tm_hour, aTm->tm_min, aTm->tm_sec);
+}
+
+void ChatLog::ChatBadLexicsAction(Player* player, std::string& msg)
+{
+    // logging
+    std::string log_str = "";
+
+    log_str.append("[");
+    log_str.append(player->GetName());
+    log_str.append("] ");
+
+    log_str.append(msg);
+
+    log_str.append("\n");
+
+    if (LexicsCutterScreenLog) printf("<INNORMATIVE!> %s", log_str.c_str());
+    if (f_innormative)
+    {
+        OutTimestamp(f_innormative);
+        fprintf(f_innormative, "%s", log_str.c_str());
+        fflush(f_innormative);
+    }
+
+    // cutting innormative lexics
+    if (LexicsCutterInnormativeCut)
+    {
+        msg = LexicsCutterCutReplacement;
+    }
+
+    if (!player || !player->GetSession()) return;
+
+    if (LexicsCutterNoActionOnGM && player->GetSession()->GetSecurity()) return;
+
+    // special action
+    const SpellEntry* sl;
+
+    switch (LexicsCutterAction)
+    {
+        case LEXICS_ACTION_SHEEP:
+        {
+            // sheep me, yeah, yeah, sheep me
+            sl = sSpellStore.LookupEntry(118);
+            if (sl)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    Aura* Aur = CreateAura(sl, i, NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        case LEXICS_ACTION_STUN:
+        {
+            // stunned surprised
+            sl = sSpellStore.LookupEntry(13005);
+            if (sl)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    Aura* Aur = CreateAura(sl, i, NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        case LEXICS_ACTION_DIE:
+        {
+            // oops, kicked the bucket
+            player->DealDamage(player, player->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }
+        break;
+
+        case LEXICS_ACTION_DRAIN:
+        {
+            // living corpse :)
+            player->DealDamage(player, player->GetHealth() - 5, NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }
+        break;
+
+
+        case LEXICS_ACTION_SILENCE:
+        {
+            // glue the mouth
+            time_t mutetime = time(NULL) + (int) (LexicsCutterActionDuration / 1000);
+            player->GetSession()->m_muteTime = mutetime;
+        }
+        break;
+
+        case LEXICS_ACTION_STUCK:
+        {
+            // yo, the Matrix has had you :) [by KAPATEJIb]
+            sl = sSpellStore.LookupEntry(23312);
+            if (sl)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    Aura* Aur = CreateAura(sl, i, NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        case LEXICS_ACTION_SICKNESS:
+        {
+            // for absence of censorship, there is punishment [by Koshei]
+            sl = sSpellStore.LookupEntry(15007);
+            if (sl)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    Aura* Aur = CreateAura(sl, i, NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        case LEXICS_ACTION_SHEAR:
+        {
+            // Lord Illidan to watch you [by Koshei]
+            sl = sSpellStore.LookupEntry(41032);
+            if (sl)
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    Aura* Aur = CreateAura(sl, i, NULL, player);
+                    if (Aur)
+                    {
+                        Aur->SetAuraDuration(LexicsCutterActionDuration);
+                        player->AddAura(Aur);
+                    }
+                }
+            }
+        }
+        break;
+
+        default:
+        // no action except logging
+        break;
+    }
+}
diff --git a/src/game/ChatLog.h b/src/game/ChatLog.h
new file mode 100644
index 0000000..7460b92
--- /dev/null
+++ b/src/game/ChatLog.h
@@ -0,0 +1,107 @@
+/* 
+ * Copyright (C) 2005,2006,2007 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef MANGOSSERVER_CHATLOG_H
+#define MANGOSSERVER_CHATLOG_H
+
+#include "SharedDefines.h"
+#include "ChatLexicsCutter.h"
+#include "ObjectMgr.h"
+#include "Policies/Singleton.h"
+
+#define CHATLOG_CHAT_TYPES_COUNT 7
+
+enum ChatLogFiles
+{
+    CHAT_LOG_CHAT = 0,
+    CHAT_LOG_PARTY = 1,
+    CHAT_LOG_GUILD = 2,
+    CHAT_LOG_WHISPER = 3,
+    CHAT_LOG_CHANNEL = 4,
+    CHAT_LOG_RAID = 5,
+    CHAT_LOG_BATTLEGROUND = 6,
+};
+
+enum LexicsActions
+{
+    LEXICS_ACTION_LOG = 0,
+    LEXICS_ACTION_SHEEP = 1,
+    LEXICS_ACTION_STUN = 2,
+    LEXICS_ACTION_DIE = 3,
+    LEXICS_ACTION_DRAIN = 4,
+    LEXICS_ACTION_SILENCE = 5,
+    LEXICS_ACTION_STUCK = 6,
+    LEXICS_ACTION_SICKNESS = 7,
+    LEXICS_ACTION_SHEAR = 8,
+};
+
+class ChatLog : public MaNGOS::Singleton<ChatLog, MaNGOS::ClassLevelLockable<ChatLog, ZThread::FastMutex> >
+{
+    public:
+        ChatLog();
+        ~ChatLog();
+
+        void Initialize();
+        
+        void ChatMsg(Player *player, std::string &msg, uint32 type);
+        void PartyMsg(Player *player, std::string &msg);
+        void GuildMsg(Player *player, std::string &msg, bool officer);
+        void WhisperMsg(Player *player, std::string &to, std::string &msg);
+        void ChannelMsg(Player *player, std::string &channel, std::string &msg);
+        void RaidMsg(Player *player, std::string &msg, uint32 type);
+        void BattleGroundMsg(Player *player, std::string &msg, uint32 type);
+        
+        void ChatBadLexicsAction(Player *player, std::string &msg);
+        
+    private:
+        bool _ChatCommon(int ChatType, Player *player, std::string &msg);
+
+        bool ChatLogEnable;
+        bool ChatLogDateSplit;
+        bool ChatLogUTFHeader;
+        bool ChatLogIgnoreUnprintable;
+
+        int lastday;
+   
+        FILE* files[CHATLOG_CHAT_TYPES_COUNT];
+        std::string names[CHATLOG_CHAT_TYPES_COUNT];
+        bool screenflag[CHATLOG_CHAT_TYPES_COUNT];
+   
+        LexicsCutter* Lexics;
+        bool cutflag[CHATLOG_CHAT_TYPES_COUNT];
+
+        bool LexicsCutterEnable;
+        bool LexicsCutterInnormativeCut;
+        bool LexicsCutterNoActionOnGM;
+        bool LexicsCutterScreenLog;
+        std::string LexicsCutterCutReplacement;
+        int LexicsCutterAction;
+        int LexicsCutterActionDuration;
+        std::string fn_innormative;
+        FILE* f_innormative;
+
+        void OpenAllFiles();
+        void CloseAllFiles();
+        void CheckDateSwitch();
+
+        void WriteInitStamps();
+        void OutTimestamp(FILE *file);
+};
+
+#define sChatLog MaNGOS::Singleton<ChatLog>::Instance()
+#endif
diff --git a/src/game/Creature.cpp b/src/game/Creature.cpp
index 34f7b1e..0a47cd9 100644
--- a/src/game/Creature.cpp
+++ b/src/game/Creature.cpp
@@ -42,6 +42,7 @@
 #include "GridNotifiers.h"
 #include "GridNotifiersImpl.h"
 #include "CellImpl.h"
+#include "OutdoorPvPMgr.h"
 
 // apply implementation of the singletons
 #include "Policies/SingletonImp.h"
@@ -740,6 +741,10 @@ void Creature::prepareGossipMenu( Player *pPlayer,uint32 gossipid )
                     case GOSSIP_OPTION_TABARDDESIGNER:
                     case GOSSIP_OPTION_AUCTIONEER:
                         break;                              // no checks
+                    case GOSSIP_OPTION_OUTDOORPVP:
+                        if ( !sOutdoorPvPMgr.CanTalkTo(pPlayer,this,(*gso)) )
+                            cantalking = false;
+                        break;
                     default:
                         sLog.outErrorDb("Creature %u (entry: %u) have unknown gossip option %u",GetGUIDLow(),GetEntry(),gso->Action);
                         break;
@@ -816,6 +821,9 @@ void Creature::OnGossipSelect(Player* player, uint32 option)
             player->PlayerTalkClass->CloseGossip();
             player->PlayerTalkClass->SendTalking( textid );
             break;
+        case GOSSIP_OPTION_OUTDOORPVP:
+            sOutdoorPvPMgr.HandleGossipOption(player, GetGUID(), gossip->GossipId);
+            break;
         case GOSSIP_OPTION_SPIRITHEALER:
             if( player->isDead() )
                 CastSpell(this,17251,true,NULL,NULL,player->GetGUID());
diff --git a/src/game/Creature.h b/src/game/Creature.h
index 5d0ff9c..56a8509 100644
--- a/src/game/Creature.h
+++ b/src/game/Creature.h
@@ -53,7 +53,8 @@ enum Gossip_Option
     GOSSIP_OPTION_STABLEPET         = 14,                   //UNIT_NPC_FLAG_STABLE            = 8192,
     GOSSIP_OPTION_ARMORER           = 15,                   //UNIT_NPC_FLAG_ARMORER           = 16384,
     GOSSIP_OPTION_UNLEARNTALENTS    = 16,                   //UNIT_NPC_FLAG_TRAINER (bonus option for GOSSIP_OPTION_TRAINER)
-    GOSSIP_OPTION_UNLEARNPETSKILLS  = 17                    //UNIT_NPC_FLAG_TRAINER (bonus option for GOSSIP_OPTION_TRAINER)
+    GOSSIP_OPTION_UNLEARNPETSKILLS  = 17,                   //UNIT_NPC_FLAG_TRAINER (bonus option for GOSSIP_OPTION_TRAINER)
+    GOSSIP_OPTION_OUTDOORPVP        = 18                    //UNIT_NPC_FLAG_OUTDOORPVP (option for outdoor pvp creatures)
 };
 
 enum Gossip_Guard
diff --git a/src/game/CreatureAIRegistry.cpp b/src/game/CreatureAIRegistry.cpp
index b76a721..ca2ddfc 100644
--- a/src/game/CreatureAIRegistry.cpp
+++ b/src/game/CreatureAIRegistry.cpp
@@ -23,6 +23,7 @@
 #include "GuardAI.h"
 #include "PetAI.h"
 #include "TotemAI.h"
+#include "OutdoorPvPObjectiveAI.h"
 #include "RandomMovementGenerator.h"
 #include "CreatureAIImpl.h"
 #include "MovementGeneratorImpl.h"
@@ -40,6 +41,7 @@ namespace AIRegistry
         (new CreatureAIFactory<GuardAI>("GuardAI"))->RegisterSelf();
         (new CreatureAIFactory<PetAI>("PetAI"))->RegisterSelf();
         (new CreatureAIFactory<TotemAI>("TotemAI"))->RegisterSelf();
+        (new CreatureAIFactory<OutdoorPvPObjectiveAI>("OutdoorPvPObjectiveAI"))->RegisterSelf();
 
         (new MovementGeneratorFactory<RandomMovementGenerator<Creature> >(RANDOM_MOTION_TYPE))->RegisterSelf();
         (new MovementGeneratorFactory<WaypointMovementGenerator<Creature> >(WAYPOINT_MOTION_TYPE))->RegisterSelf();
diff --git a/src/game/GameObject.cpp b/src/game/GameObject.cpp
index dc2aee4..aaa5e5a 100644
--- a/src/game/GameObject.cpp
+++ b/src/game/GameObject.cpp
@@ -35,7 +35,9 @@
 #include "CellImpl.h"
 #include "InstanceData.h"
 #include "BattleGround.h"
+#include "BattleGroundAV.h"
 #include "Util.h"
+#include "OutdoorPvPMgr.h"
 
 GameObject::GameObject() : WorldObject()
 {
@@ -89,7 +91,7 @@ void GameObject::RemoveFromWorld()
     Object::RemoveFromWorld();
 }
 
-bool GameObject::Create(uint32 guidlow, uint32 name_id, Map *map, float x, float y, float z, float ang, float rotation0, float rotation1, float rotation2, float rotation3, uint32 animprogress, uint32 go_state)
+bool GameObject::Create(uint32 guidlow, uint32 name_id, Map *map, float x, float y, float z, float ang, float rotation0, float rotation1, float rotation2, float rotation3, uint32 animprogress, uint32 go_state, uint32 ArtKit)
 {
     Relocate(x,y,z,ang);
     SetMapId(map->GetId());
@@ -142,6 +144,8 @@ bool GameObject::Create(uint32 guidlow, uint32 name_id, Map *map, float x, float
 
     SetGoAnimProgress(animprogress);
 
+    SetUInt32Value (GAMEOBJECT_ARTKIT, ArtKit);
+
     // Spell charges for GAMEOBJECT_TYPE_SPELLCASTER (22)
     if (goinfo->type == GAMEOBJECT_TYPE_SPELLCASTER)
         m_charges = goinfo->spellcaster.charges;
@@ -518,6 +522,7 @@ void GameObject::SaveToDB(uint32 mapid, uint8 spawnMask)
     data.animprogress = GetGoAnimProgress();
     data.go_state = GetGoState();
     data.spawnMask = spawnMask;
+    data.ArtKit = GetUInt32Value (GAMEOBJECT_ARTKIT);
 
     // updated in DB
     std::ostringstream ss;
@@ -568,11 +573,12 @@ bool GameObject::LoadFromDB(uint32 guid, Map *map)
 
     uint32 animprogress = data->animprogress;
     uint32 go_state = data->go_state;
+    uint32 ArtKit = data->ArtKit;
 
     m_DBTableGuid = guid;
     if (map->GetInstanceId() != 0) guid = objmgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT);
 
-    if (!Create(guid,entry, map, x, y, z, ang, rotation0, rotation1, rotation2, rotation3, animprogress, go_state) )
+    if (!Create(guid,entry, map, x, y, z, ang, rotation0, rotation1, rotation2, rotation3, animprogress, go_state, ArtKit) )
         return false;
 
     switch(GetGOInfo()->type)
@@ -746,7 +752,14 @@ bool GameObject::ActivateToQuest( Player *pTarget)const
         case GAMEOBJECT_TYPE_CHEST:
         {
             if(LootTemplates_Gameobject.HaveQuestLootForPlayer(GetLootId(), pTarget))
+            {
+                //look for battlegroundAV for some objects which are only activated after mine gots captured by own team
+                if(GetEntry() == BG_AV_OBJECTID_MINE_N || GetEntry() == BG_AV_OBJECTID_MINE_S)
+                    if(BattleGround *bg = pTarget->GetBattleGround())
+                        if(bg->GetTypeID() == BATTLEGROUND_AV && !(((BattleGroundAV*)bg)->PlayerCanDoMineQuest(GetEntry(),pTarget->GetTeam())))
+                            return false;
                 return true;
+            }
             break;
         }
         case GAMEOBJECT_TYPE_GOOBER:
@@ -829,6 +842,14 @@ void GameObject::UseDoorOrButton(uint32 time_to_restore)
 
 }
 
+void GameObject::SetGoArtKit(uint32 kit)
+{
+    SetUInt32Value(GAMEOBJECT_ARTKIT, kit);
+    GameObjectData *data = const_cast<GameObjectData*>(objmgr.GetGOData(m_DBTableGuid));
+    if(data)
+        data->ArtKit = kit;
+}
+
 void GameObject::SwitchDoorOrButton(bool activate)
 {
     if(activate)
@@ -1233,7 +1254,10 @@ void GameObject::Use(Unit* user)
     SpellEntry const *spellInfo = sSpellStore.LookupEntry( spellId );
     if(!spellInfo)
     {
-        sLog.outError("WORLD: unknown spell id %u at use action for gameobject (Entry: %u GoType: %u )", spellId,GetEntry(),GetGoType());
+        if(user->GetTypeId()!=TYPEID_PLAYER || !sOutdoorPvPMgr.HandleCustomSpell((Player*)user,spellId,this))
+            sLog.outError("WORLD: unknown spell id %u at use action for gameobject (Entry: %u GoType: %u )", spellId,GetEntry(),GetGoType());
+        else
+            sLog.outDebug("WORLD: %u non-dbc spell was handled by OutdoorPvP", spellId);
         return;
     }
 
diff --git a/src/game/GameObject.h b/src/game/GameObject.h
index 1fab149..d9bc54c 100644
--- a/src/game/GameObject.h
+++ b/src/game/GameObject.h
@@ -381,6 +381,7 @@ struct GameObjectData
     uint32 animprogress;
     uint32 go_state;
     uint8 spawnMask;
+    uint32 ArtKit;
 };
 
 // GCC have alternative #pragma pack() syntax and old gcc version not support pack(pop), also any gcc version not support it at some platform
@@ -416,7 +417,7 @@ class MANGOS_DLL_SPEC GameObject : public WorldObject
         void AddToWorld();
         void RemoveFromWorld();
 
-        bool Create(uint32 guidlow, uint32 name_id, Map *map, float x, float y, float z, float ang, float rotation0, float rotation1, float rotation2, float rotation3, uint32 animprogress, uint32 go_state);
+        bool Create(uint32 guidlow, uint32 name_id, Map *map, float x, float y, float z, float ang, float rotation0, float rotation1, float rotation2, float rotation3, uint32 animprogress, uint32 go_state, uint32 ArtKit = 0);
         void Update(uint32 p_time);
         static GameObject* GetGameObject(WorldObject& object, uint64 guid);
         GameObjectInfo const* GetGOInfo() const;
@@ -502,7 +503,7 @@ class MANGOS_DLL_SPEC GameObject : public WorldObject
         uint32 GetGoState() const { return GetUInt32Value(GAMEOBJECT_STATE); }
         void SetGoState(uint32 state) { SetUInt32Value(GAMEOBJECT_STATE, state); }
         uint32 GetGoArtKit() const { return GetUInt32Value(GAMEOBJECT_ARTKIT); }
-        void SetGoArtKit(uint32 artkit) { SetUInt32Value(GAMEOBJECT_ARTKIT, artkit); }
+        void SetGoArtKit(uint32 artkit);
         uint32 GetGoAnimProgress() const { return GetUInt32Value(GAMEOBJECT_ANIMPROGRESS); }
         void SetGoAnimProgress(uint32 animprogress) { SetUInt32Value(GAMEOBJECT_ANIMPROGRESS, animprogress); }
 
diff --git a/src/game/Group.cpp b/src/game/Group.cpp
index eade641..a7ce796 100644
--- a/src/game/Group.cpp
+++ b/src/game/Group.cpp
@@ -1249,6 +1249,54 @@ void Group::UpdateLooterGuid( Creature* creature, bool ifneed )
     SendUpdate();
 }
 
+uint32 Group::CanJoinBattleGroundQueue(uint32 bgTypeId, uint32 bgQueueType, uint32 MinPlayerCount, uint32 MaxPlayerCount, bool isRated, uint32 arenaSlot)
+{
+    // check for min / max count
+    uint32 memberscount = GetMembersCount();
+    if(memberscount < MinPlayerCount)
+        return BG_JOIN_ERR_GROUP_NOT_ENOUGH;
+    if(memberscount > MaxPlayerCount)
+        return BG_JOIN_ERR_GROUP_TOO_MANY;
+
+    // get a player as reference, to compare other players' stats to (arena team id, queue id based on level, etc.)
+    Player * reference = GetFirstMember()->getSource();
+    // no reference found, can't join this way
+    if(!reference)
+        return BG_JOIN_ERR_OFFLINE_MEMBER;
+
+    uint32 bgQueueId = reference->GetBattleGroundQueueIdFromLevel();
+    uint32 arenaTeamId = reference->GetArenaTeamId(arenaSlot);
+    uint32 team = reference->GetTeam();
+
+    // check every member of the group to be able to join
+    for(GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player *member = itr->getSource();
+        // offline member? don't let join
+        if(!member)
+            return BG_JOIN_ERR_OFFLINE_MEMBER;
+        // don't allow cross-faction join as group
+        if(member->GetTeam() != team)
+            return BG_JOIN_ERR_MIXED_FACTION;
+        // not in the same battleground level braket, don't let join
+        if(member->GetBattleGroundQueueIdFromLevel() != bgQueueId)
+            return BG_JOIN_ERR_MIXED_LEVELS;
+        // don't let join rated matches if the arena team id doesn't match
+        if(isRated && member->GetArenaTeamId(arenaSlot) != arenaTeamId)
+            return BG_JOIN_ERR_MIXED_ARENATEAM;
+        // don't let join if someone from the group is already in that bg queue
+        if(member->InBattleGroundQueueForBattleGroundQueueType(bgQueueType))
+            return BG_JOIN_ERR_GROUP_MEMBER_ALREADY_IN_QUEUE;
+        // check for deserter debuff in case not arena queue
+        if(bgTypeId != BATTLEGROUND_AA && !member->CanJoinToBattleground())
+            return BG_JOIN_ERR_GROUP_DESERTER;
+        // check if member can join any more battleground queues
+        if(!member->HasFreeBattleGroundQueueId())
+            return BG_JOIN_ERR_ALL_QUEUES_USED;
+    }
+    return BG_JOIN_ERR_OK;
+}
+
 //===================================================
 //============== Roll ===============================
 //===================================================
diff --git a/src/game/Group.h b/src/game/Group.h
index 0dc7135..91fccef 100644
--- a/src/game/Group.h
+++ b/src/game/Group.h
@@ -232,6 +232,7 @@ class MANGOS_DLL_SPEC Group
             SendUpdate();
         }
         void SetBattlegroundGroup(BattleGround *bg) { m_bgGroup = bg; }
+        uint32 CanJoinBattleGroundQueue(uint32 bgTypeId, uint32 bgQueueType, uint32 MinPlayerCount, uint32 MaxPlayerCount, bool isRated, uint32 arenaSlot);
 
         void ChangeMembersGroup(const uint64 &guid, const uint8 &group);
         void ChangeMembersGroup(Player *player, const uint8 &group);
diff --git a/src/game/GuardAI.cpp b/src/game/GuardAI.cpp
index 5672f14..b07146d 100644
--- a/src/game/GuardAI.cpp
+++ b/src/game/GuardAI.cpp
@@ -50,7 +50,7 @@ void GuardAI::MoveInLineOfSight(Unit *u)
         {
             //Need add code to let guard support player
             AttackStart(u);
-            u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
+            //u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
         }
     }
 }
diff --git a/src/game/Language.h b/src/game/Language.h
index cd48754..261fc3b 100644
--- a/src/game/Language.h
+++ b/src/game/Language.h
@@ -21,6 +21,8 @@
 
 enum MangosStrings
 {
+	LANG_AUTO_BROADCAST                 = 1001,
+
     // for chat commands
     LANG_SELECT_CHAR_OR_CREATURE        = 1,
     LANG_SELECT_CREATURE                = 2,
@@ -619,6 +621,63 @@ enum MangosStrings
     LANG_ARENA_FIFTEEN_SECONDS          = 703,
     LANG_ARENA_BEGUN                    = 704,
 
+    // opvp hp
+    LANG_OPVP_HP_CAPTURE_OVERLOOK_H     = 9001,
+    LANG_OPVP_HP_CAPTURE_OVERLOOK_A     = 9002,
+    LANG_OPVP_HP_CAPTURE_STADIUM_H      = 9003,
+    LANG_OPVP_HP_CAPTURE_STADIUM_A      = 9004,
+    LANG_OPVP_HP_CAPTURE_BROKENHILL_H   = 9005,
+    LANG_OPVP_HP_CAPTURE_BROKENHILL_A   = 9006,
+    LANG_OPVP_HP_LOOSE_OVERLOOK_H       = 9007,
+    LANG_OPVP_HP_LOOSE_OVERLOOK_A       = 9008,
+    LANG_OPVP_HP_LOOSE_STADIUM_H        = 9009,
+    LANG_OPVP_HP_LOOSE_STADIUM_A        = 9010,
+    LANG_OPVP_HP_LOOSE_BROKENHILL_H     = 9011,
+    LANG_OPVP_HP_LOOSE_BROKENHILL_A     = 9012,
+    // opvp zm
+    LANG_OPVP_ZM_CAPTURE_WEST_H         = 9013,
+    LANG_OPVP_ZM_CAPTURE_WEST_A         = 9014,
+    LANG_OPVP_ZM_CAPTURE_EAST_H         = 9015,
+    LANG_OPVP_ZM_CAPTURE_EAST_A         = 9016,
+    LANG_OPVP_ZM_CAPTURE_GY_H           = 9017,
+    LANG_OPVP_ZM_CAPTURE_GY_A           = 9018,
+    LANG_OPVP_ZM_LOOSE_WEST_H           = 9019,
+    LANG_OPVP_ZM_LOOSE_WEST_A           = 9020,
+    LANG_OPVP_ZM_LOOSE_EAST_H           = 9021,
+    LANG_OPVP_ZM_LOOSE_EAST_A           = 9022,
+    LANG_OPVP_ZM_LOOSE_GY_H             = 9023,
+    LANG_OPVP_ZM_LOOSE_GY_A             = 9024,
+    // opvp na
+    LANG_OPVP_NA_CAPTURE_H              = 9025,
+    LANG_OPVP_NA_CAPTURE_A              = 9026,
+    LANG_OPVP_NA_LOOSE_H                = 9027,
+    LANG_OPVP_NA_LOOSE_A                = 9028,
+    // opvp tf
+    LANG_OPVP_TF_CAPTURE_H              = 9029,
+    LANG_OPVP_TF_CAPTURE_A              = 9030,
+    LANG_OPVP_TF_LOOSE_H                = 9031,
+    LANG_OPVP_TF_LOOSE_A                = 9032,
+    // opvp ep
+    LANG_OPVP_EP_CAPTURE_NPT_H          = 9033,
+    LANG_OPVP_EP_CAPTURE_NPT_A          = 9034,
+    LANG_OPVP_EP_CAPTURE_EWT_H          = 9035,
+    LANG_OPVP_EP_CAPTURE_EWT_A          = 9036,
+    LANG_OPVP_EP_CAPTURE_CGT_H          = 9037,
+    LANG_OPVP_EP_CAPTURE_CGT_A          = 9038,
+    LANG_OPVP_EP_CAPTURE_PWT_H          = 9039,
+    LANG_OPVP_EP_CAPTURE_PWT_A          = 9040,
+    LANG_OPVP_EP_LOOSE_NPT_H            = 9041,
+    LANG_OPVP_EP_LOOSE_NPT_A            = 9042,
+    LANG_OPVP_EP_LOOSE_EWT_H            = 9043,
+    LANG_OPVP_EP_LOOSE_EWT_A            = 9044,
+    LANG_OPVP_EP_LOOSE_CGT_H            = 9045,
+    LANG_OPVP_EP_LOOSE_CGT_A            = 9046,
+    LANG_OPVP_EP_LOOSE_PWT_H            = 9047,
+    LANG_OPVP_EP_LOOSE_PWT_A            = 9048,
+    // opvp si
+    LANG_OPVP_SI_CAPTURE_H              = 9049,
+    LANG_OPVP_SI_CAPTURE_A              = 9050,
+
     LANG_WAIT_BEFORE_SPEAKING           = 705,
     LANG_NOT_EQUIPPED_ITEM              = 706,
     LANG_PLAYER_DND                     = 707,
@@ -629,11 +688,65 @@ enum MangosStrings
     LANG_BG_QUEUE_ANNOUNCE_SELF         = 711,
     LANG_BG_QUEUE_ANNOUNCE_WORLD        = 712,
 
+
     LANG_YOUR_ARENA_LEVEL_REQ_ERROR     = 713,
     LANG_HIS_ARENA_LEVEL_REQ_ERROR      = 714,
     LANG_YOUR_BG_LEVEL_REQ_ERROR        = 715,
     LANG_YOUR_ARENA_TEAM_FULL           = 716,
-    // Room for BG/ARENA                  717-799 not used
+     
+     LANG_BG_AV_ALLY                     = 717,
+     LANG_BG_AV_HORDE                    = 718,
+     LANG_BG_AV_TOWER_TAKEN              = 719,
+     LANG_BG_AV_TOWER_ASSAULTED          = 720,
+     LANG_BG_AV_TOWER_DEFENDED           = 721,
+     LANG_BG_AV_GRAVE_TAKEN              = 722,
+     LANG_BG_AV_GRAVE_DEFENDED           = 723,
+     LANG_BG_AV_GRAVE_ASSAULTED          = 724,
+ 
+     LANG_BG_AV_MINE_TAKEN               = 725,
+     LANG_BG_AV_MINE_NORTH               = 726,
+     LANG_BG_AV_MINE_SOUTH               = 727,
+ 
+     LANG_BG_AV_NODE_GRAVE_STORM_AID     = 728,
+     LANG_BG_AV_NODE_TOWER_DUN_S         = 729,
+     LANG_BG_AV_NODE_TOWER_DUN_N         = 730,
+     LANG_BG_AV_NODE_GRAVE_STORMPIKE     = 731,
+     LANG_BG_AV_NODE_TOWER_ICEWING       = 732,
+     LANG_BG_AV_NODE_GRAVE_STONE         = 733,
+     LANG_BG_AV_NODE_TOWER_STONE         = 734,
+     LANG_BG_AV_NODE_GRAVE_SNOW          = 735,
+     LANG_BG_AV_NODE_TOWER_ICE           = 736,
+     LANG_BG_AV_NODE_GRAVE_ICE           = 737,
+     LANG_BG_AV_NODE_TOWER_POINT         = 738,
+     LANG_BG_AV_NODE_GRAVE_FROST         = 739,
+     LANG_BG_AV_NODE_TOWER_FROST_E       = 740,
+     LANG_BG_AV_NODE_TOWER_FROST_W       = 741,
+     LANG_BG_AV_NODE_GRAVE_FROST_HUT     = 742,
+ 
+     LANG_BG_AV_ONEMINTOSTART            = 743,
+     LANG_BG_AV_HALFMINTOSTART           = 744,
+     LANG_BG_AV_STARTED                  = 745,
+     LANG_BG_AV_A_NEAR_LOSE              = 746,
+     LANG_BG_AV_H_NEAR_LOSE              = 747,
+
+    LANG_BG_GROUP_TOO_LARGE             = 7007, // "Your group is too large for this battleground. Please regroup to join."
+    LANG_ARENA_GROUP_TOO_LARGE          = 7008, // "Your group is too large for this arena. Please regroup to join."
+    LANG_ARENA_YOUR_TEAM_ONLY           = 7009, // "Your group has members not in your arena team. Please regroup to join."
+    LANG_ARENA_NOT_ENOUGH_PLAYERS       = 7010, // "Your group does not have enough players to join this match."
+    LANG_ARENA_GOLD_WINS                = 7011, // "The Gold Team wins!"
+    LANG_ARENA_GREEN_WINS               = 7012, // "The Green Team wins!"
+    LANG_BATTLEGROUND_PREMATURE_FINISH_WARNING = 7013,   // The battleground will end soon, because there aren't enough players. Get more ppl or win already!
+    LANG_BG_GROUP_OFFLINE_MEMBER        = 7014, // "Your group has an offline member. Please remove him before joining."
+    LANG_BG_GROUP_MIXED_FACTION         = 7015, // "Your group has players from the opposing faction. You can't join the battleground as a group."
+    LANG_BG_GROUP_MIXED_LEVELS          = 7016, // "Your group has players from different battleground brakets. You can't join as group."
+    LANG_BG_GROUP_MEMBER_ALREADY_IN_QUEUE = 7017, // "Someone in your party is already in this battleground queue. (S)he must leave it before joining as group."
+    LANG_BG_GROUP_MEMBER_DESERTER       = 7018, // "Someone in your party is Deserter. You can't join as group."
+    LANG_BG_GROUP_MEMBER_NO_FREE_QUEUE_SLOTS = 7019, // "Someone in your party is already in three battleground queues. You cannot join as group."
+
+    LANG_CANNOT_TELE_TO_BG              = 7020, // "You cannot teleport to a battleground or arena map."
+    LANG_CANNOT_SUMMON_TO_BG            = 7021, // "You cannot summon players to a battleground or arena map."
+    LANG_CANNOT_GO_TO_BG_GM             = 7022, // "You must be in GM mode to teleport to a player in a battleground."
+    LANG_CANNOT_GO_TO_BG_FROM_BG        = 7023, // "You cannot teleport to a battleground from another battleground. Please leave the current battleground first."
 
     // in game strings
     //                                  = 800, not used
diff --git a/src/game/Level1.cpp b/src/game/Level1.cpp
index 243e393..fb15fab 100644
--- a/src/game/Level1.cpp
+++ b/src/game/Level1.cpp
@@ -350,7 +350,14 @@ bool ChatHandler::HandleNamegoCommand(const char* args)
 
         Map* pMap = MapManager::Instance().GetMap(m_session->GetPlayer()->GetMapId(),m_session->GetPlayer());
 
-        if(pMap->Instanceable())
+        if(pMap->IsBattleGroundOrArena())
+        {
+            // cannot summon to bg
+            PSendSysMessage(LANG_CANNOT_SUMMON_TO_BG,chr->GetName());
+            SetSentErrorMessage(true);
+            return false;
+        }
+        else if(pMap->IsDungeon())
         {
             Map* cMap = MapManager::Instance().GetMap(chr->GetMapId(),chr);
             if( cMap->Instanceable() && cMap->GetInstanceId() != pMap->GetInstanceId() )
@@ -436,7 +443,27 @@ bool ChatHandler::HandleGonameCommand(const char* args)
     if (chr)
     {
         Map* cMap = MapManager::Instance().GetMap(chr->GetMapId(),chr);
-        if(cMap->Instanceable())
+        if(cMap->IsBattleGroundOrArena())
+        {
+            // only allow if gm mode is on
+            if (!_player->isGameMaster())
+            {
+                PSendSysMessage(LANG_CANNOT_GO_TO_BG_GM,chr->GetName());
+                SetSentErrorMessage(true);
+                return false;
+            }
+            // if already in a bg, don't let port to other
+            else if (_player->GetBattleGroundId())
+            {
+                PSendSysMessage(LANG_CANNOT_GO_TO_BG_FROM_BG,chr->GetName());
+                SetSentErrorMessage(true);
+                return false;
+            }
+            // all's well, set bg id
+            // when porting out from the bg, it will be reset to 0
+            _player->SetBattleGroundId(chr->GetBattleGroundId());
+        }
+        else if(cMap->IsDungeon())
         {
             Map* pMap = MapManager::Instance().GetMap(_player->GetMapId(),_player);
 
@@ -1200,7 +1227,7 @@ bool ChatHandler::HandleModifyScaleCommand(const char* args)
         return false;
 
     float Scale = (float)atof((char*)args);
-    if (Scale > 3.0f || Scale <= 0.0f)
+    if (Scale > 15.0f || Scale <= 0.0f)
     {
         SendSysMessage(LANG_BAD_VALUE);
         SetSentErrorMessage(true);
diff --git a/src/game/Level3.cpp b/src/game/Level3.cpp
index de6a100..7525ae5 100644
--- a/src/game/Level3.cpp
+++ b/src/game/Level3.cpp
@@ -47,6 +47,7 @@
 #include "Config/ConfigEnv.h"
 #include "Util.h"
 #include "ItemEnchantmentMgr.h"
+#include "BattleGroundMgr.h"
 #include "InstanceSaveMgr.h"
 #include "InstanceData.h"
 #include "AccountMgr.h"
@@ -4800,6 +4801,92 @@ bool ChatHandler::HandleCompleteQuest(const char* args)
     return true;
 }
 
+bool ChatHandler::HandleAHExpireCommand(const char* args)
+{
+   if (args == NULL)
+      return false;
+
+   char* ahMapIdStr = strtok((char*) args, " ");
+   char* playerGuidStr = strtok(NULL, " ");
+
+   if ((ahMapIdStr == NULL) || (playerGuidStr == NULL))
+      return false;
+
+   uint32 ahMapID = (uint32) strtoul(ahMapIdStr, NULL, 0);
+   uint32 playerGUID = (uint32) strtoul(playerGuidStr, NULL, 0);
+
+   AuctionHouseObject* auctionHouse = objmgr.GetAuctionsMap(ahMapID);
+
+   if (auctionHouse == NULL)
+      return false;
+
+   AuctionHouseObject::AuctionEntryMap::iterator itr;
+   itr = auctionHouse->GetAuctionsBegin();
+
+   while (itr != auctionHouse->GetAuctionsEnd())
+   {
+      if (itr->second->owner == playerGUID)
+         itr->second->time = sWorld.GetGameTime();
+
+      ++itr;
+   }
+
+   return true;
+}
+
+bool ChatHandler::HandleAHDeleteCommand(const char* args)
+{
+   if (args == NULL)
+      return false;
+
+   char* ahMapIdStr = strtok((char*) args, " ");
+   char* playerGuidStr = strtok(NULL, " ");
+
+   if ((ahMapIdStr == NULL) || (playerGuidStr == NULL))
+      return false;
+
+   uint32 ahMapID = (uint32) strtoul(ahMapIdStr, NULL, 0);
+   uint32 playerGUID = (uint32) strtoul(playerGuidStr, NULL, 0);
+
+   AuctionHouseObject* auctionHouse = objmgr.GetAuctionsMap(ahMapID);
+
+   if (auctionHouse == NULL)
+      return false;
+
+   AuctionHouseObject::AuctionEntryMap::iterator itr;
+   itr = auctionHouse->GetAuctionsBegin();
+
+   while (itr != auctionHouse->GetAuctionsEnd())
+   {
+      AuctionHouseObject::AuctionEntryMap::iterator tmp = itr;
+      ++itr;
+
+      if (tmp->second->owner != playerGUID)
+         continue;
+
+      Item* item = objmgr.GetAItem(tmp->second->item_guidlow);
+      if (item != NULL)
+      {
+         objmgr.RemoveAItem(tmp->second->item_guidlow);
+         item->DeleteFromDB();
+         delete item;
+      }
+      else
+      {
+         sLog.outString("ahdelete: "
+                        "clearing auction for non-existant item_guidlow (%d)",
+                        tmp->second->item_guidlow);
+      }
+
+      CharacterDatabase.PExecute("DELETE FROM `auctionhouse` WHERE `id` = '%u'",
+                                 tmp->second->Id);
+      auctionHouse->RemoveAuction(tmp->second->Id);
+      delete tmp->second;
+   }
+
+   return true;
+}
+
 bool ChatHandler::HandleBanAccountCommand(const char* args)
 {
     return HandleBanHelper(BAN_ACCOUNT,args);
@@ -5294,24 +5381,30 @@ bool ChatHandler::HandleFlyModeCommand(const char* args)
     if(!args)
         return false;
 
-    Unit *unit = getSelectedUnit();
-    if (!unit || (unit->GetTypeId() != TYPEID_PLAYER))
-        unit = m_session->GetPlayer();
+    Player *pl = m_session->GetPlayer();
+    if(!pl)
+        return false;
 
     WorldPacket data(12);
     if (strncmp(args, "on", 3) == 0)
+    {
         data.SetOpcode(SMSG_MOVE_SET_CAN_FLY);
+        pl->SetCanFly(true); 
+    }
     else if (strncmp(args, "off", 4) == 0)
+    {
         data.SetOpcode(SMSG_MOVE_UNSET_CAN_FLY);
+        pl->SetCanFly(false);
+    }
     else
     {
         SendSysMessage(LANG_USE_BOL);
         return false;
     }
-    data.append(unit->GetPackGUID());
+    data.append(pl->GetPackGUID());
     data << uint32(0);                                      // unknown
-    unit->SendMessageToSet(&data, true);
-    PSendSysMessage(LANG_COMMAND_FLYMODE_STATUS, unit->GetName(), args);
+    pl->SendMessageToSet(&data, true);
+    PSendSysMessage(LANG_COMMAND_FLYMODE_STATUS, pl->GetName(), args);
     return true;
 }
 
@@ -6096,3 +6189,9 @@ bool ChatHandler::HandleSendMessageCommand(const char* args)
     PSendSysMessage(LANG_SENDMESSAGE,name.c_str(),msg_str);
     return true;
 }
+
+bool ChatHandler::HandleFlushArenaPointsCommand(const char * /*args*/)
+{
+    sBattleGroundMgr.DistributeArenaPoints();
+    return true;
+}
diff --git a/src/game/LootHandler.cpp b/src/game/LootHandler.cpp
index 9731442..38d780d 100644
--- a/src/game/LootHandler.cpp
+++ b/src/game/LootHandler.cpp
@@ -29,6 +29,7 @@
 #include "Group.h"
 #include "World.h"
 #include "Util.h"
+#include "ObjectAccessor.h"
 
 void WorldSession::HandleAutostoreLootItemOpcode( WorldPacket & recv_data )
 {
@@ -68,6 +69,16 @@ void WorldSession::HandleAutostoreLootItemOpcode( WorldPacket & recv_data )
 
         loot = &pItem->loot;
     }
+    else if (IS_CORPSE_GUID(lguid))
+    {
+        Corpse *bones = ObjectAccessor::GetCorpse(*player, lguid);
+        if (!bones)
+        {
+            player->SendLootRelease(lguid);
+            return;
+        }
+        loot = &bones->loot;
+    }
     else
     {
         Creature* pCreature =
diff --git a/src/game/Makefile.am b/src/game/Makefile.am
index ad3315d..6301b7c 100644
--- a/src/game/Makefile.am
+++ b/src/game/Makefile.am
@@ -38,6 +38,8 @@ libmangosgame_a_SOURCES = \
     ArenaTeam.cpp \
     ArenaTeam.h \
     ArenaTeamHandler.cpp \
+    AuctionHouseBot.cpp \
+    AuctionHouseBot.h \
     AuctionHouse.cpp \
     AuctionHouseObject.h \
     Bag.cpp \
@@ -73,6 +75,10 @@ libmangosgame_a_SOURCES = \
     Chat.cpp \
     Chat.h \
     ChatHandler.cpp \
+    ChatLexicsCutter.cpp \
+    ChatLexicsCutter.h \
+    ChatLog.cpp \
+    ChatLog.h \
     CombatHandler.cpp \
     ConfusedMovementGenerator.cpp \
     ConfusedMovementGenerator.h \
@@ -177,6 +183,24 @@ libmangosgame_a_SOURCES = \
     ObjectPosSelector.h \
     Opcodes.cpp \
     Opcodes.h \
+    OutdoorPvP.cpp \
+    OutdoorPvP.h \
+    OutdoorPvPEP.cpp \
+    OutdoorPvPEP.h \
+    OutdoorPvPHP.cpp \
+    OutdoorPvPHP.h \
+    OutdoorPvPMgr.cpp \
+    OutdoorPvPMgr.h \
+    OutdoorPvPNA.cpp \
+    OutdoorPvPNA.h \
+    OutdoorPvPObjectiveAI.cpp \
+    OutdoorPvPObjectiveAI.h \
+    OutdoorPvPSI.cpp \
+    OutdoorPvPSI.h \
+    OutdoorPvPTF.cpp \
+    OutdoorPvPTF.h \
+    OutdoorPvPZM.cpp \
+    OutdoorPvPZM.h \
     Path.h \
     PetAI.cpp \
     PetAI.h \
diff --git a/src/game/MapInstanced.cpp b/src/game/MapInstanced.cpp
index 741e0a9..5f7a033 100644
--- a/src/game/MapInstanced.cpp
+++ b/src/game/MapInstanced.cpp
@@ -141,7 +141,17 @@ Map* MapInstanced::GetInstance(const WorldObject* obj)
             uint32 NewInstanceId = 0;                       // instanceId of the resulting map
             Player* player = (Player*)obj;
 
-            // TODO: battlegrounds and arenas
+            if(IsBattleGroundOrArena())
+            {
+                // instantiate or find existing bg map for player
+                // the instance id is set in battlegroundid
+                NewInstanceId = player->GetBattleGroundId();
+                assert(NewInstanceId);
+                map = _FindMap(NewInstanceId);
+                if(!map)
+                    map = CreateBattleGround(NewInstanceId);
+                return map;
+            }
 
             InstancePlayerBind *pBind = player->GetBoundInstance(GetId(), player->GetDifficulty());
             InstanceSave *pSave = pBind ? pBind->save : NULL;
diff --git a/src/game/MapManager.cpp b/src/game/MapManager.cpp
index a8d897b..82e4c8e 100644
--- a/src/game/MapManager.cpp
+++ b/src/game/MapManager.cpp
@@ -107,7 +107,7 @@ MapManager::_GetBaseMap(uint32 id)
         Guard guard(*this);
 
         const MapEntry* entry = sMapStore.LookupEntry(id);
-        if (entry && entry->IsDungeon())
+        if (entry && entry->Instanceable())
         {
             m = new MapInstanced(id, i_gridCleanUpDelay, 0);
         }
diff --git a/src/game/MiscHandler.cpp b/src/game/MiscHandler.cpp
index 238bfa8..7575fbb 100644
--- a/src/game/MiscHandler.cpp
+++ b/src/game/MiscHandler.cpp
@@ -37,6 +37,7 @@
 #include "ObjectAccessor.h"
 #include "Object.h"
 #include "BattleGround.h"
+#include "OutdoorPvP.h"
 #include "SpellAuras.h"
 #include "Pet.h"
 #include "SocialMgr.h"
@@ -561,6 +562,11 @@ void WorldSession::HandleTogglePvP( WorldPacket & recv_data )
         if(!GetPlayer()->pvpInfo.inHostileArea && GetPlayer()->IsPvP())
             GetPlayer()->pvpInfo.endTimer = time(NULL);     // start toggle-off
     }
+
+    if(OutdoorPvP * pvp = _player->GetOutdoorPvP())
+    {
+        pvp->HandlePlayerActivityChanged(_player);
+    }
 }
 
 void WorldSession::HandleZoneUpdateOpcode( WorldPacket & recv_data )
@@ -572,10 +578,13 @@ void WorldSession::HandleZoneUpdateOpcode( WorldPacket & recv_data )
 
     sLog.outDetail("WORLD: Recvd ZONE_UPDATE: %u", newZone);
 
-    if(newZone != _player->GetZoneId())
-        GetPlayer()->SendInitWorldStates();                 // only if really enters to new zone, not just area change, works strange...
-
+    // this check is definitely BAD, either we init for the old zone, or we doesn't init at all.
+    // Let's try with check commented out. Let the client decide when to re-init states.
+    // EDIT: and this works like a charm.
+//    if(newZone != _player->GetZoneId())
     GetPlayer()->UpdateZone(newZone);
+
+    GetPlayer()->SendInitWorldStates(true,newZone);                 // only if really enters to new zone, not just area change, works strange...
 }
 
 void WorldSession::HandleSetTargetOpcode( WorldPacket & recv_data )
@@ -847,6 +856,10 @@ void WorldSession::HandleCorpseReclaimOpcode(WorldPacket &recv_data)
     if (GetPlayer()->isAlive())
         return;
 
+    if (BattleGround * bg = _player->GetBattleGround())
+        if(bg->isArena())
+            return;
+
     // body not released yet
     if(!GetPlayer()->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
         return;
@@ -1009,6 +1022,12 @@ void WorldSession::HandleAreaTriggerOpcode(WorldPacket & recv_data)
         return;
     }
 
+    if(OutdoorPvP * pvp = GetPlayer()->GetOutdoorPvP())
+    {
+        if(pvp->HandleAreaTrigger(_player, Trigger_ID))
+            return;
+    }
+
     // NULL if all values default (non teleport trigger)
     AreaTrigger const* at = objmgr.GetAreaTrigger(Trigger_ID);
     if(!at)
diff --git a/src/game/MovementHandler.cpp b/src/game/MovementHandler.cpp
index 694bde8..d4c6a77 100644
--- a/src/game/MovementHandler.cpp
+++ b/src/game/MovementHandler.cpp
@@ -130,22 +130,28 @@ void WorldSession::HandleMoveWorldportAckOpcode()
         _player->RemoveSpellsCausingAura(SPELL_AURA_MOUNTED);
 
     // battleground state preper
-    if(_player->InBattleGround())
+    // only add to bg group and object, if the player was invited (else he entered through command)
+    if(_player->InBattleGround() && _player->IsInvitedForBattleGroundInstance(_player->GetBattleGroundId()))
     {
         BattleGround *bg = _player->GetBattleGround();
         if(bg)
         {
+            bg->AddPlayer(_player);
             if(bg->GetMapId() == _player->GetMapId())       // we teleported to bg
             {
-                if(!bg->GetBgRaid(_player->GetTeam()))      // first player joined
+                // get the team this way, because arenas might 'override' the teams.
+                uint32 team = bg->GetPlayerTeam(_player->GetGUID());
+                if(!team)
+                    team = _player->GetTeam();
+                if(!bg->GetBgRaid(team))      // first player joined
                 {
                     Group *group = new Group;
-                    bg->SetBgRaid(_player->GetTeam(), group);
+                    bg->SetBgRaid(team, group);
                     group->Create(_player->GetGUIDLow(), _player->GetName());
                 }
                 else                                        // raid already exist
                 {
-                    bg->GetBgRaid(_player->GetTeam())->AddMember(_player->GetGUID(), _player->GetName());
+                    bg->GetBgRaid(team)->AddMember(_player->GetGUID(), _player->GetName());
                 }
             }
         }
@@ -175,6 +181,8 @@ void WorldSession::HandleMovementOpcodes( WorldPacket & recv_data )
     if(GetPlayer()->GetDontMove())
         return;
 
+    //get opcode
+    uint16 opcode = recv_data.GetOpcode();    
     /* extract packet */
     MovementInfo movementInfo;
     uint32 MovementFlags;
@@ -258,6 +266,8 @@ void WorldSession::HandleMovementOpcodes( WorldPacket & recv_data )
             movementInfo.z+movementInfo.t_z, movementInfo.o+movementInfo.t_o) )
             return;
 
+       if ((GetPlayer()->m_anti_transportGUID == 0) && (movementInfo.t_guid !=0)) 
+       {
         // if we boarded a transport, add us to it
         if (!GetPlayer()->m_transport)
         {
@@ -275,16 +285,21 @@ void WorldSession::HandleMovementOpcodes( WorldPacket & recv_data )
                 }
             }
         }
+        GetPlayer()->m_anti_transportGUID = movementInfo.t_guid;
+      }
     }
-    else if (GetPlayer()->m_transport)                      // if we were on a transport, leave
-    {
-        GetPlayer()->m_transport->RemovePassenger(GetPlayer());
-        GetPlayer()->m_transport = NULL;
+    else if (GetPlayer()->m_anti_transportGUID != 0) { 
+        if (GetPlayer()->m_transport)                      // if we were on a transport, leave
+        {
+            GetPlayer()->m_transport->RemovePassenger(GetPlayer());
+            GetPlayer()->m_transport = NULL;
+        }
         movementInfo.t_x = 0.0f;
         movementInfo.t_y = 0.0f;
         movementInfo.t_z = 0.0f;
         movementInfo.t_o = 0.0f;
         movementInfo.t_time = 0;
+        GetPlayer()->m_anti_transportGUID = 0; 
     }
 
     // fall damage generation (ignore in flight case that can be triggred also at lags in moment teleportation to another map).
@@ -349,37 +364,166 @@ void WorldSession::HandleMovementOpcodes( WorldPacket & recv_data )
     }
 
     /*----------------------*/
-
+     // ---- anti-cheat features -->>>
+     bool kicked = true; 
+     if ((GetPlayer()->m_anti_transportGUID == 0) && sWorld.GetEnableMvAnticheat()) //&& !GetPlayer()->isInFlight()
+     {
+         UnitMoveType move_type; 
+  
+         if (MovementFlags & MOVEMENTFLAG_FLYING) move_type = MovementFlags & MOVEMENTFLAG_BACKWARD ? MOVE_FLYBACK : MOVE_FLY;
+         else if (MovementFlags & MOVEMENTFLAG_SWIMMING) move_type = MovementFlags & MOVEMENTFLAG_BACKWARD ? MOVE_SWIMBACK : MOVE_SWIM; 
+         else if (MovementFlags & MOVEMENTFLAG_WALK_MODE) move_type = MOVE_WALK;
+         //hmm... in first time after login player has MOVE_SWIMBACK instead MOVE_WALKBACK  
+         else move_type = MovementFlags & MOVEMENTFLAG_BACKWARD ? MOVE_SWIMBACK : MOVE_RUN;
+ 
+         //if (GetPlayer()->IsMounted() && (move_type == MOVE_RUN)) move_type = MOVE_MOUNTED; 
+  
+         float allowed_delta= 0;
+         float current_speed = GetPlayer()->GetSpeed(move_type);
+         float delta_x = GetPlayer()->GetPositionX() - movementInfo.x;
+         float delta_y = GetPlayer()->GetPositionY() - movementInfo.y; // + 0.002f Some vibration for HyperJump detect =)
+         float delta_z = GetPlayer()->GetPositionZ() - movementInfo.z;
+         float real_delta = delta_x * delta_x + delta_y * delta_y;
+         float tg_z = -99999; //tangens
+         float time_delta = movementInfo.time - GetPlayer()->m_anti_lastmovetime;
+         if (time_delta > 0) {
+             GetPlayer()->m_anti_lastmovetime = movementInfo.time;
+         } else {time_delta = 0;}
+         time_delta = (time_delta < 1500) ? time_delta/1000 : 1.5f; //normalize time - 2 second allowed for heavy loaded server
+ 
+         if (!(MovementFlags & (MOVEMENTFLAG_FLYING | MOVEMENTFLAG_SWIMMING)))
+           tg_z = (real_delta !=0) ? (delta_z*delta_z / real_delta) : -99999;
+         
+         if (current_speed < GetPlayer()->m_anti_last_hspeed)
+         {
+             allowed_delta = GetPlayer()->m_anti_last_hspeed;
+             if (GetPlayer()->m_anti_lastspeed_changetime == 0 ) 
+                 GetPlayer()->m_anti_lastspeed_changetime = movementInfo.time + (uint32)floor(((GetPlayer()->m_anti_last_hspeed / current_speed) * 1000)) + 100; //100ms above for random fluctuating =))) 
+         } else allowed_delta = current_speed;
+ 
+         allowed_delta = allowed_delta * time_delta;
+         allowed_delta = allowed_delta * allowed_delta + 2;
+     
+         //static char const* move_type_name[MAX_MOVE_TYPE] = {  "Walk", "Run", "Walkback", "Swim", "Swimback", "Turn", "Fly", "Flyback" };
+         //sLog.outBasic("%s newcoord: tm:%d ftm:%d | %f,%f,%fo(%f) [%X][%s]$%s",GetPlayer()->GetName(),movementInfo.time,movementInfo.fallTime,movementInfo.x,movementInfo.y,movementInfo.z,movementInfo.o,movementInfo.flags, LookupName(opcode,g_worldOpcodeNames),move_type_name[move_type]);
+         //sLog.outBasic("%f",tg_z);
+ 
+         if ((real_delta > allowed_delta) && (delta_z < 1))
+         {
+             sLog.outDebug("Movement anticheat: %s is speed exception. {real_delta=%f allowed_delta=%f | current_speed=%f preview_speed=%f time=%f}(%f %f %f %d)[%s]",GetPlayer()->GetName(),real_delta, allowed_delta, current_speed, GetPlayer()->m_anti_last_hspeed,time_delta,GetPlayer()->GetPositionX(),GetPlayer()->GetPositionY(),GetPlayer()->GetPositionZ(), GetPlayer()->GetMapId(),LookupOpcodeName(opcode));
+             kicked = false;
+         }
+         if ((real_delta>4900.0f) && !(real_delta < allowed_delta)) 
+         {
+             sLog.outDebug("Movement anticheat: %s is teleport exception. {real_delta=%f allowed_delta=%f | current_speed=%f preview_speed=%f time=%f}(%f %f %f %d)",GetPlayer()->GetName(),real_delta, allowed_delta, current_speed, GetPlayer()->m_anti_last_hspeed,time_delta,GetPlayer()->GetPositionX(),GetPlayer()->GetPositionY(),GetPlayer()->GetPositionZ(), GetPlayer()->GetMapId());
+             kicked = false;
+         }
+  
+         if (movementInfo.time>GetPlayer()->m_anti_lastspeed_changetime) 
+         {
+             GetPlayer()->m_anti_last_hspeed = current_speed; // store current speed
+             GetPlayer()->m_anti_last_vspeed = -3.2f;
+             if (GetPlayer()->m_anti_lastspeed_changetime != 0) GetPlayer()->m_anti_lastspeed_changetime = 0;
+         }
+ 
+         if ((tg_z > 1.56f) && (delta_z < GetPlayer()->m_anti_last_vspeed))
+         {
+             sLog.outDebug("Movement anticheat: %s is mountain exception. {tg_z=%f} (%f %f %f %d)",GetPlayer()->GetName(),tg_z, GetPlayer()->GetPositionX(),GetPlayer()->GetPositionY(),GetPlayer()->GetPositionZ(), GetPlayer()->GetMapId());
+             kicked = false;
+         }   
+         if (((MovementFlags & MOVEMENTFLAG_SWIMMING) == 0) && ((MovementFlags & (MOVEMENTFLAG_CAN_FLY | MOVEMENTFLAG_FLYING | MOVEMENTFLAG_FLYING2)) != 0) && !GetPlayer()->isGameMaster() && !(GetPlayer()->CanFly()))
+         {
+            sLog.outDebug("Movement anticheat: %s is fly exception. [%X]{SPELL_AURA_FLY=[%X]}", GetPlayer()->GetName(), MovementFlags,GetPlayer()->HasAuraType(SPELL_AURA_FLY));
+            kicked = false;
+         } 
+         if (((MovementFlags & MOVEMENTFLAG_WATERWALKING) != 0) && !GetPlayer()->isGameMaster() && !(GetPlayer()->HasAuraType(SPELL_AURA_WATER_WALK) | GetPlayer()->HasAuraType(SPELL_AURA_GHOST)))
+         {
+            sLog.outDebug("Movement anticheat: %s is water-walk exception. [%X]{SPELL_AURA_WATER_WALK=[%X]}", GetPlayer()->GetName(), MovementFlags, GetPlayer()->HasAuraType(SPELL_AURA_WATER_WALK));
+            kicked = false;
+         }
+         if(movementInfo.z < 0.0001f && movementInfo.z > -0.0001f && ((MovementFlags & MOVEMENTFLAG_SWIMMING) == 0) && ((MovementFlags & (MOVEMENTFLAG_CAN_FLY | MOVEMENTFLAG_FLYING | MOVEMENTFLAG_FLYING2)) == 0) && !GetPlayer()->isGameMaster() )
+         {
+             // Prevent using TeleportToPlan.
+             Map *map = GetPlayer()->GetMap();
+             if(map && map->GetHeight(movementInfo.x, movementInfo.y, MAX_HEIGHT) != movementInfo.z)
+             {
+                 sLog.outDebug("Movement anticheat: %s is teleport to plan exception. [%X]", GetPlayer()->GetName(), MovementFlags);
+                 kicked = false;
+             }
+         }
+     } else if (MovementFlags & MOVEMENTFLAG_ONTRANSPORT)
+         {
+             float trans_rad = movementInfo.t_x*movementInfo.t_x + movementInfo.t_y*movementInfo.t_y + movementInfo.t_z*movementInfo.t_z;
+             if (trans_rad > 3600.0f) // transport radius = 60 yards //cheater with on_transport_flag
+             {
+                 if (GetPlayer()->m_transport)
+                 {
+                     GetPlayer()->m_transport->RemovePassenger(GetPlayer());
+                     GetPlayer()->m_transport = NULL;
+                 }
+                 movementInfo.t_x = 0.0f;
+                 movementInfo.t_y = 0.0f;
+                 movementInfo.t_z = 0.0f;
+                 movementInfo.t_o = 0.0f;
+                 movementInfo.t_time = 0;
+                 GetPlayer()->m_anti_transportGUID = 0;
+             }
+         }
+    // <<---- anti-cheat features
     /* process position-change */
-    recv_data.put<uint32>(5, getMSTime());                  // offset flags(4) + unk(1)
-    WorldPacket data(recv_data.GetOpcode(), (GetPlayer()->GetPackGUID().size()+recv_data.size()));
-    data.append(GetPlayer()->GetPackGUID());
-    data.append(recv_data.contents(), recv_data.size());
-    GetPlayer()->SendMessageToSet(&data, false);
+    if (kicked) 
+    {
+        recv_data.put<uint32>(5, getMSTime());                  // offset flags(4) + unk(1)
+        WorldPacket data(recv_data.GetOpcode(), (GetPlayer()->GetPackGUID().size()+recv_data.size()));
+        data.append(GetPlayer()->GetPackGUID());
+        data.append(recv_data.contents(), recv_data.size());
+        GetPlayer()->SendMessageToSet(&data, false);
 
-    GetPlayer()->SetPosition(movementInfo.x, movementInfo.y, movementInfo.z, movementInfo.o);
-    GetPlayer()->m_movementInfo = movementInfo;
+        GetPlayer()->SetPosition(movementInfo.x, movementInfo.y, movementInfo.z, movementInfo.o);
+        GetPlayer()->m_movementInfo = movementInfo;
 
-    if(GetPlayer()->isMovingOrTurning())
-        GetPlayer()->RemoveSpellsCausingAura(SPELL_AURA_FEIGN_DEATH);
+        if(GetPlayer()->isMovingOrTurning())
+            GetPlayer()->RemoveSpellsCausingAura(SPELL_AURA_FEIGN_DEATH);
 
-    if(movementInfo.z < -500.0f)
-    {
-        // NOTE: this is actually called many times while falling
-        // even after the player has been teleported away
-        // TODO: discard movement packets after the player is rooted
-        if(GetPlayer()->isAlive())
+        if(movementInfo.z < -500.0f)
         {
-            GetPlayer()->EnvironmentalDamage(GetPlayer()->GetGUID(),DAMAGE_FALL_TO_VOID, GetPlayer()->GetMaxHealth());
-            // change the death state to CORPSE to prevent the death timer from
-            // starting in the next player update
-            GetPlayer()->KillPlayer();
-            GetPlayer()->BuildPlayerRepop();
-        }
+            if(GetPlayer()->InBattleGround() 
+                && GetPlayer()->GetBattleGround() 
+                && GetPlayer()->GetBattleGround()->HandlePlayerUnderMap(_player))
+                {
+                    // do nothing, the handle already did if returned true
+                }
+            else
+            {
+                // NOTE: this is actually called many times while falling
+                // even after the player has been teleported away
+                // TODO: discard movement packets after the player is rooted
+                if(GetPlayer()->isAlive())
+                {
+                    GetPlayer()->EnvironmentalDamage(GetPlayer()->GetGUID(),DAMAGE_FALL_TO_VOID, GetPlayer()->GetMaxHealth());
+                    // change the death state to CORPSE to prevent the death timer from
+                    // starting in the next player update
+                    GetPlayer()->KillPlayer();
+                    GetPlayer()->BuildPlayerRepop();
+                }
 
-        // cancel the death timer here if started
-        GetPlayer()->RepopAtGraveyard();
-    }
+                // cancel the death timer here if started
+                GetPlayer()->RepopAtGraveyard();
+            }
+        }
+        if (GetPlayer()->m_anti_alarmcount > 0){
+            sLog.outError("Movement anticheat: %s produce %d anticheat alarms",GetPlayer()->GetName(),GetPlayer()->m_anti_alarmcount);
+            GetPlayer()->m_anti_alarmcount = 0;
+        }
+    } else {
+        GetPlayer()->m_anti_alarmcount++;
+        WorldPacket data;
+        GetPlayer()->SetUnitMovementFlags(0);
+        GetPlayer()->BuildTeleportAckMsg(&data, GetPlayer()->GetPositionX(), GetPlayer()->GetPositionY(), GetPlayer()->GetPositionZ(), GetPlayer()->GetOrientation());
+        GetPlayer()->GetSession()->SendPacket(&data);
+        GetPlayer()->BuildHeartBeatMsg(&data);
+        GetPlayer()->SendMessageToSet(&data, true); 
+    } 
 }
 
 void WorldSession::HandleForceSpeedChangeAck(WorldPacket &recv_data)
@@ -498,7 +642,7 @@ void WorldSession::HandleForceSpeedChangeAck(WorldPacket &recv_data)
         }
         else                                                // must be lesser - cheating
         {
-            sLog.outBasic("Player %s from account id %u kicked for incorrect speed (must be %f instead %f)",
+            sLog.outError("KickPlayer!!!Player %s from account id %u kicked for incorrect speed (must be %f instead %f)",
                 _player->GetName(),_player->GetSession()->GetAccountId(),_player->GetSpeed(move_type), newspeed);
             _player->GetSession()->KickPlayer();
         }
diff --git a/src/game/Object.cpp b/src/game/Object.cpp
index 0b6bb20..08de19b 100644
--- a/src/game/Object.cpp
+++ b/src/game/Object.cpp
@@ -540,6 +540,8 @@ void Object::_BuildValuesUpdate(uint8 updatetype, ByteBuffer * data, UpdateMask
                 IsActivateToQuest = true;
                 updateMask->SetBit(GAMEOBJECT_DYN_FLAGS);
             }
+            if (GetUInt32Value(GAMEOBJECT_ARTKIT))
+                updateMask->SetBit(GAMEOBJECT_ARTKIT);
         }
     }
     else                                                    //case UPDATETYPE_VALUES
@@ -569,7 +571,7 @@ void Object::_BuildValuesUpdate(uint8 updatetype, ByteBuffer * data, UpdateMask
             {
                 // remove custom flag before send
                 if( index == UNIT_NPC_FLAGS )
-                    *data << uint32(m_uint32Values[ index ] & ~UNIT_NPC_FLAG_GUARD);
+                    *data << uint32(m_uint32Values[ index ] & ~(UNIT_NPC_FLAG_GUARD + UNIT_NPC_FLAG_OUTDOORPVP));
                 // FIXME: Some values at server stored in float format but must be sent to client in uint32 format
                 else if(index >= UNIT_FIELD_BASEATTACKTIME && index <= UNIT_FIELD_RANGEDATTACKTIME)
                 {
@@ -1125,7 +1127,7 @@ void WorldObject::UpdateGroundPositionZ(float x, float y, float &z) const
 {
     float new_z = MapManager::Instance().GetBaseMap(GetMapId())->GetHeight(x,y,z,true);
     if(new_z > INVALID_HEIGHT)
-        z = new_z+ 0.05f;                                   // just to be sure that we are not a few pixel under the surface
+        z = new_z; //+ 0.05f;                                   // just to be sure that we are not a few pixel under the surface
 }
 
 bool WorldObject::IsPositionValid() const
@@ -1557,7 +1559,7 @@ void WorldObject::GetNearPoint(WorldObject const* searcher, float &x, float &y,
     }
 
     float angle;                                            // candidate of angle for free pos
-
+    
     // special case when one from list empty and then empty side preferred
     if(selector.FirstAngle(angle))
     {
@@ -1571,7 +1573,12 @@ void WorldObject::GetNearPoint(WorldObject const* searcher, float &x, float &y,
 
     // set first used pos in lists
     selector.InitializeAngle();
-
+    
+    // Debugging LoS problem when angle == 0.00, set some vars
+    bool localDebug = false;
+    uint32 localCounter = 0;
+    uint32 localCounter2 = 0;
+    
     // select in positions after current nodes (selection one by one)
     while(selector.NextAngle(angle))                        // angle for free pos
     {
@@ -1581,51 +1588,92 @@ void WorldObject::GetNearPoint(WorldObject const* searcher, float &x, float &y,
 
         if(IsWithinLOS(x,y,z))
             return;
+
+        // Start outputting debug when angle == 0.00
+        if(!angle && !localCounter) {
+                sLog.outError("WorldObject::GetNearPoint: DEBUG START (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
+                localDebug = true;
+        }
+        
+        if(++localCounter > 100) {
+            sLog.outError("WorldObject::GetNearPoint: FIRST WHILE LOOP more then 100 iterations, BREAK (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
+            break;
+        }
     }
 
     // BAD NEWS: not free pos (or used or have LOS problems)
     // Attempt find _used_ pos without LOS problem
+    
+    if(localDebug) sLog.outError("WorldObject::GetNearPoint: CHECKPOINT 1 (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
 
     if(!first_los_conflict)
     {
+        if(localDebug) sLog.outError("WorldObject::GetNearPoint: CHECKPOINT 1A (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
+        
         x = first_x;
         y = first_y;
 
         UpdateGroundPositionZ(x,y,z);                       // update to LOS height if available
+        
+        if(localDebug) sLog.outError("WorldObject::GetNearPoint: RETURN POINT 1 (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
         return;
     }
+    
+    if(localDebug) sLog.outError("WorldObject::GetNearPoint: CHECKPOINT 2 (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
 
     // special case when one from list empty and then empty side preferred
     if( selector.IsNonBalanced() )
     {
+        if(localDebug) sLog.outError("WorldObject::GetNearPoint: CHECKPOINT 2A (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
+        
         if(!selector.FirstAngle(angle))                     // _used_ pos
         {
+            if(localDebug) sLog.outError("WorldObject::GetNearPoint: CHECKPOINT 2B (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
+            
             GetNearPoint2D(x,y,distance2d,absAngle+angle);
             z = GetPositionZ();
             UpdateGroundPositionZ(x,y,z);                   // update to LOS height if available
 
-            if(IsWithinLOS(x,y,z))
+            if(IsWithinLOS(x,y,z)) {
+                if(localDebug) sLog.outError("WorldObject::GetNearPoint: RETURN POINT 2 (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
                 return;
+            }
         }
     }
+    
+    if(localDebug) sLog.outError("WorldObject::GetNearPoint: CHECKPOINT 3 (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
 
     // set first used pos in lists
     selector.InitializeAngle();
+    
+    if(localDebug) sLog.outError("WorldObject::GetNearPoint: CHECKPOINT 4 (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
 
     // select in positions after current nodes (selection one by one)
     while(selector.NextUsedAngle(angle))                    // angle for used pos but maybe without LOS problem
     {
+        if(localDebug) sLog.outError("WorldObject::GetNearPoint: CHECKPOINT 4A (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
+        
         GetNearPoint2D(x,y,distance2d,absAngle+angle);
         z = GetPositionZ();
         UpdateGroundPositionZ(x,y,z);                       // update to LOS height if available
 
-        if(IsWithinLOS(x,y,z))
+        if(IsWithinLOS(x,y,z)) {
+            if(localDebug) sLog.outError("WorldObject::GetNearPoint: RETURN POINT 3 (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
             return;
+        }
+        
+        if(++localCounter2 > 100) {
+            sLog.outError("WorldObject::GetNearPoint: SECOND WHILE LOOP more then 100 iterations, BREAK (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
+            break;
+        }
     }
+    
+    if(localDebug) sLog.outError("WorldObject::GetNearPoint: CHECKPOINT 5 (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
 
     // BAD BAD NEWS: all found pos (free and used) have LOS problem :(
     x = first_x;
     y = first_y;
 
     UpdateGroundPositionZ(x,y,z);                           // update to LOS height if available
+    if(localDebug) sLog.outError("WorldObject::GetNearPoint: RETURN POINT 4 (angle = %f, map_id = %u, x = %f, y = %f, z = %f)", angle, GetMapId(), x, y, z);
 }
diff --git a/src/game/ObjectMgr.cpp b/src/game/ObjectMgr.cpp
index 9ce7fad..c8a90c0 100644
--- a/src/game/ObjectMgr.cpp
+++ b/src/game/ObjectMgr.cpp
@@ -20,6 +20,7 @@
 #include "Database/DatabaseEnv.h"
 #include "Database/SQLStorage.h"
 
+#include "AuctionHouseBot.h"
 #include "Log.h"
 #include "MapManager.h"
 #include "ObjectMgr.h"
@@ -415,6 +416,9 @@ void ObjectMgr::SendAuctionSalePendingMail( AuctionEntry * auction )
 //call this method to send mail to auction owner, when auction is successful, it does not clear ram
 void ObjectMgr::SendAuctionSuccessfulMail( AuctionEntry * auction )
 {
+    if (auction->owner == AuctionHouseBotNoMail())
+        return;
+
     uint64 owner_guid = MAKE_NEW_GUID(auction->owner, 0, HIGHGUID_PLAYER);
     Player *owner = GetPlayer(owner_guid);
 
@@ -1091,6 +1095,7 @@ void ObjectMgr::LoadGameobjects()
         data.spawntimesecs  = fields[11].GetInt32();
         data.animprogress   = fields[12].GetUInt32();
         data.go_state       = fields[13].GetUInt32();
+        data.ArtKit         = 0;
         data.spawnMask      = fields[14].GetUInt8();
         int16 gameEvent     = fields[15].GetInt16();
 
@@ -4785,6 +4790,54 @@ bool ObjectMgr::AddGraveYardLink(uint32 id, uint32 zoneId, uint32 team, bool inD
     return true;
 }
 
+void ObjectMgr::RemoveGraveYardLink(uint32 id, uint32 zoneId, uint32 team, bool inDB)
+{
+    GraveYardMap::iterator graveLow  = mGraveYardMap.lower_bound(zoneId);
+    GraveYardMap::iterator graveUp   = mGraveYardMap.upper_bound(zoneId);
+    if(graveLow==graveUp)
+    {
+        //sLog.outErrorDb("Table `game_graveyard_zone` incomplete: Zone %u Team %u does not have a linked graveyard.",zoneId,team);
+        return;
+    }
+
+    bool found = false;
+
+    GraveYardMap::iterator itr;
+
+    for(itr = graveLow; itr != graveUp; ++itr)
+    {
+        GraveYardData & data = itr->second;
+
+        // skip not matching safezone id
+        if(data.safeLocId != id)
+            continue;
+
+        // skip enemy faction graveyard at same map (normal area, city, or battleground)
+        // team == 0 case can be at call from .neargrave
+        if(data.team != 0 && team != 0 && data.team != team)
+            continue;
+
+        found = true;
+        break;
+    }
+
+    // no match, return
+    if(!found)
+        return;
+
+    // remove from links
+    mGraveYardMap.erase(itr);
+
+    // remove link from DB
+    if(inDB)
+    {
+        WorldDatabase.PExecute("DELETE FROM game_graveyard_zone WHERE id = '%u' AND ghost_zone = '%u' AND faction = '%u'",id,zoneId,team);
+    }
+
+    return;
+}
+
+
 void ObjectMgr::LoadAreaTriggerTeleports()
 {
     mAreaTriggers.clear();                                  // need for reload case
diff --git a/src/game/ObjectMgr.h b/src/game/ObjectMgr.h
index b6997a9..2ad0bb6 100644
--- a/src/game/ObjectMgr.h
+++ b/src/game/ObjectMgr.h
@@ -309,6 +309,8 @@ class ObjectMgr
         ArenaTeam* GetArenaTeamByCapitan(uint64 const& guid) const;
         void AddArenaTeam(ArenaTeam* arenateam) { mArenaTeamSet.insert( arenateam ); }
         void RemoveArenaTeam(ArenaTeam* arenateam) { mArenaTeamSet.erase( arenateam ); }
+        ArenaTeamSet::iterator GetArenaTeamSetBegin() { return mArenaTeamSet.begin(); }
+        ArenaTeamSet::iterator GetArenaTeamSetEnd() { return mArenaTeamSet.end(); }
 
         static CreatureInfo const *GetCreatureTemplate( uint32 id );
         CreatureModelInfo const *GetCreatureModelInfo( uint32 modelid );
@@ -436,6 +438,7 @@ class ObjectMgr
 
         WorldSafeLocsEntry const *GetClosestGraveYard(float x, float y, float z, uint32 MapId, uint32 team);
         bool AddGraveYardLink(uint32 id, uint32 zone, uint32 team, bool inDB = true);
+        void RemoveGraveYardLink(uint32 id, uint32 zone, uint32 team, bool inDB = false);
         void LoadGraveyardZones();
         GraveYardData const* FindGraveYardData(uint32 id, uint32 zone);
 
diff --git a/src/game/ObjectPosSelector.cpp b/src/game/ObjectPosSelector.cpp
index 6855e21..f682c2e 100644
--- a/src/game/ObjectPosSelector.cpp
+++ b/src/game/ObjectPosSelector.cpp
@@ -17,6 +17,7 @@
  */
 
 #include "ObjectPosSelector.h"
+#include "Log.h"
 
 ObjectPosSelector::ObjectPosSelector(float x,float y,float size,float dist)
 : m_center_x(x),m_center_y(y),m_size(size),m_dist(dist)
@@ -99,14 +100,32 @@ bool ObjectPosSelector::NextAngle(float& angle)
 
 bool ObjectPosSelector::NextUsedAngle(float& angle)
 {
+    // Debugging LoS problem when angle == 0.00, set some vars
+    bool localDebug = false;
+    uint32 localCounter = 0;
+    
+    // Start outputting debug when angle == 0.00
+    if(!angle) {
+        sLog.outError("ObjectPosSelector::NextUsedAngle: DEBUG START (angle = %f)", angle);
+        localDebug = true;
+    }
+    
     while(m_nextUsedPos[USED_POS_PLUS]!=m_UsedPosLists[USED_POS_PLUS].end() ||
         m_nextUsedPos[USED_POS_MINUS]!=m_UsedPosLists[USED_POS_MINUS].end() )
     {
         // calculate next possible angle
-        if(!NextPosibleAngle(angle))
+        if(!NextPosibleAngle(angle)) {
+            if(localDebug) sLog.outError("ObjectPosSelector::NextUsedAngle: RETURN POINT 1 (angle = %f)", angle);
             return true;
+        }
+            
+        if(++localCounter > 100) {
+            sLog.outError("ObjectPosSelector::NextUsedAngle: WHILE LOOP more then 100 iterations, BREAK (angle = %f)", angle);
+            break;
+        }
     }
 
+    if(localDebug) sLog.outError("ObjectPosSelector::NextUsedAngle: RETURN POINT 2 (angle = %f)", angle);
     return false;
 }
 
diff --git a/src/game/OutdoorPvP.cpp b/src/game/OutdoorPvP.cpp
new file mode 100644
index 0000000..a043398
--- /dev/null
+++ b/src/game/OutdoorPvP.cpp
@@ -0,0 +1,726 @@
+#include "OutdoorPvP.h"
+#include "OutdoorPvPMgr.h"
+#include "ObjectAccessor.h"
+#include "ObjectMgr.h"
+#include "Map.h"
+#include "MapManager.h"
+#include "OutdoorPvPObjectiveAI.h"
+#include "Group.h"
+#include "WorldPacket.h"
+
+OutdoorPvPObjective::OutdoorPvPObjective(OutdoorPvP * pvp) 
+: m_PvP(pvp), m_AllianceActivePlayerCount(0), m_HordeActivePlayerCount(0),
+m_ShiftTimer(0), m_ShiftPhase(0), m_ShiftMaxPhase(0), m_OldPhase(0),
+m_State(0), m_OldState(0), m_CapturePoint(0), m_NeutralValue(0), m_ShiftMaxCaptureSpeed(0), m_CapturePointCreature(0)
+{
+}
+
+bool OutdoorPvPObjective::HandlePlayerEnter(Player * plr)
+{
+    // only called if really entered, so no use in the return value anymore
+    // player distance and activity state was checked already in the AI
+    std::set<uint64>::iterator pitr = m_ActivePlayerGuids.find(plr->GetGUID());
+    // if not already counted as active, add player
+    if(pitr == m_ActivePlayerGuids.end())
+    {
+        if(plr->GetTeam() == ALLIANCE)
+            ++m_AllianceActivePlayerCount;
+        else
+            ++m_HordeActivePlayerCount;
+        m_ActivePlayerGuids.insert(plr->GetGUID());
+        sLog.outDebug("player %u entered an outdoorpvpobjective", plr->GetGUIDLow());
+        return true;
+    }
+    return true;
+}
+
+void OutdoorPvPObjective::HandlePlayerLeave(Player * plr)
+{
+    // only decrease the count if the player is in the active list
+    if(m_ActivePlayerGuids.find(plr->GetGUID())!=m_ActivePlayerGuids.end())
+    {
+        if(plr->GetTeam() == ALLIANCE)
+            --m_AllianceActivePlayerCount;
+        else
+            --m_HordeActivePlayerCount;
+        m_ActivePlayerGuids.erase(plr->GetGUID());
+    }
+}
+
+void OutdoorPvPObjective::HandlePlayerActivityChanged(Player * plr)
+{
+    if(m_CapturePointCreature)
+        if(Creature * c = HashMapHolder<Creature>::Find(m_CapturePointCreature))
+            if(c->AI())
+                c->AI()->MoveInLineOfSight(plr);
+}
+
+bool OutdoorPvPObjective::AddObject(uint32 type, uint32 entry, uint32 map, float x, float y, float z, float o, float rotation0, float rotation1, float rotation2, float rotation3)
+{
+    GameObjectInfo const* goinfo = objmgr.GetGameObjectInfo(entry);
+    if (!goinfo)
+        return false;
+
+    uint32 guid = objmgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT);
+
+    GameObjectData& data = objmgr.NewGOData(guid);
+
+    data.id             = entry;
+    data.mapid          = map;
+    data.posX           = x;
+    data.posY           = y;
+    data.posZ           = z;
+    data.orientation    = o;
+    data.rotation0      = rotation0;
+    data.rotation1      = rotation1;
+    data.rotation2      = rotation2;
+    data.rotation3      = rotation3;
+    data.spawntimesecs  = 0;
+    data.animprogress   = 100;
+    data.spawnMask      = 1;
+    data.go_state       = 1;
+
+    objmgr.AddGameobjectToGrid(guid, &data);
+
+    // 2 way registering
+    m_Objects[type] = MAKE_NEW_GUID(guid, entry, HIGHGUID_GAMEOBJECT);
+    m_ObjectTypes[m_Objects[type]]=type;
+
+    Map * pMap = MapManager::Instance().FindMap(map);
+    if(!pMap)
+        return true;
+    GameObject * go = new GameObject;
+    if(!go->Create(guid,entry, pMap,x,y,z,o,rotation0,rotation1,rotation2,rotation3,100,1))
+    {
+        sLog.outError("Gameobject template %u not found in database.", entry);
+        delete go;
+        return true;
+    }
+
+    go->SetRespawnTime(0);
+    objmgr.SaveGORespawnTime(go->GetDBTableGUIDLow(),0,0);
+    pMap->Add(go);
+
+    return true;
+}
+
+bool OutdoorPvPObjective::AddCreature(uint32 type, uint32 entry, uint32 teamval, uint32 map, float x, float y, float z, float o, uint32 spawntimedelay)
+{
+    CreatureInfo const *cinfo = objmgr.GetCreatureTemplate(entry);
+    if(!cinfo)
+    {
+        return false;
+    }
+
+    uint32 displayId = objmgr.ChooseDisplayId(teamval, cinfo, NULL);
+    CreatureModelInfo const *minfo = objmgr.GetCreatureModelRandomGender(displayId);
+    if (!minfo)
+    {
+        return false;
+    }
+    else
+        displayId = minfo->modelid;                        // it can be different (for another gender)
+
+    uint32 guid = objmgr.GenerateLowGuid(HIGHGUID_UNIT);
+
+    CreatureData& data = objmgr.NewOrExistCreatureData(guid);
+
+    data.id = entry;
+    data.mapid = map;
+    data.displayid = displayId;
+    data.equipmentId = cinfo->equipmentId;
+    data.posX = x;
+    data.posY = y;
+    data.posZ = z;
+    data.orientation = o;
+    data.spawntimesecs = spawntimedelay;
+    data.spawndist = 0;
+    data.currentwaypoint = 0;
+    data.curhealth = cinfo->maxhealth;
+    data.curmana = cinfo->maxmana;
+    data.is_dead = false;
+    data.movementType = cinfo->MovementType;
+    data.spawnMask = 1;
+
+    objmgr.AddCreatureToGrid(guid, &data);
+
+    m_Creatures[type] = MAKE_NEW_GUID(guid, entry, HIGHGUID_UNIT);
+    m_CreatureTypes[m_Creatures[type]] = type;
+
+    Map * pMap = MapManager::Instance().FindMap(map);
+    if(!pMap)
+        return true;
+    Creature* pCreature = new Creature;
+    if (!pCreature->Create(guid, pMap, entry, teamval))
+    {
+        sLog.outError("Can't create creature entry: %u",entry);
+        delete pCreature;
+        return true;
+    }
+
+    pCreature->AIM_Initialize();
+
+    pCreature->Relocate(x, y, z, o);
+
+    if(!pCreature->IsPositionValid())
+    {
+        sLog.outError("ERROR: Creature (guidlow %d, entry %d) not added to opvp. Suggested coordinates isn't valid (X: %f Y: %f)",pCreature->GetGUIDLow(),pCreature->GetEntry(),pCreature->GetPositionX(),pCreature->GetPositionY());
+        return false;
+    }
+
+    if(spawntimedelay)
+        pCreature->SetRespawnDelay(spawntimedelay);
+
+    pMap->Add(pCreature);
+
+    return true;
+}
+
+bool OutdoorPvPObjective::AddCapturePoint(uint32 entry, uint32 map, float x, float y, float z, float o, float rotation0, float rotation1, float rotation2, float rotation3)
+{
+    sLog.outDebug("creating capture point %u and capture point creature",entry);
+
+    // check info existence
+    GameObjectInfo const* goinfo = objmgr.GetGameObjectInfo(entry);
+    if (!goinfo)
+        return false;
+
+    CreatureInfo const *cinfo = objmgr.GetCreatureTemplate(OPVP_TRIGGER_CREATURE_ENTRY);
+    if(!cinfo)
+        return false;
+
+    // create capture point creature
+    uint32 displayId = objmgr.ChooseDisplayId(0, cinfo, NULL);
+
+    uint32 creature_guid = objmgr.GenerateLowGuid(HIGHGUID_UNIT);
+
+    CreatureData& cdata = objmgr.NewOrExistCreatureData(creature_guid);
+
+    cdata.id = OPVP_TRIGGER_CREATURE_ENTRY;
+    cdata.mapid = map;
+    cdata.displayid = displayId;
+    cdata.equipmentId = cinfo->equipmentId;
+    cdata.posX = x;
+    cdata.posY = y;
+    cdata.posZ = z;
+    cdata.orientation = o;
+    cdata.spawntimesecs = 1;
+    cdata.spawndist = 0;
+    cdata.currentwaypoint = 0;
+    cdata.curhealth = cinfo->maxhealth;
+    cdata.curmana = cinfo->maxmana;
+    cdata.is_dead = false;
+    cdata.movementType = cinfo->MovementType;
+    cdata.spawnMask = 1;
+
+    objmgr.AddCreatureToGrid(creature_guid, &cdata);
+    m_CapturePointCreature = MAKE_NEW_GUID(creature_guid, OPVP_TRIGGER_CREATURE_ENTRY, HIGHGUID_UNIT);
+
+    // create capture point go
+    uint32 guid = objmgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT);
+
+    GameObjectData& data = objmgr.NewGOData(guid);
+
+    data.id             = entry;
+    data.mapid          = map;
+    data.posX           = x;
+    data.posY           = y;
+    data.posZ           = z;
+    data.orientation    = o;
+    data.rotation0      = rotation0;
+    data.rotation1      = rotation1;
+    data.rotation2      = rotation2;
+    data.rotation3      = rotation3;
+    data.spawntimesecs  = 1;
+    data.animprogress   = 100;
+    data.spawnMask      = 1;
+    data.go_state       = 1;
+
+    objmgr.AddGameobjectToGrid(guid, &data);
+
+    m_CapturePoint = MAKE_NEW_GUID(guid, entry, HIGHGUID_GAMEOBJECT);
+
+    // get the needed values from goinfo
+    m_ShiftMaxPhase = goinfo->raw.data[17];
+    m_ShiftMaxCaptureSpeed = m_ShiftMaxPhase / float(goinfo->raw.data[16]);
+    m_NeutralValue = goinfo->raw.data[12];
+
+    // add to map if map is already loaded
+    Map * pMap = MapManager::Instance().FindMap(map);
+    if(!pMap)
+        return true;
+    // add GO...
+    GameObject * go = new GameObject;
+    if(!go->Create(guid,entry, pMap,x,y,z,o,rotation0,rotation1,rotation2,rotation3,100,1))
+    {
+        sLog.outError("Gameobject template %u not found in database.", entry);
+        delete go;
+    }
+    else
+    {
+        go->SetRespawnTime(0);
+        objmgr.SaveGORespawnTime(go->GetDBTableGUIDLow(), 0, 0);
+        pMap->Add(go);
+    }
+    // add creature...
+    Creature* pCreature = new Creature;
+    if (!pCreature->Create(creature_guid, pMap, OPVP_TRIGGER_CREATURE_ENTRY, 0))
+    {
+        sLog.outError("Can't create creature entry: %u",entry);
+        delete pCreature;
+    }
+    else
+    {
+        pCreature->AIM_Initialize();
+
+        pCreature->Relocate(x, y, z, o);
+
+        if(!pCreature->IsPositionValid())
+        {
+            sLog.outError("ERROR: Creature (guidlow %d, entry %d) not added to opvp. Suggested coordinates isn't valid (X: %f Y: %f)",pCreature->GetGUIDLow(),pCreature->GetEntry(),pCreature->GetPositionX(),pCreature->GetPositionY());
+            return false;
+        }
+
+        pMap->Add(pCreature);
+    }
+    return true;
+}
+
+bool OutdoorPvPObjective::DelCreature(uint32 type)
+{
+    if(!m_Creatures[type])
+    {
+        sLog.outDebug("opvp creature type %u was already deleted",type);
+        return false;
+    }
+
+    Creature *cr = HashMapHolder<Creature>::Find(m_Creatures[type]);
+    if(!cr)
+    {
+        sLog.outError("Can't find creature guid: %u",m_Creatures[type]);
+        return false;
+    }
+    sLog.outDebug("deleting opvp creature type %u",type);
+    uint32 guid = cr->GetDBTableGUIDLow();
+    // dont save respawn time
+    cr->SetRespawnTime(0);
+    cr->RemoveCorpse();
+    cr->CleanupsBeforeDelete();
+    // explicit removal from map
+    // beats me why this is needed, but with the recent removal "cleanup" some creatures stay in the map if "properly" deleted
+    // so this is a big fat workaround, if AddObjectToRemoveList and DoDelayedMovesAndRemoves worked correctly, this wouldn't be needed
+    if(Map * map = MapManager::Instance().FindMap(cr->GetMapId()))
+        map->Remove(cr,false);
+    // delete respawn time for this creature
+    WorldDatabase.PExecute("DELETE FROM creature_respawn WHERE guid = '%u'", guid);
+    cr->AddObjectToRemoveList();
+    objmgr.DeleteCreatureData(guid);
+    m_CreatureTypes[m_Creatures[type]] = 0;
+    m_Creatures[type] = 0;
+    return true;
+}
+
+bool OutdoorPvPObjective::DelObject(uint32 type)
+{
+    if(!m_Objects[type])
+        return false;
+
+    GameObject *obj = HashMapHolder<GameObject>::Find(m_Objects[type]);
+    if(!obj)
+    {
+        sLog.outError("Can't find gobject guid: %u",m_Objects[type]);
+        return false;
+    }
+    uint32 guid = obj->GetDBTableGUIDLow();
+    obj->SetRespawnTime(0);                                 // not save respawn time
+    obj->Delete();
+    objmgr.DeleteGOData(guid);
+    m_ObjectTypes[m_Objects[type]] = 0;
+    m_Objects[type] = 0;
+    return true;
+}
+
+bool OutdoorPvPObjective::DelCapturePoint()
+{
+    if(!m_CapturePoint)
+        return false;
+
+    GameObject *obj = HashMapHolder<GameObject>::Find(m_CapturePoint);
+    if(!obj)
+    {
+        sLog.outError("Can't find gobject guid: %u",m_CapturePoint);
+        return false;
+    }
+    uint32 guid = obj->GetDBTableGUIDLow();
+    obj->SetRespawnTime(0);                                 // not save respawn time
+    obj->Delete();
+    objmgr.DeleteGOData(guid);
+    m_CapturePoint = 0;
+    return true;
+}
+
+void OutdoorPvPObjective::DeleteSpawns()
+{
+    for(std::map<uint32,uint64>::iterator i = m_Objects.begin(); i != m_Objects.end(); ++i)
+        DelObject(i->first);
+    for(std::map<uint32,uint64>::iterator i = m_Creatures.begin(); i != m_Creatures.end(); ++i)
+        DelCreature(i->first);
+    DelCapturePoint();
+}
+
+void OutdoorPvP::DeleteSpawns()
+{
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+        (*itr)->DeleteSpawns();
+}
+
+OutdoorPvP::OutdoorPvP()
+{
+}
+
+OutdoorPvP::~OutdoorPvP()
+{
+    DeleteSpawns();
+}
+
+void OutdoorPvP::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    if(plr->GetTeam()==ALLIANCE)
+        m_PlayerGuids[0].insert(plr->GetGUID());
+    else
+        m_PlayerGuids[1].insert(plr->GetGUID());
+}
+
+void OutdoorPvP::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // inform the objectives of the leaving
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+        (*itr)->HandlePlayerLeave(plr);
+    // remove the world state information from the player (we can't keep everyone up to date, so leave out those who are not in the concerning zones)
+    if(zone != plr->GetZoneId())
+        SendRemoveWorldStates(plr);
+    if(plr->GetTeam()==ALLIANCE)
+        m_PlayerGuids[0].erase(plr->GetGUID());
+    else
+        m_PlayerGuids[1].erase(plr->GetGUID());
+    sLog.outDebug("player left an outdoorpvp zone");
+}
+
+bool OutdoorPvP::Update(uint32 diff)
+{
+    bool objective_changed = false;
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+        objective_changed |= (*itr)->Update(diff);
+    return objective_changed;
+}
+
+bool OutdoorPvPObjective::Update(uint32 diff)
+{
+    uint32 Challenger = 0;
+    if(m_ShiftTimer<diff)
+    {
+        m_ShiftTimer = OUTDOORPVP_OBJECTIVE_UPDATE_INTERVAL;
+
+        // get the difference of numbers
+        float fact_diff = (m_AllianceActivePlayerCount - m_HordeActivePlayerCount);
+
+        if(fact_diff<0)
+        {
+            if(fact_diff < - m_ShiftMaxCaptureSpeed)
+                fact_diff = - m_ShiftMaxCaptureSpeed;
+            Challenger = HORDE;
+            // horde is in majority, but it's already horde-controlled -> no change
+            if(m_State == OBJECTIVESTATE_HORDE && m_ShiftPhase == - m_ShiftMaxPhase)
+                return false;
+        }
+        else if(fact_diff>0)
+        {
+            if(fact_diff > m_ShiftMaxCaptureSpeed)
+                fact_diff = m_ShiftMaxCaptureSpeed;
+            Challenger = ALLIANCE;
+            // ally is in majority, but it's already ally-controlled -> no change
+            if(m_State == OBJECTIVESTATE_ALLIANCE && m_ShiftPhase == m_ShiftMaxPhase)
+                return false;
+        }
+        else /*if(fact_diff==0)*/ // no change
+            return false;
+
+        m_OldPhase = m_ShiftPhase;
+
+        m_OldState = m_State;
+
+        m_ShiftPhase += fact_diff;
+
+        // check limits, these are over the grey part
+        if(m_ShiftPhase <= - m_ShiftMaxPhase * (float)(m_NeutralValue) / 100.0f)
+        {
+            if(m_ShiftPhase <= - m_ShiftMaxPhase)
+                m_ShiftPhase = - m_ShiftMaxPhase;
+            m_State = OBJECTIVESTATE_HORDE;
+            return true;
+        }
+        else if(m_ShiftPhase >= m_ShiftMaxPhase * (float)(m_NeutralValue) / 100.0f)
+        {
+            if(m_ShiftPhase >= m_ShiftMaxPhase)
+                m_ShiftPhase = m_ShiftMaxPhase;
+            m_State = OBJECTIVESTATE_ALLIANCE;
+            return true;
+        }
+
+        if(m_OldPhase*m_ShiftPhase <=0)
+        {
+            // gone through neutral
+            // if challenger is ally, then n->a challenge
+            if(Challenger == ALLIANCE)
+                m_State = OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE;
+            // if challenger is horde, then n->h challenge
+            else if(Challenger == HORDE)
+                m_State = OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE;
+        }
+        else
+        {
+            // old phase and current are on the same side, so one team challenges the other
+            if(Challenger == ALLIANCE && (m_OldState == OBJECTIVESTATE_HORDE || m_OldState == OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE))
+                m_State = OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE;
+            else if(Challenger == HORDE && (m_OldState == OBJECTIVESTATE_ALLIANCE || m_OldState == OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE))
+                m_State = OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE;
+        }
+
+        return true;
+    } else m_ShiftTimer-=diff;
+
+    return false;
+}
+
+bool OutdoorPvPObjective::HandleCaptureCreaturePlayerMoveInLos(Player * p, Creature * c)
+{
+    // check if guid matches
+    if(c->GetGUID() != m_CapturePointCreature)
+        return false;
+
+    // check if capture point go is spawned
+    GameObject * cp = HashMapHolder<GameObject>::Find(m_CapturePoint);
+    if(!cp)
+        return false;
+
+    // check range and activity
+    if(cp->IsWithinDistInMap(p,cp->GetGOInfo()->raw.data[0]) && p->IsOutdoorPvPActive())
+    {
+        // data[8] will be used for player enter
+        return HandleCapturePointEvent(p, cp->GetGOInfo()->raw.data[8]); //i_objective->HandlePlayerEnter((Player*)u);
+    }
+    else
+    {
+        // data[9] will be used for player leave
+        return HandleCapturePointEvent(p, cp->GetGOInfo()->raw.data[9]); //i_objective->HandlePlayerLeave((Player*)u);
+    }
+}
+
+void OutdoorPvP::SendUpdateWorldState(uint32 field, uint32 value)
+{
+    // send to both factions
+    for(int i = 0; i < 2; ++i)
+    {
+        // send to all players present in the area
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[i].begin(); itr != m_PlayerGuids[i].end(); ++itr)
+        {
+            Player * plr = objmgr.GetPlayer(*itr);
+            if(plr)
+            {
+                plr->SendUpdateWorldState(field,value);
+            }
+        }
+    }
+}
+
+void OutdoorPvPObjective::SendUpdateWorldState(uint32 field, uint32 value)
+{
+    // send to all players present in the area
+    for(std::set<uint64>::iterator itr = m_ActivePlayerGuids.begin(); itr != m_ActivePlayerGuids.end(); ++itr)
+    {
+        Player * plr = objmgr.GetPlayer(*itr);
+        if(plr)
+        {
+            plr->SendUpdateWorldState(field,value);
+        }
+    }
+}
+
+void OutdoorPvPObjective::SendObjectiveComplete(uint32 id,uint64 guid)
+{
+    uint32 controlling_faction;
+    switch(m_State)
+    {
+    case OBJECTIVESTATE_ALLIANCE:
+        controlling_faction = ALLIANCE;
+        break;
+    case OBJECTIVESTATE_HORDE:
+        controlling_faction = HORDE;
+        break;
+    default:
+        return;
+        break;
+    }
+
+    // send to all players present in the area
+    for(std::set<uint64>::iterator itr = m_ActivePlayerGuids.begin(); itr != m_ActivePlayerGuids.end(); ++itr)
+    {
+        Player * plr = objmgr.GetPlayer(*itr);
+        if(plr && plr->GetTeam() == controlling_faction)
+        {
+            plr->KilledMonster(id,guid);
+        }
+    }
+}
+
+void OutdoorPvP::HandlePlayerActivityChanged(Player * plr)
+{
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+        (*itr)->HandlePlayerActivityChanged(plr);
+}
+
+void OutdoorPvP::HandleKill(Player *killer, Unit * killed)
+{
+    if(Group * pGroup = killer->GetGroup())
+    {
+        for(GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player *pGroupGuy = itr->getSource();
+
+            if(!pGroupGuy)
+                continue;
+
+            // skip if too far away
+            if(!pGroupGuy->IsAtGroupRewardDistance(killed))
+                continue;
+
+            // creature kills must be notified, even if not inside objective / not outdoor pvp active
+            // player kills only count if active and inside objective
+            if(( pGroupGuy->IsOutdoorPvPActive() && IsInsideObjective(pGroupGuy) ) || killed->GetTypeId() == TYPEID_UNIT)
+            {
+                HandleKillImpl(pGroupGuy, killed);
+            }
+        }
+    }
+    else
+    {
+        // creature kills must be notified, even if not inside objective / not outdoor pvp active
+        if(killer && (( killer->IsOutdoorPvPActive() && IsInsideObjective(killer) ) || killed->GetTypeId() == TYPEID_UNIT))
+        {
+            HandleKillImpl(killer, killed);
+        }
+    }
+}
+
+bool OutdoorPvP::IsInsideObjective(Player *plr)
+{
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        if((*itr)->IsInsideObjective(plr))
+            return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPObjective::IsInsideObjective(Player *plr)
+{
+    std::set<uint64>::iterator itr = m_ActivePlayerGuids.find(plr->GetGUID());
+    return itr != m_ActivePlayerGuids.end();
+}
+
+bool OutdoorPvP::HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go)
+{
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        if((*itr)->HandleCustomSpell(plr,spellId,go))
+            return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPObjective::HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go)
+{
+    if(!plr->IsOutdoorPvPActive())
+        return false;
+    return false;
+}
+
+bool OutdoorPvP::HandleOpenGo(Player *plr, uint64 guid)
+{
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        if((*itr)->HandleOpenGo(plr,guid) >= 0)
+            return true;
+    }
+    return false;
+}
+
+bool OutdoorPvP::HandleCaptureCreaturePlayerMoveInLos(Player * p, Creature * c)
+{
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        if((*itr)->HandleCaptureCreaturePlayerMoveInLos(p, c))
+            return true;
+    }
+    return false;
+}
+
+bool OutdoorPvP::HandleGossipOption(Player * plr, uint64 guid, uint32 id)
+{
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        if((*itr)->HandleGossipOption(plr, guid, id))
+            return true;
+    }
+    return false;
+}
+
+bool OutdoorPvP::CanTalkTo(Player * plr, Creature * c, GossipOption &gso)
+{
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        if((*itr)->CanTalkTo(plr, c, gso))
+            return true;
+    }
+    return false;
+}
+
+bool OutdoorPvP::HandleDropFlag(Player * plr, uint32 id)
+{
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        if((*itr)->HandleDropFlag(plr, id))
+            return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPObjective::HandleGossipOption(Player * plr, uint64 guid, uint32 id)
+{
+    return false;
+}
+
+bool OutdoorPvPObjective::CanTalkTo(Player * plr, Creature * c, GossipOption &gso)
+{
+    return false;
+}
+
+bool OutdoorPvPObjective::HandleDropFlag(Player * plr, uint32 id)
+{
+    return false;
+}
+
+int32 OutdoorPvPObjective::HandleOpenGo(Player *plr, uint64 guid)
+{
+    std::map<uint64,uint32>::iterator itr = m_ObjectTypes.find(guid);
+    if(itr != m_ObjectTypes.end())
+    {
+        return itr->second;   
+    }
+    return -1;
+}
+
+bool OutdoorPvP::HandleAreaTrigger(Player *plr, uint32 trigger)
+{
+    return false;
+}
diff --git a/src/game/OutdoorPvP.h b/src/game/OutdoorPvP.h
new file mode 100644
index 0000000..c5dbeb8
--- /dev/null
+++ b/src/game/OutdoorPvP.h
@@ -0,0 +1,211 @@
+#ifndef OUTDOOR_PVP_H_
+#define OUTDOOR_PVP_H_
+
+#include "Util.h"
+
+#include <map>
+#include <set>
+
+#define OUTDOORPVP_OBJECTIVE_UPDATE_INTERVAL 1000
+
+#define OPVP_TRIGGER_CREATURE_ENTRY 12999
+
+enum ObjectiveStates{
+    OBJECTIVESTATE_NEUTRAL = 0,
+    OBJECTIVESTATE_ALLIANCE = 1,
+    OBJECTIVESTATE_HORDE = 2,
+    OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE = 3,
+    OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE = 4,
+    OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE = 5,
+    OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE = 6
+};
+
+enum OutdoorPvPTypes{
+    OUTDOOR_PVP_HP = 1,
+    OUTDOOR_PVP_NA = 2,
+    OUTDOOR_PVP_TF = 3,
+    OUTDOOR_PVP_ZM = 4,
+    OUTDOOR_PVP_SI = 5,
+    OUTDOOR_PVP_EP = 6
+};
+
+// struct for go spawning
+struct go_type{
+    uint32 entry;
+    uint32 map;
+    float x;
+    float y;
+    float z;
+    float o;
+    float rot0;
+    float rot1;
+    float rot2;
+    float rot3;
+};
+
+// struct for creature spawning
+struct creature_type{
+    uint32 entry;
+    uint32 teamval;
+    uint32 map;
+    float x;
+    float y;
+    float z;
+    float o;
+};
+
+// some class predefs
+class Player;
+class GameObject;
+class WorldPacket;
+class Creature;
+class Unit;
+struct GossipOption;
+
+class OutdoorPvP;
+class OutdoorPvPObjective
+{
+public:
+    OutdoorPvPObjective(OutdoorPvP * pvp);
+
+    virtual void FillInitialWorldStates(WorldPacket & data) {}
+
+    // send world state update to all players present
+    virtual void SendUpdateWorldState(uint32 field, uint32 value);
+    // send kill notify to players in the controlling faction
+    virtual void SendObjectiveComplete(uint32 id, uint64 guid);
+
+    // used when player is activated/inactivated in the area
+    virtual bool HandlePlayerEnter(Player * plr);
+    virtual void HandlePlayerLeave(Player * plr);
+    virtual void HandlePlayerActivityChanged(Player * plr);
+
+    // checks if player is in range of a capture credit marker
+    virtual bool IsInsideObjective(Player * plr);
+
+    virtual bool HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go);
+    virtual int32 HandleOpenGo(Player *plr, uint64 guid);
+
+    // returns true if the state of the objective has changed, in this case, the OutdoorPvP must send a world state ui update.
+    virtual bool Update(uint32 diff);
+
+    virtual bool HandleCapturePointEvent(Player * plr, uint32 eventId) { return false; }
+
+    virtual bool HandleCaptureCreaturePlayerMoveInLos(Player * p, Creature * c);
+
+    virtual bool HandleGossipOption(Player *plr, uint64 guid, uint32 gossipid);
+
+    virtual bool CanTalkTo(Player * plr, Creature * c, GossipOption &gso);
+
+    virtual bool HandleDropFlag(Player * plr, uint32 spellId);
+
+    virtual void DeleteSpawns();
+protected:
+
+    virtual bool AddCapturePoint(uint32 entry, uint32 map, float x, float y, float z, float o, float rotation0, float rotation1, float rotation2, float rotation3);
+    virtual bool AddObject(uint32 type, uint32 entry, uint32 map, float x, float y, float z, float o, float rotation0, float rotation1, float rotation2, float rotation3);
+    virtual bool AddCreature(uint32 type, uint32 entry, uint32 teamval, uint32 map, float x, float y, float z, float o, uint32 spawntimedelay = 0);
+
+    virtual bool DelCreature(uint32 type);
+    virtual bool DelObject(uint32 type);
+    virtual bool DelCapturePoint();
+
+protected:
+    // active players in the area of the objective
+    std::set<uint64> m_ActivePlayerGuids;
+    int32 m_AllianceActivePlayerCount;
+    int32 m_HordeActivePlayerCount;
+    // time left to capture the objective
+    uint32 m_ShiftTimer;
+    // total shift needed to capture the objective
+    float m_ShiftMaxPhase;
+    // maximum speed of capture
+    float m_ShiftMaxCaptureSpeed;
+    // the status of the objective
+    float m_ShiftPhase;
+    // phase before update, used to check which faction is in conquer / control
+    float m_OldPhase;
+    // objective states
+    uint32 m_OldState;
+    uint32 m_State;
+    // neutral value on capture bar
+    uint32 m_NeutralValue;
+
+    // pointer to the OutdoorPvP this objective belongs to
+    OutdoorPvP* m_PvP;
+
+    // map to store the various gameobjects and creatures spawned by the objective
+    //        type , guid
+    std::map<uint32,uint64> m_Objects;
+    std::map<uint32,uint64> m_Creatures;
+    std::map<uint64,uint32> m_ObjectTypes;
+    std::map<uint64,uint32> m_CreatureTypes;
+    uint64 m_CapturePoint;
+    uint64 m_CapturePointCreature;
+};
+
+// base class for specific outdoor pvp handlers
+class OutdoorPvP
+{
+public:
+    // ctor
+    OutdoorPvP();
+    // dtor
+    ~OutdoorPvP();
+    // deletes all gos/creatures spawned by the pvp
+    void DeleteSpawns();
+
+    typedef std::set<OutdoorPvPObjective *> OutdoorPvPObjectiveSet;
+
+    // called from Player::UpdateZone to add / remove buffs given by outdoor pvp events
+    virtual void HandlePlayerEnterZone(Player * plr, uint32 zone);
+    virtual void HandlePlayerLeaveZone(Player * plr, uint32 zone);
+    virtual void HandlePlayerActivityChanged(Player * plr);
+    // called when a player triggers an areatrigger
+    virtual bool HandleAreaTrigger(Player * plr, uint32 trigger);
+    // called on custom spell
+    virtual bool HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go);
+    // called on go use
+    virtual bool HandleOpenGo(Player *plr, uint64 guid);
+    // called from moveinlineofsight
+    virtual bool HandleCaptureCreaturePlayerMoveInLos(Player * p, Creature * c);
+
+    // setup stuff
+    virtual bool SetupOutdoorPvP() {return true;}
+
+    // world state stuff
+    virtual void SendRemoveWorldStates(Player * plr) {}
+    virtual void FillInitialWorldStates(WorldPacket & data) {}
+
+    // send world state update to all players present
+    virtual void SendUpdateWorldState(uint32 field, uint32 value);
+
+    // called by OutdoorPvPMgr, updates the objectives and if needed, sends new worldstateui information
+    virtual bool Update(uint32 diff);
+
+    // handle npc/player kill
+    virtual void HandleKill(Player * killer, Unit * killed);
+    virtual void HandleKillImpl(Player * killer, Unit * killed) {}
+
+    // checks if player is in range of a capture credit marker
+    virtual bool IsInsideObjective(Player * plr);
+
+    // awards rewards for player kill
+    virtual void AwardKillBonus(Player * plr) {}
+
+    uint32 GetTypeId() {return m_TypeId;}
+
+    virtual bool HandleDropFlag(Player * plr, uint32 spellId);
+
+    virtual bool HandleGossipOption(Player *plr, uint64 guid, uint32 gossipid);
+
+    virtual bool CanTalkTo(Player * plr, Creature * c, GossipOption &gso);
+protected:
+    // the map of the objectives belonging to this outdoorpvp
+    OutdoorPvPObjectiveSet m_OutdoorPvPObjectives;
+    // players in the zones of this outdoorpvp, 0 - alliance, 1 - horde
+    std::set<uint64> m_PlayerGuids[2];
+    uint32 m_TypeId;
+};
+
+#endif /*OUTDOOR_PVP_H_*/
diff --git a/src/game/OutdoorPvPEP.cpp b/src/game/OutdoorPvPEP.cpp
new file mode 100644
index 0000000..dd6ae0f
--- /dev/null
+++ b/src/game/OutdoorPvPEP.cpp
@@ -0,0 +1,878 @@
+#include "OutdoorPvPEP.h"
+#include "WorldPacket.h"
+#include "Player.h"
+#include "GameObject.h"
+#include "ObjectMgr.h"
+#include "ObjectAccessor.h"
+#include "OutdoorPvPMgr.h"
+#include "Creature.h"
+#include "Language.h"
+#include "World.h"
+
+OutdoorPvPObjectiveEP_EWT::OutdoorPvPObjectiveEP_EWT(OutdoorPvP *pvp)
+: OutdoorPvPObjective(pvp), m_TowerState(EP_TS_N)
+{
+    AddCapturePoint(EPCapturePoints[EP_EWT].entry,EPCapturePoints[EP_EWT].map,EPCapturePoints[EP_EWT].x,EPCapturePoints[EP_EWT].y,EPCapturePoints[EP_EWT].z,EPCapturePoints[EP_EWT].o,EPCapturePoints[EP_EWT].rot0,EPCapturePoints[EP_EWT].rot1,EPCapturePoints[EP_EWT].rot2,EPCapturePoints[EP_EWT].rot3);
+    AddObject(EP_EWT_FLAGS,EPTowerFlags[EP_EWT].entry,EPTowerFlags[EP_EWT].map,EPTowerFlags[EP_EWT].x,EPTowerFlags[EP_EWT].y,EPTowerFlags[EP_EWT].z,EPTowerFlags[EP_EWT].o,EPTowerFlags[EP_EWT].rot0,EPTowerFlags[EP_EWT].rot1,EPTowerFlags[EP_EWT].rot2,EPTowerFlags[EP_EWT].rot3);
+}
+
+bool OutdoorPvPObjectiveEP_EWT::Update(uint32 diff)
+{
+    if(OutdoorPvPObjective::Update(diff))
+    {
+        if(m_OldState != m_State || fabs(m_ShiftPhase) == m_ShiftMaxPhase)  // state won't change, only phase when maxed out!
+        {
+            // if changing from controlling alliance to horde or vice versa
+            if( m_OldState == OBJECTIVESTATE_ALLIANCE )
+            {
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString((LANG_OPVP_EP_LOOSE_EWT_A),-1));
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_EWT] = 0;
+            }
+            else if ( m_OldState == OBJECTIVESTATE_HORDE )
+            {
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString((LANG_OPVP_EP_LOOSE_EWT_H),-1));
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_EWT] = 0;
+            }
+
+            uint32 artkit = 21;
+
+            switch(m_State)
+            {
+            case OBJECTIVESTATE_ALLIANCE:
+                if(m_ShiftPhase == m_ShiftMaxPhase)
+                {
+                    m_TowerState = EP_TS_A;
+                    SummonSupportUnitAtNorthpassTower(ALLIANCE);
+                }
+                else
+                    m_TowerState = EP_TS_A_P;
+                artkit = 2;
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_EWT] = ALLIANCE;
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_CAPTURE_EWT_A,-1));
+                break;
+            case OBJECTIVESTATE_HORDE:
+                if(m_ShiftPhase == -m_ShiftMaxPhase)
+                {
+                    m_TowerState = EP_TS_H;
+                    SummonSupportUnitAtNorthpassTower(HORDE);
+                }
+                else
+                    m_TowerState = EP_TS_H_P;
+                artkit = 1;
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_EWT] = HORDE;
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_CAPTURE_EWT_H,-1));
+                break;
+            case OBJECTIVESTATE_NEUTRAL:
+                m_TowerState = EP_TS_N;
+                break;
+            case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+            case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+                m_TowerState = EP_TS_N_A;
+                break;
+            case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+            case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+                m_TowerState = EP_TS_N_H;
+                break;
+            }
+
+            GameObject* flag = HashMapHolder<GameObject>::Find(m_CapturePoint);
+            GameObject* flag2 = HashMapHolder<GameObject>::Find(m_Objects[EP_EWT_FLAGS]);
+            if(flag)
+            {
+                flag->SetGoArtKit(artkit);
+                flag->SendUpdateObjectToAllExcept(NULL);
+            }
+            if(flag2)
+            {
+                flag2->SetGoArtKit(artkit);
+                flag2->SendUpdateObjectToAllExcept(NULL);
+            }
+
+
+            UpdateTowerState();
+
+            // complete quest objective
+            if(m_TowerState == EP_TS_A || m_TowerState == EP_TS_H)
+                SendObjectiveComplete(EP_EWT_CM, 0);
+        }
+
+        if(m_ShiftPhase != m_OldPhase)
+        {
+            // send this too, sometimes the slider disappears, dunno why :(
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+            // send these updates to only the ones in this objective
+            uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+            // send this too, sometimes it resets :S
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_NeutralValue);
+        }
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_EWT::FillInitialWorldStates(WorldPacket &data)
+{
+    data << EP_EWT_A << uint32(bool(m_TowerState & EP_TS_A));
+    data << EP_EWT_H << uint32(bool(m_TowerState & EP_TS_H));
+    data << EP_EWT_A_P << uint32(bool(m_TowerState & EP_TS_A_P));
+    data << EP_EWT_H_P << uint32(bool(m_TowerState & EP_TS_H_P));
+    data << EP_EWT_N_A << uint32(bool(m_TowerState & EP_TS_N_A));
+    data << EP_EWT_N_H << uint32(bool(m_TowerState & EP_TS_N_H));
+    data << EP_EWT_N << uint32(bool(m_TowerState & EP_TS_N));
+}
+
+void OutdoorPvPObjectiveEP_EWT::UpdateTowerState()
+{
+    m_PvP->SendUpdateWorldState(EP_EWT_A , bool(m_TowerState & EP_TS_A));
+    m_PvP->SendUpdateWorldState(EP_EWT_H , bool(m_TowerState & EP_TS_H));
+    m_PvP->SendUpdateWorldState(EP_EWT_A_P , bool(m_TowerState & EP_TS_A_P));
+    m_PvP->SendUpdateWorldState(EP_EWT_H_P , bool(m_TowerState & EP_TS_H_P));
+    m_PvP->SendUpdateWorldState(EP_EWT_N_A , bool(m_TowerState & EP_TS_N_A));
+    m_PvP->SendUpdateWorldState(EP_EWT_N_H , bool(m_TowerState & EP_TS_N_H));
+    m_PvP->SendUpdateWorldState(EP_EWT_N , bool(m_TowerState & EP_TS_N));
+}
+
+bool OutdoorPvPObjectiveEP_EWT::HandlePlayerEnter(Player *plr)
+{
+    if(OutdoorPvPObjective::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_NeutralValue);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_EWT::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 0);
+    OutdoorPvPObjective::HandlePlayerLeave(plr);
+}
+
+bool OutdoorPvPObjectiveEP_EWT::HandleCapturePointEvent(Player *plr, uint32 eventId)
+{
+    if(eventId == EPTowerPlayerEnterEvents[EP_EWT])
+    {
+        this->HandlePlayerEnter(plr);
+        return true;
+    }
+    else if (eventId == EPTowerPlayerLeaveEvents[EP_EWT])
+    {
+        this->HandlePlayerLeave(plr);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_EWT::SummonSupportUnitAtNorthpassTower(uint32 team)
+{
+    const creature_type * ct = NULL;
+    if(team == ALLIANCE)
+        ct=EP_EWT_Summons_A;
+    else
+        ct=EP_EWT_Summons_H;
+
+    for(int i = 0; i < EP_EWT_NUM_CREATURES; ++i)
+    {
+        DelCreature(i);
+        AddCreature(i,ct[i].entry,ct[i].teamval,ct[i].map,ct[i].x,ct[i].y,ct[i].z,ct[i].o,1000000);
+    }
+}
+
+// NPT
+OutdoorPvPObjectiveEP_NPT::OutdoorPvPObjectiveEP_NPT(OutdoorPvP *pvp)
+: OutdoorPvPObjective(pvp), m_TowerState(EP_TS_N)
+{
+    AddCapturePoint(EPCapturePoints[EP_NPT].entry,EPCapturePoints[EP_NPT].map,EPCapturePoints[EP_NPT].x,EPCapturePoints[EP_NPT].y,EPCapturePoints[EP_NPT].z,EPCapturePoints[EP_NPT].o,EPCapturePoints[EP_NPT].rot0,EPCapturePoints[EP_NPT].rot1,EPCapturePoints[EP_NPT].rot2,EPCapturePoints[EP_NPT].rot3);
+    AddObject(EP_NPT_FLAGS,EPTowerFlags[EP_NPT].entry,EPTowerFlags[EP_NPT].map,EPTowerFlags[EP_NPT].x,EPTowerFlags[EP_NPT].y,EPTowerFlags[EP_NPT].z,EPTowerFlags[EP_NPT].o,EPTowerFlags[EP_NPT].rot0,EPTowerFlags[EP_NPT].rot1,EPTowerFlags[EP_NPT].rot2,EPTowerFlags[EP_NPT].rot3);
+}
+
+bool OutdoorPvPObjectiveEP_NPT::Update(uint32 diff)
+{
+    if(OutdoorPvPObjective::Update(diff))
+    {
+        if(m_OldState != m_State || fabs(m_ShiftPhase) == m_ShiftMaxPhase)  // state won't change, only phase when maxed out!
+        {
+            // if changing from controlling alliance to horde or vice versa
+            if( m_OldState == OBJECTIVESTATE_ALLIANCE )
+            {
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_LOOSE_NPT_A,-1));
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_NPT] = 0;
+            }
+            else if ( m_OldState == OBJECTIVESTATE_HORDE )
+            {
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_LOOSE_NPT_H,-1));
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_NPT] = 0;
+            }
+
+            uint32 artkit = 21;
+
+            switch(m_State)
+            {
+            case OBJECTIVESTATE_ALLIANCE:
+                if(m_ShiftPhase == m_ShiftMaxPhase)
+                {
+                    m_TowerState = EP_TS_A;
+                    SummonGO(ALLIANCE);
+                }
+                else
+                    m_TowerState = EP_TS_A_P;
+                artkit = 2;
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_NPT] = ALLIANCE;
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_CAPTURE_NPT_A,-1));
+                break;
+            case OBJECTIVESTATE_HORDE:
+                if(m_ShiftPhase == -m_ShiftMaxPhase)
+                {
+                    m_TowerState = EP_TS_H;
+                    SummonGO(HORDE);
+                }
+                else
+                    m_TowerState = EP_TS_H_P;
+                artkit = 1;
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_NPT] = HORDE;
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_CAPTURE_NPT_H,-1));
+                break;
+            case OBJECTIVESTATE_NEUTRAL:
+                m_TowerState = EP_TS_N;
+                DelObject(EP_NPT_BUFF);
+                break;
+            case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+            case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+                m_TowerState = EP_TS_N_A;
+                break;
+            case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+            case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+                m_TowerState = EP_TS_N_H;
+                break;
+            }
+
+            GameObject* flag = HashMapHolder<GameObject>::Find(m_CapturePoint);
+            GameObject* flag2 = HashMapHolder<GameObject>::Find(m_Objects[EP_NPT_FLAGS]);
+            if(flag)
+            {
+                flag->SetGoArtKit(artkit);
+                flag->SendUpdateObjectToAllExcept(NULL);
+            }
+            if(flag2)
+            {
+                flag2->SetGoArtKit(artkit);
+                flag2->SendUpdateObjectToAllExcept(NULL);
+            }
+
+            UpdateTowerState();
+
+            // complete quest objective
+            if(m_TowerState == EP_TS_A || m_TowerState == EP_TS_H)
+                SendObjectiveComplete(EP_NPT_CM, 0);
+        }
+
+        if(m_ShiftPhase != m_OldPhase)
+        {
+            // send this too, sometimes the slider disappears, dunno why :(
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+            // send these updates to only the ones in this objective
+            uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+            // send this too, sometimes it resets :S
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_NeutralValue);
+        }
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_NPT::FillInitialWorldStates(WorldPacket &data)
+{
+    data << EP_NPT_A << uint32(bool(m_TowerState & EP_TS_A));
+    data << EP_NPT_H << uint32(bool(m_TowerState & EP_TS_H));
+    data << EP_NPT_A_P << uint32(bool(m_TowerState & EP_TS_A_P));
+    data << EP_NPT_H_P << uint32(bool(m_TowerState & EP_TS_H_P));
+    data << EP_NPT_N_A << uint32(bool(m_TowerState & EP_TS_N_A));
+    data << EP_NPT_N_H << uint32(bool(m_TowerState & EP_TS_N_H));
+    data << EP_NPT_N << uint32(bool(m_TowerState & EP_TS_N));
+}
+
+void OutdoorPvPObjectiveEP_NPT::UpdateTowerState()
+{
+    m_PvP->SendUpdateWorldState(EP_NPT_A , bool(m_TowerState & EP_TS_A));
+    m_PvP->SendUpdateWorldState(EP_NPT_H , bool(m_TowerState & EP_TS_H));
+    m_PvP->SendUpdateWorldState(EP_NPT_A_P , bool(m_TowerState & EP_TS_A_P));
+    m_PvP->SendUpdateWorldState(EP_NPT_H_P , bool(m_TowerState & EP_TS_H_P));
+    m_PvP->SendUpdateWorldState(EP_NPT_N_A , bool(m_TowerState & EP_TS_N_A));
+    m_PvP->SendUpdateWorldState(EP_NPT_N_H , bool(m_TowerState & EP_TS_N_H));
+    m_PvP->SendUpdateWorldState(EP_NPT_N , bool(m_TowerState & EP_TS_N));
+}
+
+bool OutdoorPvPObjectiveEP_NPT::HandlePlayerEnter(Player *plr)
+{
+    if(OutdoorPvPObjective::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_NeutralValue);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_NPT::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 0);
+    OutdoorPvPObjective::HandlePlayerLeave(plr);
+}
+
+bool OutdoorPvPObjectiveEP_NPT::HandleCapturePointEvent(Player *plr, uint32 eventId)
+{
+    if(eventId == EPTowerPlayerEnterEvents[EP_NPT])
+    {
+        this->HandlePlayerEnter(plr);
+        return true;
+    }
+    else if (eventId == EPTowerPlayerLeaveEvents[EP_NPT])
+    {
+        this->HandlePlayerLeave(plr);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_NPT::SummonGO(uint32 team)
+{
+    DelObject(EP_NPT_BUFF);
+    AddObject(EP_NPT_BUFF,EP_NPT_LordaeronShrine.entry,EP_NPT_LordaeronShrine.map,EP_NPT_LordaeronShrine.x,EP_NPT_LordaeronShrine.y,EP_NPT_LordaeronShrine.z,EP_NPT_LordaeronShrine.o,EP_NPT_LordaeronShrine.rot0,EP_NPT_LordaeronShrine.rot1,EP_NPT_LordaeronShrine.rot2,EP_NPT_LordaeronShrine.rot3);
+    GameObject * go = HashMapHolder<GameObject>::Find(m_Objects[EP_NPT_BUFF]);
+    if(go)
+    {
+        go->SetUInt32Value(GAMEOBJECT_FACTION,(team == ALLIANCE ? 84 : 83));
+    }
+}
+
+// CGT
+OutdoorPvPObjectiveEP_CGT::OutdoorPvPObjectiveEP_CGT(OutdoorPvP *pvp)
+: OutdoorPvPObjective(pvp), m_TowerState(EP_TS_N)
+{
+    AddCapturePoint(EPCapturePoints[EP_CGT].entry,EPCapturePoints[EP_CGT].map,EPCapturePoints[EP_CGT].x,EPCapturePoints[EP_CGT].y,EPCapturePoints[EP_CGT].z,EPCapturePoints[EP_CGT].o,EPCapturePoints[EP_CGT].rot0,EPCapturePoints[EP_CGT].rot1,EPCapturePoints[EP_CGT].rot2,EPCapturePoints[EP_CGT].rot3);
+    AddObject(EP_CGT_FLAGS,EPTowerFlags[EP_CGT].entry,EPTowerFlags[EP_CGT].map,EPTowerFlags[EP_CGT].x,EPTowerFlags[EP_CGT].y,EPTowerFlags[EP_CGT].z,EPTowerFlags[EP_CGT].o,EPTowerFlags[EP_CGT].rot0,EPTowerFlags[EP_CGT].rot1,EPTowerFlags[EP_CGT].rot2,EPTowerFlags[EP_CGT].rot3);
+}
+
+bool OutdoorPvPObjectiveEP_CGT::Update(uint32 diff)
+{
+    if(OutdoorPvPObjective::Update(diff))
+    {
+        if(m_OldState != m_State || fabs(m_ShiftPhase) == m_ShiftMaxPhase)  // state won't change, only phase when maxed out!
+        {
+            // if changing from controlling alliance to horde or vice versa
+            if( m_OldState == OBJECTIVESTATE_ALLIANCE )
+            {
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_LOOSE_CGT_A,-1));
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_CGT] = 0;
+            }
+            else if ( m_OldState == OBJECTIVESTATE_HORDE )
+            {
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_LOOSE_CGT_H,-1));
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_CGT] = 0;
+            }
+
+            uint32 artkit = 21;
+
+            switch(m_State)
+            {
+            case OBJECTIVESTATE_ALLIANCE:
+                if(m_ShiftPhase == m_ShiftMaxPhase)
+                {
+                    m_TowerState = EP_TS_A;
+                    LinkGraveYard(ALLIANCE);
+                }
+                else
+                    m_TowerState = EP_TS_A_P;
+                artkit = 2;
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_CGT] = ALLIANCE;
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_CAPTURE_CGT_A,-1));
+                break;
+            case OBJECTIVESTATE_HORDE:
+                if(m_ShiftPhase == -m_ShiftMaxPhase)
+                {
+                    m_TowerState = EP_TS_H;
+                    LinkGraveYard(HORDE);
+                }
+                else
+                    m_TowerState = EP_TS_H_P;
+                artkit = 1;
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_CGT] = HORDE;
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_CAPTURE_CGT_H,-1));
+                break;
+            case OBJECTIVESTATE_NEUTRAL:
+                m_TowerState = EP_TS_N;
+                break;
+            case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+            case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+                m_TowerState = EP_TS_N_A;
+                break;
+            case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+            case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+                m_TowerState = EP_TS_N_H;
+                break;
+            }
+
+            GameObject* flag = HashMapHolder<GameObject>::Find(m_CapturePoint);
+            GameObject* flag2 = HashMapHolder<GameObject>::Find(m_Objects[EP_CGT_FLAGS]);
+            if(flag)
+            {
+                flag->SetGoArtKit(artkit);
+                flag->SendUpdateObjectToAllExcept(NULL);
+            }
+            if(flag2)
+            {
+                flag2->SetGoArtKit(artkit);
+                flag2->SendUpdateObjectToAllExcept(NULL);
+            }
+
+            UpdateTowerState();
+
+            // complete quest objective
+            if(m_TowerState == EP_TS_A || m_TowerState == EP_TS_H)
+                SendObjectiveComplete(EP_CGT_CM, 0);
+        }
+
+        if(m_ShiftPhase != m_OldPhase)
+        {
+            // send this too, sometimes the slider disappears, dunno why :(
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+            // send these updates to only the ones in this objective
+            uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+            // send this too, sometimes it resets :S
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_NeutralValue);
+        }
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_CGT::FillInitialWorldStates(WorldPacket &data)
+{
+    data << EP_CGT_A << uint32(bool(m_TowerState & EP_TS_A));
+    data << EP_CGT_H << uint32(bool(m_TowerState & EP_TS_H));
+    data << EP_CGT_A_P << uint32(bool(m_TowerState & EP_TS_A_P));
+    data << EP_CGT_H_P << uint32(bool(m_TowerState & EP_TS_H_P));
+    data << EP_CGT_N_A << uint32(bool(m_TowerState & EP_TS_N_A));
+    data << EP_CGT_N_H << uint32(bool(m_TowerState & EP_TS_N_H));
+    data << EP_CGT_N << uint32(bool(m_TowerState & EP_TS_N));
+}
+
+void OutdoorPvPObjectiveEP_CGT::UpdateTowerState()
+{
+    m_PvP->SendUpdateWorldState(EP_CGT_A , bool(m_TowerState & EP_TS_A));
+    m_PvP->SendUpdateWorldState(EP_CGT_H , bool(m_TowerState & EP_TS_H));
+    m_PvP->SendUpdateWorldState(EP_CGT_A_P , bool(m_TowerState & EP_TS_A_P));
+    m_PvP->SendUpdateWorldState(EP_CGT_H_P , bool(m_TowerState & EP_TS_H_P));
+    m_PvP->SendUpdateWorldState(EP_CGT_N_A , bool(m_TowerState & EP_TS_N_A));
+    m_PvP->SendUpdateWorldState(EP_CGT_N_H , bool(m_TowerState & EP_TS_N_H));
+    m_PvP->SendUpdateWorldState(EP_CGT_N , bool(m_TowerState & EP_TS_N));
+}
+
+bool OutdoorPvPObjectiveEP_CGT::HandlePlayerEnter(Player *plr)
+{
+    if(OutdoorPvPObjective::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_NeutralValue);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_CGT::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 0);
+    OutdoorPvPObjective::HandlePlayerLeave(plr);
+}
+
+bool OutdoorPvPObjectiveEP_CGT::HandleCapturePointEvent(Player *plr, uint32 eventId)
+{
+    if(eventId == EPTowerPlayerEnterEvents[EP_CGT])
+    {
+        this->HandlePlayerEnter(plr);
+        return true;
+    }
+    else if (eventId == EPTowerPlayerLeaveEvents[EP_CGT])
+    {
+        this->HandlePlayerLeave(plr);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_CGT::LinkGraveYard(uint32 team)
+{
+    objmgr.RemoveGraveYardLink(EP_GraveYardId,EP_GraveYardZone,team,false);
+    objmgr.AddGraveYardLink(EP_GraveYardId,EP_GraveYardZone,team,false);
+}
+
+// PWT
+OutdoorPvPObjectiveEP_PWT::OutdoorPvPObjectiveEP_PWT(OutdoorPvP *pvp)
+: OutdoorPvPObjective(pvp), m_TowerState(EP_TS_N)
+{
+    AddCapturePoint(EPCapturePoints[EP_PWT].entry,EPCapturePoints[EP_PWT].map,EPCapturePoints[EP_PWT].x,EPCapturePoints[EP_PWT].y,EPCapturePoints[EP_PWT].z,EPCapturePoints[EP_PWT].o,EPCapturePoints[EP_PWT].rot0,EPCapturePoints[EP_PWT].rot1,EPCapturePoints[EP_PWT].rot2,EPCapturePoints[EP_PWT].rot3);
+    AddObject(EP_PWT_FLAGS,EPTowerFlags[EP_PWT].entry,EPTowerFlags[EP_PWT].map,EPTowerFlags[EP_PWT].x,EPTowerFlags[EP_PWT].y,EPTowerFlags[EP_PWT].z,EPTowerFlags[EP_PWT].o,EPTowerFlags[EP_PWT].rot0,EPTowerFlags[EP_PWT].rot1,EPTowerFlags[EP_PWT].rot2,EPTowerFlags[EP_PWT].rot3);
+    memset(m_taximask, 0, sizeof(m_taximask));
+    SetTaximaskNode(EP_PWT_Taxi);
+    SetTaximaskNode(EP_CGT_Taxi);
+    SetTaximaskNode(EP_EWT_Taxi);
+    SetTaximaskNode(EP_NPT_Taxi);
+}
+
+bool OutdoorPvPObjectiveEP_PWT::Update(uint32 diff)
+{
+    if(OutdoorPvPObjective::Update(diff))
+    {
+        if(m_OldState != m_State || fabs(m_ShiftPhase) == m_ShiftMaxPhase)  // state won't change, only phase when maxed out!
+        {
+            // if changing from controlling alliance to horde or vice versa
+            if( m_OldState == OBJECTIVESTATE_ALLIANCE )
+            {
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_LOOSE_PWT_A,-1));
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_PWT] = 0;
+            }
+            else if ( m_OldState == OBJECTIVESTATE_HORDE )
+            {
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_LOOSE_PWT_H,-1));
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_PWT] = 0;
+            }
+
+            uint32 artkit = 21;
+
+            switch(m_State)
+            {
+            case OBJECTIVESTATE_ALLIANCE:
+                if(m_ShiftPhase == m_ShiftMaxPhase)
+                {
+                    m_TowerState = EP_TS_A;
+                    SummonFlightMaster(ALLIANCE);
+                }
+                else
+                    m_TowerState = EP_TS_A_P;
+                artkit = 2;
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_PWT] = ALLIANCE;
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_CAPTURE_PWT_A,-1));
+                break;
+            case OBJECTIVESTATE_HORDE:
+                if(m_ShiftPhase == -m_ShiftMaxPhase)
+                {
+                    m_TowerState = EP_TS_H;
+                    SummonFlightMaster(HORDE);
+                }
+                else
+                    m_TowerState = EP_TS_H_P;
+                artkit = 1;
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_PWT] = HORDE;
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_CAPTURE_PWT_H,-1));
+                break;
+            case OBJECTIVESTATE_NEUTRAL:
+                m_TowerState = EP_TS_N;
+                DelCreature(EP_PWT_FLIGHTMASTER);
+                break;
+            case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+            case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+                m_TowerState = EP_TS_N_A;
+                break;
+            case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+            case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+                m_TowerState = EP_TS_N_H;
+                break;
+            }
+
+            GameObject* flag = HashMapHolder<GameObject>::Find(m_CapturePoint);
+            GameObject* flag2 = HashMapHolder<GameObject>::Find(m_Objects[EP_PWT_FLAGS]);
+            if(flag)
+            {
+                flag->SetGoArtKit(artkit);
+                flag->SendUpdateObjectToAllExcept(NULL);
+            }
+            if(flag2)
+            {
+                flag2->SetGoArtKit(artkit);
+                flag2->SendUpdateObjectToAllExcept(NULL);
+            }
+
+            UpdateTowerState();
+
+            // complete quest objective
+            if(m_TowerState == EP_TS_A || m_TowerState == EP_TS_H)
+                SendObjectiveComplete(EP_PWT_CM, 0);
+        }
+
+        if(m_ShiftPhase != m_OldPhase)
+        {
+            // send this too, sometimes the slider disappears, dunno why :(
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+            // send these updates to only the ones in this objective
+            uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+            // send this too, sometimes it resets :S
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_NeutralValue);
+        }
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_PWT::FillInitialWorldStates(WorldPacket &data)
+{
+    data << EP_PWT_A << uint32(bool(m_TowerState & EP_TS_A));
+    data << EP_PWT_H << uint32(bool(m_TowerState & EP_TS_H));
+    data << EP_PWT_A_P << uint32(bool(m_TowerState & EP_TS_A_P));
+    data << EP_PWT_H_P << uint32(bool(m_TowerState & EP_TS_H_P));
+    data << EP_PWT_N_A << uint32(bool(m_TowerState & EP_TS_N_A));
+    data << EP_PWT_N_H << uint32(bool(m_TowerState & EP_TS_N_H));
+    data << EP_PWT_N << uint32(bool(m_TowerState & EP_TS_N));
+}
+
+void OutdoorPvPObjectiveEP_PWT::UpdateTowerState()
+{
+    m_PvP->SendUpdateWorldState(EP_PWT_A , bool(m_TowerState & EP_TS_A));
+    m_PvP->SendUpdateWorldState(EP_PWT_H , bool(m_TowerState & EP_TS_H));
+    m_PvP->SendUpdateWorldState(EP_PWT_A_P , bool(m_TowerState & EP_TS_A_P));
+    m_PvP->SendUpdateWorldState(EP_PWT_H_P , bool(m_TowerState & EP_TS_H_P));
+    m_PvP->SendUpdateWorldState(EP_PWT_N_A , bool(m_TowerState & EP_TS_N_A));
+    m_PvP->SendUpdateWorldState(EP_PWT_N_H , bool(m_TowerState & EP_TS_N_H));
+    m_PvP->SendUpdateWorldState(EP_PWT_N , bool(m_TowerState & EP_TS_N));
+}
+
+bool OutdoorPvPObjectiveEP_PWT::HandlePlayerEnter(Player *plr)
+{
+    if(OutdoorPvPObjective::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_NeutralValue);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_PWT::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 0);
+    OutdoorPvPObjective::HandlePlayerLeave(plr);
+}
+
+bool OutdoorPvPObjectiveEP_PWT::HandleCapturePointEvent(Player *plr, uint32 eventId)
+{
+    if(eventId == EPTowerPlayerEnterEvents[EP_PWT])
+    {
+        this->HandlePlayerEnter(plr);
+        return true;
+    }
+    else if (eventId == EPTowerPlayerLeaveEvents[EP_PWT])
+    {
+        this->HandlePlayerLeave(plr);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_PWT::SummonFlightMaster(uint32 team)
+{
+    DelCreature(EP_PWT_FLIGHTMASTER);
+    AddCreature(EP_PWT_FLIGHTMASTER,EP_PWT_FlightMaster.entry,team,EP_PWT_FlightMaster.map,EP_PWT_FlightMaster.x,EP_PWT_FlightMaster.y,EP_PWT_FlightMaster.z,EP_PWT_FlightMaster.o);
+    Creature * c = HashMapHolder<Creature>::Find(m_Creatures[EP_PWT_FLIGHTMASTER]);
+    if(c)
+    {
+        GossipOption * gso = new GossipOption;
+        gso->Action = GOSSIP_OPTION_OUTDOORPVP;
+        gso->GossipId = 0;
+        gso->Option.assign("As the breeze whips straight as an arrow, let her go over Kill Devil Hill!");
+        gso->Id = 50;
+        gso->Icon = 1;
+        gso->NpcFlag = 0;
+        c->addGossipOption(*gso);
+    }
+}
+
+bool OutdoorPvPObjectiveEP_PWT::HandleGossipOption(Player *plr, uint64 guid, uint32 gossipid)
+{
+    std::map<uint64,uint32>::iterator itr = m_CreatureTypes.find(guid);
+    if(itr != m_CreatureTypes.end())
+    {
+        Creature * cr = HashMapHolder<Creature>::Find(guid);
+        if(!cr)
+            return true;
+        if(itr->second == EP_PWT_FLIGHTMASTER)
+        {
+            uint32 curloc = EP_PWT_Taxi;
+
+            WorldPacket data( SMSG_SHOWTAXINODES, (4+8+4+8*4) );
+            data << uint32( 1 );
+            data << uint64( cr->GetGUID() );
+            data << uint32( curloc );
+
+            for (uint8 i=0; i<TaxiMaskSize; i++)
+                data << uint32(m_taximask[i]);                  // known nodes
+
+            plr->GetSession()->SendPacket( &data );
+        }
+        return true;
+    }
+    return false;
+}
+
+// ep
+OutdoorPvPEP::OutdoorPvPEP()
+{
+    m_TypeId = OUTDOOR_PVP_EP;
+    memset(EP_Controls,0,sizeof(EP_Controls));
+    m_AllianceTowersControlled = 0;
+    m_HordeTowersControlled = 0;
+}
+
+bool OutdoorPvPEP::SetupOutdoorPvP()
+{
+    for(int i = 0; i < EPBuffZonesNum; ++i)
+        sOutdoorPvPMgr.AddZone(EPBuffZones[i],this);
+
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveEP_EWT(this));
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveEP_PWT(this));
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveEP_CGT(this));
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveEP_NPT(this));
+    return true;
+}
+
+bool OutdoorPvPEP::Update(uint32 diff)
+{
+    if(OutdoorPvP::Update(diff))
+    {
+        m_AllianceTowersControlled = 0;
+        m_HordeTowersControlled = 0;
+        for(int i = 0; i < EP_TOWER_NUM; ++i)
+        {
+            if(EP_Controls[i] == ALLIANCE)
+                ++m_AllianceTowersControlled;
+            else if(EP_Controls[i] == HORDE)
+                ++m_HordeTowersControlled;
+            SendUpdateWorldState(EP_UI_TOWER_COUNT_A,m_AllianceTowersControlled);
+            SendUpdateWorldState(EP_UI_TOWER_COUNT_H,m_HordeTowersControlled);
+            BuffTeams();
+        }
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPEP::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    // add buffs
+    if(plr->GetTeam() == ALLIANCE)
+    {
+        if(m_AllianceTowersControlled && m_AllianceTowersControlled < 5)
+            plr->CastSpell(plr,EP_AllianceBuffs[m_AllianceTowersControlled-1],true);
+    }
+    else
+    {
+        if(m_HordeTowersControlled && m_HordeTowersControlled < 5)
+            plr->CastSpell(plr,EP_HordeBuffs[m_HordeTowersControlled-1],true);
+    }
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPEP::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    if(plr->GetTeam() == ALLIANCE)
+    {
+        for(int i = 0; i < 4; ++i)
+            plr->RemoveAurasDueToSpell(EP_AllianceBuffs[i]);
+    }
+    else
+    {
+        for(int i = 0; i < 4; ++i)
+            plr->RemoveAurasDueToSpell(EP_HordeBuffs[i]);
+    }
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+void OutdoorPvPEP::BuffTeams()
+{
+    for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+    {
+        if(Player * plr = objmgr.GetPlayer(*itr))
+        {
+            for(int i = 0; i < 4; ++i)
+                plr->RemoveAurasDueToSpell(EP_AllianceBuffs[i]);
+            if(m_AllianceTowersControlled && m_AllianceTowersControlled < 5)
+                plr->CastSpell(plr,EP_AllianceBuffs[m_AllianceTowersControlled-1],true);
+        }
+    }
+    for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+    {
+        if(Player * plr = objmgr.GetPlayer(*itr))
+        {
+            for(int i = 0; i < 4; ++i)
+                plr->RemoveAurasDueToSpell(EP_HordeBuffs[i]);
+            if(m_HordeTowersControlled && m_HordeTowersControlled < 5)
+                plr->CastSpell(plr,EP_HordeBuffs[m_HordeTowersControlled-1],true);
+        }
+    }
+}
+
+void OutdoorPvPEP::FillInitialWorldStates(WorldPacket & data)
+{
+    data << EP_UI_TOWER_COUNT_A << m_AllianceTowersControlled;
+    data << EP_UI_TOWER_COUNT_H << m_HordeTowersControlled;
+    data << EP_UI_TOWER_SLIDER_DISPLAY << uint32(0);
+    data << EP_UI_TOWER_SLIDER_POS << uint32(50);
+    data << EP_UI_TOWER_SLIDER_N << uint32(100);
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        (*itr)->FillInitialWorldStates(data);
+    }
+}
+
+void OutdoorPvPEP::SendRemoveWorldStates(Player *plr)
+{
+    plr->SendUpdateWorldState(EP_UI_TOWER_COUNT_A,0);
+    plr->SendUpdateWorldState(EP_UI_TOWER_COUNT_H,0);
+    plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY,0);
+    plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS,0);
+    plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_N,0);
+
+    plr->SendUpdateWorldState(EP_EWT_A,0);
+    plr->SendUpdateWorldState(EP_EWT_H,0);
+    plr->SendUpdateWorldState(EP_EWT_N,0);
+    plr->SendUpdateWorldState(EP_EWT_A_P,0);
+    plr->SendUpdateWorldState(EP_EWT_H_P,0);
+    plr->SendUpdateWorldState(EP_EWT_N_A,0);
+    plr->SendUpdateWorldState(EP_EWT_N_H,0);
+
+    plr->SendUpdateWorldState(EP_PWT_A,0);
+    plr->SendUpdateWorldState(EP_PWT_H,0);
+    plr->SendUpdateWorldState(EP_PWT_N,0);
+    plr->SendUpdateWorldState(EP_PWT_A_P,0);
+    plr->SendUpdateWorldState(EP_PWT_H_P,0);
+    plr->SendUpdateWorldState(EP_PWT_N_A,0);
+    plr->SendUpdateWorldState(EP_PWT_N_H,0);
+
+    plr->SendUpdateWorldState(EP_NPT_A,0);
+    plr->SendUpdateWorldState(EP_NPT_H,0);
+    plr->SendUpdateWorldState(EP_NPT_N,0);
+    plr->SendUpdateWorldState(EP_NPT_A_P,0);
+    plr->SendUpdateWorldState(EP_NPT_H_P,0);
+    plr->SendUpdateWorldState(EP_NPT_N_A,0);
+    plr->SendUpdateWorldState(EP_NPT_N_H,0);
+
+    plr->SendUpdateWorldState(EP_CGT_A,0);
+    plr->SendUpdateWorldState(EP_CGT_H,0);
+    plr->SendUpdateWorldState(EP_CGT_N,0);
+    plr->SendUpdateWorldState(EP_CGT_A_P,0);
+    plr->SendUpdateWorldState(EP_CGT_H_P,0);
+    plr->SendUpdateWorldState(EP_CGT_N_A,0);
+    plr->SendUpdateWorldState(EP_CGT_N_H,0);
+}
diff --git a/src/game/OutdoorPvPEP.h b/src/game/OutdoorPvPEP.h
new file mode 100644
index 0000000..762e1d2
--- /dev/null
+++ b/src/game/OutdoorPvPEP.h
@@ -0,0 +1,272 @@
+#ifndef OUTDOOR_PVP_EP_
+#define OUTDOOR_PVP_EP_
+
+#include "OutdoorPvP.h"
+
+#include "Database/DBCStructure.h"
+
+const uint32 EP_AllianceBuffs[4] = {11413, 11414, 11415, 1386};
+
+const uint32 EP_HordeBuffs[4] = {30880, 30683, 30682, 29520};
+
+const uint32 EP_GraveYardZone = 139;
+
+const uint32 EP_GraveYardId = 927;
+
+const uint32 EPBuffZonesNum = 3;
+
+const uint32 EP_EWT_CM = 17690;
+const uint32 EP_CGT_CM = 17689;
+const uint32 EP_NPT_CM = 17696;
+const uint32 EP_PWT_CM = 17698;
+
+const uint32 EPBuffZones[EPBuffZonesNum] = {139, 2017, 2057};
+
+enum EP_TaxiNodes {
+    EP_CGT_Taxi = 87,
+    EP_EWT_Taxi = 86,
+    EP_NPT_Taxi = 85,
+    EP_PWT_Taxi = 84
+};
+
+enum EP_EastwallTowerWorldStates {
+    EP_EWT_A = 2354,
+    EP_EWT_H = 2356,
+    EP_EWT_A_P = 2357, // ally progressing
+    EP_EWT_H_P = 2358,
+    EP_EWT_N_A = 2359, // ally conquested
+    EP_EWT_N_H = 2360,
+    EP_EWT_N = 2361
+};
+
+enum EP_NorthpassTowerWorldStates {
+    EP_NPT_N = 2352,
+    EP_NPT_N_A = 2362,
+    EP_NPT_N_H = 2363,
+    EP_NPT_A_P = 2364,
+    EP_NPT_H_P = 2365,
+    EP_NPT_A = 2372,
+    EP_NPT_H = 2373
+};
+
+enum EP_PlagewoodTowerWorldStates {
+    EP_PWT_N_A = 2366,
+    EP_PWT_N_H = 2353, //2367 not present! use neutral!
+    EP_PWT_A_P = 2368,
+    EP_PWT_H_P = 2369,
+    EP_PWT_A = 2370,
+    EP_PWT_H = 2371,
+    EP_PWT_N = 2353
+};
+
+enum EP_CrownGuardTowerWorldStates {
+    EP_CGT_N_A = 2374,
+    EP_CGT_N_H = 2375,
+    EP_CGT_A_P = 2376,
+    EP_CGT_H_P = 2377,
+    EP_CGT_A = 2378,
+    EP_CGT_H = 2379,
+    EP_CGT_N = 2355
+};
+
+enum EP_WorldStates {
+    EP_UI_TOWER_SLIDER_DISPLAY = 2426,
+    EP_UI_TOWER_SLIDER_POS = 2427,
+    EP_UI_TOWER_SLIDER_N = 2428,
+
+    EP_UI_TOWER_COUNT_A = 2327,
+    EP_UI_TOWER_COUNT_H = 2328
+};
+
+enum EP_Summons {
+    EP_EWT_COMMANDER = 0,
+    EP_EWT_SOLDIER1,
+    EP_EWT_SOLDIER2,
+    EP_EWT_SOLDIER3,
+    EP_EWT_SOLDIER4,
+    EP_PWT_FLIGHTMASTER,
+};
+
+enum EP_GoSummons {
+    EP_NPT_BUFF = 0,
+    EP_NPT_FLAGS,
+    EP_EWT_FLAGS,
+    EP_CGT_FLAGS,
+    EP_PWT_FLAGS
+};
+
+enum EP_Towers {
+    EP_EWT = 0, // plaguelands 03
+    EP_NPT,// plaguelands 01
+    EP_PWT,// plaguelands 04
+    EP_CGT,// plaguelands 02
+    EP_TOWER_NUM
+};
+
+const go_type EPCapturePoints[EP_TOWER_NUM] = {
+    {182097,0,2574.51,-4794.89,144.704,-1.45003,-0.097056,0.095578,-0.656229,0.742165},
+    {181899,0,3181.08,-4379.36,174.123,-2.03472,-0.065392,0.119494,-0.842275,0.521553},
+    {182098,0,2962.71,-3042.31,154.789,2.08426,-0.074807,-0.113837,0.855928,0.49883},
+    {182096,0,1860.85,-3731.23,196.716,-2.53214,0.033967,-0.131914,0.944741,-0.298177}
+};
+
+const go_type EPTowerFlags[EP_TOWER_NUM] = {
+    {182106,0,2569.60,-4772.93,115.399,2.72271,0,0,0.978148,0.207912},
+    {182106,0,3148.17,-4365.51,145.029,1.53589,0,0,0.694658,0.71934},
+    {182106,0,2992.63,-3022.95,125.593,3.03687,0,0,0.99863,0.052336},
+    {182106,0,1838.42,-3703.56,167.713,0.890118,0,0,0.430511,0.902585}
+};
+
+const uint32 EPTowerPlayerEnterEvents[EP_TOWER_NUM] = {10691,10699,10701,10705};
+
+const uint32 EPTowerPlayerLeaveEvents[EP_TOWER_NUM] = {10692,10698,10700,10704};
+
+const uint32 EP_NUM_CREATURES = 6;
+const uint32 EP_EWT_NUM_CREATURES = 5;
+
+// one lordaeron commander, 4 soldiers
+// should be spawned at EWT and follow a path, but trans-grid pathing isn't safe, so summon them directly at NPT
+const creature_type EP_EWT_Summons_A[EP_EWT_NUM_CREATURES] = {
+    {17635,469,0, 3167.61,-4352.09,138.20,4.5811},
+    {17647,469,0, 3172.74,-4352.99,139.14,4.9873},
+    {17647,469,0, 3165.89,-4354.46,138.67,3.7244},
+    {17647,469,0, 3164.65,-4350.26,138.22,2.4794},
+    {17647,469,0, 3169.91,-4349.68,138.37,0.7444}
+};
+
+const creature_type EP_EWT_Summons_H[EP_EWT_NUM_CREATURES] = {
+    {17995,67,0, 3167.61,-4352.09,138.20,4.5811},
+    {17996,67,0, 3172.74,-4352.99,139.14,4.9873},
+    {17996,67,0, 3165.89,-4354.46,138.67,3.7244},
+    {17996,67,0, 3164.65,-4350.26,138.22,2.4794},
+    {17996,67,0, 3169.91,-4349.68,138.37,0.7444}
+};
+
+enum EP_TowerStates {
+    EP_TS_N = 1,
+    EP_TS_N_A = 2,
+    EP_TS_N_H = 4,
+    EP_TS_A_P = 8,
+    EP_TS_H_P = 16,
+    EP_TS_A = 32,
+    EP_TS_H = 64
+};
+
+// when spawning, pay attention at setting the faction manually!
+const creature_type EP_PWT_FlightMaster = {17209,0,0,2987.5,-3049.11,120.126,5.75959};
+
+// after spawning, modify the faction so that only the controller will be able to use it with SetUInt32Value(GAMEOBJECT_FACTION, faction_id);
+const go_type EP_NPT_LordaeronShrine = {181682,0,3167.72,-4355.91,138.785,1.69297,0,0,0.748956,0.66262};
+
+class OutdoorPvPEP;
+
+class OutdoorPvPObjectiveEP_EWT : public OutdoorPvPObjective
+{
+friend class OutdoorPvPEP;
+public:
+    OutdoorPvPObjectiveEP_EWT(OutdoorPvP * pvp);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+protected:
+    bool HandleCapturePointEvent(Player * plr, uint32 eventId);
+    void SummonSupportUnitAtNorthpassTower(uint32 team);
+    void UpdateTowerState();
+protected:
+    uint32 m_TowerState;
+};
+
+class OutdoorPvPObjectiveEP_NPT : public OutdoorPvPObjective
+{
+friend class OutdoorPvPEP;
+public:
+    OutdoorPvPObjectiveEP_NPT(OutdoorPvP * pvp);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+protected:
+    bool HandleCapturePointEvent(Player * plr, uint32 eventId);
+    void SummonGO(uint32 team);
+    void UpdateTowerState();
+protected:
+    uint32 m_TowerState;
+};
+
+class OutdoorPvPObjectiveEP_CGT : public OutdoorPvPObjective
+{
+friend class OutdoorPvPEP;
+public:
+    OutdoorPvPObjectiveEP_CGT(OutdoorPvP * pvp);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+protected:
+    bool HandleCapturePointEvent(Player * plr, uint32 eventId);
+    void LinkGraveYard(uint32 team);
+    void UpdateTowerState();
+protected:
+    uint32 m_TowerState;
+};
+
+class OutdoorPvPObjectiveEP_PWT : public OutdoorPvPObjective
+{
+friend class OutdoorPvPEP;
+public:
+    OutdoorPvPObjectiveEP_PWT(OutdoorPvP * pvp);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+    bool HandleGossipOption(Player *plr, uint64 guid, uint32 gossipid);
+protected:
+    bool HandleCapturePointEvent(Player * plr, uint32 eventId);
+    void SummonFlightMaster(uint32 team);
+    void UpdateTowerState();
+    // copy from player.h
+    bool SetTaximaskNode(uint32 nodeidx)
+    {
+        uint8  field   = uint8((nodeidx - 1) / 32);
+        uint32 submask = 1<<((nodeidx-1)%32);
+        if ((m_taximask[field] & submask) != submask )
+        {
+            m_taximask[field] |= submask;
+            return true;
+        }
+        else
+            return false;
+    }
+protected:
+    uint32 m_TowerState;
+    TaxiMask m_taximask;
+};
+
+class OutdoorPvPEP : public OutdoorPvP
+{
+friend class OutdoorPvPObjectiveEP_EWT;
+friend class OutdoorPvPObjectiveEP_NPT;
+friend class OutdoorPvPObjectiveEP_PWT;
+friend class OutdoorPvPObjectiveEP_CGT;
+public:
+    OutdoorPvPEP();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket &data);
+    void SendRemoveWorldStates(Player * plr);
+    void BuffTeams();
+private:
+    // how many towers are controlled
+    uint32 EP_Controls[EP_TOWER_NUM];
+    uint32 m_AllianceTowersControlled;
+    uint32 m_HordeTowersControlled;
+};
+
+#endif
diff --git a/src/game/OutdoorPvPHP.cpp b/src/game/OutdoorPvPHP.cpp
new file mode 100644
index 0000000..54fec5b
--- /dev/null
+++ b/src/game/OutdoorPvPHP.cpp
@@ -0,0 +1,380 @@
+#include "OutdoorPvPHP.h"
+#include "OutdoorPvP.h"
+#include "OutdoorPvPMgr.h"
+#include "Player.h"
+#include "WorldPacket.h"
+#include "World.h"
+#include "ObjectMgr.h"
+#include "Language.h"
+
+const uint32 HP_LANG_LOOSE_A[HP_TOWER_NUM] = {LANG_OPVP_HP_LOOSE_BROKENHILL_A,LANG_OPVP_HP_LOOSE_OVERLOOK_A,LANG_OPVP_HP_LOOSE_STADIUM_A};
+
+const uint32 HP_LANG_LOOSE_H[HP_TOWER_NUM] = {LANG_OPVP_HP_LOOSE_BROKENHILL_H,LANG_OPVP_HP_LOOSE_OVERLOOK_H,LANG_OPVP_HP_LOOSE_STADIUM_H};
+
+const uint32 HP_LANG_CAPTURE_A[HP_TOWER_NUM] = {LANG_OPVP_HP_CAPTURE_BROKENHILL_A,LANG_OPVP_HP_CAPTURE_OVERLOOK_A,LANG_OPVP_HP_CAPTURE_STADIUM_A};
+
+const uint32 HP_LANG_CAPTURE_H[HP_TOWER_NUM] = {LANG_OPVP_HP_CAPTURE_BROKENHILL_H,LANG_OPVP_HP_CAPTURE_OVERLOOK_H,LANG_OPVP_HP_CAPTURE_STADIUM_H};
+
+OutdoorPvPObjectiveHP::OutdoorPvPObjectiveHP(OutdoorPvP *pvp,OutdoorPvPHPTowerType type)
+: OutdoorPvPObjective(pvp), m_TowerType(type)
+{
+    AddCapturePoint(HPCapturePoints[type].entry,
+        HPCapturePoints[type].map,
+        HPCapturePoints[type].x,
+        HPCapturePoints[type].y,
+        HPCapturePoints[type].z,
+        HPCapturePoints[type].o,
+        HPCapturePoints[type].rot0,
+        HPCapturePoints[type].rot1,
+        HPCapturePoints[type].rot2,
+        HPCapturePoints[type].rot3);
+    AddObject(type,
+        HPTowerFlags[type].entry,
+        HPTowerFlags[type].map,
+        HPTowerFlags[type].x,
+        HPTowerFlags[type].y,
+        HPTowerFlags[type].z,
+        HPTowerFlags[type].o,
+        HPTowerFlags[type].rot0,
+        HPTowerFlags[type].rot1,
+        HPTowerFlags[type].rot2,
+        HPTowerFlags[type].rot3);
+}
+
+OutdoorPvPHP::OutdoorPvPHP()
+{
+    m_TypeId = OUTDOOR_PVP_HP;
+}
+
+bool OutdoorPvPHP::SetupOutdoorPvP()
+{
+    m_AllianceTowersControlled = 0;
+    m_HordeTowersControlled = 0;
+    // add the zones affected by the pvp buff
+    for(int i = 0; i < OutdoorPvPHPBuffZonesNum; ++i)
+        sOutdoorPvPMgr.AddZone(OutdoorPvPHPBuffZones[i],this);
+
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveHP(this,HP_TOWER_BROKEN_HILL));
+
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveHP(this,HP_TOWER_OVERLOOK));
+
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveHP(this,HP_TOWER_STADIUM));
+
+    return true;
+}
+
+void OutdoorPvPHP::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    // add buffs
+    if(plr->GetTeam() == ALLIANCE)
+    {
+        if(m_AllianceTowersControlled >=3)
+            plr->CastSpell(plr,AllianceBuff,true);
+    }
+    else
+    {
+        if(m_HordeTowersControlled >=3)
+            plr->CastSpell(plr,HordeBuff,true);
+    }
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPHP::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    if(plr->GetTeam() == ALLIANCE)
+    {
+        plr->RemoveAurasDueToSpell(AllianceBuff);
+    }
+    else
+    {
+        plr->RemoveAurasDueToSpell(HordeBuff);
+    }
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+bool OutdoorPvPHP::Update(uint32 diff)
+{
+    bool changed = false;
+    if(changed = OutdoorPvP::Update(diff))
+    {
+        if(m_AllianceTowersControlled == 3)
+            BuffTeam(ALLIANCE);
+        else if(m_HordeTowersControlled == 3)
+            BuffTeam(HORDE);
+        else
+            BuffTeam(NULL);
+        SendUpdateWorldState(HP_UI_TOWER_COUNT_A, m_AllianceTowersControlled);
+        SendUpdateWorldState(HP_UI_TOWER_COUNT_H, m_HordeTowersControlled);
+    }
+    return changed;
+}
+
+void OutdoorPvPHP::SendRemoveWorldStates(Player *plr)
+{
+    plr->SendUpdateWorldState(HP_UI_TOWER_DISPLAY_A,0);
+    plr->SendUpdateWorldState(HP_UI_TOWER_DISPLAY_H,0);
+    plr->SendUpdateWorldState(HP_UI_TOWER_COUNT_H,0);
+    plr->SendUpdateWorldState(HP_UI_TOWER_COUNT_A,0);
+    plr->SendUpdateWorldState(HP_UI_TOWER_SLIDER_N,0);
+    plr->SendUpdateWorldState(HP_UI_TOWER_SLIDER_POS,0);
+    plr->SendUpdateWorldState(HP_UI_TOWER_SLIDER_DISPLAY,0);
+    for(int i = 0; i < HP_TOWER_NUM; ++i)
+    {
+        plr->SendUpdateWorldState(HP_MAP_N[i],0);
+        plr->SendUpdateWorldState(HP_MAP_A[i],0);
+        plr->SendUpdateWorldState(HP_MAP_H[i],0);
+    }
+}
+
+void OutdoorPvPHP::FillInitialWorldStates(WorldPacket &data)
+{
+    data << uint32(HP_UI_TOWER_DISPLAY_A) << uint32(1);
+    data << uint32(HP_UI_TOWER_DISPLAY_H) << uint32(1);
+    data << uint32(HP_UI_TOWER_COUNT_A) << uint32(m_AllianceTowersControlled);
+    data << uint32(HP_UI_TOWER_COUNT_H) << uint32(m_HordeTowersControlled);
+    data << uint32(HP_UI_TOWER_SLIDER_DISPLAY) << uint32(0);
+    data << uint32(HP_UI_TOWER_SLIDER_POS) << uint32(50);
+    data << uint32(HP_UI_TOWER_SLIDER_N) << uint32(100);
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        (*itr)->FillInitialWorldStates(data);
+    }
+}
+
+bool OutdoorPvPObjectiveHP::Update(uint32 diff)
+{
+    // if status changed:
+    if(OutdoorPvPObjective::Update(diff))
+    {
+        if(m_OldState != m_State)
+        {
+            uint32 field = 0;
+            switch(m_OldState)
+            {
+            case OBJECTIVESTATE_NEUTRAL:
+                field = HP_MAP_N[m_TowerType];
+                break;
+            case OBJECTIVESTATE_ALLIANCE:
+                field = HP_MAP_A[m_TowerType];
+                if(((OutdoorPvPHP*)m_PvP)->m_AllianceTowersControlled)
+                    ((OutdoorPvPHP*)m_PvP)->m_AllianceTowersControlled--;
+                sWorld.SendZoneText(OutdoorPvPHPBuffZones[0],objmgr.GetMangosString(HP_LANG_LOOSE_A[m_TowerType],-1));
+                break;
+            case OBJECTIVESTATE_HORDE:
+                field = HP_MAP_H[m_TowerType];
+                if(((OutdoorPvPHP*)m_PvP)->m_HordeTowersControlled)
+                    ((OutdoorPvPHP*)m_PvP)->m_HordeTowersControlled--;
+                sWorld.SendZoneText(OutdoorPvPHPBuffZones[0],objmgr.GetMangosString(HP_LANG_LOOSE_H[m_TowerType],-1));
+                break;
+            case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+                field = HP_MAP_N[m_TowerType];
+                break;
+            case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+                field = HP_MAP_N[m_TowerType];
+                break;
+            case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+                field = HP_MAP_A[m_TowerType];
+                break;
+            case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+                field = HP_MAP_H[m_TowerType];
+                break;
+            }
+
+            // send world state update
+            if(field)
+            {
+                m_PvP->SendUpdateWorldState(field, 0);
+                field = 0;
+            }
+            uint32 artkit = 21;
+            uint32 artkit2 = HP_TowerArtKit_N[m_TowerType];
+            switch(m_State)
+            {
+            case OBJECTIVESTATE_NEUTRAL:
+                field = HP_MAP_N[m_TowerType];
+                break;
+            case OBJECTIVESTATE_ALLIANCE:
+                field = HP_MAP_A[m_TowerType];
+                artkit = 2;
+                artkit2 = HP_TowerArtKit_A[m_TowerType];
+                if(((OutdoorPvPHP*)m_PvP)->m_AllianceTowersControlled<3)
+                    ((OutdoorPvPHP*)m_PvP)->m_AllianceTowersControlled++;
+                sWorld.SendZoneText(OutdoorPvPHPBuffZones[0],objmgr.GetMangosString(HP_LANG_CAPTURE_A[m_TowerType],-1));
+                break;
+            case OBJECTIVESTATE_HORDE:
+                field = HP_MAP_H[m_TowerType];
+                artkit = 1;
+                artkit2 = HP_TowerArtKit_H[m_TowerType];
+                if(((OutdoorPvPHP*)m_PvP)->m_HordeTowersControlled<3)
+                    ((OutdoorPvPHP*)m_PvP)->m_HordeTowersControlled++;
+                sWorld.SendZoneText(OutdoorPvPHPBuffZones[0],objmgr.GetMangosString(HP_LANG_CAPTURE_H[m_TowerType],-1));
+                break;
+            case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+                field = HP_MAP_N[m_TowerType];
+                break;
+            case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+                field = HP_MAP_N[m_TowerType];
+                break;
+            case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+                field = HP_MAP_A[m_TowerType];
+                artkit = 2;
+                artkit2 = HP_TowerArtKit_A[m_TowerType];
+                break;
+            case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+                field = HP_MAP_H[m_TowerType];
+                artkit = 1;
+                artkit2 = HP_TowerArtKit_H[m_TowerType];
+                break;
+            }
+
+            GameObject* flag = HashMapHolder<GameObject>::Find(m_CapturePoint);
+            GameObject* flag2 = HashMapHolder<GameObject>::Find(m_Objects[m_TowerType]);
+            if(flag)
+            {
+                flag->SetGoArtKit(artkit);
+                flag->SendUpdateObjectToAllExcept(NULL);
+            }
+            if(flag2)
+            {
+                flag2->SetGoArtKit(artkit2);
+                flag2->SendUpdateObjectToAllExcept(NULL);
+            }
+
+            // send world state update
+            if(field)
+                m_PvP->SendUpdateWorldState(field, 1);
+
+            // complete quest objective
+            if(m_State == OBJECTIVESTATE_ALLIANCE || m_State == OBJECTIVESTATE_HORDE)
+                SendObjectiveComplete(HP_CREDITMARKER[m_TowerType], 0);
+        }
+
+        if(m_ShiftPhase != m_OldPhase)
+        {
+            SendUpdateWorldState(HP_UI_TOWER_SLIDER_N, m_NeutralValue);
+            // send these updates to only the ones in this objective
+            uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+            SendUpdateWorldState(HP_UI_TOWER_SLIDER_POS, phase);
+            // send this too, sometimes the slider disappears, dunno why :(
+            SendUpdateWorldState(HP_UI_TOWER_SLIDER_DISPLAY, 1);
+        }
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveHP::FillInitialWorldStates(WorldPacket &data)
+{
+    switch(m_State)
+    {
+        case OBJECTIVESTATE_ALLIANCE:
+        case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+            data << uint32(HP_MAP_N[m_TowerType]) << uint32(0);
+            data << uint32(HP_MAP_A[m_TowerType]) << uint32(1);
+            data << uint32(HP_MAP_H[m_TowerType]) << uint32(0);
+            break;
+        case OBJECTIVESTATE_HORDE:
+        case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+            data << uint32(HP_MAP_N[m_TowerType]) << uint32(0);
+            data << uint32(HP_MAP_A[m_TowerType]) << uint32(0);
+            data << uint32(HP_MAP_H[m_TowerType]) << uint32(1);
+            break;
+        case OBJECTIVESTATE_NEUTRAL:
+        case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+        case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+        default:
+            data << uint32(HP_MAP_N[m_TowerType]) << uint32(1);
+            data << uint32(HP_MAP_A[m_TowerType]) << uint32(0);
+            data << uint32(HP_MAP_H[m_TowerType]) << uint32(0);
+            break;
+    }
+}
+
+bool OutdoorPvPObjectiveHP::HandlePlayerEnter(Player *plr)
+{
+    if(OutdoorPvPObjective::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(HP_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+        plr->SendUpdateWorldState(HP_UI_TOWER_SLIDER_POS, phase);
+        plr->SendUpdateWorldState(HP_UI_TOWER_SLIDER_N, m_NeutralValue);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveHP::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(HP_UI_TOWER_SLIDER_DISPLAY, 0);
+    OutdoorPvPObjective::HandlePlayerLeave(plr);
+}
+
+void OutdoorPvPHP::BuffTeam(uint32 team)
+{
+    if(team == ALLIANCE)
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->CastSpell(plr,AllianceBuff,true);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(HordeBuff);
+        }
+    }
+    else if(team == HORDE)
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->CastSpell(plr,HordeBuff,true);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(AllianceBuff);
+        }
+    }
+    else
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(AllianceBuff);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(HordeBuff);
+        }
+    }
+}
+
+void OutdoorPvPHP::HandleKillImpl(Player *plr, Unit * killed)
+{
+    if(killed->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    if(plr->GetTeam() == ALLIANCE && ((Player*)killed)->GetTeam() != ALLIANCE)
+        plr->CastSpell(plr,AlliancePlayerKillReward,true);
+    else if(plr->GetTeam() == HORDE && ((Player*)killed)->GetTeam() != HORDE)
+        plr->CastSpell(plr,HordePlayerKillReward,true);
+}
+
+bool OutdoorPvPObjectiveHP::HandleCapturePointEvent(Player *plr, uint32 eventId)
+{
+    if(eventId == HP_CapturePointEvent_Enter[m_TowerType])
+    {
+        this->HandlePlayerEnter(plr);
+        return true;
+    }
+    else if(eventId == HP_CapturePointEvent_Leave[m_TowerType])
+    {
+        this->HandlePlayerLeave(plr);
+        return true;
+    }
+    return false;
+}
diff --git a/src/game/OutdoorPvPHP.h b/src/game/OutdoorPvPHP.h
new file mode 100644
index 0000000..33a5bbf
--- /dev/null
+++ b/src/game/OutdoorPvPHP.h
@@ -0,0 +1,100 @@
+#ifndef OUTDOOR_PVP_HP_
+#define OUTDOOR_PVP_HP_
+
+#include "OutdoorPvP.h"
+
+#define OutdoorPvPHPBuffZonesNum 6
+                                                         //  HP, citadel, ramparts, blood furnace, shattered halls, mag's lair
+const uint32 OutdoorPvPHPBuffZones[OutdoorPvPHPBuffZonesNum] = { 3483, 3563, 3562, 3713, 3714, 3836 };
+
+const uint32 AllianceBuff = 32071;
+
+const uint32 HordeBuff = 32049;
+
+const uint32 AlliancePlayerKillReward = 32155;
+
+const uint32 HordePlayerKillReward = 32158;
+
+enum OutdoorPvPHPTowerType{
+    HP_TOWER_BROKEN_HILL = 0,
+    HP_TOWER_OVERLOOK = 1,
+    HP_TOWER_STADIUM = 2,
+    HP_TOWER_NUM = 3
+};
+
+const uint32 HP_CREDITMARKER[HP_TOWER_NUM] = {19032,19028,19029};
+
+const uint32 HP_CapturePointEvent_Enter[HP_TOWER_NUM] = {11404,11396,11388};
+
+const uint32 HP_CapturePointEvent_Leave[HP_TOWER_NUM] = {11403,11395,11387};
+
+enum OutdoorPvPHPWorldStates{
+    HP_UI_TOWER_DISPLAY_A = 0x9ba,
+    HP_UI_TOWER_DISPLAY_H = 0x9b9,
+
+    HP_UI_TOWER_COUNT_H = 0x9ae,
+    HP_UI_TOWER_COUNT_A = 0x9ac,
+
+    HP_UI_TOWER_SLIDER_N = 2475,
+    HP_UI_TOWER_SLIDER_POS = 2474,
+    HP_UI_TOWER_SLIDER_DISPLAY = 2473
+};
+
+const uint32 HP_MAP_N[HP_TOWER_NUM] = {0x9b5,0x9b2,0x9a8};
+
+const uint32 HP_MAP_A[HP_TOWER_NUM] = {0x9b3,0x9b0,0x9a7};
+
+const uint32 HP_MAP_H[HP_TOWER_NUM] = {0x9b4,0x9b1,0x9a6};
+
+const uint32 HP_TowerArtKit_A[HP_TOWER_NUM] = {65,62,67};
+
+const uint32 HP_TowerArtKit_H[HP_TOWER_NUM] = {64,61,68};
+
+const uint32 HP_TowerArtKit_N[HP_TOWER_NUM] = {66,63,69};
+
+const go_type HPCapturePoints[HP_TOWER_NUM] = {
+    {182175,530,-471.462,3451.09,34.6432,0.174533,0,0,0.087156,0.996195},      // 0 - Broken Hill
+    {182174,530,-184.889,3476.93,38.205,-0.017453,0,0,0.008727,-0.999962},     // 1 - Overlook
+    {182173,530,-290.016,3702.42,56.6729,0.034907,0,0,0.017452,0.999848}     // 2 - Stadium
+};
+
+const go_type HPTowerFlags[HP_TOWER_NUM] = {
+    {183514,530,-467.078,3528.17,64.7121,3.14159,0,0,1,0},  // 0 broken hill
+    {182525,530,-187.887,3459.38,60.0403,-3.12414,0,0,0.999962,-0.008727}, // 1 overlook
+    {183515,530,-289.610,3696.83,75.9447,3.12414,0,0,0.999962,0.008727} // 2 stadium
+};
+
+class OutdoorPvPObjectiveHP : public OutdoorPvPObjective
+{
+public:
+    OutdoorPvPObjectiveHP(OutdoorPvP * pvp, OutdoorPvPHPTowerType type);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+    bool HandleCapturePointEvent(Player * plr, uint32 eventId);
+private:
+    OutdoorPvPHPTowerType m_TowerType;
+};
+
+class OutdoorPvPHP : public OutdoorPvP
+{
+friend class OutdoorPvPObjectiveHP;
+public:
+    OutdoorPvPHP();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket &data);
+    void SendRemoveWorldStates(Player * plr);
+    void HandleKillImpl(Player * plr, Unit * killed);
+    void BuffTeam(uint32 team);
+private:
+    // how many towers are controlled
+    uint32 m_AllianceTowersControlled;
+    uint32 m_HordeTowersControlled;
+};
+
+#endif
diff --git a/src/game/OutdoorPvPMgr.cpp b/src/game/OutdoorPvPMgr.cpp
new file mode 100644
index 0000000..3121b60
--- /dev/null
+++ b/src/game/OutdoorPvPMgr.cpp
@@ -0,0 +1,219 @@
+#include "OutdoorPvPMgr.h"
+#include "OutdoorPvPHP.h"
+#include "OutdoorPvPNA.h"
+#include "OutdoorPvPTF.h"
+#include "OutdoorPvPZM.h"
+#include "OutdoorPvPSI.h"
+#include "OutdoorPvPEP.h"
+#include "Player.h"
+#include "Policies/SingletonImp.h"
+
+INSTANTIATE_SINGLETON_1( OutdoorPvPMgr );
+
+OutdoorPvPMgr::OutdoorPvPMgr()
+{
+    sLog.outDebug("Instantiating OutdoorPvPMgr");
+}
+
+OutdoorPvPMgr::~OutdoorPvPMgr()
+{
+    sLog.outDebug("Deleting OutdoorPvPMgr");
+    for(OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        (*itr)->DeleteSpawns();
+    }
+}
+
+void OutdoorPvPMgr::InitOutdoorPvP()
+{
+    // create new opvp
+    OutdoorPvP * pOP = new OutdoorPvPHP;
+    // respawn, init variables
+    if(!pOP->SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : HP init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.insert(pOP);
+        sLog.outDebug("OutdoorPvP : HP successfully initiated.");
+    }
+
+
+    pOP = new OutdoorPvPNA;
+    // respawn, init variables
+    if(!pOP->SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : NA init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.insert(pOP);
+        sLog.outDebug("OutdoorPvP : NA successfully initiated.");
+    }
+
+
+    pOP = new OutdoorPvPTF;
+    // respawn, init variables
+    if(!pOP->SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : TF init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.insert(pOP);
+        sLog.outDebug("OutdoorPvP : TF successfully initiated.");
+    }
+
+    pOP = new OutdoorPvPZM;
+    // respawn, init variables
+    if(!pOP->SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : ZM init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.insert(pOP);
+        sLog.outDebug("OutdoorPvP : ZM successfully initiated.");
+    }
+
+    pOP = new OutdoorPvPSI;
+    // respawn, init variables
+    if(!pOP->SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : SI init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.insert(pOP);
+        sLog.outDebug("OutdoorPvP : SI successfully initiated.");
+    }
+
+    pOP = new OutdoorPvPEP;
+    // respawn, init variables
+    if(!pOP->SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : EP init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.insert(pOP);
+        sLog.outDebug("OutdoorPvP : EP successfully initiated.");
+    }
+}
+
+void OutdoorPvPMgr::AddZone(uint32 zoneid, OutdoorPvP *handle)
+{
+    m_OutdoorPvPMap[zoneid] = handle;
+}
+
+
+void OutdoorPvPMgr::HandlePlayerEnterZone(Player *plr, uint32 zoneid)
+{
+    OutdoorPvPMap::iterator itr = m_OutdoorPvPMap.find(zoneid);
+    if(itr == m_OutdoorPvPMap.end())
+    {
+        // no handle for this zone, return
+        return;
+    }
+    // add possibly beneficial buffs to plr for zone
+    itr->second->HandlePlayerEnterZone(plr, zoneid);
+    plr->SendInitWorldStates();
+    sLog.outDebug("Player %u entered outdoorpvp id %u",plr->GetGUIDLow(), itr->second->GetTypeId());
+}
+
+void OutdoorPvPMgr::HandlePlayerLeaveZone(Player *plr, uint32 zoneid)
+{
+    OutdoorPvPMap::iterator itr = m_OutdoorPvPMap.find(zoneid);
+    if(itr == m_OutdoorPvPMap.end())
+    {
+        // no handle for this zone, return
+        return;
+    }
+    // inform the OutdoorPvP class of the leaving, it should remove the player from all objectives
+    itr->second->HandlePlayerLeaveZone(plr, zoneid);
+    sLog.outDebug("Player %u left outdoorpvp id %u",plr->GetGUIDLow(), itr->second->GetTypeId());
+}
+
+OutdoorPvP * OutdoorPvPMgr::GetOutdoorPvPToZoneId(uint32 zoneid)
+{
+    OutdoorPvPMap::iterator itr = m_OutdoorPvPMap.find(zoneid);
+    if(itr == m_OutdoorPvPMap.end())
+    {
+        // no handle for this zone, return
+        return NULL;
+    }
+    return itr->second;
+}
+
+void OutdoorPvPMgr::Update(uint32 diff)
+{
+    for(OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        (*itr)->Update(diff);
+    }
+}
+
+bool OutdoorPvPMgr::HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go)
+{
+    for(OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)->HandleCustomSpell(plr,spellId,go))
+            return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPMgr::HandleOpenGo(Player *plr, uint64 guid)
+{
+    for(OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)->HandleOpenGo(plr,guid))
+            return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPMgr::HandleCaptureCreaturePlayerMoveInLos(Player * plr, Creature * c)
+{
+    for(OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)->HandleCaptureCreaturePlayerMoveInLos(plr,c))
+            return true;
+    }
+    return false;
+}
+
+void OutdoorPvPMgr::HandleGossipOption(Player *plr, uint64 guid, uint32 gossipid)
+{
+    for(OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)->HandleGossipOption(plr,guid,gossipid))
+            return;
+    }
+}
+
+bool OutdoorPvPMgr::CanTalkTo(Player * plr, Creature * c, GossipOption & gso)
+{
+    for(OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)->CanTalkTo(plr,c,gso))
+            return true;
+    }
+    return false;
+}
+
+void OutdoorPvPMgr::HandleDropFlag(Player *plr, uint32 spellId)
+{
+    for(OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)->HandleDropFlag(plr,spellId))
+            return;
+    }
+}
diff --git a/src/game/OutdoorPvPMgr.h b/src/game/OutdoorPvPMgr.h
new file mode 100644
index 0000000..2fbefa9
--- /dev/null
+++ b/src/game/OutdoorPvPMgr.h
@@ -0,0 +1,59 @@
+#ifndef OUTDOOR_PVP_MGR_H_
+#define OUTDOOR_PVP_MGR_H_
+
+#include "OutdoorPvP.h"
+#include "Policies/Singleton.h"
+
+class Player;
+class GameObject;
+class Creature;
+struct GossipOption;
+
+// class to handle player enter / leave / areatrigger / GO use events
+class OutdoorPvPMgr
+{
+public:
+    // ctor
+    OutdoorPvPMgr();
+    // dtor
+    ~OutdoorPvPMgr();
+
+    // create outdoor pvp events
+    void InitOutdoorPvP();
+    // called when a player enters an outdoor pvp area
+    void HandlePlayerEnterZone(Player * plr, uint32 areaflag);
+    // called when player leaves an outdoor pvp area
+    void HandlePlayerLeaveZone(Player * plr, uint32 areaflag);
+    // return assigned outdoor pvp
+    OutdoorPvP * GetOutdoorPvPToZoneId(uint32 zoneid);
+    // handle custom (non-exist in dbc) spell if registered
+    bool HandleCustomSpell(Player * plr, uint32 spellId, GameObject* go);
+    // handle custom go if registered
+    bool HandleOpenGo(Player * plr, uint64 guid);
+
+    void AddZone(uint32 zoneid, OutdoorPvP * handle);
+
+    void Update(uint32 diff);
+
+    bool HandleCaptureCreaturePlayerMoveInLos(Player * plr, Creature * c);
+
+    void HandleGossipOption(Player * player, uint64 guid, uint32 gossipid);
+
+    bool CanTalkTo(Player * player, Creature * creature, GossipOption & gso);
+
+    void HandleDropFlag(Player * plr, uint32 spellId);
+
+    typedef std::set<OutdoorPvP*> OutdoorPvPSet;
+    typedef std::map<uint32 /* zoneid */, OutdoorPvP*> OutdoorPvPMap;
+private:
+    // contains all initiated outdoor pvp events
+    // used when initing / cleaning up
+    OutdoorPvPSet  m_OutdoorPvPSet;
+    // maps the zone ids to an outdoor pvp event
+    // used in player event handling
+    OutdoorPvPMap   m_OutdoorPvPMap;
+};
+
+#define sOutdoorPvPMgr MaNGOS::Singleton<OutdoorPvPMgr>::Instance()
+
+#endif /*OUTDOOR_PVP_MGR_H_*/
diff --git a/src/game/OutdoorPvPNA.cpp b/src/game/OutdoorPvPNA.cpp
new file mode 100644
index 0000000..d9621f5
--- /dev/null
+++ b/src/game/OutdoorPvPNA.cpp
@@ -0,0 +1,706 @@
+#include "OutdoorPvPNA.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "OutdoorPvPMgr.h"
+#include "WorldPacket.h"
+#include "Language.h"
+#include "World.h"
+
+OutdoorPvPNA::OutdoorPvPNA()
+{
+    m_TypeId = OUTDOOR_PVP_NA;
+}
+
+void OutdoorPvPNA::HandleKillImpl(Player *plr, Unit * killed)
+{
+    if(killed->GetTypeId() == TYPEID_PLAYER && plr->GetTeam() != ((Player*)killed)->GetTeam())
+    {
+        plr->KilledMonster(NA_CREDIT_MARKER,0); // 0 guid, btw it isn't even used in killedmonster function :S
+        if(plr->GetTeam() == ALLIANCE)
+            plr->CastSpell(plr,NA_KILL_TOKEN_ALLIANCE,true);
+        else
+            plr->CastSpell(plr,NA_KILL_TOKEN_HORDE,true);
+    }
+}
+
+uint32 OutdoorPvPObjectiveNA::GetAliveGuardsCount()
+{
+    uint32 cnt = 0;
+    for(std::map<uint32, uint64>::iterator itr = m_Creatures.begin(); itr != m_Creatures.end(); ++itr)
+    {
+        switch(itr->first)
+        {
+        case NA_NPC_GUARD_01:
+        case NA_NPC_GUARD_02:
+        case NA_NPC_GUARD_03:
+        case NA_NPC_GUARD_04:
+        case NA_NPC_GUARD_05:
+        case NA_NPC_GUARD_06:
+        case NA_NPC_GUARD_07:
+        case NA_NPC_GUARD_08:
+        case NA_NPC_GUARD_09:
+        case NA_NPC_GUARD_10:
+        case NA_NPC_GUARD_11:
+        case NA_NPC_GUARD_12:
+        case NA_NPC_GUARD_13:
+        case NA_NPC_GUARD_14:
+        case NA_NPC_GUARD_15:
+            {
+                if(Creature * cr = HashMapHolder<Creature>::Find(itr->second))
+                {
+                    if(cr->isAlive())
+                        ++cnt;
+                }
+                else if (CreatureData const * cd = objmgr.GetCreatureData(GUID_LOPART(itr->second)))
+                {
+                    if(!cd->is_dead)
+                        ++cnt;
+                }
+            }
+            break;
+        default:
+            break;
+        }
+    }
+    return cnt;
+}
+
+void OutdoorPvPNA::BuffTeam(uint32 team)
+{
+    if(team == ALLIANCE)
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->CastSpell(plr,NA_CAPTURE_BUFF,true);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(NA_CAPTURE_BUFF);
+        }
+    }
+    else if(team == HORDE)
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->CastSpell(plr,NA_CAPTURE_BUFF,true);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(NA_CAPTURE_BUFF);
+        }
+    }
+    else
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(NA_CAPTURE_BUFF);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(NA_CAPTURE_BUFF);
+        }
+    }
+}
+
+void OutdoorPvPObjectiveNA::SpawnNPCsForTeam(uint32 team)
+{
+    const creature_type * creatures = NULL;
+    if(team == ALLIANCE)
+        creatures=AllianceControlNPCs;
+    else if(team == HORDE)
+        creatures=HordeControlNPCs;
+    else
+        return;
+    for(int i = 0; i < NA_CONTROL_NPC_NUM; ++i)
+        AddCreature(i,creatures[i].entry,creatures[i].teamval,creatures[i].map,creatures[i].x,creatures[i].y,creatures[i].z,creatures[i].o,1000000);
+}
+
+void OutdoorPvPObjectiveNA::DeSpawnNPCs()
+{
+    for(int i = 0; i < NA_CONTROL_NPC_NUM; ++i)
+        DelCreature(i);
+}
+
+void OutdoorPvPObjectiveNA::SpawnGOsForTeam(uint32 team)
+{
+    const go_type * gos = NULL;
+    if(team == ALLIANCE)
+        gos=AllianceControlGOs;
+    else if(team == HORDE)
+        gos=HordeControlGOs;
+    else
+        return;
+    for(int i = 0; i < NA_CONTROL_GO_NUM; ++i)
+    {
+        if( i == NA_ROOST_S ||
+            i == NA_ROOST_W ||
+            i == NA_ROOST_N ||
+            i == NA_ROOST_E ||
+            i == NA_BOMB_WAGON_S || 
+            i == NA_BOMB_WAGON_W || 
+            i == NA_BOMB_WAGON_N || 
+            i == NA_BOMB_WAGON_E )
+            continue;   // roosts and bomb wagons are spawned when someone uses the matching destroyed roost
+        AddObject(i,gos[i].entry,gos[i].map,gos[i].x,gos[i].y,gos[i].z,gos[i].o,gos[i].rot0,gos[i].rot1,gos[i].rot2,gos[i].rot3);
+    }
+}
+
+void OutdoorPvPObjectiveNA::DeSpawnGOs()
+{
+    for(int i = 0; i < NA_CONTROL_GO_NUM; ++i)
+    {
+        DelObject(i);
+    }
+}
+
+void OutdoorPvPObjectiveNA::FactionTakeOver(uint32 team)
+{
+    if(m_ControllingFaction)
+        objmgr.RemoveGraveYardLink(NA_HALAA_GRAVEYARD,NA_HALAA_GRAVEYARD_ZONE,m_ControllingFaction,false);
+    if(m_ControllingFaction == ALLIANCE)
+        sWorld.SendZoneText(NA_HALAA_GRAVEYARD_ZONE,objmgr.GetMangosString(LANG_OPVP_NA_LOOSE_A,-1));
+    else if(m_ControllingFaction == HORDE)
+        sWorld.SendZoneText(NA_HALAA_GRAVEYARD_ZONE,objmgr.GetMangosString(LANG_OPVP_NA_LOOSE_H,-1));
+
+    m_ControllingFaction = team;
+    if(m_ControllingFaction)
+        objmgr.AddGraveYardLink(NA_HALAA_GRAVEYARD,NA_HALAA_GRAVEYARD_ZONE,m_ControllingFaction,false);
+    DeSpawnGOs();
+    DeSpawnNPCs();
+    SpawnGOsForTeam(team);
+    SpawnNPCsForTeam(team);
+    m_GuardsAlive = NA_GUARDS_MAX;
+    m_capturable = false;
+    this->UpdateHalaaWorldState();
+    if(team == ALLIANCE)
+    {
+        m_WyvernStateSouth = WYVERN_NEU_HORDE;
+        m_WyvernStateNorth = WYVERN_NEU_HORDE;
+        m_WyvernStateEast = WYVERN_NEU_HORDE;
+        m_WyvernStateWest = WYVERN_NEU_HORDE;
+        m_PvP->SendUpdateWorldState(NA_UI_HORDE_GUARDS_SHOW, 0);
+        m_PvP->SendUpdateWorldState(NA_UI_ALLIANCE_GUARDS_SHOW, 1);
+        m_PvP->SendUpdateWorldState(NA_UI_GUARDS_LEFT, m_GuardsAlive);
+        sWorld.SendZoneText(NA_HALAA_GRAVEYARD_ZONE,objmgr.GetMangosString(LANG_OPVP_NA_CAPTURE_A,-1));
+    }
+    else
+    {
+        m_WyvernStateSouth = WYVERN_NEU_ALLIANCE;
+        m_WyvernStateNorth = WYVERN_NEU_ALLIANCE;
+        m_WyvernStateEast = WYVERN_NEU_ALLIANCE;
+        m_WyvernStateWest = WYVERN_NEU_ALLIANCE;
+        m_PvP->SendUpdateWorldState(NA_UI_HORDE_GUARDS_SHOW, 1);
+        m_PvP->SendUpdateWorldState(NA_UI_ALLIANCE_GUARDS_SHOW, 0);
+        m_PvP->SendUpdateWorldState(NA_UI_GUARDS_LEFT, m_GuardsAlive);
+        sWorld.SendZoneText(NA_HALAA_GRAVEYARD_ZONE,objmgr.GetMangosString(LANG_OPVP_NA_CAPTURE_H,-1));
+    }
+    this->UpdateWyvernRoostWorldState(NA_ROOST_S);
+    this->UpdateWyvernRoostWorldState(NA_ROOST_N);
+    this->UpdateWyvernRoostWorldState(NA_ROOST_W);
+    this->UpdateWyvernRoostWorldState(NA_ROOST_E);
+    ((OutdoorPvPNA*)m_PvP)->BuffTeam(team);
+}
+
+bool OutdoorPvPObjectiveNA::HandlePlayerEnter(Player *plr)
+{
+    if(OutdoorPvPObjective::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(NA_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+        plr->SendUpdateWorldState(NA_UI_TOWER_SLIDER_POS, phase);
+        plr->SendUpdateWorldState(NA_UI_TOWER_SLIDER_N, m_NeutralValue);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveNA::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(NA_UI_TOWER_SLIDER_DISPLAY, 0);
+    OutdoorPvPObjective::HandlePlayerLeave(plr);
+}
+
+OutdoorPvPObjectiveNA::OutdoorPvPObjectiveNA(OutdoorPvP *pvp) : 
+OutdoorPvPObjective(pvp), m_capturable(true), m_GuardsAlive(0), m_ControllingFaction(0),
+m_HalaaState(HALAA_N), m_WyvernStateSouth(0), m_WyvernStateNorth(0), m_WyvernStateWest(0),
+m_WyvernStateEast(0), m_RespawnTimer(NA_RESPAWN_TIME), m_GuardCheckTimer(NA_GUARD_CHECK_TIME)
+{
+    AddCapturePoint(182210,530,-1572.57,7945.3,-22.475,2.05949,0,0,0.857167,0.515038);
+}
+
+bool OutdoorPvPNA::SetupOutdoorPvP()
+{
+//    m_TypeId = OUTDOOR_PVP_NA; _MUST_ be set in ctor, because of spawns cleanup
+    // add the zones affected by the pvp buff
+    sOutdoorPvPMgr.AddZone(NA_BUFF_ZONE,this);
+
+    // halaa
+    m_obj = new OutdoorPvPObjectiveNA(this);
+    if(!m_obj)
+        return false;
+    m_OutdoorPvPObjectives.insert(m_obj);
+
+    return true;
+}
+
+void OutdoorPvPNA::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    // add buffs
+    if(plr->GetTeam() == m_obj->m_ControllingFaction)
+        plr->CastSpell(plr,NA_CAPTURE_BUFF,true);
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPNA::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    plr->RemoveAurasDueToSpell(NA_CAPTURE_BUFF);
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+void OutdoorPvPNA::FillInitialWorldStates(WorldPacket &data)
+{
+    m_obj->FillInitialWorldStates(data);
+}
+
+void OutdoorPvPObjectiveNA::FillInitialWorldStates(WorldPacket &data)
+{
+    if(m_ControllingFaction == ALLIANCE)
+    {
+        data << NA_UI_HORDE_GUARDS_SHOW << uint32(0);
+        data << NA_UI_ALLIANCE_GUARDS_SHOW << uint32(1);
+    }
+    else if(m_ControllingFaction == HORDE)
+    {
+        data << NA_UI_HORDE_GUARDS_SHOW << uint32(1);
+        data << NA_UI_ALLIANCE_GUARDS_SHOW << uint32(0);
+    }
+    else
+    {
+        data << NA_UI_HORDE_GUARDS_SHOW << uint32(0);
+        data << NA_UI_ALLIANCE_GUARDS_SHOW << uint32(0);
+    }
+
+    data << NA_UI_GUARDS_MAX << NA_GUARDS_MAX;
+    data << NA_UI_GUARDS_LEFT << uint32(m_GuardsAlive);
+
+    data << NA_UI_TOWER_SLIDER_DISPLAY << uint32(0);
+    data << NA_UI_TOWER_SLIDER_POS << uint32(50);
+    data << NA_UI_TOWER_SLIDER_N << uint32(100);
+
+    data << NA_MAP_WYVERN_NORTH_NEU_H << uint32(bool(m_WyvernStateNorth & WYVERN_NEU_HORDE));
+    data << NA_MAP_WYVERN_NORTH_NEU_A << uint32(bool(m_WyvernStateNorth & WYVERN_NEU_ALLIANCE));
+    data << NA_MAP_WYVERN_NORTH_H << uint32(bool(m_WyvernStateNorth & WYVERN_HORDE));
+    data << NA_MAP_WYVERN_NORTH_A << uint32(bool(m_WyvernStateNorth & WYVERN_ALLIANCE));
+
+    data << NA_MAP_WYVERN_SOUTH_NEU_H << uint32(bool(m_WyvernStateSouth & WYVERN_NEU_HORDE));
+    data << NA_MAP_WYVERN_SOUTH_NEU_A << uint32(bool(m_WyvernStateSouth & WYVERN_NEU_ALLIANCE));
+    data << NA_MAP_WYVERN_SOUTH_H << uint32(bool(m_WyvernStateSouth & WYVERN_HORDE));
+    data << NA_MAP_WYVERN_SOUTH_A << uint32(bool(m_WyvernStateSouth & WYVERN_ALLIANCE));
+
+    data << NA_MAP_WYVERN_WEST_NEU_H << uint32(bool(m_WyvernStateWest & WYVERN_NEU_HORDE));
+    data << NA_MAP_WYVERN_WEST_NEU_A << uint32(bool(m_WyvernStateWest & WYVERN_NEU_ALLIANCE));
+    data << NA_MAP_WYVERN_WEST_H << uint32(bool(m_WyvernStateWest & WYVERN_HORDE));
+    data << NA_MAP_WYVERN_WEST_A << uint32(bool(m_WyvernStateWest & WYVERN_ALLIANCE));
+
+    data << NA_MAP_WYVERN_EAST_NEU_H << uint32(bool(m_WyvernStateEast & WYVERN_NEU_HORDE));
+    data << NA_MAP_WYVERN_EAST_NEU_A << uint32(bool(m_WyvernStateEast & WYVERN_NEU_ALLIANCE));
+    data << NA_MAP_WYVERN_EAST_H << uint32(bool(m_WyvernStateEast & WYVERN_HORDE));
+    data << NA_MAP_WYVERN_EAST_A << uint32(bool(m_WyvernStateEast & WYVERN_ALLIANCE));
+
+    data << NA_MAP_HALAA_NEUTRAL << uint32(bool(m_HalaaState & HALAA_N));
+    data << NA_MAP_HALAA_NEU_A << uint32(bool(m_HalaaState & HALAA_N_A));
+    data << NA_MAP_HALAA_NEU_H << uint32(bool(m_HalaaState & HALAA_N_H));
+    data << NA_MAP_HALAA_HORDE << uint32(bool(m_HalaaState & HALAA_H));
+    data << NA_MAP_HALAA_ALLIANCE << uint32(bool(m_HalaaState & HALAA_A)); 
+}
+
+void OutdoorPvPNA::SendRemoveWorldStates(Player *plr)
+{
+    plr->SendUpdateWorldState(NA_UI_HORDE_GUARDS_SHOW,0);
+    plr->SendUpdateWorldState(NA_UI_ALLIANCE_GUARDS_SHOW,0);
+    plr->SendUpdateWorldState(NA_UI_GUARDS_MAX,0);
+    plr->SendUpdateWorldState(NA_UI_GUARDS_LEFT,0);
+    plr->SendUpdateWorldState(NA_UI_TOWER_SLIDER_DISPLAY,0);
+    plr->SendUpdateWorldState(NA_UI_TOWER_SLIDER_POS,0);
+    plr->SendUpdateWorldState(NA_UI_TOWER_SLIDER_N,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_NEU_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_NEU_A,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_A,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_NEU_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_NEU_A,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_A,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_WEST_NEU_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_WEST_NEU_A,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_WEST_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_WEST_A,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_EAST_NEU_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_EAST_NEU_A,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_EAST_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_EAST_A,0);
+    plr->SendUpdateWorldState(NA_MAP_HALAA_NEUTRAL,0);
+    plr->SendUpdateWorldState(NA_MAP_HALAA_NEU_A,0);
+    plr->SendUpdateWorldState(NA_MAP_HALAA_NEU_H,0);
+    plr->SendUpdateWorldState(NA_MAP_HALAA_HORDE,0);
+    plr->SendUpdateWorldState(NA_MAP_HALAA_ALLIANCE,0); 
+}
+
+bool OutdoorPvPNA::Update(uint32 diff)
+{
+    return m_obj->Update(diff);
+}
+
+bool OutdoorPvPObjectiveNA::HandleCustomSpell(Player * plr, uint32 spellId, GameObject * go)
+{
+    std::vector<uint32> nodes;
+    nodes.resize(2);
+    bool retval = false;
+    switch(spellId)
+    {
+    case NA_SPELL_FLY_NORTH:
+        nodes[0] = FlightPathStartNodes[NA_ROOST_N];
+        nodes[1] = FlightPathEndNodes[NA_ROOST_N];
+        plr->ActivateTaxiPathTo(nodes);
+        plr->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);
+        plr->UpdatePvP(true,true);
+        retval = true;
+        break;
+    case NA_SPELL_FLY_SOUTH:
+        nodes[0] = FlightPathStartNodes[NA_ROOST_S];
+        nodes[1] = FlightPathEndNodes[NA_ROOST_S];
+        plr->ActivateTaxiPathTo(nodes);
+        plr->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);
+        plr->UpdatePvP(true,true);
+        retval = true;
+        break;
+    case NA_SPELL_FLY_WEST:
+        nodes[0] = FlightPathStartNodes[NA_ROOST_W];
+        nodes[1] = FlightPathEndNodes[NA_ROOST_W];
+        plr->ActivateTaxiPathTo(nodes);
+        plr->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);
+        plr->UpdatePvP(true,true);
+        retval = true;
+        break;
+    case NA_SPELL_FLY_EAST:
+        nodes[0] = FlightPathStartNodes[NA_ROOST_E];
+        nodes[1] = FlightPathEndNodes[NA_ROOST_E];
+        plr->ActivateTaxiPathTo(nodes);
+        plr->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);
+        plr->UpdatePvP(true,true);
+        retval = true;
+        break;
+    default:
+        break;
+    }
+
+    if(retval)
+    {
+        //Adding items
+        uint32 noSpaceForCount = 0;
+
+        // check space and find places
+        ItemPosCountVec dest;                           
+
+        int32 count = 10;
+        uint32 itemid = 24538;
+                                                                // bomb id count
+        uint8 msg = plr->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, itemid, count, &noSpaceForCount );
+        if( msg != EQUIP_ERR_OK )                               // convert to possible store amount
+            count -= noSpaceForCount;
+
+        if( count == 0 || dest.empty())                         // can't add any
+        {
+            return true;
+        }
+
+        Item* item = plr->StoreNewItem( dest, itemid, true);
+
+        if(count > 0 && item)
+        {
+            plr->SendNewItem(item,count,true,false);
+        }
+
+        return true;
+    }
+    return false;
+}
+
+int32 OutdoorPvPObjectiveNA::HandleOpenGo(Player *plr, uint64 guid)
+{
+    uint32 retval = OutdoorPvPObjective::HandleOpenGo(plr, guid);
+    if(retval>=0)
+    {
+        const go_type * gos = NULL;
+        if(m_ControllingFaction == ALLIANCE)
+            gos=AllianceControlGOs;
+        else if(m_ControllingFaction == HORDE)
+            gos=HordeControlGOs;
+        else
+            return -1;
+
+        int32 del = -1;
+        int32 del2 = -1;
+        int32 add = -1;
+        int32 add2 = -1;
+
+        switch(retval)
+        {
+        case NA_DESTROYED_ROOST_S:
+            del = NA_DESTROYED_ROOST_S;
+            add = NA_ROOST_S;
+            add2 = NA_BOMB_WAGON_S;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateSouth = WYVERN_ALLIANCE;
+            else
+                m_WyvernStateSouth = WYVERN_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_S);
+            break;
+        case NA_DESTROYED_ROOST_N:
+            del = NA_DESTROYED_ROOST_N;
+            add = NA_ROOST_N;
+            add2 = NA_BOMB_WAGON_N;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateNorth = WYVERN_ALLIANCE;
+            else
+                m_WyvernStateNorth = WYVERN_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_N);
+            break;
+        case NA_DESTROYED_ROOST_W:
+            del = NA_DESTROYED_ROOST_W;
+            add = NA_ROOST_W;
+            add2 = NA_BOMB_WAGON_W;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateWest = WYVERN_ALLIANCE;
+            else
+                m_WyvernStateWest = WYVERN_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_W);
+            break;
+        case NA_DESTROYED_ROOST_E:
+            del = NA_DESTROYED_ROOST_E;
+            add = NA_ROOST_E;
+            add2 = NA_BOMB_WAGON_E;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateEast = WYVERN_ALLIANCE;
+            else
+                m_WyvernStateEast = WYVERN_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_E);
+            break;
+        case NA_BOMB_WAGON_S:
+            del = NA_BOMB_WAGON_S;
+            del2 = NA_ROOST_S;
+            add = NA_DESTROYED_ROOST_S;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateSouth = WYVERN_NEU_ALLIANCE;
+            else
+                m_WyvernStateSouth = WYVERN_NEU_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_S);
+            break;
+        case NA_BOMB_WAGON_N:
+            del = NA_BOMB_WAGON_N;
+            del2 = NA_ROOST_N;
+            add = NA_DESTROYED_ROOST_N;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateNorth = WYVERN_NEU_ALLIANCE;
+            else
+                m_WyvernStateNorth = WYVERN_NEU_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_N);
+            break;
+        case NA_BOMB_WAGON_W:
+            del = NA_BOMB_WAGON_W;
+            del2 = NA_ROOST_W;
+            add = NA_DESTROYED_ROOST_W;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateWest = WYVERN_NEU_ALLIANCE;
+            else
+                m_WyvernStateWest = WYVERN_NEU_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_W);
+            break;
+        case NA_BOMB_WAGON_E:
+            del = NA_BOMB_WAGON_E;
+            del2 = NA_ROOST_E;
+            add = NA_DESTROYED_ROOST_E;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateEast = WYVERN_NEU_ALLIANCE;
+            else
+                m_WyvernStateEast = WYVERN_NEU_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_E);
+            break;
+        default:
+            return -1;
+            break;
+        }
+
+        if(del>-1)
+            DelObject(del);
+
+        if(del2>-1)
+            DelObject(del2);
+
+        if(add>-1)
+            AddObject(add,gos[add].entry,gos[add].map,gos[add].x,gos[add].y,gos[add].z,gos[add].o,gos[add].rot0,gos[add].rot1,gos[add].rot2,gos[add].rot3);
+
+        if(add2>-1)
+            AddObject(add2,gos[add2].entry,gos[add2].map,gos[add2].x,gos[add2].y,gos[add2].z,gos[add2].o,gos[add2].rot0,gos[add2].rot1,gos[add2].rot2,gos[add2].rot3);
+
+        return retval;
+    }
+    return -1;
+}
+
+bool OutdoorPvPObjectiveNA::Update(uint32 diff)
+{
+    // let the controlling faction advance in phase
+    bool capturable = false;
+    if(m_ControllingFaction == ALLIANCE && m_AllianceActivePlayerCount > m_HordeActivePlayerCount)
+        capturable = true;
+    else if(m_ControllingFaction == HORDE && m_AllianceActivePlayerCount < m_HordeActivePlayerCount)
+        capturable = true;
+
+    if(m_GuardCheckTimer < diff)
+    {
+        m_GuardCheckTimer = NA_GUARD_CHECK_TIME;
+        uint32 cnt = GetAliveGuardsCount();
+        if(cnt != m_GuardsAlive)
+        {
+            m_GuardsAlive = cnt;
+            if(m_GuardsAlive == 0)
+                m_capturable = true;
+            // update the guard count for the players in zone
+            m_PvP->SendUpdateWorldState(NA_UI_GUARDS_LEFT,m_GuardsAlive);
+        }
+    } else m_GuardCheckTimer -= diff;
+
+    if((m_capturable || capturable) && OutdoorPvPObjective::Update(diff))
+    {
+        if(m_RespawnTimer < diff)
+        {
+            // if the guards have been killed, then the challenger has one hour to take over halaa.
+            // in case they fail to do it, the guards are respawned, and they have to start again.
+            if(m_ControllingFaction)
+                FactionTakeOver(m_ControllingFaction);
+            m_RespawnTimer = NA_RESPAWN_TIME;
+        } else m_RespawnTimer -= diff;
+
+        if(m_OldState != m_State)
+        {
+            uint32 artkit = 21;
+            switch(m_State)
+            {
+            case OBJECTIVESTATE_NEUTRAL:
+                m_HalaaState = HALAA_N;
+                break;
+            case OBJECTIVESTATE_ALLIANCE:
+                m_HalaaState = HALAA_A;
+                FactionTakeOver(ALLIANCE);
+                artkit = 2;
+                break;
+            case OBJECTIVESTATE_HORDE:
+                m_HalaaState = HALAA_H;
+                FactionTakeOver(HORDE);
+                artkit = 1;
+                break;
+            case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+                m_HalaaState = HALAA_N_A;
+                break;
+            case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+                m_HalaaState = HALAA_N_H;
+                break;
+            case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+                m_HalaaState = HALAA_N_A;
+                artkit = 2;
+                break;
+            case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+                m_HalaaState = HALAA_N_H;
+                artkit = 1;
+                break;
+            }
+
+            GameObject* flag = HashMapHolder<GameObject>::Find(m_CapturePoint);
+            if(flag)
+            {
+                flag->SetGoArtKit(artkit);
+                flag->SendUpdateObjectToAllExcept(NULL);
+            }
+
+            UpdateHalaaWorldState();
+        }
+
+        if(m_ShiftPhase != m_OldPhase)
+        {
+            // send this too, sometimes the slider disappears, dunno why :(
+            SendUpdateWorldState(NA_UI_TOWER_SLIDER_DISPLAY, 1);
+            // send these updates to only the ones in this objective
+            uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+            SendUpdateWorldState(NA_UI_TOWER_SLIDER_POS, phase);
+            SendUpdateWorldState(NA_UI_TOWER_SLIDER_N, m_NeutralValue);
+        }
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveNA::UpdateHalaaWorldState()
+{
+    m_PvP->SendUpdateWorldState( NA_MAP_HALAA_NEUTRAL ,uint32(bool(m_HalaaState & HALAA_N)));
+    m_PvP->SendUpdateWorldState( NA_MAP_HALAA_NEU_A ,uint32(bool(m_HalaaState & HALAA_N_A)));
+    m_PvP->SendUpdateWorldState( NA_MAP_HALAA_NEU_H ,uint32(bool(m_HalaaState & HALAA_N_H)));
+    m_PvP->SendUpdateWorldState( NA_MAP_HALAA_HORDE ,uint32(bool(m_HalaaState & HALAA_H)));
+    m_PvP->SendUpdateWorldState( NA_MAP_HALAA_ALLIANCE ,uint32(bool(m_HalaaState & HALAA_A)));
+}
+
+void OutdoorPvPObjectiveNA::UpdateWyvernRoostWorldState(uint32 roost)
+{
+    switch(roost)
+    {
+    case NA_ROOST_S:
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_NEU_H,uint32(bool(m_WyvernStateSouth & WYVERN_NEU_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_NEU_A,uint32(bool(m_WyvernStateSouth & WYVERN_NEU_ALLIANCE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_H,uint32(bool(m_WyvernStateSouth & WYVERN_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_A,uint32(bool(m_WyvernStateSouth & WYVERN_ALLIANCE)));
+        break;
+    case NA_ROOST_N:
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_NEU_H,uint32(bool(m_WyvernStateNorth & WYVERN_NEU_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_NEU_A,uint32(bool(m_WyvernStateNorth & WYVERN_NEU_ALLIANCE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_H,uint32(bool(m_WyvernStateNorth & WYVERN_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_A,uint32(bool(m_WyvernStateNorth & WYVERN_ALLIANCE)));
+        break;
+    case NA_ROOST_W:
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_WEST_NEU_H,uint32(bool(m_WyvernStateWest & WYVERN_NEU_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_WEST_NEU_A,uint32(bool(m_WyvernStateWest & WYVERN_NEU_ALLIANCE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_WEST_H,uint32(bool(m_WyvernStateWest & WYVERN_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_WEST_A,uint32(bool(m_WyvernStateWest & WYVERN_ALLIANCE)));
+        break;
+    case NA_ROOST_E:
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_EAST_NEU_H,uint32(bool(m_WyvernStateEast & WYVERN_NEU_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_EAST_NEU_A,uint32(bool(m_WyvernStateEast & WYVERN_NEU_ALLIANCE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_EAST_H,uint32(bool(m_WyvernStateEast & WYVERN_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_EAST_A,uint32(bool(m_WyvernStateEast & WYVERN_ALLIANCE)));
+        break;
+    }
+}
+
+bool OutdoorPvPObjectiveNA::HandleCapturePointEvent(Player *plr, uint32 eventId)
+{
+    switch(eventId)
+    {
+    case 11821:
+        this->HandlePlayerEnter(plr);
+        return true;
+        break;
+    case 11822:
+        this->HandlePlayerLeave(plr);
+        return true;
+        break;
+    default:
+        break;
+    }
+    return false;
+}
diff --git a/src/game/OutdoorPvPNA.h b/src/game/OutdoorPvPNA.h
new file mode 100644
index 0000000..65a70bb
--- /dev/null
+++ b/src/game/OutdoorPvPNA.h
@@ -0,0 +1,279 @@
+#ifndef OUTDOOR_PVP_NA_
+#define OUTDOOR_PVP_NA_
+
+// TODO: "sometimes" set to neutral
+
+#include "OutdoorPvP.h"
+
+// kill credit for pks
+const uint32 NA_CREDIT_MARKER = 24867;
+
+const uint32 NA_KILL_TOKEN_ALLIANCE = 33005;
+const uint32 NA_KILL_TOKEN_HORDE = 33004;
+
+const uint32 NA_CAPTURE_BUFF = 33795;  // strength of the halaani
+
+const uint32 NA_GUARDS_MAX = 15;
+
+const uint32 NA_BUFF_ZONE = 3518;
+
+const uint32 NA_HALAA_GRAVEYARD = 993;
+
+const uint32 NA_HALAA_GRAVEYARD_ZONE = 3518; // need to add zone id, not area id
+
+const uint32 NA_RESPAWN_TIME = 3600000; // one hour to capture after defeating all guards
+
+const uint32 NA_GUARD_CHECK_TIME = 500; // every half second
+
+enum OutdoorPvPNAWorldStates{
+    NA_UI_HORDE_GUARDS_SHOW = 2503,
+    NA_UI_ALLIANCE_GUARDS_SHOW = 2502,
+    NA_UI_GUARDS_MAX = 2493,
+    NA_UI_GUARDS_LEFT = 2491,
+
+    NA_UI_TOWER_SLIDER_DISPLAY = 2495,
+    NA_UI_TOWER_SLIDER_POS = 2494,
+    NA_UI_TOWER_SLIDER_N = 2497,
+
+    NA_MAP_WYVERN_NORTH_NEU_H = 2762,
+    NA_MAP_WYVERN_NORTH_NEU_A = 2662,
+    NA_MAP_WYVERN_NORTH_H = 2663,
+    NA_MAP_WYVERN_NORTH_A = 2664,
+
+    NA_MAP_WYVERN_SOUTH_NEU_H = 2760,
+    NA_MAP_WYVERN_SOUTH_NEU_A = 2670,
+    NA_MAP_WYVERN_SOUTH_H = 2668,
+    NA_MAP_WYVERN_SOUTH_A = 2669,
+
+    NA_MAP_WYVERN_WEST_NEU_H = 2761,
+    NA_MAP_WYVERN_WEST_NEU_A = 2667,
+    NA_MAP_WYVERN_WEST_H = 2665,
+    NA_MAP_WYVERN_WEST_A = 2666,
+
+    NA_MAP_WYVERN_EAST_NEU_H = 2763,
+    NA_MAP_WYVERN_EAST_NEU_A = 2659,
+    NA_MAP_WYVERN_EAST_H = 2660,
+    NA_MAP_WYVERN_EAST_A = 2661,
+
+    NA_MAP_HALAA_NEUTRAL = 2671,
+    NA_MAP_HALAA_NEU_A = 2676,
+    NA_MAP_HALAA_NEU_H = 2677,
+    NA_MAP_HALAA_HORDE = 2672,
+    NA_MAP_HALAA_ALLIANCE = 2673 
+};
+
+const uint32 FLIGHT_NODES_NUM = 4;
+
+// used to access the elements of Horde/AllyControlGOs
+enum ControlGOTypes{
+    NA_ROOST_S = 0,
+    NA_ROOST_W = 1,
+    NA_ROOST_N = 2,
+    NA_ROOST_E = 3,
+
+    NA_BOMB_WAGON_S = 4,
+    NA_BOMB_WAGON_W = 5,
+    NA_BOMB_WAGON_N = 6,
+    NA_BOMB_WAGON_E = 7,
+
+    NA_DESTROYED_ROOST_S = 8, 
+    NA_DESTROYED_ROOST_W = 9, 
+    NA_DESTROYED_ROOST_N = 10,
+    NA_DESTROYED_ROOST_E = 11,
+
+    NA_CONTROL_GO_NUM = 12
+};
+
+const uint32 FlightPathStartNodes[FLIGHT_NODES_NUM] = {103,105,107,109};
+const uint32 FlightPathEndNodes[FLIGHT_NODES_NUM] = {104,106,108,110};
+
+enum FlightSpellsNA{
+    NA_SPELL_FLY_SOUTH = 32059,
+    NA_SPELL_FLY_WEST = 32068,
+    NA_SPELL_FLY_NORTH = 32075,
+    NA_SPELL_FLY_EAST = 32081
+};
+
+// spawned when the alliance is attacking, horde is in control
+const go_type HordeControlGOs[NA_CONTROL_GO_NUM] = {
+    {182267,530,-1815.8,8036.51,-26.2354,-2.89725,0,0,0.992546,-0.121869}, //ALLY_ROOST_SOUTH
+    {182280,530,-1507.95,8132.1,-19.5585,-1.3439,0,0,0.622515,-0.782608}, //ALLY_ROOST_WEST
+    {182281,530,-1384.52,7779.33,-11.1663,-0.575959,0,0,0.284015,-0.95882}, //ALLY_ROOST_NORTH
+    {182282,530,-1650.11,7732.56,-15.4505,-2.80998,0,0,0.986286,-0.165048}, //ALLY_ROOST_EAST
+
+    {182222,530,-1825.4022,8039.2602,-26.08,-2.89725,0,0,0.992546,-0.121869}, //HORDE_BOMB_WAGON_SOUTH
+    {182272,530,-1515.37,8136.91,-20.42,-1.3439,0,0,0.622515,-0.782608}, //HORDE_BOMB_WAGON_WEST
+    {182273,530,-1377.95,7773.44,-10.31,-0.575959,0,0,0.284015,-0.95882}, //HORDE_BOMB_WAGON_NORTH
+    {182274,530,-1659.87,7733.15,-15.75,-2.80998,0,0,0.986286,-0.165048}, //HORDE_BOMB_WAGON_EAST
+
+    {182266,530,-1815.8,8036.51,-26.2354,-2.89725,0,0,0.992546,-0.121869}, //DESTROYED_ALLY_ROOST_SOUTH
+    {182275,530,-1507.95,8132.1,-19.5585,-1.3439,0,0,0.622515,-0.782608}, //DESTROYED_ALLY_ROOST_WEST
+    {182276,530,-1384.52,7779.33,-11.1663,-0.575959,0,0,0.284015,-0.95882}, //DESTROYED_ALLY_ROOST_NORTH
+    {182277,530,-1650.11,7732.56,-15.4505,-2.80998,0,0,0.986286,-0.165048}  //DESTROYED_ALLY_ROOST_EAST
+};
+
+// spawned when the horde is attacking, alliance is in control
+const go_type AllianceControlGOs[NA_CONTROL_GO_NUM] = {
+    {182301,530,-1815.8,8036.51,-26.2354,-2.89725,0,0,0.992546,-0.121869}, //HORDE_ROOST_SOUTH
+    {182302,530,-1507.95,8132.1,-19.5585,-1.3439,0,0,0.622515,-0.782608}, //HORDE_ROOST_WEST
+    {182303,530,-1384.52,7779.33,-11.1663,-0.575959,0,0,0.284015,-0.95882}, //HORDE_ROOST_NORTH
+    {182304,530,-1650.11,7732.56,-15.4505,-2.80998,0,0,0.986286,-0.165048}, //HORDE_ROOST_EAST
+
+    {182305,530,-1825.4022,8039.2602,-26.08,-2.89725,0,0,0.992546,-0.121869}, //ALLY_BOMB_WAGON_SOUTH
+    {182306,530,-1515.37,8136.91,-20.42,-1.3439,0,0,0.622515,-0.782608}, //ALLY_BOMB_WAGON_WEST
+    {182307,530,-1377.95,7773.44,-10.31,-0.575959,0,0,0.284015,-0.95882}, //ALLY_BOMB_WAGON_NORTH
+    {182308,530,-1659.87,7733.15,-15.75,-2.80998,0,0,0.986286,-0.165048}, //ALLY_BOMB_WAGON_EAST
+
+    {182297,530,-1815.8,8036.51,-26.2354,-2.89725,0,0,0.992546,-0.121869}, //DESTROYED_HORDE_ROOST_SOUTH
+    {182298,530,-1507.95,8132.1,-19.5585,-1.3439,0,0,0.622515,-0.782608}, //DESTROYED_HORDE_ROOST_WEST
+    {182299,530,-1384.52,7779.33,-11.1663,-0.575959,0,0,0.284015,-0.95882}, //DESTROYED_HORDE_ROOST_NORTH
+    {182300,530,-1650.11,7732.56,-15.4505,-2.80998,0,0,0.986286,-0.165048}  //DESTROYED_HORDE_ROOST_EAST
+};
+
+enum ControlNPCTypes{
+    NA_NPC_RESEARCHER = 0,
+    NA_NPC_QUARTERMASTER,
+    NA_NPC_BLADE_MERCHANT,
+    NA_NPC_FOOD_MERCHANT,
+    NA_NPC_AMMO,
+
+    NA_NPC_GUARD_01,
+    NA_NPC_GUARD_02,
+    NA_NPC_GUARD_03,
+    NA_NPC_GUARD_04,
+    NA_NPC_GUARD_05,
+    NA_NPC_GUARD_06,
+    NA_NPC_GUARD_07,
+    NA_NPC_GUARD_08,
+    NA_NPC_GUARD_09,
+    NA_NPC_GUARD_10,
+    NA_NPC_GUARD_11,
+    NA_NPC_GUARD_12,
+    NA_NPC_GUARD_13,
+    NA_NPC_GUARD_14,
+    NA_NPC_GUARD_15,
+
+    NA_CONTROL_NPC_NUM
+};
+
+const creature_type HordeControlNPCs[NA_CONTROL_NPC_NUM] = {
+    {18816,67,530,-1523.92,7951.76,-17.6942,3.51172},
+    {18821,67,530,-1527.75,7952.46,-17.6948,3.99317},
+    {21474,67,530,-1520.14,7927.11,-20.2527,3.39389},
+    {21484,67,530,-1524.84,7930.34,-20.182,3.6405},
+    {21483,67,530,-1570.01,7993.8,-22.4505,5.02655},
+    {18192,67,530,-1654.06,8000.46,-26.59,3.37},
+    {18192,67,530,-1487.18,7899.1,-19.53,0.954},
+    {18192,67,530,-1480.88,7908.79,-19.19,4.485},
+    {18192,67,530,-1540.56,7995.44,-20.45,0.947},
+    {18192,67,530,-1546.95,8000.85,-20.72,6.035},
+    {18192,67,530,-1595.31,7860.53,-21.51,3.747},
+    {18192,67,530,-1642.31,7995.59,-25.8,3.317},
+    {18192,67,530,-1545.46,7995.35,-20.63,1.094},
+    {18192,67,530,-1487.58,7907.99,-19.27,5.567},
+    {18192,67,530,-1651.54,7988.56,-26.5289,2.98451},
+    {18192,67,530,-1602.46,7866.43,-22.1177,4.74729},
+    {18192,67,530,-1591.22,7875.29,-22.3536,4.34587},
+    {18192,67,530,-1550.6,7944.45,-21.63,3.559},
+    {18192,67,530,-1545.57,7935.83,-21.13,3.448},
+    {18192,67,530,-1550.86,7937.56,-21.7,3.801}
+};
+
+const creature_type AllianceControlNPCs[NA_CONTROL_NPC_NUM] = {
+    {18817,469,530,-1591.18,8020.39,-22.2042,4.59022},
+    {18822,469,530,-1588.0,8019.0,-22.2042,4.06662},
+    {21485,469,530,-1521.93,7927.37,-20.2299,3.24631},
+    {21487,469,530,-1540.33,7971.95,-20.7186,3.07178},
+    {21488,469,530,-1570.01,7993.8,-22.4505,5.02655},
+    {18256,469,530,-1654.06,8000.46,-26.59,3.37},
+    {18256,469,530,-1487.18,7899.1,-19.53,0.954},
+    {18256,469,530,-1480.88,7908.79,-19.19,4.485},
+    {18256,469,530,-1540.56,7995.44,-20.45,0.947},
+    {18256,469,530,-1546.95,8000.85,-20.72,6.035},
+    {18256,469,530,-1595.31,7860.53,-21.51,3.747},
+    {18256,469,530,-1642.31,7995.59,-25.8,3.317},
+    {18256,469,530,-1545.46,7995.35,-20.63,1.094},
+    {18256,469,530,-1487.58,7907.99,-19.27,5.567},
+    {18256,469,530,-1651.54,7988.56,-26.5289,2.98451},
+    {18256,469,530,-1602.46,7866.43,-22.1177,4.74729},
+    {18256,469,530,-1591.22,7875.29,-22.3536,4.34587},
+    {18256,469,530,-1603.75,8000.36,-24.18,4.516},
+    {18256,469,530,-1585.73,7994.68,-23.29,4.439},
+    {18256,469,530,-1595.5,7991.27,-23.53,4.738}
+};
+
+enum WyvernStates{
+    WYVERN_NEU_HORDE = 1,
+    WYVERN_NEU_ALLIANCE = 2,
+    WYVERN_HORDE = 4,
+    WYVERN_ALLIANCE = 8
+};
+
+enum HalaaStates{
+    HALAA_N = 1,
+    HALAA_N_A = 2,
+    HALAA_A = 4,
+    HALAA_N_H = 8,
+    HALAA_H = 16
+};
+
+class Unit;
+class Creature;
+class OutdoorPvPNA;
+class OutdoorPvPObjectiveNA : public OutdoorPvPObjective
+{
+friend class OutdoorPvPNA;
+public:
+    OutdoorPvPObjectiveNA(OutdoorPvP * pvp);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+    bool HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go);
+    int32 HandleOpenGo(Player *plr, uint64 guid);
+    uint32 GetAliveGuardsCount();
+protected:
+    // called when a faction takes control
+    void FactionTakeOver(uint32 team);
+
+    void DeSpawnNPCs();
+    void DeSpawnGOs();
+    void SpawnNPCsForTeam(uint32 team);
+    void SpawnGOsForTeam(uint32 team);
+
+    void UpdateWyvernRoostWorldState(uint32 roost);
+    void UpdateHalaaWorldState();
+
+    bool HandleCapturePointEvent(Player * plr, uint32 eventId);
+private:
+    bool m_capturable;
+    uint32 m_GuardsAlive;
+    uint32 m_ControllingFaction;
+    uint32 m_WyvernStateNorth;
+    uint32 m_WyvernStateSouth;
+    uint32 m_WyvernStateEast;
+    uint32 m_WyvernStateWest;
+    uint32 m_HalaaState;
+    uint32 m_RespawnTimer;
+    uint32 m_GuardCheckTimer;
+};
+
+class OutdoorPvPNA : public OutdoorPvP
+{
+friend class OutdoorPvPObjectiveNA;
+public:
+    OutdoorPvPNA();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket &data);
+    void SendRemoveWorldStates(Player * plr);
+    void HandleKillImpl(Player * plr, Unit * killed);
+    void BuffTeam(uint32 team);
+private:
+    OutdoorPvPObjectiveNA * m_obj;
+};
+
+#endif
diff --git a/src/game/OutdoorPvPObjectiveAI.cpp b/src/game/OutdoorPvPObjectiveAI.cpp
new file mode 100644
index 0000000..1e28d42
--- /dev/null
+++ b/src/game/OutdoorPvPObjectiveAI.cpp
@@ -0,0 +1,65 @@
+/* 
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "OutdoorPvPObjectiveAI.h"
+#include "Creature.h"
+#include "Player.h"
+#include "Unit.h"
+#include "OutdoorPvPMgr.h"
+#include "World.h"
+
+#define MAX_OUTDOOR_PVP_DISTANCE 200 // the max value in capture point type go data0 is 100 currently, so use twice that much to handle leaving as well
+
+OutdoorPvPObjectiveAI::OutdoorPvPObjectiveAI(Creature &c) : i_creature(c)
+{
+    sLog.outDebug("OutdoorPvP objective AI assigned to creature guid %u", c.GetGUIDLow());
+}
+
+void OutdoorPvPObjectiveAI::MoveInLineOfSight(Unit *u)
+{
+    // IsVisible only passes for players in range, so no need to check again
+    // leaving/entering distance will be checked based on go range data
+    sOutdoorPvPMgr.HandleCaptureCreaturePlayerMoveInLos(((Player*)u),&i_creature);
+}
+
+int OutdoorPvPObjectiveAI::Permissible(const Creature * c)
+{
+    // this AI can only be assigned if the AIName is OutdoorPvPObjectiveAI. It shouldn't be returned by permissible check.
+    return PERMIT_BASE_NO;
+}
+
+bool OutdoorPvPObjectiveAI::IsVisible(Unit *pl) const
+{
+    return (pl->GetTypeId() == TYPEID_PLAYER) && (i_creature.GetDistance(pl) < MAX_OUTDOOR_PVP_DISTANCE * MAX_OUTDOOR_PVP_DISTANCE);
+}
+
+void OutdoorPvPObjectiveAI::AttackStart(Unit *)
+{
+    EnterEvadeMode();
+}
+
+void OutdoorPvPObjectiveAI::EnterEvadeMode()
+{
+    i_creature.DeleteThreatList();
+    i_creature.CombatStop();
+}
+
+void OutdoorPvPObjectiveAI::UpdateAI(const uint32 diff)
+{
+}
+
diff --git a/src/game/OutdoorPvPObjectiveAI.h b/src/game/OutdoorPvPObjectiveAI.h
new file mode 100644
index 0000000..aa93740
--- /dev/null
+++ b/src/game/OutdoorPvPObjectiveAI.h
@@ -0,0 +1,43 @@
+/* 
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef MANGOS_OUTDOORPVPOBJECTIVEAI_H
+#define MANGOS_OUTDOORPVPOBJECTIVEAI_H
+
+#include "CreatureAI.h"
+
+class Creature;
+
+class MANGOS_DLL_DECL OutdoorPvPObjectiveAI : public CreatureAI
+{
+    public:
+
+        OutdoorPvPObjectiveAI(Creature &c);
+
+        void MoveInLineOfSight(Unit *);
+        bool IsVisible(Unit *) const;
+        void AttackStart(Unit *);
+        void EnterEvadeMode();
+        void UpdateAI(const uint32 diff);
+
+        static int Permissible(const Creature *);
+
+    private:
+        Creature &i_creature;
+};
+#endif
diff --git a/src/game/OutdoorPvPSI.cpp b/src/game/OutdoorPvPSI.cpp
new file mode 100644
index 0000000..7fd726f
--- /dev/null
+++ b/src/game/OutdoorPvPSI.cpp
@@ -0,0 +1,244 @@
+#include "OutdoorPvPSI.h"
+#include "WorldPacket.h"
+#include "Player.h"
+#include "GameObject.h"
+#include "MapManager.h"
+#include "ObjectMgr.h"
+#include "OutdoorPvPMgr.h"
+#include "Language.h"
+#include "World.h"
+
+OutdoorPvPSI::OutdoorPvPSI()
+{
+    m_TypeId = OUTDOOR_PVP_SI;
+    m_Gathered_A = 0;
+    m_Gathered_H = 0;
+    m_LastController = 0;
+}
+
+void OutdoorPvPSI::FillInitialWorldStates(WorldPacket &data)
+{
+    data << SI_GATHERED_A << m_Gathered_A;
+    data << SI_GATHERED_H << m_Gathered_H;
+    data << SI_SILITHYST_MAX << SI_MAX_RESOURCES;
+}
+
+void OutdoorPvPSI::SendRemoveWorldStates(Player *plr)
+{
+    plr->SendUpdateWorldState(SI_GATHERED_A,0);
+    plr->SendUpdateWorldState(SI_GATHERED_H,0);
+    plr->SendUpdateWorldState(SI_SILITHYST_MAX,0);
+}
+
+void OutdoorPvPSI::UpdateWorldState()
+{
+    SendUpdateWorldState(SI_GATHERED_A,m_Gathered_A);
+    SendUpdateWorldState(SI_GATHERED_H,m_Gathered_H);
+    SendUpdateWorldState(SI_SILITHYST_MAX,SI_MAX_RESOURCES);
+}
+
+bool OutdoorPvPSI::SetupOutdoorPvP()
+{
+    for(int i = 0; i < OutdoorPvPSIBuffZonesNum; ++i)
+        sOutdoorPvPMgr.AddZone(OutdoorPvPSIBuffZones[i],this);
+    return true;
+}
+
+bool OutdoorPvPSI::Update(uint32 diff)
+{
+    return false;
+}
+
+void OutdoorPvPSI::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    if(plr->GetTeam() == m_LastController)
+        plr->CastSpell(plr,SI_CENARION_FAVOR,true);
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPSI::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    plr->RemoveAurasDueToSpell(SI_CENARION_FAVOR);
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+void OutdoorPvPSI::BuffTeam(uint32 team)
+{
+    if(team == ALLIANCE)
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->CastSpell(plr,SI_CENARION_FAVOR,true);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(SI_CENARION_FAVOR);
+        }
+    }
+    else if(team == HORDE)
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->CastSpell(plr,SI_CENARION_FAVOR,true);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(SI_CENARION_FAVOR);
+        }
+    }
+    else
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(SI_CENARION_FAVOR);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(SI_CENARION_FAVOR);
+        }
+    }
+}
+
+bool OutdoorPvPSI::HandleAreaTrigger(Player *plr, uint32 trigger)
+{
+    switch(trigger)
+    {
+    case SI_AREATRIGGER_A:
+        if(plr->GetTeam() == ALLIANCE && plr->HasAura(SI_SILITHYST_FLAG,0))
+        {
+            // remove aura
+            plr->RemoveAurasDueToSpell(SI_SILITHYST_FLAG);
+            ++ m_Gathered_A;
+            if(m_Gathered_A >= SI_MAX_RESOURCES)
+            {
+                BuffTeam(ALLIANCE);
+                sWorld.SendZoneText(OutdoorPvPSIBuffZones[0],objmgr.GetMangosString(LANG_OPVP_SI_CAPTURE_A,-1));
+                m_LastController = ALLIANCE;
+                m_Gathered_A = 0;
+                m_Gathered_H = 0;
+            }
+            UpdateWorldState();
+            // reward player
+            plr->CastSpell(plr,SI_TRACES_OF_SILITHYST,true);
+            // add 19 honor
+            plr->RewardHonor(NULL,1,19);
+            // add 20 cenarion circle repu
+            plr->ModifyFactionReputation(609,20);
+            // complete quest
+            plr->KilledMonster(SI_TURNIN_QUEST_CM_A,0);
+        }
+        return true;
+    case SI_AREATRIGGER_H:
+        if(plr->GetTeam() == HORDE && plr->HasAura(SI_SILITHYST_FLAG,0))
+        {
+            // remove aura
+            plr->RemoveAurasDueToSpell(SI_SILITHYST_FLAG);
+            ++ m_Gathered_H;
+            if(m_Gathered_H >= SI_MAX_RESOURCES)
+            {
+                BuffTeam(HORDE);
+                sWorld.SendZoneText(OutdoorPvPSIBuffZones[0],objmgr.GetMangosString(LANG_OPVP_SI_CAPTURE_H,-1));
+                m_LastController = HORDE;
+                m_Gathered_A = 0;
+                m_Gathered_H = 0;
+            }
+            UpdateWorldState();
+            // reward player
+            plr->CastSpell(plr,SI_TRACES_OF_SILITHYST,true);
+            // add 19 honor
+            plr->RewardHonor(NULL,1,19);
+            // add 20 cenarion circle repu
+            plr->ModifyFactionReputation(609,20);
+            // complete quest
+            plr->KilledMonster(SI_TURNIN_QUEST_CM_H,0);
+        }
+        return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPSI::HandleDropFlag(Player *plr, uint32 spellId)
+{
+    if(spellId == SI_SILITHYST_FLAG)
+    {
+        // if it was dropped away from the player's turn-in point, then create a silithyst mound, if it was dropped near the areatrigger, then it was dispelled by the outdoorpvp, so do nothing
+        switch(plr->GetTeam())
+        {
+        case ALLIANCE:
+            {
+                AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(SI_AREATRIGGER_A);
+                if(atEntry)
+                {
+                    // 5.0f is safe-distance
+                    if(plr->GetDistance(atEntry->x,atEntry->y,atEntry->z) > 5.0f + atEntry->radius)
+                    {
+                        // he dropped it further, summon mound
+                        GameObject * go = new GameObject;
+                        Map * map = MapManager::Instance().GetMap(plr->GetMapId(), plr);
+                        if(!map)
+                            return true;
+                        if(!go->Create(objmgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT),SI_SILITHYST_MOUND, map,plr->GetPositionX(),plr->GetPositionY(),plr->GetPositionZ(),plr->GetOrientation(),0,0,0,0,100,1))
+                        {
+                            delete go;                
+                        }
+                        else
+                        {
+                            go->SetRespawnTime(0);
+                            map->Add(go);
+                        }
+                    }
+                }
+            }
+            break;
+        case HORDE:
+            {
+                AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(SI_AREATRIGGER_H);
+                if(atEntry)
+                {
+                    // 5.0f is safe-distance
+                    if(plr->GetDistance(atEntry->x,atEntry->y,atEntry->z) > 5.0f + atEntry->radius)
+                    {
+                        // he dropped it further, summon mound
+                        GameObject * go = new GameObject;
+                        Map * map = MapManager::Instance().GetMap(plr->GetMapId(), plr);
+                        if(!map)
+                            return true;
+                        if(!go->Create(objmgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT),SI_SILITHYST_MOUND, map ,plr->GetPositionX(),plr->GetPositionY(),plr->GetPositionZ(),plr->GetOrientation(),0,0,0,0,100,1))
+                        {
+                            delete go;                
+                        }
+                        else
+                        {
+                            go->SetRespawnTime(0);
+                            map->Add(go);
+                        }
+                    }
+                }
+            }
+            break;
+        }
+        return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPSI::HandleCustomSpell(Player *plr, uint32 spellId, GameObject *go)
+{
+    if(!go || spellId != SI_SILITHYST_FLAG_GO_SPELL)
+        return false;
+    plr->CastSpell(plr,SI_SILITHYST_FLAG,true);
+    if(go->GetGOInfo()->id == SI_SILITHYST_MOUND)
+    {
+        // despawn go
+        go->SetRespawnTime(0);
+        go->Delete();
+    }
+    return true;
+}
diff --git a/src/game/OutdoorPvPSI.h b/src/game/OutdoorPvPSI.h
new file mode 100644
index 0000000..9ee8c8a
--- /dev/null
+++ b/src/game/OutdoorPvPSI.h
@@ -0,0 +1,57 @@
+#ifndef OUTDOOR_PVP_SI_
+#define OUTDOOR_PVP_SI_
+
+#include "OutdoorPvP.h"
+
+const uint32 SI_SILITHYST_FLAG_GO_SPELL = 29518;
+
+const uint32 SI_SILITHYST_FLAG = 29519;
+
+const uint32 SI_TRACES_OF_SILITHYST = 29534;
+
+const uint32 SI_CENARION_FAVOR = 30754;
+
+const uint32 SI_MAX_RESOURCES = 200;
+
+const uint32 OutdoorPvPSIBuffZonesNum = 3;
+
+const uint32 OutdoorPvPSIBuffZones[OutdoorPvPSIBuffZonesNum] = { 1377, 3428, 3429 };
+
+const uint32 SI_AREATRIGGER_H = 4168;
+
+const uint32 SI_AREATRIGGER_A = 4162;
+
+const uint32 SI_TURNIN_QUEST_CM_A = 17090;
+
+const uint32 SI_TURNIN_QUEST_CM_H = 18199;
+
+const uint32 SI_SILITHYST_MOUND = 181597;
+
+enum SI_WorldStates{
+    SI_GATHERED_A = 2313,
+    SI_GATHERED_H = 2314,
+    SI_SILITHYST_MAX = 2317
+};
+
+class OutdoorPvPSI : public OutdoorPvP
+{
+public:
+    OutdoorPvPSI();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket &data);
+    void SendRemoveWorldStates(Player * plr);
+    bool HandleAreaTrigger(Player * plr, uint32 trigger);
+    bool HandleDropFlag(Player * plr, uint32 spellId);
+    bool HandleCustomSpell(Player * plr, uint32 spellId, GameObject *go);
+    void BuffTeam(uint32 team);
+    void UpdateWorldState();
+private:
+    uint32 m_Gathered_A;
+    uint32 m_Gathered_H;
+    uint32 m_LastController;
+};
+
+#endif
diff --git a/src/game/OutdoorPvPTF.cpp b/src/game/OutdoorPvPTF.cpp
new file mode 100644
index 0000000..bfbe343
--- /dev/null
+++ b/src/game/OutdoorPvPTF.cpp
@@ -0,0 +1,348 @@
+#include "OutdoorPvPTF.h"
+#include "OutdoorPvPMgr.h"
+#include "WorldPacket.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "Language.h"
+#include "World.h"
+
+OutdoorPvPTF::OutdoorPvPTF()
+{
+    m_TypeId = OUTDOOR_PVP_TF;
+}
+
+OutdoorPvPObjectiveTF::OutdoorPvPObjectiveTF(OutdoorPvP *pvp, OutdoorPvPTF_TowerType type)
+: OutdoorPvPObjective(pvp), m_TowerType(type), m_TowerState(TF_TOWERSTATE_N)
+{
+    AddCapturePoint(TFCapturePoints[type].entry,TFCapturePoints[type].map,TFCapturePoints[type].x,TFCapturePoints[type].y,TFCapturePoints[type].z,TFCapturePoints[type].o,TFCapturePoints[type].rot0,TFCapturePoints[type].rot1,TFCapturePoints[type].rot2,TFCapturePoints[type].rot3);
+}
+
+void OutdoorPvPObjectiveTF::FillInitialWorldStates(WorldPacket &data)
+{
+    data << uint32(TFTowerWorldStates[m_TowerType].n) << uint32(bool(m_TowerState & TF_TOWERSTATE_N));
+    data << uint32(TFTowerWorldStates[m_TowerType].h) << uint32(bool(m_TowerState & TF_TOWERSTATE_H));
+    data << uint32(TFTowerWorldStates[m_TowerType].a) << uint32(bool(m_TowerState & TF_TOWERSTATE_A));
+}
+
+void OutdoorPvPTF::FillInitialWorldStates(WorldPacket &data)
+{
+    data << TF_UI_TOWER_SLIDER_POS << uint32(50);
+    data << TF_UI_TOWER_SLIDER_N << uint32(100);
+    data << TF_UI_TOWER_SLIDER_DISPLAY << uint32(0);
+
+    data << TF_UI_TOWER_COUNT_H << m_HordeTowersControlled;
+    data << TF_UI_TOWER_COUNT_A << m_AllianceTowersControlled;
+    data << TF_UI_TOWERS_CONTROLLED_DISPLAY << uint32(!m_IsLocked);
+
+    data << TF_UI_LOCKED_TIME_MINUTES_FIRST_DIGIT << first_digit;
+    data << TF_UI_LOCKED_TIME_MINUTES_SECOND_DIGIT << second_digit;
+    data << TF_UI_LOCKED_TIME_HOURS << hours_left;
+
+    data << TF_UI_LOCKED_DISPLAY_NEUTRAL << uint32(m_IsLocked && !m_HordeTowersControlled && !m_AllianceTowersControlled);
+    data << TF_UI_LOCKED_DISPLAY_HORDE << uint32(m_IsLocked && (m_HordeTowersControlled > m_AllianceTowersControlled));
+    data << TF_UI_LOCKED_DISPLAY_ALLIANCE << uint32(m_IsLocked && (m_HordeTowersControlled < m_AllianceTowersControlled));
+
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        (*itr)->FillInitialWorldStates(data);
+    }
+}
+
+void OutdoorPvPTF::SendRemoveWorldStates(Player * plr)
+{
+    plr->SendUpdateWorldState(TF_UI_TOWER_SLIDER_POS,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_TOWER_SLIDER_N,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_TOWER_SLIDER_DISPLAY,uint32(0));
+
+    plr->SendUpdateWorldState(TF_UI_TOWER_COUNT_H,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_TOWER_COUNT_A,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_TOWERS_CONTROLLED_DISPLAY,uint32(0));
+
+    plr->SendUpdateWorldState(TF_UI_LOCKED_TIME_MINUTES_FIRST_DIGIT,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_LOCKED_TIME_MINUTES_SECOND_DIGIT,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_LOCKED_TIME_HOURS,uint32(0));
+
+    plr->SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_NEUTRAL,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_HORDE,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_ALLIANCE,uint32(0));
+
+    for(int i = 0; i < TF_TOWER_NUM; ++i)
+    {
+        plr->SendUpdateWorldState(uint32(TFTowerWorldStates[i].n),uint32(0));
+        plr->SendUpdateWorldState(uint32(TFTowerWorldStates[i].h),uint32(0));
+        plr->SendUpdateWorldState(uint32(TFTowerWorldStates[i].a),uint32(0));
+    }
+}
+
+void OutdoorPvPObjectiveTF::UpdateTowerState()
+{
+    m_PvP->SendUpdateWorldState(uint32(TFTowerWorldStates[m_TowerType].n),uint32(bool(m_TowerState & TF_TOWERSTATE_N)));
+    m_PvP->SendUpdateWorldState(uint32(TFTowerWorldStates[m_TowerType].h),uint32(bool(m_TowerState & TF_TOWERSTATE_H)));
+    m_PvP->SendUpdateWorldState(uint32(TFTowerWorldStates[m_TowerType].a),uint32(bool(m_TowerState & TF_TOWERSTATE_A)));
+}
+
+bool OutdoorPvPObjectiveTF::HandlePlayerEnter(Player *plr)
+{
+    if(OutdoorPvPObjective::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(TF_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+        plr->SendUpdateWorldState(TF_UI_TOWER_SLIDER_POS, phase);
+        plr->SendUpdateWorldState(TF_UI_TOWER_SLIDER_N, m_NeutralValue);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveTF::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(TF_UI_TOWER_SLIDER_DISPLAY, 0);
+    OutdoorPvPObjective::HandlePlayerLeave(plr);
+}
+
+bool OutdoorPvPObjectiveTF::HandleCapturePointEvent(Player *plr, uint32 eventId)
+{
+    if(eventId == TFTowerPlayerEnterEvents[m_TowerType])
+    {
+        this->HandlePlayerEnter(plr);
+        return true;
+    }
+    else if (eventId == TFTowerPlayerLeaveEvents[m_TowerType])
+    {
+        this->HandlePlayerLeave(plr);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPTF::BuffTeam(uint32 team)
+{
+    if(team == ALLIANCE)
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->CastSpell(plr,TF_CAPTURE_BUFF,true);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(TF_CAPTURE_BUFF);
+        }
+    }
+    else if(team == HORDE)
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->CastSpell(plr,TF_CAPTURE_BUFF,true);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(TF_CAPTURE_BUFF);
+        }
+    }
+    else
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(TF_CAPTURE_BUFF);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(TF_CAPTURE_BUFF);
+        }
+    }
+}
+
+bool OutdoorPvPTF::Update(uint32 diff)
+{
+    bool changed = false;
+
+    if(changed = OutdoorPvP::Update(diff))
+    {
+        if(m_AllianceTowersControlled == TF_TOWER_NUM)
+        {
+            BuffTeam(ALLIANCE);
+            m_IsLocked = true;
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_NEUTRAL,uint32(0));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_HORDE,uint32(0));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_ALLIANCE,uint32(1));
+            SendUpdateWorldState(TF_UI_TOWERS_CONTROLLED_DISPLAY, uint32(0));
+        }
+        else if(m_HordeTowersControlled == TF_TOWER_NUM)
+        {
+            BuffTeam(HORDE);
+            m_IsLocked = true;
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_NEUTRAL,uint32(0));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_HORDE,uint32(1));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_ALLIANCE,uint32(0));
+            SendUpdateWorldState(TF_UI_TOWERS_CONTROLLED_DISPLAY, uint32(0));
+        }
+        else
+            BuffTeam(NULL);
+        SendUpdateWorldState(TF_UI_TOWER_COUNT_A, m_AllianceTowersControlled);
+        SendUpdateWorldState(TF_UI_TOWER_COUNT_H, m_HordeTowersControlled);
+    }
+    if(m_IsLocked)
+    {
+        // lock timer is down, release lock
+        if(m_LockTimer < diff)
+        {
+            m_LockTimer = TF_LOCK_TIME;
+            m_LockTimerUpdate = 0;
+            m_IsLocked = false;
+            SendUpdateWorldState(TF_UI_TOWERS_CONTROLLED_DISPLAY, uint32(1));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_NEUTRAL,uint32(0));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_HORDE,uint32(0));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_ALLIANCE,uint32(0));
+        }
+        else
+        {
+            // worldstateui update timer is down, update ui with new time data
+            if(m_LockTimerUpdate < diff)
+            {
+                m_LockTimerUpdate = TF_LOCK_TIME_UPDATE;
+                uint32 minutes_left = m_LockTimer / 60000;
+                hours_left = minutes_left / 60;
+                minutes_left -= hours_left * 60;
+                second_digit = minutes_left % 10;
+                first_digit = minutes_left / 10;
+
+                SendUpdateWorldState(TF_UI_LOCKED_TIME_MINUTES_FIRST_DIGIT,first_digit);
+                SendUpdateWorldState(TF_UI_LOCKED_TIME_MINUTES_SECOND_DIGIT,second_digit);
+                SendUpdateWorldState(TF_UI_LOCKED_TIME_HOURS,hours_left);
+            } else m_LockTimerUpdate -= diff;
+            m_LockTimer -= diff;
+        }
+    }
+    return changed;
+}
+
+void OutdoorPvPTF::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    if(plr->GetTeam() == ALLIANCE)
+    {
+        if(m_AllianceTowersControlled >= TF_TOWER_NUM)
+            plr->CastSpell(plr,TF_CAPTURE_BUFF,true);
+    }
+    else
+    {
+        if(m_HordeTowersControlled >= TF_TOWER_NUM)
+            plr->CastSpell(plr,TF_CAPTURE_BUFF,true);
+    }
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPTF::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    plr->RemoveAurasDueToSpell(TF_CAPTURE_BUFF);
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+bool OutdoorPvPTF::SetupOutdoorPvP()
+{
+    m_AllianceTowersControlled = 0;
+    m_HordeTowersControlled = 0;
+
+    m_IsLocked = false;
+    m_LockTimer = TF_LOCK_TIME;
+    m_LockTimerUpdate = 0; 
+    hours_left = 6;
+    second_digit = 0;
+    first_digit = 0;
+
+    // add the zones affected by the pvp buff
+    for(int i = 0; i < OutdoorPvPTFBuffZonesNum; ++i)
+        sOutdoorPvPMgr.AddZone(OutdoorPvPTFBuffZones[i],this);
+
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveTF(this,TF_TOWER_NW));
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveTF(this,TF_TOWER_N));
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveTF(this,TF_TOWER_NE));
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveTF(this,TF_TOWER_SE));
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveTF(this,TF_TOWER_S));
+
+    return true;
+}
+
+bool OutdoorPvPObjectiveTF::Update(uint32 diff)
+{
+    // can update even in locked state if gathers the controlling faction
+    bool canupdate = ((((OutdoorPvPTF*)m_PvP)->m_AllianceTowersControlled > 0) && this->m_AllianceActivePlayerCount > this->m_HordeActivePlayerCount) ||
+            ((((OutdoorPvPTF*)m_PvP)->m_HordeTowersControlled > 0) && this->m_AllianceActivePlayerCount < this->m_HordeActivePlayerCount);
+    // if gathers the other faction, then only update if the pvp is unlocked
+    canupdate = canupdate || !((OutdoorPvPTF*)m_PvP)->m_IsLocked;
+    if(canupdate && OutdoorPvPObjective::Update(diff))
+    {
+        if(m_OldState != m_State)
+        {
+            // if changing from controlling alliance to horde
+            if( m_OldState == OBJECTIVESTATE_ALLIANCE )
+            {
+                if(((OutdoorPvPTF*)m_PvP)->m_AllianceTowersControlled)
+                    ((OutdoorPvPTF*)m_PvP)->m_AllianceTowersControlled--;
+                sWorld.SendZoneText(OutdoorPvPTFBuffZones[0],objmgr.GetMangosString(LANG_OPVP_TF_LOOSE_A, -1));
+            }
+            // if changing from controlling horde to alliance
+            else if ( m_OldState == OBJECTIVESTATE_HORDE )
+            {
+                if(((OutdoorPvPTF*)m_PvP)->m_HordeTowersControlled)
+                    ((OutdoorPvPTF*)m_PvP)->m_HordeTowersControlled--;
+                sWorld.SendZoneText(OutdoorPvPTFBuffZones[0],objmgr.GetMangosString(LANG_OPVP_TF_LOOSE_H,-1));
+            }
+
+            uint32 artkit = 21;
+
+            switch(m_State)
+            {
+            case OBJECTIVESTATE_ALLIANCE:
+                m_TowerState = TF_TOWERSTATE_A;
+                artkit = 2;
+                if(((OutdoorPvPTF*)m_PvP)->m_AllianceTowersControlled<TF_TOWER_NUM)
+                    ((OutdoorPvPTF*)m_PvP)->m_AllianceTowersControlled++;
+                sWorld.SendZoneText(OutdoorPvPTFBuffZones[0],objmgr.GetMangosString(LANG_OPVP_TF_CAPTURE_A,-1));
+                break;
+            case OBJECTIVESTATE_HORDE:
+                m_TowerState = TF_TOWERSTATE_H;
+                artkit = 1;
+                if(((OutdoorPvPTF*)m_PvP)->m_HordeTowersControlled<TF_TOWER_NUM)
+                    ((OutdoorPvPTF*)m_PvP)->m_HordeTowersControlled++;
+                sWorld.SendZoneText(OutdoorPvPTFBuffZones[0],objmgr.GetMangosString(LANG_OPVP_TF_CAPTURE_H,-1));
+                break;
+            case OBJECTIVESTATE_NEUTRAL:
+            case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+            case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+            case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+            case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+                m_TowerState = TF_TOWERSTATE_N;
+                break;
+            }
+
+            GameObject* flag = HashMapHolder<GameObject>::Find(m_CapturePoint);
+            if(flag)
+            {
+                flag->SetGoArtKit(artkit);
+                flag->SendUpdateObjectToAllExcept(NULL);
+            }
+
+            UpdateTowerState();
+        }
+
+        if(m_ShiftPhase != m_OldPhase)
+        {
+            // send this too, sometimes the slider disappears, dunno why :(
+            SendUpdateWorldState(TF_UI_TOWER_SLIDER_DISPLAY, 1);
+            // send these updates to only the ones in this objective
+            uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+            SendUpdateWorldState(TF_UI_TOWER_SLIDER_POS, phase);
+            // send this too, sometimes it resets :S
+            SendUpdateWorldState(TF_UI_TOWER_SLIDER_N, m_NeutralValue);
+        }
+        return true;
+    }
+    return false;
+}
diff --git a/src/game/OutdoorPvPTF.h b/src/game/OutdoorPvPTF.h
new file mode 100644
index 0000000..802f163
--- /dev/null
+++ b/src/game/OutdoorPvPTF.h
@@ -0,0 +1,117 @@
+#ifndef OUTDOOR_PVP_TF_
+#define OUTDOOR_PVP_TF_
+
+#include "OutdoorPvP.h"
+
+const uint32 OutdoorPvPTFBuffZonesNum = 5;
+
+const uint32 OutdoorPvPTFBuffZones[OutdoorPvPTFBuffZonesNum] = { 3519 /*Terokkar Forest*/, 3791 /*Sethekk Halls*/, 3789 /*Shadow Labyrinth*/, 3792 /*Mana-Tombs*/, 3790 /*Auchenai Crypts*/ };
+
+// locked for 6 hours after capture
+const uint32 TF_LOCK_TIME = 3600 * 6 * 1000;
+// update lock timer every 1/4 minute (overkill, but this way it's sure the timer won't "jump" 2 minutes at once.)
+const uint32 TF_LOCK_TIME_UPDATE = 15000;
+
+// blessing of auchindoun
+const uint32 TF_CAPTURE_BUFF = 33377;
+
+const uint32 TF_ALLY_QUEST = 11505;
+const uint32 TF_HORDE_QUEST = 11506;
+
+enum OutdoorPvPTF_TowerType{
+    TF_TOWER_NW = 0,
+    TF_TOWER_N,
+    TF_TOWER_NE,
+    TF_TOWER_SE,
+    TF_TOWER_S,
+    TF_TOWER_NUM
+};
+
+const go_type TFCapturePoints[TF_TOWER_NUM] = {
+    {183104,530,-3081.65,5335.03,17.1853,-2.14675,0,0,0.878817,-0.477159},
+    {183411,530,-2939.9,4788.73,18.987,2.77507,0,0,0.983255,0.182236},
+    {183412,530,-3174.94,4440.97,16.2281,1.86750,0,0.803857,0.594823},
+    {183413,530,-3603.31,4529.15,20.9077,0.994838,0,0,0.477159,0.878817},
+    {183414,530,-3812.37,4899.3,17.7249,0.087266,0,0,0.043619,0.999048}
+};
+
+struct tf_tower_world_state{
+    uint32 n;
+    uint32 h;
+    uint32 a;
+};
+
+const tf_tower_world_state TFTowerWorldStates[TF_TOWER_NUM] = {
+    {0xa79,0xa7a,0xa7b},
+    {0xa7e,0xa7d,0xa7c},
+    {0xa82,0xa81,0xa80},
+    {0xa88,0xa87,0xa86},
+    {0xa85,0xa84,0xa83}
+};
+
+const uint32 TFTowerPlayerEnterEvents[TF_TOWER_NUM] = {12226, 12497, 12486, 12499, 12501};
+
+const uint32 TFTowerPlayerLeaveEvents[TF_TOWER_NUM] = {12225, 12496, 12487, 12498, 12500};
+
+enum TFWorldStates{
+    TF_UI_TOWER_SLIDER_POS = 0xa41,
+    TF_UI_TOWER_SLIDER_N = 0xa40,
+    TF_UI_TOWER_SLIDER_DISPLAY = 0xa3f,
+
+    TF_UI_TOWER_COUNT_H = 0xa3e,
+    TF_UI_TOWER_COUNT_A = 0xa3d,
+    TF_UI_TOWERS_CONTROLLED_DISPLAY = 0xa3c,
+
+    TF_UI_LOCKED_TIME_MINUTES_FIRST_DIGIT = 0x9d0,
+    TF_UI_LOCKED_TIME_MINUTES_SECOND_DIGIT = 0x9ce,
+    TF_UI_LOCKED_TIME_HOURS = 0x9cd,
+    TF_UI_LOCKED_DISPLAY_NEUTRAL = 0x9cc,
+    TF_UI_LOCKED_DISPLAY_HORDE = 0xad0,
+    TF_UI_LOCKED_DISPLAY_ALLIANCE = 0xacf
+};
+
+enum TFTowerStates {
+    TF_TOWERSTATE_N = 1,
+    TF_TOWERSTATE_H = 2,
+    TF_TOWERSTATE_A = 4
+};
+
+class OutdoorPvPObjectiveTF : public OutdoorPvPObjective
+{
+public:
+    OutdoorPvPObjectiveTF(OutdoorPvP * pvp, OutdoorPvPTF_TowerType type);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+    void UpdateTowerState();
+protected:
+    virtual bool HandleCapturePointEvent(Player * plr, uint32 eventId);
+protected:
+    OutdoorPvPTF_TowerType m_TowerType;
+    uint32 m_TowerState;
+};
+
+class OutdoorPvPTF : public OutdoorPvP
+{
+friend class OutdoorPvPObjectiveTF;
+public:
+    OutdoorPvPTF();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket &data);
+    void SendRemoveWorldStates(Player * plr);
+    void BuffTeam(uint32 team);
+private:
+    bool m_IsLocked;
+    uint32 m_LockTimer;
+    uint32 m_LockTimerUpdate;
+    uint32 m_AllianceTowersControlled;
+    uint32 m_HordeTowersControlled;
+    uint32 hours_left, second_digit, first_digit;
+};
+
+#endif
diff --git a/src/game/OutdoorPvPZM.cpp b/src/game/OutdoorPvPZM.cpp
new file mode 100644
index 0000000..83b22cc
--- /dev/null
+++ b/src/game/OutdoorPvPZM.cpp
@@ -0,0 +1,476 @@
+#include "OutdoorPvPZM.h"
+#include "ObjectMgr.h"
+#include "OutdoorPvPMgr.h"
+#include "Player.h"
+#include "Creature.h"
+#include "ObjectAccessor.h"
+#include "WorldPacket.h"
+#include "GossipDef.h"
+#include "World.h"
+
+OutdoorPvPObjectiveZM_Beacon::OutdoorPvPObjectiveZM_Beacon(OutdoorPvP *pvp, ZM_BeaconType type)
+: OutdoorPvPObjective(pvp), m_TowerType(type), m_TowerState(ZM_TOWERSTATE_N)
+{
+    AddCapturePoint(ZMCapturePoints[type].entry,ZMCapturePoints[type].map,ZMCapturePoints[type].x,ZMCapturePoints[type].y,ZMCapturePoints[type].z,ZMCapturePoints[type].o,ZMCapturePoints[type].rot0,ZMCapturePoints[type].rot1,ZMCapturePoints[type].rot2,ZMCapturePoints[type].rot3);
+}
+
+void OutdoorPvPObjectiveZM_Beacon::FillInitialWorldStates(WorldPacket &data)
+{
+    data << uint32(ZMBeaconInfo[m_TowerType].ui_tower_n) << uint32(bool(m_TowerState & ZM_TOWERSTATE_N));
+    data << uint32(ZMBeaconInfo[m_TowerType].map_tower_n) << uint32(bool(m_TowerState & ZM_TOWERSTATE_N));
+    data << uint32(ZMBeaconInfo[m_TowerType].ui_tower_a) << uint32(bool(m_TowerState & ZM_TOWERSTATE_A));
+    data << uint32(ZMBeaconInfo[m_TowerType].map_tower_a) << uint32(bool(m_TowerState & ZM_TOWERSTATE_A));
+    data << uint32(ZMBeaconInfo[m_TowerType].ui_tower_h) << uint32(bool(m_TowerState & ZM_TOWERSTATE_H));
+    data << uint32(ZMBeaconInfo[m_TowerType].map_tower_h) << uint32(bool(m_TowerState & ZM_TOWERSTATE_H));
+}
+
+void OutdoorPvPObjectiveZM_Beacon::UpdateTowerState()
+{
+    m_PvP->SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].ui_tower_n),uint32(bool(m_TowerState & ZM_TOWERSTATE_N)));
+    m_PvP->SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].map_tower_n),uint32(bool(m_TowerState & ZM_TOWERSTATE_N)));
+    m_PvP->SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].ui_tower_a),uint32(bool(m_TowerState & ZM_TOWERSTATE_A)));
+    m_PvP->SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].map_tower_a),uint32(bool(m_TowerState & ZM_TOWERSTATE_A)));
+    m_PvP->SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].ui_tower_h),uint32(bool(m_TowerState & ZM_TOWERSTATE_H)));
+    m_PvP->SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].map_tower_h),uint32(bool(m_TowerState & ZM_TOWERSTATE_H)));
+}
+
+bool OutdoorPvPObjectiveZM_Beacon::HandlePlayerEnter(Player *plr)
+{
+    if(OutdoorPvPObjective::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_disp, 1);
+        uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+        plr->SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_pos, phase);
+        plr->SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_n, m_NeutralValue);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveZM_Beacon::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_disp, 0);
+    OutdoorPvPObjective::HandlePlayerLeave(plr);
+}
+
+bool OutdoorPvPObjectiveZM_Beacon::HandleCapturePointEvent(Player *plr, uint32 eventId)
+{
+    if(eventId == ZMBeaconInfo[m_TowerType].event_enter)
+    {
+        this->HandlePlayerEnter(plr);
+        return true;
+    }
+    else if (eventId == ZMBeaconInfo[m_TowerType].event_leave)
+    {
+        this->HandlePlayerLeave(plr);
+        return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPObjectiveZM_Beacon::Update(uint32 diff)
+{
+    if(OutdoorPvPObjective::Update(diff))
+    {
+        if(m_OldState != m_State)
+        {
+            // if changing from controlling alliance to horde
+            if( m_OldState == OBJECTIVESTATE_ALLIANCE )
+            {
+                if(((OutdoorPvPZM*)m_PvP)->m_AllianceTowersControlled)
+                    ((OutdoorPvPZM*)m_PvP)->m_AllianceTowersControlled--;
+                sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,objmgr.GetMangosString(ZMBeaconLooseA[m_TowerType], -1));
+            }
+            // if changing from controlling horde to alliance
+            else if ( m_OldState == OBJECTIVESTATE_HORDE )
+            {
+                if(((OutdoorPvPZM*)m_PvP)->m_HordeTowersControlled)
+                    ((OutdoorPvPZM*)m_PvP)->m_HordeTowersControlled--;
+                sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,objmgr.GetMangosString(ZMBeaconLooseH[m_TowerType],-1));
+            }
+
+            switch(m_State)
+            {
+            case OBJECTIVESTATE_ALLIANCE:
+                m_TowerState = ZM_TOWERSTATE_A;
+                if(((OutdoorPvPZM*)m_PvP)->m_AllianceTowersControlled<ZM_NUM_BEACONS)
+                    ((OutdoorPvPZM*)m_PvP)->m_AllianceTowersControlled++;
+                sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,objmgr.GetMangosString(ZMBeaconCaptureA[m_TowerType],-1));
+                break;
+            case OBJECTIVESTATE_HORDE:
+                m_TowerState = ZM_TOWERSTATE_H;
+                if(((OutdoorPvPZM*)m_PvP)->m_HordeTowersControlled<ZM_NUM_BEACONS)
+                    ((OutdoorPvPZM*)m_PvP)->m_HordeTowersControlled++;
+                sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,objmgr.GetMangosString(ZMBeaconCaptureH[m_TowerType],-1));
+                break;
+            case OBJECTIVESTATE_NEUTRAL:
+            case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+            case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+            case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+            case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+                m_TowerState = ZM_TOWERSTATE_N;
+                break;
+            }
+
+            UpdateTowerState();
+        }
+
+        if(m_ShiftPhase != m_OldPhase)
+        {
+            // send this too, sometimes the slider disappears, dunno why :(
+            SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_disp, 1);
+            // send these updates to only the ones in this objective
+            uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+            SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_pos, phase);
+            SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_n, m_NeutralValue);
+        }
+        return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPZM::Update(uint32 diff)
+{
+    bool changed = false;
+    if(changed = OutdoorPvP::Update(diff))
+    {
+        if(m_AllianceTowersControlled == ZM_NUM_BEACONS)
+            m_GraveYard->SetBeaconState(ALLIANCE);
+        else if(m_HordeTowersControlled == ZM_NUM_BEACONS)
+            m_GraveYard->SetBeaconState(HORDE);
+        else
+            m_GraveYard->SetBeaconState(0);
+    }
+    return changed;
+}
+
+void OutdoorPvPZM::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    if(plr->GetTeam() == ALLIANCE)
+    {
+        if(m_GraveYard->m_GraveYardState & ZM_GRAVEYARD_A)
+            plr->CastSpell(plr,ZM_CAPTURE_BUFF,true);
+    }
+    else
+    {
+        if(m_GraveYard->m_GraveYardState & ZM_GRAVEYARD_H)
+            plr->CastSpell(plr,ZM_CAPTURE_BUFF,true);
+    }
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPZM::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    plr->RemoveAurasDueToSpell(ZM_CAPTURE_BUFF);
+    // remove flag
+    plr->RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_A);
+    plr->RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_H);
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+OutdoorPvPZM::OutdoorPvPZM()
+{
+    m_TypeId = OUTDOOR_PVP_ZM;
+    m_GraveYard = NULL;
+    m_AllianceTowersControlled = 0;
+    m_HordeTowersControlled = 0;
+
+}
+
+bool OutdoorPvPZM::SetupOutdoorPvP()
+{
+    m_AllianceTowersControlled = 0;
+    m_HordeTowersControlled = 0;
+
+    // add the zones affected by the pvp buff
+    for(int i = 0; i < OutdoorPvPZMBuffZonesNum; ++i)
+        sOutdoorPvPMgr.AddZone(OutdoorPvPZMBuffZones[i],this);
+
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveZM_Beacon(this,ZM_BEACON_WEST));
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveZM_Beacon(this,ZM_BEACON_EAST));
+    m_GraveYard = new OutdoorPvPObjectiveZM_GraveYard(this);
+    m_OutdoorPvPObjectives.insert(m_GraveYard); // though the update function isn't used, the handleusego is!
+
+    return true;
+}
+
+void OutdoorPvPZM::HandleKillImpl(Player *plr, Unit * killed)
+{
+    if(killed->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    if(plr->GetTeam() == ALLIANCE && ((Player*)killed)->GetTeam() != ALLIANCE)
+        plr->CastSpell(plr,ZM_AlliancePlayerKillReward,true);
+    else if(plr->GetTeam() == HORDE && ((Player*)killed)->GetTeam() != HORDE)
+        plr->CastSpell(plr,ZM_HordePlayerKillReward,true);
+}
+
+void OutdoorPvPZM::BuffTeam(uint32 team)
+{
+    if(team == ALLIANCE)
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->CastSpell(plr,ZM_CAPTURE_BUFF,true);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(ZM_CAPTURE_BUFF);
+        }
+    }
+    else if(team == HORDE)
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->CastSpell(plr,ZM_CAPTURE_BUFF,true);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(ZM_CAPTURE_BUFF);
+        }
+    }
+    else
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(ZM_CAPTURE_BUFF);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(ZM_CAPTURE_BUFF);
+        }
+    }
+}
+
+bool OutdoorPvPObjectiveZM_GraveYard::Update(uint32 diff)
+{
+    bool retval = m_State != m_OldState;
+    m_State = m_OldState;
+    return retval;
+}
+
+int32 OutdoorPvPObjectiveZM_GraveYard::HandleOpenGo(Player *plr, uint64 guid)
+{
+    uint32 retval = OutdoorPvPObjective::HandleOpenGo(plr, guid);
+    if(retval>=0)
+    {
+        if(plr->HasAura(ZM_BATTLE_STANDARD_A,0) && m_GraveYardState != ZM_GRAVEYARD_A)
+        {
+            if(m_GraveYardState == ZM_GRAVEYARD_H)
+                sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,objmgr.GetMangosString(LANG_OPVP_ZM_LOOSE_GY_H,-1));
+            m_GraveYardState = ZM_GRAVEYARD_A;
+            DelObject(0);   // only one gotype is used in the whole outdoor pvp, no need to call it a constant
+            AddObject(0,ZM_Banner_A.entry,ZM_Banner_A.map,ZM_Banner_A.x,ZM_Banner_A.y,ZM_Banner_A.z,ZM_Banner_A.o,ZM_Banner_A.rot0,ZM_Banner_A.rot1,ZM_Banner_A.rot2,ZM_Banner_A.rot3);
+            objmgr.RemoveGraveYardLink(ZM_GRAVEYARD_ID, ZM_GRAVEYARD_ZONE, HORDE);          // rem gy
+            objmgr.AddGraveYardLink(ZM_GRAVEYARD_ID, ZM_GRAVEYARD_ZONE, ALLIANCE, false);   // add gy
+            ((OutdoorPvPZM*)m_PvP)->BuffTeam(ALLIANCE);
+            plr->RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_A);
+            sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,objmgr.GetMangosString(LANG_OPVP_ZM_CAPTURE_GY_A, -1));
+        }
+        else if(plr->HasAura(ZM_BATTLE_STANDARD_H,0) && m_GraveYardState != ZM_GRAVEYARD_H)
+        {
+            if(m_GraveYardState == ZM_GRAVEYARD_A)
+                sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,objmgr.GetMangosString(LANG_OPVP_ZM_LOOSE_GY_A,-1));
+            m_GraveYardState = ZM_GRAVEYARD_H;
+            DelObject(0);   // only one gotype is used in the whole outdoor pvp, no need to call it a constant
+            AddObject(0,ZM_Banner_H.entry,ZM_Banner_H.map,ZM_Banner_H.x,ZM_Banner_H.y,ZM_Banner_H.z,ZM_Banner_H.o,ZM_Banner_H.rot0,ZM_Banner_H.rot1,ZM_Banner_H.rot2,ZM_Banner_H.rot3);
+            objmgr.RemoveGraveYardLink(ZM_GRAVEYARD_ID, ZM_GRAVEYARD_ZONE, ALLIANCE);          // rem gy
+            objmgr.AddGraveYardLink(ZM_GRAVEYARD_ID, ZM_GRAVEYARD_ZONE, HORDE, false);   // add gy
+            ((OutdoorPvPZM*)m_PvP)->BuffTeam(HORDE);
+            plr->RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_H);
+            sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,objmgr.GetMangosString(LANG_OPVP_ZM_CAPTURE_GY_H,-1));
+        }
+        UpdateTowerState();
+    }
+    return retval;
+}
+
+OutdoorPvPObjectiveZM_GraveYard::OutdoorPvPObjectiveZM_GraveYard(OutdoorPvP *pvp)
+: OutdoorPvPObjective(pvp)
+{
+    m_BothControllingFaction = 0;
+    m_GraveYardState = ZM_GRAVEYARD_N;
+    m_FlagCarrierGUID = 0;
+    // add field scouts here
+    AddCreature(ZM_ALLIANCE_FIELD_SCOUT,ZM_AllianceFieldScout.entry,ZM_AllianceFieldScout.teamval,ZM_AllianceFieldScout.map,ZM_AllianceFieldScout.x,ZM_AllianceFieldScout.y,ZM_AllianceFieldScout.z,ZM_AllianceFieldScout.o);
+    AddCreature(ZM_HORDE_FIELD_SCOUT,ZM_HordeFieldScout.entry,ZM_HordeFieldScout.teamval,ZM_HordeFieldScout.map,ZM_HordeFieldScout.x,ZM_HordeFieldScout.y,ZM_HordeFieldScout.z,ZM_HordeFieldScout.o);
+    // add neutral banner
+    AddObject(0,ZM_Banner_N.entry,ZM_Banner_N.map,ZM_Banner_N.x,ZM_Banner_N.y,ZM_Banner_N.z,ZM_Banner_N.o,ZM_Banner_N.rot0,ZM_Banner_N.rot1,ZM_Banner_N.rot2,ZM_Banner_N.rot3);
+}
+
+void OutdoorPvPObjectiveZM_GraveYard::UpdateTowerState()
+{
+    m_PvP->SendUpdateWorldState(ZM_MAP_GRAVEYARD_N,uint32(bool(m_GraveYardState & ZM_GRAVEYARD_N)));
+    m_PvP->SendUpdateWorldState(ZM_MAP_GRAVEYARD_H,uint32(bool(m_GraveYardState & ZM_GRAVEYARD_H)));
+    m_PvP->SendUpdateWorldState(ZM_MAP_GRAVEYARD_A,uint32(bool(m_GraveYardState & ZM_GRAVEYARD_A)));
+
+    m_PvP->SendUpdateWorldState(ZM_MAP_ALLIANCE_FLAG_READY,uint32(m_BothControllingFaction == ALLIANCE));
+    m_PvP->SendUpdateWorldState(ZM_MAP_ALLIANCE_FLAG_NOT_READY,uint32(m_BothControllingFaction != ALLIANCE));
+    m_PvP->SendUpdateWorldState(ZM_MAP_HORDE_FLAG_READY,uint32(m_BothControllingFaction == HORDE));
+    m_PvP->SendUpdateWorldState(ZM_MAP_HORDE_FLAG_NOT_READY,uint32(m_BothControllingFaction != HORDE));
+}
+
+void OutdoorPvPObjectiveZM_GraveYard::FillInitialWorldStates(WorldPacket &data)
+{
+    data << ZM_MAP_GRAVEYARD_N  << uint32(bool(m_GraveYardState & ZM_GRAVEYARD_N));
+    data << ZM_MAP_GRAVEYARD_H  << uint32(bool(m_GraveYardState & ZM_GRAVEYARD_H));
+    data << ZM_MAP_GRAVEYARD_A  << uint32(bool(m_GraveYardState & ZM_GRAVEYARD_A));
+
+    data << ZM_MAP_ALLIANCE_FLAG_READY  << uint32(m_BothControllingFaction == ALLIANCE);
+    data << ZM_MAP_ALLIANCE_FLAG_NOT_READY  << uint32(m_BothControllingFaction != ALLIANCE);
+    data << ZM_MAP_HORDE_FLAG_READY  << uint32(m_BothControllingFaction == HORDE);
+    data << ZM_MAP_HORDE_FLAG_NOT_READY  << uint32(m_BothControllingFaction != HORDE);
+}
+
+void OutdoorPvPObjectiveZM_GraveYard::SetBeaconState(uint32 controlling_faction)
+{
+    // nothing to do here
+    if(m_BothControllingFaction == controlling_faction)
+        return;
+    m_BothControllingFaction = controlling_faction;
+
+    switch(controlling_faction)
+    {
+    case ALLIANCE:
+        // if ally already controls the gy and taken back both beacons, return, nothing to do for us
+        if(m_GraveYardState & ZM_GRAVEYARD_A)
+            return;
+        // ally doesn't control the gy, but controls the side beacons -> add gossip option, add neutral banner
+        break;
+    case HORDE:
+        // if horde already controls the gy and taken back both beacons, return, nothing to do for us
+        if(m_GraveYardState & ZM_GRAVEYARD_H)
+            return;
+        // horde doesn't control the gy, but controls the side beacons -> add gossip option, add neutral banner
+        break;
+    default:
+        // if the graveyard is not neutral, then leave it that way
+        // if the graveyard is neutral, then we have to dispel the buff from the flag carrier
+        if(m_GraveYardState & ZM_GRAVEYARD_N)
+        {
+            // gy was neutral, thus neutral banner was spawned, it is possible that someone was taking the flag to the gy
+            if(m_FlagCarrierGUID)
+            {
+                // remove flag from carrier, reset flag carrier guid
+                Player * p = objmgr.GetPlayer(m_FlagCarrierGUID);
+                if(p)
+                {
+                   p->RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_A);
+                   p->RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_H);
+                }
+                m_FlagCarrierGUID = 0;
+            }
+        }
+        break;
+    }
+    // send worldstateupdate
+    UpdateTowerState();
+}
+
+bool OutdoorPvPObjectiveZM_GraveYard::CanTalkTo(Player * plr, Creature * c, GossipOption & gso)
+{
+    uint64 guid = c->GetGUID();
+    std::map<uint64,uint32>::iterator itr = m_CreatureTypes.find(guid);
+    if(itr != m_CreatureTypes.end())
+    {
+        if(itr->second == ZM_ALLIANCE_FIELD_SCOUT && plr->GetTeam() == ALLIANCE && m_BothControllingFaction == ALLIANCE && !m_FlagCarrierGUID && m_GraveYardState != ZM_GRAVEYARD_A)
+        {
+            gso.Option.assign("Give me the flag, I'll take it to the Central Tower for the glory of the Alliance!");
+            return true;
+        }
+        else if(itr->second == ZM_HORDE_FIELD_SCOUT && plr->GetTeam() == HORDE && m_BothControllingFaction == HORDE && !m_FlagCarrierGUID && m_GraveYardState != ZM_GRAVEYARD_H)
+        {
+            gso.Option.assign("Give me the flag, I'll take it to the Central Tower for the glory of the Horde!");
+            return true;
+        }
+    }
+    return false;
+}
+
+bool OutdoorPvPObjectiveZM_GraveYard::HandleGossipOption(Player *plr, uint64 guid, uint32 gossipid)
+{
+    std::map<uint64,uint32>::iterator itr = m_CreatureTypes.find(guid);
+    if(itr != m_CreatureTypes.end())
+    {
+        Creature * cr = HashMapHolder<Creature>::Find(guid);
+        if(!cr)
+            return true;
+        // if the flag is already taken, then return
+        if(m_FlagCarrierGUID)
+            return true;
+        if(itr->second == ZM_ALLIANCE_FIELD_SCOUT)
+        {
+            cr->CastSpell(plr,ZM_BATTLE_STANDARD_A,true);
+            m_FlagCarrierGUID = plr->GetGUID();
+        }
+        else if(itr->second == ZM_HORDE_FIELD_SCOUT)
+        {
+            cr->CastSpell(plr,ZM_BATTLE_STANDARD_H,true);
+            m_FlagCarrierGUID = plr->GetGUID();
+        }
+        UpdateTowerState();
+        plr->PlayerTalkClass->CloseGossip();
+        return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPObjectiveZM_GraveYard::HandleDropFlag(Player * plr, uint32 spellId)
+{
+    switch(spellId)
+    {
+    case ZM_BATTLE_STANDARD_A:
+        m_FlagCarrierGUID = 0;
+        return true;
+    case ZM_BATTLE_STANDARD_H:
+        m_FlagCarrierGUID = 0;
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPZM::FillInitialWorldStates(WorldPacket &data)
+{
+    data << ZM_WORLDSTATE_UNK_1 << uint32(1);
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        (*itr)->FillInitialWorldStates(data);
+    }
+}
+
+void OutdoorPvPZM::SendRemoveWorldStates(Player *plr)
+{
+    plr->SendUpdateWorldState(ZM_UI_TOWER_SLIDER_N_W,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_SLIDER_POS_W,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_SLIDER_DISPLAY_W,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_SLIDER_N_E,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_SLIDER_POS_E,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_SLIDER_DISPLAY_E,0);
+    plr->SendUpdateWorldState(ZM_WORLDSTATE_UNK_1,1);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_EAST_N,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_EAST_H,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_EAST_A,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_WEST_N,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_WEST_H,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_WEST_A,0);
+    plr->SendUpdateWorldState(ZM_MAP_TOWER_EAST_N,0);
+    plr->SendUpdateWorldState(ZM_MAP_TOWER_EAST_H,0);
+    plr->SendUpdateWorldState(ZM_MAP_TOWER_EAST_A,0);
+    plr->SendUpdateWorldState(ZM_MAP_GRAVEYARD_H,0);
+    plr->SendUpdateWorldState(ZM_MAP_GRAVEYARD_A,0);
+    plr->SendUpdateWorldState(ZM_MAP_GRAVEYARD_N,0);
+    plr->SendUpdateWorldState(ZM_MAP_TOWER_WEST_N,0);
+    plr->SendUpdateWorldState(ZM_MAP_TOWER_WEST_H,0);
+    plr->SendUpdateWorldState(ZM_MAP_TOWER_WEST_A,0);
+    plr->SendUpdateWorldState(ZM_MAP_HORDE_FLAG_READY,0);
+    plr->SendUpdateWorldState(ZM_MAP_HORDE_FLAG_NOT_READY,0);
+    plr->SendUpdateWorldState(ZM_MAP_ALLIANCE_FLAG_NOT_READY,0);
+    plr->SendUpdateWorldState(ZM_MAP_ALLIANCE_FLAG_READY,0);
+}
diff --git a/src/game/OutdoorPvPZM.h b/src/game/OutdoorPvPZM.h
new file mode 100644
index 0000000..ae94f59
--- /dev/null
+++ b/src/game/OutdoorPvPZM.h
@@ -0,0 +1,197 @@
+#ifndef OUTDOOR_PVP_ZM_
+#define OUTDOOR_PVP_ZM_
+
+#include "OutdoorPvP.h"
+#include "Language.h"
+
+const uint32 OutdoorPvPZMBuffZonesNum = 5;
+// the buff is cast in these zones
+const uint32 OutdoorPvPZMBuffZones[OutdoorPvPZMBuffZonesNum] = {3521,3607,3717,3715,3716};
+// cast on the players of the controlling faction
+const uint32 ZM_CAPTURE_BUFF = 33779;  // twin spire blessing
+// spell that the field scout casts on the player to carry the flag
+const uint32 ZM_BATTLE_STANDARD_A = 32430;
+// spell that the field scout casts on the player to carry the flag
+const uint32 ZM_BATTLE_STANDARD_H = 32431;
+// linked when the central tower is controlled
+const uint32 ZM_GRAVEYARD_ZONE = 3521;
+// linked when the central tower is controlled
+const uint32 ZM_GRAVEYARD_ID = 969;
+// token create spell
+const uint32 ZM_AlliancePlayerKillReward = 32155;
+// token create spell
+const uint32 ZM_HordePlayerKillReward = 32158;
+
+// banners 182527, 182528, 182529, gotta check them ingame
+const go_type ZM_Banner_A = { 182527,530,253.54,7083.81,36.7728,-0.017453,0,0,0.008727,-0.999962 };
+const go_type ZM_Banner_H = { 182528,530,253.54,7083.81,36.7728,-0.017453,0,0,0.008727,-0.999962 };
+const go_type ZM_Banner_N = { 182529,530,253.54,7083.81,36.7728,-0.017453,0,0,0.008727,-0.999962 };
+
+// horde field scout spawn data
+const creature_type ZM_HordeFieldScout = {18564,67,530,296.625,7818.4,42.6294,5.18363};
+// alliance field scout spawn data
+const creature_type ZM_AllianceFieldScout = {18581,469,530,374.395,6230.08,22.8351,0.593412};
+
+enum ZMCreatureTypes{
+    ZM_ALLIANCE_FIELD_SCOUT = 0,
+    ZM_HORDE_FIELD_SCOUT,
+    ZM_CREATURE_NUM
+};
+
+struct zm_beacon {
+    uint32 slider_disp;
+    uint32 slider_n;
+    uint32 slider_pos;
+    uint32 ui_tower_n;
+    uint32 ui_tower_h;
+    uint32 ui_tower_a;
+    uint32 map_tower_n;
+    uint32 map_tower_h;
+    uint32 map_tower_a;
+    uint32 event_enter;
+    uint32 event_leave;
+};
+
+enum ZM_BeaconType{
+    ZM_BEACON_EAST = 0,
+    ZM_BEACON_WEST,
+    ZM_NUM_BEACONS
+};
+
+const zm_beacon ZMBeaconInfo[ZM_NUM_BEACONS] = {
+    {2533,2535,2534,2560,2559,2558,2652,2651,2650,11807,11806},
+    {2527,2529,2528,2557,2556,2555,2646,2645,2644,11805,11804}
+};
+
+const uint32 ZMBeaconCaptureA[ZM_NUM_BEACONS] = {
+    LANG_OPVP_ZM_CAPTURE_EAST_A,
+    LANG_OPVP_ZM_CAPTURE_WEST_A
+};
+
+const uint32 ZMBeaconCaptureH[ZM_NUM_BEACONS] = {
+    LANG_OPVP_ZM_CAPTURE_EAST_H,
+    LANG_OPVP_ZM_CAPTURE_WEST_H
+};
+
+const uint32 ZMBeaconLooseA[ZM_NUM_BEACONS] = {
+    LANG_OPVP_ZM_LOOSE_EAST_A,
+    LANG_OPVP_ZM_LOOSE_WEST_A
+};
+
+const uint32 ZMBeaconLooseH[ZM_NUM_BEACONS] = {
+    LANG_OPVP_ZM_LOOSE_EAST_H,
+    LANG_OPVP_ZM_LOOSE_WEST_H
+};
+
+const go_type ZMCapturePoints[ZM_NUM_BEACONS] = {
+    {182523,530,303.243,6841.36,40.1245,-1.58825,0,0,0.71325,-0.700909},
+    {182522,530,336.466,7340.26,41.4984,-1.58825,0,0,0.71325,-0.700909}
+};
+
+enum OutdoorPvPZMWorldStates
+{
+    ZM_UI_TOWER_SLIDER_N_W = 2529,
+    ZM_UI_TOWER_SLIDER_POS_W = 2528,
+    ZM_UI_TOWER_SLIDER_DISPLAY_W = 2527,
+
+    ZM_UI_TOWER_SLIDER_N_E = 2535,
+    ZM_UI_TOWER_SLIDER_POS_E = 2534,
+    ZM_UI_TOWER_SLIDER_DISPLAY_E = 2533,
+
+    ZM_WORLDSTATE_UNK_1 = 2653,
+
+    ZM_UI_TOWER_EAST_N = 2560,
+    ZM_UI_TOWER_EAST_H = 2559,
+    ZM_UI_TOWER_EAST_A = 2558,
+    ZM_UI_TOWER_WEST_N = 2557,
+    ZM_UI_TOWER_WEST_H = 2556,
+    ZM_UI_TOWER_WEST_A = 2555,
+
+    ZM_MAP_TOWER_EAST_N = 2652,
+    ZM_MAP_TOWER_EAST_H = 2651,
+    ZM_MAP_TOWER_EAST_A = 2650,
+    ZM_MAP_GRAVEYARD_H = 2649,
+    ZM_MAP_GRAVEYARD_A = 2648,
+    ZM_MAP_GRAVEYARD_N = 2647,
+    ZM_MAP_TOWER_WEST_N = 2646,
+    ZM_MAP_TOWER_WEST_H = 2645,
+    ZM_MAP_TOWER_WEST_A = 2644,
+
+    ZM_MAP_HORDE_FLAG_READY = 2658,
+    ZM_MAP_HORDE_FLAG_NOT_READY = 2657,
+    ZM_MAP_ALLIANCE_FLAG_NOT_READY = 2656,
+    ZM_MAP_ALLIANCE_FLAG_READY = 2655
+};
+
+enum ZM_TowerStateMask{
+    ZM_TOWERSTATE_N = 1,
+    ZM_TOWERSTATE_A = 2,
+    ZM_TOWERSTATE_H = 4
+};
+
+class OutdoorPvPZM;
+class OutdoorPvPObjectiveZM_Beacon : public OutdoorPvPObjective
+{
+friend class OutdoorPvPZM;
+public:
+    OutdoorPvPObjectiveZM_Beacon(OutdoorPvP * pvp, ZM_BeaconType type);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+    void UpdateTowerState();
+protected:
+    bool HandleCapturePointEvent(Player * plr, uint32 eventId);
+protected:
+    ZM_BeaconType m_TowerType;
+    uint32 m_TowerState;
+};
+
+enum ZM_GraveYardState{
+    ZM_GRAVEYARD_N = 1,
+    ZM_GRAVEYARD_A = 2,
+    ZM_GRAVEYARD_H = 4
+};
+
+class OutdoorPvPObjectiveZM_GraveYard : public OutdoorPvPObjective
+{
+friend class OutdoorPvPZM;
+public:
+    OutdoorPvPObjectiveZM_GraveYard(OutdoorPvP * pvp);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket & data);
+    void UpdateTowerState();
+    int32 HandleOpenGo(Player *plr, uint64 guid);
+    void SetBeaconState(uint32 controlling_team); // not good atm
+    bool HandleGossipOption(Player * plr, uint64 guid, uint32 gossipid);
+    bool HandleDropFlag(Player * plr, uint32 spellId);
+    bool CanTalkTo(Player * plr, Creature * c, GossipOption &gso);
+private:
+    uint32 m_GraveYardState;
+protected:
+    uint32 m_BothControllingFaction;
+    uint64 m_FlagCarrierGUID;
+};
+
+class OutdoorPvPZM : public OutdoorPvP
+{
+friend class OutdoorPvPObjectiveZM_Beacon;
+public:
+    OutdoorPvPZM();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket &data);
+    void SendRemoveWorldStates(Player * plr);
+    void HandleKillImpl(Player * plr, Unit * killed);
+    void BuffTeam(uint32 team);
+private:
+    OutdoorPvPObjectiveZM_GraveYard * m_GraveYard;
+    uint32 m_AllianceTowersControlled;
+    uint32 m_HordeTowersControlled;
+};
+
+// todo: flag carrier death/leave/mount/activitychange should give back the gossip options
+#endif
diff --git a/src/game/Pet.cpp b/src/game/Pet.cpp
index 9f9f12d..9ba4b85 100644
--- a/src/game/Pet.cpp
+++ b/src/game/Pet.cpp
@@ -366,6 +366,10 @@ bool Pet::LoadPetFromDB( Unit* owner, uint32 petentry, uint32 petnumber, bool cu
         }
     }
 
+	//set last used pet number (for use in BG's)
+    if(owner->GetTypeId() == TYPEID_PLAYER && isControlled() && !isTemporarySummoned() && (getPetType() == SUMMON_PET || getPetType() == HUNTER_PET))
+		((Player*)owner)->SetLastPetNumber(pet_number);
+
     return true;
 }
 
@@ -619,7 +623,7 @@ void Pet::RegenerateFocus()
     AuraList const& ModPowerRegenPCTAuras = GetAurasByType(SPELL_AURA_MOD_POWER_REGEN_PERCENT);
     for(AuraList::const_iterator i = ModPowerRegenPCTAuras.begin(); i != ModPowerRegenPCTAuras.end(); ++i)
         if ((*i)->GetModifier()->m_miscvalue == POWER_FOCUS)
-            addvalue *= ((*i)->GetModifier()->m_amount + 100) / 100.0f;
+            addvalue *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount + 100) / 100.0f;
 
     ModifyPower(POWER_FOCUS, (int32)addvalue);
 }
diff --git a/src/game/PetAI.cpp b/src/game/PetAI.cpp
index 81ca688..9822209 100644
--- a/src/game/PetAI.cpp
+++ b/src/game/PetAI.cpp
@@ -55,7 +55,7 @@ void PetAI::MoveInLineOfSight(Unit *u)
             if(i_pet.IsWithinLOSInMap(u))
             {
                 AttackStart(u);
-                u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
+                //u->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
             }
         }
     }
diff --git a/src/game/Player.cpp b/src/game/Player.cpp
index 1d48a28..5aceeee 100644
--- a/src/game/Player.cpp
+++ b/src/game/Player.cpp
@@ -52,7 +52,10 @@
 #include "Transports.h"
 #include "Weather.h"
 #include "BattleGround.h"
+#include "BattleGroundAV.h"
 #include "BattleGroundMgr.h"
+#include "OutdoorPvP.h"
+#include "OutdoorPvPMgr.h"
 #include "ArenaTeam.h"
 #include "Chat.h"
 #include "Database/DatabaseImpl.h"
@@ -346,8 +349,8 @@ Player::Player (WorldSession *session): Unit()
     m_bgBattleGroundID = 0;
     for (int j=0; j < PLAYER_MAX_BATTLEGROUND_QUEUES; j++)
     {
-        m_bgBattleGroundQueueID[j].bgType  = 0;
-        m_bgBattleGroundQueueID[j].invited = false;
+        m_bgBattleGroundQueueID[j].bgQueueType  = 0;
+        m_bgBattleGroundQueueID[j].invitedToInstance = 0;
     }
     m_bgTeam = 0;
 
@@ -366,6 +369,8 @@ Player::Player (WorldSession *session): Unit()
     //when dying/logging out
     m_oldpetspell = 0;
 
+    m_lastpetnumber = 0;
+
     ////////////////////Rest System/////////////////////
     time_inn_enter=0;
     inn_pos_mapid=0;
@@ -375,6 +380,16 @@ Player::Player (WorldSession *session): Unit()
     m_rest_bonus=0;
     rest_type=REST_TYPE_NO;
     ////////////////////Rest System/////////////////////
+    //movement anticheat
+    m_anti_lastmovetime = 0;   //last movement time 
+    m_anti_transportGUID = 0;  //current transport GUID
+    m_anti_last_hspeed = 7.0f; //horizontal speed, default RUN speed
+    m_anti_lastspeed_changetime = 0; //last speed change time
+    m_anti_last_vspeed = -3.2f;//vertical speed, default max jump height
+
+    m_anti_lastalarmtime = 0;    //last time when alarm generated
+    m_anti_alarmcount = 0;       //alarm counter
+    ///////////////////////////////// 
 
     m_mailsLoaded = false;
     m_mailsUpdated = false;
@@ -766,7 +781,7 @@ void Player::HandleDrowning()
 
     AuraList const& mModWaterBreathing = GetAurasByType(SPELL_AURA_MOD_WATER_BREATHING);
     for(AuraList::const_iterator i = mModWaterBreathing.begin(); i != mModWaterBreathing.end(); ++i)
-        UnderWaterTime = uint32(UnderWaterTime * (100.0f + (*i)->GetModifier()->m_amount) / 100.0f);
+        UnderWaterTime = uint32(UnderWaterTime * (100.0f + (*i)->GetModifier()->m_amount * (*i)->m_stackAmount) / 100.0f);
 
     if ((m_isunderwater & 0x01) && !(m_isunderwater & 0x80) && isAlive())
     {
@@ -1439,7 +1454,8 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
     MapEntry const* mEntry = sMapStore.LookupEntry(mapid);
 
     // don't let enter battlegrounds without assigned battleground id (for example through areatrigger)...
-    if(!InBattleGround() && mEntry->IsBattleGround() && !GetSession()->GetSecurity())
+    // don't let gm level > 1 either
+    if(!InBattleGround() && mEntry->IsBattleGroundOrArena())
         return false;
 
     // client without expansion support
@@ -1554,7 +1570,7 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
     else
     {
         // far teleport to another map
-        Map* oldmap = IsInWorld() ? MapManager::Instance().GetMap(GetMapId(), this) : NULL;
+        Map* oldmap = IsInWorld() ? MapManager::Instance().FindMap(GetMapId(), GetInstanceId()) : NULL;
         // check if we can enter before stopping combat / removing pet / totems / interrupting spells
 
         // Check enter rights before map getting to avoid creating instance copy for player
@@ -1796,7 +1812,7 @@ void Player::Regenerate(Powers power)
         AuraList const& ModPowerRegenPCTAuras = GetAurasByType(SPELL_AURA_MOD_POWER_REGEN_PERCENT);
         for(AuraList::const_iterator i = ModPowerRegenPCTAuras.begin(); i != ModPowerRegenPCTAuras.end(); ++i)
             if ((*i)->GetModifier()->m_miscvalue == power)
-                addvalue *= ((*i)->GetModifier()->m_amount + 100) / 100.0f;
+                addvalue *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount + 100) / 100.0f;
     }
 
     if (power != POWER_RAGE)
@@ -1837,7 +1853,7 @@ void Player::RegenerateHealth()
         {
             AuraList const& mModHealthRegenPct = GetAurasByType(SPELL_AURA_MOD_HEALTH_REGEN_PERCENT);
             for(AuraList::const_iterator i = mModHealthRegenPct.begin(); i != mModHealthRegenPct.end(); ++i)
-                addvalue *= (100.0f + (*i)->GetModifier()->m_amount) / 100.0f;
+                addvalue *= (100.0f + (*i)->GetModifier()->m_amount * (*i)->m_stackAmount) / 100.0f;
         }
         else if(HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT))
             addvalue *= GetTotalAuraModifier(SPELL_AURA_MOD_REGEN_DURING_COMBAT) / 100.0f;
@@ -2034,7 +2050,7 @@ void Player::GiveXP(uint32 xp, Unit* victim)
     // handle SPELL_AURA_MOD_XP_PCT auras
     Unit::AuraList const& ModXPPctAuras = GetAurasByType(SPELL_AURA_MOD_XP_PCT);
     for(Unit::AuraList::const_iterator i = ModXPPctAuras.begin();i != ModXPPctAuras.end(); ++i)
-        xp = uint32(xp*(1.0f + (*i)->GetModifier()->m_amount / 100.0f));
+        xp = uint32(xp*(1.0f + (*i)->GetModifier()->m_amount * (*i)->m_stackAmount / 100.0f));
 
     // XP resting bonus for kill
     uint32 rested_bonus_xp = victim ? GetXPRestBonus(xp) : 0;
@@ -3429,6 +3445,29 @@ void Player::DeleteFromDB(uint64 playerguid, uint32 accountId, bool updateRealmC
             guild->DelMember(guid);
     }
 
+    // remove from arena teams
+    uint32 at_id = GetArenaTeamIdFromDB(playerguid,ARENA_TEAM_2v2);
+    if(at_id != 0)
+    {
+        ArenaTeam * at = objmgr.GetArenaTeamById(at_id);
+        if(at)
+            at->DelMember(playerguid);
+    }
+    at_id = GetArenaTeamIdFromDB(playerguid,ARENA_TEAM_3v3);
+    if(at_id != 0)
+    {
+        ArenaTeam * at = objmgr.GetArenaTeamById(at_id);
+        if(at)
+            at->DelMember(playerguid);
+    }
+    at_id = GetArenaTeamIdFromDB(playerguid,ARENA_TEAM_5v5);
+    if(at_id != 0)
+    {
+        ArenaTeam * at = objmgr.GetArenaTeamById(at_id);
+        if(at)
+            at->DelMember(playerguid);
+    }
+
     // the player was uninvited already on logout so just remove from group
     QueryResult *resultGroup = CharacterDatabase.PQuery("SELECT leaderGuid FROM group_member WHERE memberGuid='%u'", guid);
     if(resultGroup)
@@ -4050,7 +4089,7 @@ void Player::RepopAtGraveyard()
     // Special handle for battleground maps
     BattleGround *bg = sBattleGroundMgr.GetBattleGround(GetBattleGroundId());
 
-    if(bg && (bg->GetTypeID() == BATTLEGROUND_AB || bg->GetTypeID() == BATTLEGROUND_EY))
+    if(bg && (bg->GetTypeID() == BATTLEGROUND_AB || bg->GetTypeID() == BATTLEGROUND_EY || bg->GetTypeID() == BATTLEGROUND_AV))
         ClosestGrave = bg->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetTeam());
     else
         ClosestGrave = objmgr.GetClosestGraveYard( GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam() );
@@ -4732,6 +4771,7 @@ void Player::UpdateWeaponSkill (WeaponAttackType attType)
 
 void Player::UpdateCombatSkills(Unit *pVictim, WeaponAttackType attType, MeleeHitOutcome outcome, bool defence)
 {
+/* Not need, this checked on call this func from trigger system
     switch(outcome)
     {
         case MELEE_HIT_CRIT:
@@ -4744,7 +4784,7 @@ void Player::UpdateCombatSkills(Unit *pVictim, WeaponAttackType attType, MeleeHi
         default:
             break;
     }
-
+*/
     uint32 plevel = getLevel();                             // if defense than pVictim == attacker
     uint32 greylevel = MaNGOS::XP::GetGrayLevel(plevel);
     uint32 moblevel = pVictim->getLevelForTarget(this);
@@ -5857,6 +5897,10 @@ bool Player::RewardHonor(Unit *uVictim, uint32 groupsize, float honor)
     // need call before fields update to have chance move yesterday data to appropriate fields before today data change.
     UpdateHonorFields();
 
+    // do not reward honor in arenas, but return true to enable onkill spellproc
+    if(InBattleGround() && GetBattleGround() && GetBattleGround()->isArena())
+        return true;
+
     if(honor <= 0)
     {
         if(!uVictim || uVictim == this || uVictim->HasAuraType(SPELL_AURA_NO_PVP_CREDIT))
@@ -5928,7 +5972,7 @@ bool Player::RewardHonor(Unit *uVictim, uint32 groupsize, float honor)
             if (!cVictim->isRacialLeader())
                 return false;
 
-            honor = 100;                                    // ??? need more info
+            honor = 2000;                                    // ??? need more info
             victim_rank = 19;                               // HK: Leader
         }
     }
@@ -6024,8 +6068,9 @@ uint32 Player::GetArenaTeamIdFromDB(uint64 guid, uint8 type)
     QueryResult *result = CharacterDatabase.PQuery("SELECT arenateamid FROM arena_team_member WHERE guid='%u'", GUID_LOPART(guid));
     if(result)
     {
-        // init id to 0, check the arena type before assigning a value to id
-        uint32 id = 0;
+        bool found = false;
+        // init id to find the type of the arenateam
+        uint32 id = (*result)[0].GetUInt32();
         do
         {
             QueryResult *result2 = CharacterDatabase.PQuery("SELECT type FROM arena_team WHERE arenateamid='%u'", id);
@@ -6036,13 +6081,13 @@ uint32 Player::GetArenaTeamIdFromDB(uint64 guid, uint8 type)
                 if(dbtype == type)
                 {
                     // if the type matches, we've found the id
-                    id = (*result)[0].GetUInt32();
+                    found = true;
                     break;
                 }
             }
         } while(result->NextRow());
         delete result;
-        return id;
+        if(found) return id;
     }
     // no arenateam for the specified guid, return 0
     return 0;
@@ -6110,6 +6155,7 @@ void Player::UpdateArea(uint32 newArea)
 
 void Player::UpdateZone(uint32 newZone)
 {
+    uint32 oldZoneId  = m_zoneUpdateId;
     m_zoneUpdateId    = newZone;
     m_zoneUpdateTimer = ZONE_UPDATE_INTERVAL;
 
@@ -6120,6 +6166,13 @@ void Player::UpdateZone(uint32 newZone)
     if(!zone)
         return;
 
+    // inform outdoor pvp
+    if(oldZoneId != m_zoneUpdateId)
+    {
+        sOutdoorPvPMgr.HandlePlayerLeaveZone(this, oldZoneId);
+        sOutdoorPvPMgr.HandlePlayerEnterZone(this, m_zoneUpdateId);
+    }
+
     if (sWorld.getConfig(CONFIG_WEATHER))
     {
         Weather *wth = sWorld.FindWeather(zone->ID);
@@ -6253,6 +6306,11 @@ void Player::CheckDuelDistance(time_t currTime)
     }
 }
 
+bool Player::IsOutdoorPvPActive()
+{
+    return (isAlive() && !HasInvisibilityAura() && !HasStealthAura() && (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP) || sWorld.IsPvPRealm())  && !HasUnitMovementFlag(MOVEMENTFLAG_FLYING2) && !isInFlight());
+}
+
 void Player::DuelComplete(DuelCompleteType type)
 {
     // duel not requested
@@ -6608,7 +6666,7 @@ void Player::_ApplyWeaponDependentAuraCritMod(Item *item, WeaponAttackType attac
 
     if (item->IsFitToSpellRequirements(aura->GetSpellProto()))
     {
-        HandleBaseModValue(mod, FLAT_MOD, float (aura->GetModifier()->m_amount), apply);
+        HandleBaseModValue(mod, FLAT_MOD, float (aura->GetModifier()->m_amount * aura->m_stackAmount), apply);
     }
 }
 
@@ -6642,7 +6700,7 @@ void Player::_ApplyWeaponDependentAuraDamageMod(Item *item, WeaponAttackType att
 
     if (item->IsFitToSpellRequirements(aura->GetSpellProto()))
     {
-        HandleStatModifier(unitMod, unitModType, float(modifier->m_amount),apply);
+        HandleStatModifier(unitMod, unitModType, float(modifier->m_amount * aura->m_stackAmount),apply);
     }
 }
 
@@ -7047,9 +7105,7 @@ void Player::SendLoot(uint64 guid, LootType loot_type)
     sLog.outDebug("Player::SendLoot");
     if (IS_GAMEOBJECT_GUID(guid))
     {
-        sLog.outDebug("       IS_GAMEOBJECT_GUID(guid)");
-        GameObject *go =
-            ObjectAccessor::GetGameObject(*this, guid);
+        GameObject *go = ObjectAccessor::GetGameObject(*this, guid);
 
         // not check distance for GO in case owned GO (fishing bobber case, for example)
         // And permit out of range GO with no owner in case fishing hole
@@ -7063,18 +7119,24 @@ void Player::SendLoot(uint64 guid, LootType loot_type)
 
         if(go->getLootState() == GO_READY)
         {
-            uint32 lootid =  go->GetLootId();
+            if((go->GetEntry() == BG_AV_OBJECTID_MINE_N || go->GetEntry() == BG_AV_OBJECTID_MINE_S))
+                if( BattleGround *bg = GetBattleGround())
+                    if(bg->GetTypeID() == BATTLEGROUND_AV)
+                        if(!(((BattleGroundAV*)bg)->PlayerCanDoMineQuest(go->GetEntry(),GetTeam())))
+                        {
+                            SendLootRelease(guid);
+                            return;
+                        }
 
-            if(lootid)
+            if(uint32 lootid = go->GetLootId())
             {
-                sLog.outDebug("       if(lootid)");
                 loot->clear();
                 loot->FillLoot(lootid, LootTemplates_Gameobject, this);
+                go->SetLootState(GO_ACTIVATED);
             }
 
             if(loot_type == LOOT_FISHING)
                 go->getFishLoot(loot);
-
             go->SetLootState(GO_ACTIVATED);
         }
     }
@@ -7141,6 +7203,8 @@ void Player::SendLoot(uint64 guid, LootType loot_type)
             bones->lootForBody = true;
             uint32 pLevel = bones->loot.gold;
             bones->loot.clear();
+            if(GetBattleGround()->GetTypeID() == BATTLEGROUND_AV)
+                loot->FillLoot(1, LootTemplates_Creature, this);
             // It may need a better formula
             // Now it works like this: lvl10: ~6copper, lvl70: ~9silver
             bones->loot.gold = (uint32)( urand(50, 150) * 0.016f * pow( ((float)pLevel)/5.76f, 2.5f) * sWorld.getRate(RATE_DROP_MONEY) );
@@ -7271,32 +7335,27 @@ void Player::SendLoot(uint64 guid, LootType loot_type)
     SetLootGUID(guid);
 
     QuestItemList *q_list = 0;
+    QuestItemList *ffa_list = 0;
+    QuestItemList *conditional_list = 0;
     if (permission != NONE_PERMISSION)
     {
+        QuestItemMap::const_iterator itr;
         QuestItemMap const& lootPlayerQuestItems = loot->GetPlayerQuestItems();
-        QuestItemMap::const_iterator itr = lootPlayerQuestItems.find(GetGUIDLow());
+        itr = lootPlayerQuestItems.find(GetGUIDLow());
         if (itr == lootPlayerQuestItems.end())
             q_list = loot->FillQuestLoot(this);
         else
             q_list = itr->second;
-    }
-
-    QuestItemList *ffa_list = 0;
-    if (permission != NONE_PERMISSION)
-    {
+        
         QuestItemMap const& lootPlayerFFAItems = loot->GetPlayerFFAItems();
-        QuestItemMap::const_iterator itr = lootPlayerFFAItems.find(GetGUIDLow());
+        itr = lootPlayerFFAItems.find(GetGUIDLow());
         if (itr == lootPlayerFFAItems.end())
             ffa_list = loot->FillFFALoot(this);
         else
             ffa_list = itr->second;
-    }
-
-    QuestItemList *conditional_list = 0;
-    if (permission != NONE_PERMISSION)
-    {
+        
         QuestItemMap const& lootPlayerNonQuestNonFFAConditionalItems = loot->GetPlayerNonQuestNonFFAConditionalItems();
-        QuestItemMap::const_iterator itr = lootPlayerNonQuestNonFFAConditionalItems.find(GetGUIDLow());
+        itr = lootPlayerNonQuestNonFFAConditionalItems.find(GetGUIDLow());
         if (itr == lootPlayerNonQuestNonFFAConditionalItems.end())
             conditional_list = loot->FillNonQuestNonFFAConditionalLoot(this);
         else
@@ -7347,13 +7406,17 @@ void Player::SendUpdateWorldState(uint32 Field, uint32 Value)
     GetSession()->SendPacket(&data);
 }
 
-void Player::SendInitWorldStates()
+void Player::SendInitWorldStates(bool forceZone, uint32 forceZoneId)
 {
     // data depends on zoneid/mapid...
     BattleGround* bg = GetBattleGround();
     uint16 NumberOfFields = 0;
     uint32 mapid = GetMapId();
-    uint32 zoneid = GetZoneId();
+    uint32 zoneid;
+    if(forceZone)
+        zoneid = forceZoneId;
+    else
+        zoneid = GetZoneId();
     uint32 areaid = GetAreaId();
     sLog.outDebug("Sending SMSG_INIT_WORLD_STATES to Map:%u, Zone: %u", mapid, zoneid);
     // may be exist better way to do this...
@@ -7378,6 +7441,12 @@ void Player::SendInitWorldStates()
         case 2918:
             NumberOfFields = 6;
             break;
+        case 139:
+            NumberOfFields = 39;
+            break;
+        case 1377:
+            NumberOfFields = 13;
+            break;
         case 2597:
             NumberOfFields = 81;
             break;
@@ -7389,7 +7458,10 @@ void Player::SendInitWorldStates()
             NumberOfFields = 38;
             break;
         case 3483:
-            NumberOfFields = 22;
+            NumberOfFields = 25;
+            break;
+        case 3518:
+            NumberOfFields = 37;
             break;
         case 3519:
             NumberOfFields = 36;
@@ -7439,82 +7511,149 @@ void Player::SendInitWorldStates()
         case 1537:
         case 2257:
             break;
+        case 139: // EPL
+            {
+                OutdoorPvP * pvp = this->GetOutdoorPvP();
+                if(pvp && pvp->GetTypeId() == OUTDOOR_PVP_EP)
+                    pvp->FillInitialWorldStates(data);
+                else
+                {
+                    data << uint32(0x97a) << uint32(0x0); // 10 2426 
+                    data << uint32(0x917) << uint32(0x0); // 11 2327 
+                    data << uint32(0x918) << uint32(0x0); // 12 2328 
+                    data << uint32(0x97b) << uint32(0x32); // 13 2427
+                    data << uint32(0x97c) << uint32(0x32); // 14 2428
+                    data << uint32(0x933) << uint32(0x1); // 15 2355 
+                    data << uint32(0x946) << uint32(0x0); // 16 2374 
+                    data << uint32(0x947) << uint32(0x0); // 17 2375 
+                    data << uint32(0x948) << uint32(0x0); // 18 2376 
+                    data << uint32(0x949) << uint32(0x0); // 19 2377 
+                    data << uint32(0x94a) << uint32(0x0); // 20 2378 
+                    data << uint32(0x94b) << uint32(0x0); // 21 2379 
+                    data << uint32(0x932) << uint32(0x0); // 22 2354 
+                    data << uint32(0x934) << uint32(0x0); // 23 2356 
+                    data << uint32(0x935) << uint32(0x0); // 24 2357 
+                    data << uint32(0x936) << uint32(0x0); // 25 2358 
+                    data << uint32(0x937) << uint32(0x0); // 26 2359 
+                    data << uint32(0x938) << uint32(0x0); // 27 2360 
+                    data << uint32(0x939) << uint32(0x1); // 28 2361 
+                    data << uint32(0x930) << uint32(0x1); // 29 2352 
+                    data << uint32(0x93a) << uint32(0x0); // 30 2362 
+                    data << uint32(0x93b) << uint32(0x0); // 31 2363 
+                    data << uint32(0x93c) << uint32(0x0); // 32 2364 
+                    data << uint32(0x93d) << uint32(0x0); // 33 2365 
+                    data << uint32(0x944) << uint32(0x0); // 34 2372 
+                    data << uint32(0x945) << uint32(0x0); // 35 2373 
+                    data << uint32(0x931) << uint32(0x1); // 36 2353 
+                    data << uint32(0x93e) << uint32(0x0); // 37 2366 
+                    data << uint32(0x931) << uint32(0x1); // 38 2367 ??  grey horde not in dbc! send for consistency's sake, and to match field count
+                    data << uint32(0x940) << uint32(0x0); // 39 2368 
+                    data << uint32(0x941) << uint32(0x0); // 7 2369 
+                    data << uint32(0x942) << uint32(0x0); // 8 2370 
+                    data << uint32(0x943) << uint32(0x0); // 9 2371 
+                }
+            }
+            break;
+        case 1377: // Silithus			
+            {
+                OutdoorPvP * pvp = this->GetOutdoorPvP();
+                if(pvp && pvp->GetTypeId() == OUTDOOR_PVP_SI)
+                    pvp->FillInitialWorldStates(data);
+                else
+                {
+                    // states are always shown
+                    data << uint32(2313) << uint32(0x0); // 7 ally silityst gathered
+                    data << uint32(2314) << uint32(0x0); // 8 horde silityst gathered
+                    data << uint32(2317) << uint32(0x0); // 9 max silithyst
+                }
+                // dunno about these... aq opening event maybe?
+                data << uint32(2322) << uint32(0x0); // 10 sandworm N
+                data << uint32(2323) << uint32(0x0); // 11 sandworm S
+                data << uint32(2324) << uint32(0x0); // 12 sandworm SW
+                data << uint32(2325) << uint32(0x0); // 13 sandworm E	
+            }
+            break;
         case 2597:                                          // AV
-            data << uint32(0x7ae) << uint32(0x1);           // 7
-            data << uint32(0x532) << uint32(0x1);           // 8
-            data << uint32(0x531) << uint32(0x0);           // 9
-            data << uint32(0x52e) << uint32(0x0);           // 10
-            data << uint32(0x571) << uint32(0x0);           // 11
-            data << uint32(0x570) << uint32(0x0);           // 12
-            data << uint32(0x567) << uint32(0x1);           // 13
-            data << uint32(0x566) << uint32(0x1);           // 14
-            data << uint32(0x550) << uint32(0x1);           // 15
-            data << uint32(0x544) << uint32(0x0);           // 16
-            data << uint32(0x536) << uint32(0x0);           // 17
-            data << uint32(0x535) << uint32(0x1);           // 18
-            data << uint32(0x518) << uint32(0x0);           // 19
-            data << uint32(0x517) << uint32(0x0);           // 20
-            data << uint32(0x574) << uint32(0x0);           // 21
-            data << uint32(0x573) << uint32(0x0);           // 22
-            data << uint32(0x572) << uint32(0x0);           // 23
-            data << uint32(0x56f) << uint32(0x0);           // 24
-            data << uint32(0x56e) << uint32(0x0);           // 25
-            data << uint32(0x56d) << uint32(0x0);           // 26
-            data << uint32(0x56c) << uint32(0x0);           // 27
-            data << uint32(0x56b) << uint32(0x0);           // 28
-            data << uint32(0x56a) << uint32(0x1);           // 29
-            data << uint32(0x569) << uint32(0x1);           // 30
-            data << uint32(0x568) << uint32(0x1);           // 13
-            data << uint32(0x565) << uint32(0x0);           // 32
-            data << uint32(0x564) << uint32(0x0);           // 33
-            data << uint32(0x563) << uint32(0x0);           // 34
-            data << uint32(0x562) << uint32(0x0);           // 35
-            data << uint32(0x561) << uint32(0x0);           // 36
-            data << uint32(0x560) << uint32(0x0);           // 37
-            data << uint32(0x55f) << uint32(0x0);           // 38
-            data << uint32(0x55e) << uint32(0x0);           // 39
-            data << uint32(0x55d) << uint32(0x0);           // 40
-            data << uint32(0x3c6) << uint32(0x4);           // 41
-            data << uint32(0x3c4) << uint32(0x6);           // 42
-            data << uint32(0x3c2) << uint32(0x4);           // 43
-            data << uint32(0x516) << uint32(0x1);           // 44
-            data << uint32(0x515) << uint32(0x0);           // 45
-            data << uint32(0x3b6) << uint32(0x6);           // 46
-            data << uint32(0x55c) << uint32(0x0);           // 47
-            data << uint32(0x55b) << uint32(0x0);           // 48
-            data << uint32(0x55a) << uint32(0x0);           // 49
-            data << uint32(0x559) << uint32(0x0);           // 50
-            data << uint32(0x558) << uint32(0x0);           // 51
-            data << uint32(0x557) << uint32(0x0);           // 52
-            data << uint32(0x556) << uint32(0x0);           // 53
-            data << uint32(0x555) << uint32(0x0);           // 54
-            data << uint32(0x554) << uint32(0x1);           // 55
-            data << uint32(0x553) << uint32(0x1);           // 56
-            data << uint32(0x552) << uint32(0x1);           // 57
-            data << uint32(0x551) << uint32(0x1);           // 58
-            data << uint32(0x54f) << uint32(0x0);           // 59
-            data << uint32(0x54e) << uint32(0x0);           // 60
-            data << uint32(0x54d) << uint32(0x1);           // 61
-            data << uint32(0x54c) << uint32(0x0);           // 62
-            data << uint32(0x54b) << uint32(0x0);           // 63
-            data << uint32(0x545) << uint32(0x0);           // 64
-            data << uint32(0x543) << uint32(0x1);           // 65
-            data << uint32(0x542) << uint32(0x0);           // 66
-            data << uint32(0x540) << uint32(0x0);           // 67
-            data << uint32(0x53f) << uint32(0x0);           // 68
-            data << uint32(0x53e) << uint32(0x0);           // 69
-            data << uint32(0x53d) << uint32(0x0);           // 70
-            data << uint32(0x53c) << uint32(0x0);           // 71
-            data << uint32(0x53b) << uint32(0x0);           // 72
-            data << uint32(0x53a) << uint32(0x1);           // 73
-            data << uint32(0x539) << uint32(0x0);           // 74
-            data << uint32(0x538) << uint32(0x0);           // 75
-            data << uint32(0x537) << uint32(0x0);           // 76
-            data << uint32(0x534) << uint32(0x0);           // 77
-            data << uint32(0x533) << uint32(0x0);           // 78
-            data << uint32(0x530) << uint32(0x0);           // 79
-            data << uint32(0x52f) << uint32(0x0);           // 80
-            data << uint32(0x52d) << uint32(0x1);           // 81
+            if (bg && bg->GetTypeID() == BATTLEGROUND_AV)
+                bg->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(0x7ae) << uint32(0x1);           // 7 snowfall n
+                data << uint32(0x532) << uint32(0x1);           // 8 frostwolfhut hc 
+                data << uint32(0x531) << uint32(0x0);           // 9 frostwolfhut ac
+                data << uint32(0x52e) << uint32(0x0);           // 10 stormpike firstaid a_a
+                data << uint32(0x571) << uint32(0x0);           // 11 east frostwolf tower horde assaulted -unused
+                data << uint32(0x570) << uint32(0x0);           // 12 west frostwolf tower horde assaulted - unused
+                data << uint32(0x567) << uint32(0x1);           // 13 frostwolfe c
+                data << uint32(0x566) << uint32(0x1);           // 14 frostwolfw c
+                data << uint32(0x550) << uint32(0x1);           // 15 irondeep (N) ally
+                data << uint32(0x544) << uint32(0x0);           // 16 ice grave a_a
+                data << uint32(0x536) << uint32(0x0);           // 17 stormpike grave h_c
+                data << uint32(0x535) << uint32(0x1);           // 18 stormpike grave a_c
+                data << uint32(0x518) << uint32(0x0);           // 19 stoneheart grave a_a
+                data << uint32(0x517) << uint32(0x0);           // 20 stoneheart grave h_a
+                data << uint32(0x574) << uint32(0x0);           // 21 1396 unk
+                data << uint32(0x573) << uint32(0x0);           // 22 iceblood tower horde assaulted -unused
+                data << uint32(0x572) << uint32(0x0);           // 23 towerpoint horde assaulted - unused
+                data << uint32(0x56f) << uint32(0x0);           // 24 1391 unk
+                data << uint32(0x56e) << uint32(0x0);           // 25 iceblood a
+                data << uint32(0x56d) << uint32(0x0);           // 26 towerp a
+                data << uint32(0x56c) << uint32(0x0);           // 27 frostwolfe a
+                data << uint32(0x56b) << uint32(0x0);           // 28 froswolfw a
+                data << uint32(0x56a) << uint32(0x1);           // 29 1386 unk
+                data << uint32(0x569) << uint32(0x1);           // 30 iceblood c
+                data << uint32(0x568) << uint32(0x1);           // 31 towerp c
+                data << uint32(0x565) << uint32(0x0);           // 32 stoneh tower a
+                data << uint32(0x564) << uint32(0x0);           // 33 icewing tower a
+                data << uint32(0x563) << uint32(0x0);           // 34 dunn a
+                data << uint32(0x562) << uint32(0x0);           // 35 duns a
+                data << uint32(0x561) << uint32(0x0);           // 36 stoneheart bunker alliance assaulted - unused
+                data << uint32(0x560) << uint32(0x0);           // 37 icewing bunker alliance assaulted - unused
+                data << uint32(0x55f) << uint32(0x0);           // 38 dunbaldar south alliance assaulted - unused
+                data << uint32(0x55e) << uint32(0x0);           // 39 dunbaldar north alliance assaulted - unused
+                data << uint32(0x55d) << uint32(0x0);           // 40 stone tower d
+                data << uint32(0x3c6) << uint32(0x0);           // 41 966 unk
+                data << uint32(0x3c4) << uint32(0x0);           // 42 964 unk
+                data << uint32(0x3c2) << uint32(0x0);           // 43 962 unk
+                data << uint32(0x516) << uint32(0x1);           // 44 stoneheart grave a_c
+                data << uint32(0x515) << uint32(0x0);           // 45 stonheart grave h_c
+                data << uint32(0x3b6) << uint32(0x0);           // 46 950 unk
+                data << uint32(0x55c) << uint32(0x0);           // 47 icewing tower d
+                data << uint32(0x55b) << uint32(0x0);           // 48 dunn d
+                data << uint32(0x55a) << uint32(0x0);           // 49 duns d
+                data << uint32(0x559) << uint32(0x0);           // 50 1369 unk
+                data << uint32(0x558) << uint32(0x0);           // 51 iceblood d
+                data << uint32(0x557) << uint32(0x0);           // 52 towerp d
+                data << uint32(0x556) << uint32(0x0);           // 53 frostwolfe d
+                data << uint32(0x555) << uint32(0x0);           // 54 frostwolfw d
+                data << uint32(0x554) << uint32(0x1);           // 55 stoneh tower c
+                data << uint32(0x553) << uint32(0x1);           // 56 icewing tower c
+                data << uint32(0x552) << uint32(0x1);           // 57 dunn c
+                data << uint32(0x551) << uint32(0x1);           // 58 duns c
+                data << uint32(0x54f) << uint32(0x0);           // 59 irondeep (N) horde
+                data << uint32(0x54e) << uint32(0x0);           // 60 irondeep (N) ally
+                data << uint32(0x54d) << uint32(0x1);           // 61 mine (S) neutral
+                data << uint32(0x54c) << uint32(0x0);           // 62 mine (S) horde
+                data << uint32(0x54b) << uint32(0x0);           // 63 mine (S) ally
+                data << uint32(0x545) << uint32(0x0);           // 64 iceblood h_a
+                data << uint32(0x543) << uint32(0x1);           // 65 iceblod h_c
+                data << uint32(0x542) << uint32(0x0);           // 66 iceblood a_c
+                data << uint32(0x540) << uint32(0x0);           // 67 snowfall h_a
+                data << uint32(0x53f) << uint32(0x0);           // 68 snowfall a_a
+                data << uint32(0x53e) << uint32(0x0);           // 69 snowfall h_c
+                data << uint32(0x53d) << uint32(0x0);           // 70 snowfall a_c
+                data << uint32(0x53c) << uint32(0x0);           // 71 frostwolf g h_a
+                data << uint32(0x53b) << uint32(0x0);           // 72 frostwolf g a_a
+                data << uint32(0x53a) << uint32(0x1);           // 73 frostwolf g h_c
+                data << uint32(0x539) << uint32(0x0);           // 74 frostwolf g a_c
+                data << uint32(0x538) << uint32(0x0);           // 75 stormpike grave h_a
+                data << uint32(0x537) << uint32(0x0);           // 76 stormpike grave a_a
+                data << uint32(0x534) << uint32(0x0);           // 77 frostwolf hut h_a
+                data << uint32(0x533) << uint32(0x0);           // 78 frostwolf hut a_a
+                data << uint32(0x530) << uint32(0x0);           // 79 stormpike first aid h_a
+                data << uint32(0x52f) << uint32(0x0);           // 80 stormpike first aid h_c
+                data << uint32(0x52d) << uint32(0x1);           // 81 stormpike first aid a_c
+            }
             break;
         case 3277:                                          // WS
             if (bg && bg->GetTypeID() == BATTLEGROUND_WS)
@@ -7610,92 +7749,180 @@ void Player::SendInitWorldStates()
                 // and some more ... unknown
             }
             break;
+        // any of these needs change! the client remembers the prev setting!
+        // ON EVERY ZONE LEAVE, RESET THE OLD ZONE'S WORLD STATE, BUT AT LEAST THE UI STUFF!
         case 3483:                                          // Hellfire Peninsula
-            data << uint32(0x9ba) << uint32(0x1);           // 10
-            data << uint32(0x9b9) << uint32(0x1);           // 11
-            data << uint32(0x9b5) << uint32(0x0);           // 12
-            data << uint32(0x9b4) << uint32(0x1);           // 13
-            data << uint32(0x9b3) << uint32(0x0);           // 14
-            data << uint32(0x9b2) << uint32(0x0);           // 15
-            data << uint32(0x9b1) << uint32(0x1);           // 16
-            data << uint32(0x9b0) << uint32(0x0);           // 17
-            data << uint32(0x9ae) << uint32(0x0);           // 18 horde pvp objectives captured
-            data << uint32(0x9ac) << uint32(0x0);           // 19
-            data << uint32(0x9a8) << uint32(0x0);           // 20
-            data << uint32(0x9a7) << uint32(0x0);           // 21
-            data << uint32(0x9a6) << uint32(0x1);           // 22
+            {
+                OutdoorPvP * pvp = this->GetOutdoorPvP();
+                if(pvp && pvp->GetTypeId() == OUTDOOR_PVP_HP)
+                    pvp->FillInitialWorldStates(data);
+                else
+                {
+                    data << uint32(0x9ba) << uint32(0x1);           // 10 // add ally tower main gui icon       // maybe should be sent only on login?
+                    data << uint32(0x9b9) << uint32(0x1);           // 11 // add horde tower main gui icon      // maybe should be sent only on login?
+                    data << uint32(0x9b5) << uint32(0x0);           // 12 // show neutral broken hill icon      // 2485
+                    data << uint32(0x9b4) << uint32(0x1);           // 13 // show icon above broken hill        // 2484
+                    data << uint32(0x9b3) << uint32(0x0);           // 14 // show ally broken hill icon         // 2483
+                    data << uint32(0x9b2) << uint32(0x0);           // 15 // show neutral overlook icon         // 2482
+                    data << uint32(0x9b1) << uint32(0x1);           // 16 // show the overlook arrow            // 2481
+                    data << uint32(0x9b0) << uint32(0x0);           // 17 // show ally overlook icon            // 2480
+                    data << uint32(0x9ae) << uint32(0x0);           // 18 // horde pvp objectives captured      // 2478
+                    data << uint32(0x9ac) << uint32(0x0);           // 19 // ally pvp objectives captured       // 2476
+                    data << uint32(2475)  << uint32(100); //: ally / horde slider grey area                              // show only in direct vicinity!
+                    data << uint32(2474)  << uint32(50);  //: ally / horde slider percentage, 100 for ally, 0 for horde  // show only in direct vicinity!
+                    data << uint32(2473)  << uint32(0);   //: ally / horde slider display                                // show only in direct vicinity!
+                    data << uint32(0x9a8) << uint32(0x0);           // 20 // show the neutral stadium icon      // 2472
+                    data << uint32(0x9a7) << uint32(0x0);           // 21 // show the ally stadium icon         // 2471 
+                    data << uint32(0x9a6) << uint32(0x1);           // 22 // show the horde stadium icon        // 2470
+                }
+            }
+            break;
+        case 3518:
+            {
+                OutdoorPvP * pvp = this->GetOutdoorPvP();
+                if(pvp && pvp->GetTypeId() == OUTDOOR_PVP_NA)
+                    pvp->FillInitialWorldStates(data);
+                else
+                {
+                    data << uint32(2503) << uint32(0x0);    // 10
+                    data << uint32(2502) << uint32(0x0);    // 11
+                    data << uint32(2493) << uint32(0x0);    // 12
+                    data << uint32(2491) << uint32(0x0);    // 13
+
+                    data << uint32(2495) << uint32(0x0);    // 14
+                    data << uint32(2494) << uint32(0x0);    // 15
+                    data << uint32(2497) << uint32(0x0);    // 16
+
+                    data << uint32(2762) << uint32(0x0);    // 17
+                    data << uint32(2662) << uint32(0x0);    // 18
+                    data << uint32(2663) << uint32(0x0);    // 19
+                    data << uint32(2664) << uint32(0x0);    // 20
+
+                    data << uint32(2760) << uint32(0x0);    // 21
+                    data << uint32(2670) << uint32(0x0);    // 22
+                    data << uint32(2668) << uint32(0x0);    // 23
+                    data << uint32(2669) << uint32(0x0);    // 24
+
+                    data << uint32(2761) << uint32(0x0);    // 25
+                    data << uint32(2667) << uint32(0x0);    // 26
+                    data << uint32(2665) << uint32(0x0);    // 27
+                    data << uint32(2666) << uint32(0x0);    // 28
+
+                    data << uint32(2763) << uint32(0x0);    // 29
+                    data << uint32(2659) << uint32(0x0);    // 30
+                    data << uint32(2660) << uint32(0x0);    // 31
+                    data << uint32(2661) << uint32(0x0);    // 32
+
+                    data << uint32(2671) << uint32(0x0);    // 33
+                    data << uint32(2676) << uint32(0x0);    // 34
+                    data << uint32(2677) << uint32(0x0);    // 35
+                    data << uint32(2672) << uint32(0x0);    // 36
+                    data << uint32(2673) << uint32(0x0);    // 37
+                }
+            }
             break;
         case 3519:                                          // Terokkar Forest
-            data << uint32(0xa41) << uint32(0x0);           // 10
-            data << uint32(0xa40) << uint32(0x14);          // 11
-            data << uint32(0xa3f) << uint32(0x0);           // 12
-            data << uint32(0xa3e) << uint32(0x0);           // 13
-            data << uint32(0xa3d) << uint32(0x5);           // 14
-            data << uint32(0xa3c) << uint32(0x0);           // 15
-            data << uint32(0xa87) << uint32(0x0);           // 16
-            data << uint32(0xa86) << uint32(0x0);           // 17
-            data << uint32(0xa85) << uint32(0x0);           // 18
-            data << uint32(0xa84) << uint32(0x0);           // 19
-            data << uint32(0xa83) << uint32(0x0);           // 20
-            data << uint32(0xa82) << uint32(0x0);           // 21
-            data << uint32(0xa81) << uint32(0x0);           // 22
-            data << uint32(0xa80) << uint32(0x0);           // 23
-            data << uint32(0xa7e) << uint32(0x0);           // 24
-            data << uint32(0xa7d) << uint32(0x0);           // 25
-            data << uint32(0xa7c) << uint32(0x0);           // 26
-            data << uint32(0xa7b) << uint32(0x0);           // 27
-            data << uint32(0xa7a) << uint32(0x0);           // 28
-            data << uint32(0xa79) << uint32(0x0);           // 29
-            data << uint32(0x9d0) << uint32(0x5);           // 30
-            data << uint32(0x9ce) << uint32(0x0);           // 31
-            data << uint32(0x9cd) << uint32(0x0);           // 32
-            data << uint32(0x9cc) << uint32(0x0);           // 33
-            data << uint32(0xa88) << uint32(0x0);           // 34
-            data << uint32(0xad0) << uint32(0x0);           // 35
-            data << uint32(0xacf) << uint32(0x1);           // 36
+            {
+                OutdoorPvP * pvp = this->GetOutdoorPvP();
+                if(pvp && pvp->GetTypeId() == OUTDOOR_PVP_TF)
+                    pvp->FillInitialWorldStates(data);
+                else
+                {
+                    data << uint32(0xa41) << uint32(0x0);           // 10 // 2625 capture bar pos
+                    data << uint32(0xa40) << uint32(0x14);          // 11 // 2624 capture bar neutral
+                    data << uint32(0xa3f) << uint32(0x0);           // 12 // 2623 show capture bar
+                    data << uint32(0xa3e) << uint32(0x0);           // 13 // 2622 horde towers controlled
+                    data << uint32(0xa3d) << uint32(0x5);           // 14 // 2621 ally towers controlled
+                    data << uint32(0xa3c) << uint32(0x0);           // 15 // 2620 show towers controlled
+                    data << uint32(0xa88) << uint32(0x0);           // 16 // 2696 SE Neu
+                    data << uint32(0xa87) << uint32(0x0);           // 17 // SE Horde
+                    data << uint32(0xa86) << uint32(0x0);           // 18 // SE Ally
+                    data << uint32(0xa85) << uint32(0x0);           // 19 //S Neu
+                    data << uint32(0xa84) << uint32(0x0);           // 20 S Horde
+                    data << uint32(0xa83) << uint32(0x0);           // 21 S Ally
+                    data << uint32(0xa82) << uint32(0x0);           // 22 NE Neu
+                    data << uint32(0xa81) << uint32(0x0);           // 23 NE Horde
+                    data << uint32(0xa80) << uint32(0x0);           // 24 NE Ally
+                    data << uint32(0xa7e) << uint32(0x0);           // 25 // 2686 N Neu
+                    data << uint32(0xa7d) << uint32(0x0);           // 26 N Horde
+                    data << uint32(0xa7c) << uint32(0x0);           // 27 N Ally
+                    data << uint32(0xa7b) << uint32(0x0);           // 28 NW Ally
+                    data << uint32(0xa7a) << uint32(0x0);           // 29 NW Horde
+                    data << uint32(0xa79) << uint32(0x0);           // 30 NW Neutral
+                    data << uint32(0x9d0) << uint32(0x5);           // 31 // 2512 locked time remaining seconds first digit
+                    data << uint32(0x9ce) << uint32(0x0);           // 32 // 2510 locked time remaining seconds second digit
+                    data << uint32(0x9cd) << uint32(0x0);           // 33 // 2509 locked time remaining minutes
+                    data << uint32(0x9cc) << uint32(0x0);           // 34 // 2508 neutral locked time show
+                    data << uint32(0xad0) << uint32(0x0);           // 35 // 2768 horde locked time show
+                    data << uint32(0xacf) << uint32(0x1);           // 36 // 2767 ally locked time show
+                }
+            }
             break;
         case 3521:                                          // Zangarmarsh
-            data << uint32(0x9e1) << uint32(0x0);           // 10
-            data << uint32(0x9e0) << uint32(0x0);           // 11
-            data << uint32(0x9df) << uint32(0x0);           // 12
-            data << uint32(0xa5d) << uint32(0x1);           // 13
-            data << uint32(0xa5c) << uint32(0x0);           // 14
-            data << uint32(0xa5b) << uint32(0x1);           // 15
-            data << uint32(0xa5a) << uint32(0x0);           // 16
-            data << uint32(0xa59) << uint32(0x1);           // 17
-            data << uint32(0xa58) << uint32(0x0);           // 18
-            data << uint32(0xa57) << uint32(0x0);           // 19
-            data << uint32(0xa56) << uint32(0x0);           // 20
-            data << uint32(0xa55) << uint32(0x1);           // 21
-            data << uint32(0xa54) << uint32(0x0);           // 22
-            data << uint32(0x9e7) << uint32(0x0);           // 23
-            data << uint32(0x9e6) << uint32(0x0);           // 24
-            data << uint32(0x9e5) << uint32(0x0);           // 25
-            data << uint32(0xa00) << uint32(0x0);           // 26
-            data << uint32(0x9ff) << uint32(0x1);           // 27
-            data << uint32(0x9fe) << uint32(0x0);           // 28
-            data << uint32(0x9fd) << uint32(0x0);           // 29
-            data << uint32(0x9fc) << uint32(0x1);           // 30
-            data << uint32(0x9fb) << uint32(0x0);           // 31
-            data << uint32(0xa62) << uint32(0x0);           // 32
-            data << uint32(0xa61) << uint32(0x1);           // 33
-            data << uint32(0xa60) << uint32(0x1);           // 34
-            data << uint32(0xa5f) << uint32(0x0);           // 35
+            {
+                OutdoorPvP * pvp = this->GetOutdoorPvP();
+                if(pvp && pvp->GetTypeId() == OUTDOOR_PVP_ZM)
+                    pvp->FillInitialWorldStates(data);
+                else
+                {
+                    data << uint32(0x9e1) << uint32(0x0);           // 10 //2529
+                    data << uint32(0x9e0) << uint32(0x0);           // 11
+                    data << uint32(0x9df) << uint32(0x0);           // 12
+                    data << uint32(0xa5d) << uint32(0x1);           // 13 //2653 
+                    data << uint32(0xa5c) << uint32(0x0);           // 14 //2652 east beacon neutral
+                    data << uint32(0xa5b) << uint32(0x1);           // 15 horde
+                    data << uint32(0xa5a) << uint32(0x0);           // 16 ally
+                    data << uint32(0xa59) << uint32(0x1);           // 17 // 2649 Twin spire graveyard horde  12???
+                    data << uint32(0xa58) << uint32(0x0);           // 18 ally     14 ???
+                    data << uint32(0xa57) << uint32(0x0);           // 19 neutral  7???
+                    data << uint32(0xa56) << uint32(0x0);           // 20 // 2646 west beacon neutral
+                    data << uint32(0xa55) << uint32(0x1);           // 21 horde
+                    data << uint32(0xa54) << uint32(0x0);           // 22 ally
+                    data << uint32(0x9e7) << uint32(0x0);           // 23 // 2535
+                    data << uint32(0x9e6) << uint32(0x0);           // 24
+                    data << uint32(0x9e5) << uint32(0x0);           // 25
+                    data << uint32(0xa00) << uint32(0x0);           // 26 // 2560
+                    data << uint32(0x9ff) << uint32(0x1);           // 27
+                    data << uint32(0x9fe) << uint32(0x0);           // 28
+                    data << uint32(0x9fd) << uint32(0x0);           // 29 
+                    data << uint32(0x9fc) << uint32(0x1);           // 30
+                    data << uint32(0x9fb) << uint32(0x0);           // 31
+                    data << uint32(0xa62) << uint32(0x0);           // 32 // 2658
+                    data << uint32(0xa61) << uint32(0x1);           // 33
+                    data << uint32(0xa60) << uint32(0x1);           // 34
+                    data << uint32(0xa5f) << uint32(0x0);           // 35
+                }
+            }
             break;
         case 3698:                                          // Nagrand Arena
-            data << uint32(0xa0f) << uint32(0x0);           // 7
-            data << uint32(0xa10) << uint32(0x0);           // 8
-            data << uint32(0xa11) << uint32(0x0);           // 9
+            if (bg && bg->GetTypeID() == BATTLEGROUND_NA)
+                bg->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(0xa0f) << uint32(0x0);           // 7
+                data << uint32(0xa10) << uint32(0x0);           // 8
+                data << uint32(0xa11) << uint32(0x0);           // 9 show
+            }
             break;
         case 3702:                                          // Blade's Edge Arena
-            data << uint32(0x9f0) << uint32(0x0);           // 7
-            data << uint32(0x9f1) << uint32(0x0);           // 8
-            data << uint32(0x9f3) << uint32(0x0);           // 9
+            if (bg && bg->GetTypeID() == BATTLEGROUND_BE)
+                bg->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(0x9f0) << uint32(0x0);           // 7 gold
+                data << uint32(0x9f1) << uint32(0x0);           // 8 green
+                data << uint32(0x9f3) << uint32(0x0);           // 9 show
+            }
             break;
         case 3968:                                          // Ruins of Lordaeron
-            data << uint32(0xbb8) << uint32(0x0);           // 7
-            data << uint32(0xbb9) << uint32(0x0);           // 8
-            data << uint32(0xbba) << uint32(0x0);           // 9
+            if (bg && bg->GetTypeID() == BATTLEGROUND_RL)
+                bg->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(0xbb8) << uint32(0x0);           // 7 gold 
+                data << uint32(0xbb9) << uint32(0x0);           // 8 green
+                data << uint32(0xbba) << uint32(0x0);           // 9 show
+            }
             break;
         case 3703:                                          // Shattrath City
             break;
@@ -13016,7 +13243,8 @@ bool Player::HasQuestForItem( uint32 itemid ) const
 
             // hide quest if player is in raid-group and quest is no raid quest
             if(GetGroup() && GetGroup()->isRaidGroup() && qinfo->GetType() != QUEST_TYPE_RAID)
-                continue;
+                if(!InBattleGround()) //there are two ways.. we can make every bg-quest a raidquest, or add this code here.. i don't know if this can be exploited by other quests, but i think all other quests depend on a specific area.. but keep this in mind, if something strange happens later
+                    continue;
 
             // There should be no mixed ReqItem/ReqSource drop
             // This part for ReqItem drop
@@ -14724,8 +14952,10 @@ void Player::SaveToDB()
     // first save/honor gain after midnight will also update the player's honor fields
     UpdateHonorFields();
 
-    // Must saved before enter into BattleGround
-    if(InBattleGround())
+    // players aren't saved on battleground maps
+    uint32 mapid = IsBeingTeleported() ? GetTeleportDest().mapid : GetMapId();
+    const MapEntry * me = sMapStore.LookupEntry(mapid);
+    if(!me || me->IsBattleGroundOrArena())
         return;
 
     int is_save_resting = HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING) ? 1 : 0;
@@ -15500,7 +15730,7 @@ void Player::RemovePet(Pet* pet, PetSaveMode mode, bool returnreagent)
     if(!pet)
         pet = GetPet();
 
-    if(returnreagent && (pet || m_temporaryUnsummonedPetNumber))
+    if(returnreagent && (pet || m_temporaryUnsummonedPetNumber) && !InBattleGround())
     {
         //returning of reagents only for players, so best done here
         uint32 spellId = pet ? pet->GetUInt32Value(UNIT_CREATED_BY_SPELL) : m_oldpetspell;
@@ -17481,7 +17711,8 @@ bool Player::InArena() const
 
 bool Player::GetBGAccessByLevel(uint32 bgTypeId) const
 {
-    BattleGround *bg = sBattleGroundMgr.GetBattleGround(bgTypeId);
+    // get a template bg instead of running one
+    BattleGround *bg = sBattleGroundMgr.GetBattleGroundTemplate(bgTypeId);
     if(!bg)
         return false;
 
@@ -17510,6 +17741,7 @@ uint32 Player::GetMaxLevelForBattleGroundQueueId(uint32 queue_id)
     return 10*(queue_id+2)-1;
 }
 
+//TODO make this more generic - current implementation is wrong
 uint32 Player::GetBattleGroundQueueIdFromLevel() const
 {
     uint32 level = getLevel();
@@ -17675,6 +17907,11 @@ void Player::AutoUnequipOffhandIfNeed()
     }
 }
 
+OutdoorPvP * Player::GetOutdoorPvP() const
+{
+    return sOutdoorPvPMgr.GetOutdoorPvPToZoneId(GetZoneId());
+}
+
 bool Player::HasItemFitToSpellReqirements(SpellEntry const* spellInfo, Item const* ignoreItem)
 {
     if(spellInfo->EquippedItemClass < 0)
@@ -18159,9 +18396,34 @@ bool Player::isAllowUseBattleGroundObject()
 {
     return ( //InBattleGround() &&                            // in battleground - not need, check in other cases
              !IsMounted() &&                                  // not mounted
+             !isTotalImmunity() &&                            // not totally immuned
              !HasStealthAura() &&                             // not stealthed
              !HasInvisibilityAura() &&                        // not invisible
              !HasAura(SPELL_RECENTLY_DROPPED_FLAG, 0) &&      // can't pickup
              isAlive()                                        // live player
            );
 }
+
+bool Player::isTotalImmunity()
+{
+    AuraList const& immune = GetAurasByType(SPELL_AURA_SCHOOL_IMMUNITY);
+
+    for(AuraList::const_iterator itr = immune.begin(); itr != immune.end(); ++itr)
+    {
+        if (((*itr)->GetModifier()->m_miscvalue & SPELL_SCHOOL_MASK_ALL) !=0)   // total immunity
+        {
+            return true;
+        }
+        if (((*itr)->GetModifier()->m_miscvalue & SPELL_SCHOOL_MASK_NORMAL) !=0)   // physical damage immunity
+        {
+            for(AuraList::const_iterator i = immune.begin(); i != immune.end(); ++i)
+            {
+                if (((*i)->GetModifier()->m_miscvalue & SPELL_SCHOOL_MASK_MAGIC) !=0)   // magic immunity
+                {
+                    return true;
+                }
+            }
+        }
+    }
+    return false;
+}
diff --git a/src/game/Player.h b/src/game/Player.h
index aaaaac6..d35434a 100644
--- a/src/game/Player.h
+++ b/src/game/Player.h
@@ -45,6 +45,7 @@ class PlayerMenu;
 class Transport;
 class UpdateMask;
 class PlayerSocial;
+class OutdoorPvP;
 
 typedef std::deque<Mail*> PlayerMails;
 
@@ -1778,7 +1779,7 @@ class MANGOS_DLL_SPEC Player : public Unit
         void UpdateEquipSpellsAtFormChange();
         void CastItemCombatSpell(Item *item,Unit* Target, WeaponAttackType attType);
 
-        void SendInitWorldStates();
+        void SendInitWorldStates(bool force = false, uint32 forceZoneId = 0);
         void SendUpdateWorldState(uint32 Field, uint32 Value);
         void SendDirectMessage(WorldPacket *data);
 
@@ -1805,24 +1806,32 @@ class MANGOS_DLL_SPEC Player : public Unit
         static uint32 GetMaxLevelForBattleGroundQueueId(uint32 queue_id);
         uint32 GetBattleGroundQueueIdFromLevel() const;
 
-        uint32 GetBattleGroundQueueId(uint32 index) const { return m_bgBattleGroundQueueID[index].bgType; }
-        uint32 GetBattleGroundQueueIndex(uint32 bgType) const
+        bool InBattleGroundQueue() const 	 
+	    { 	 
+	        for (int i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++) 	 
+                if (m_bgBattleGroundQueueID[i].bgQueueType != 0) 	 
+	                return true; 	 
+	        return false; 	 
+	    }
+
+        uint32 GetBattleGroundQueueId(uint32 index) const { return m_bgBattleGroundQueueID[index].bgQueueType; }
+        uint32 GetBattleGroundQueueIndex(uint32 bgQueueType) const
         {
             for (int i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
-                if (m_bgBattleGroundQueueID[i].bgType == bgType)
+                if (m_bgBattleGroundQueueID[i].bgQueueType == bgQueueType)
                     return i;
             return PLAYER_MAX_BATTLEGROUND_QUEUES;
         }
-        bool IsInvitedForBattleGroundType(uint32 bgType) const
+        bool IsInvitedForBattleGroundQueueType(uint32 bgQueueType) const
         {
             for (int i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
-                if (m_bgBattleGroundQueueID[i].bgType == bgType)
-                    return m_bgBattleGroundQueueID[i].invited;
+                if (m_bgBattleGroundQueueID[i].bgQueueType == bgQueueType)
+                    return m_bgBattleGroundQueueID[i].invitedToInstance != 0;
             return PLAYER_MAX_BATTLEGROUND_QUEUES;
         }
-        bool InBattleGroundQueueForBattleGroundType(uint32 bgType) const
+        bool InBattleGroundQueueForBattleGroundQueueType(uint32 bgQueueType) const
         {
-            return GetBattleGroundQueueIndex(bgType) < PLAYER_MAX_BATTLEGROUND_QUEUES;
+            return GetBattleGroundQueueIndex(bgQueueType) < PLAYER_MAX_BATTLEGROUND_QUEUES;
         }
 
         void SetBattleGroundId(uint32 val)  { m_bgBattleGroundID = val; }
@@ -1830,34 +1839,47 @@ class MANGOS_DLL_SPEC Player : public Unit
         {
             for (int i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
             {
-                if (m_bgBattleGroundQueueID[i].bgType == 0 || m_bgBattleGroundQueueID[i].bgType == val)
+                if (m_bgBattleGroundQueueID[i].bgQueueType == 0 || m_bgBattleGroundQueueID[i].bgQueueType == val)
                 {
-                    m_bgBattleGroundQueueID[i].bgType = val;
-                    m_bgBattleGroundQueueID[i].invited = false;
+                    m_bgBattleGroundQueueID[i].bgQueueType = val;
+                    m_bgBattleGroundQueueID[i].invitedToInstance = 0;
                     return i;
                 }
             }
             return PLAYER_MAX_BATTLEGROUND_QUEUES;
         }
+        bool HasFreeBattleGroundQueueId()
+        {
+            for (int i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
+                if (m_bgBattleGroundQueueID[i].bgQueueType == 0)
+                    return true;
+            return false;
+        }
         void RemoveBattleGroundQueueId(uint32 val)
         {
             for (int i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
             {
-                if (m_bgBattleGroundQueueID[i].bgType == val)
+                if (m_bgBattleGroundQueueID[i].bgQueueType == val)
                 {
-                    m_bgBattleGroundQueueID[i].bgType = 0;
-                    m_bgBattleGroundQueueID[i].invited = false;
+                    m_bgBattleGroundQueueID[i].bgQueueType = 0;
+                    m_bgBattleGroundQueueID[i].invitedToInstance = 0;
                     return;
                 }
             }
         }
-        void SetInviteForBattleGroundType(uint32 bgType)
+        void SetInviteForBattleGroundQueueType(uint32 bgQueueType, uint32 instanceId)
         {
             for (int i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
-                if (m_bgBattleGroundQueueID[i].bgType == bgType)
-                    m_bgBattleGroundQueueID[i].invited = true;
+                if (m_bgBattleGroundQueueID[i].bgQueueType == bgQueueType)
+                    m_bgBattleGroundQueueID[i].invitedToInstance = instanceId;
+        }
+        bool IsInvitedForBattleGroundInstance(uint32 instanceId) const
+        {
+            for (int i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
+                if (m_bgBattleGroundQueueID[i].invitedToInstance == instanceId)
+                    return true;
+            return false;
         }
-
         uint32 GetBattleGroundEntryPointMap() const { return m_bgEntryPointMap; }
         float GetBattleGroundEntryPointX() const { return m_bgEntryPointX; }
         float GetBattleGroundEntryPointY() const { return m_bgEntryPointY; }
@@ -1883,6 +1905,15 @@ class MANGOS_DLL_SPEC Player : public Unit
 
         bool GetBGAccessByLevel(uint32 bgTypeId) const;
         bool isAllowUseBattleGroundObject();
+        bool isTotalImmunity();
+
+        /*********************************************************/
+        /***               OUTDOOR PVP SYSTEM                  ***/
+        /*********************************************************/
+
+        OutdoorPvP * GetOutdoorPvP() const;
+        // returns true if the player is in active state for outdoor pvp objective capturing, false otherwise
+        bool IsOutdoorPvPActive();
 
         /*********************************************************/
         /***                    REST SYSTEM                    ***/
@@ -1914,7 +1945,8 @@ class MANGOS_DLL_SPEC Player : public Unit
         bool isMoving() const { return HasUnitMovementFlag(movementFlagsMask); }
         bool isMovingOrTurning() const { return HasUnitMovementFlag(movementOrTurningFlagsMask); }
 
-        bool CanFly() const { return HasUnitMovementFlag(MOVEMENTFLAG_CAN_FLY); }
+        bool CanFly() const { return m_can_fly; }
+        void SetCanFly(bool set) {m_can_fly = set;}
         bool IsFlying() const { return HasUnitMovementFlag(MOVEMENTFLAG_FLYING); }
 
         void HandleDrowning();
@@ -1980,6 +2012,10 @@ class MANGOS_DLL_SPEC Player : public Unit
         uint32 GetOldPetSpell() const { return m_oldpetspell; }
         void SetOldPetSpell(uint32 petspell) { m_oldpetspell = petspell; }
 
+		// last used pet number (for BG's)
+        uint32 GetLastPetNumber() const { return m_lastpetnumber; }
+        void SetLastPetNumber(uint32 petnumber) { m_lastpetnumber = petnumber; }
+
         /*********************************************************/
         /***                 INSTANCE SYSTEM                   ***/
         /*********************************************************/
@@ -2038,8 +2074,8 @@ class MANGOS_DLL_SPEC Player : public Unit
         */
         struct BgBattleGroundQueueID_Rec
         {
-            uint32 bgType;
-            bool   invited;
+            uint32 bgQueueType;
+            uint32 invitedToInstance;
         };
         BgBattleGroundQueueID_Rec m_bgBattleGroundQueueID[PLAYER_MAX_BATTLEGROUND_QUEUES];
         uint32 m_bgEntryPointMap;
@@ -2220,6 +2256,16 @@ class MANGOS_DLL_SPEC Player : public Unit
         float m_rest_bonus;
         RestType rest_type;
         ////////////////////Rest System/////////////////////
+        //movement anticheat
+        uint32 m_anti_lastmovetime;     //last movement time 
+        uint64 m_anti_transportGUID;    //current transport GUID
+        float  m_anti_last_hspeed;      //horizontal speed, default RUN speed
+        uint32 m_anti_lastspeed_changetime;  //last speed change time
+        float  m_anti_last_vspeed;      //vertical speed, default max jump height
+ 
+        uint64 m_anti_lastalarmtime;    //last time when alarm generated
+        uint64 m_anti_alarmcount;       //alarm counter 
+        bool m_can_fly;
 
         // Transports
         Transport * m_transport;
@@ -2241,9 +2287,12 @@ class MANGOS_DLL_SPEC Player : public Unit
         uint32 m_temporaryUnsummonedPetNumber;
         uint32 m_oldpetspell;
 
-        uint64 m_miniPet;
+		// last used pet number (for BG's)
+		uint32 m_lastpetnumber;
         GuardianPetList m_guardianPets;
 
+		uint64 m_miniPet;
+
         // Player summoning
         time_t m_summon_expire;
         uint32 m_summon_mapid;
diff --git a/src/game/QuestHandler.cpp b/src/game/QuestHandler.cpp
index 42eea50..154198f 100644
--- a/src/game/QuestHandler.cpp
+++ b/src/game/QuestHandler.cpp
@@ -29,6 +29,8 @@
 #include "ObjectAccessor.h"
 #include "ScriptCalls.h"
 #include "Group.h"
+#include "BattleGround.h"
+#include "BattleGroundAV.h"
 
 void WorldSession::HandleQuestgiverStatusQueryOpcode( WorldPacket & recv_data )
 {
@@ -395,9 +397,15 @@ void WorldSession::HandleQuestComplete(WorldPacket& recv_data)
 
     sLog.outDebug( "WORLD: Received CMSG_QUESTGIVER_COMPLETE_QUEST npc = %u, quest = %u",uint32(GUID_LOPART(guid)),quest );
 
+    
     Quest const *pQuest = objmgr.GetQuestTemplate(quest);
     if( pQuest )
     {
+        if(GetPlayer()->InBattleGround())
+            if(BattleGround* bg = GetPlayer()->GetBattleGround())
+                if(bg->GetTypeID() == BATTLEGROUND_AV)
+                    ((BattleGroundAV*)bg)->HandleQuestComplete(quest, GetPlayer());
+
         if( _player->GetQuestStatus( quest ) != QUEST_STATUS_COMPLETE )
         {
             if( pQuest->IsRepeatable() )
diff --git a/src/game/SharedDefines.h b/src/game/SharedDefines.h
index 34e3eb1..fdc2154 100644
--- a/src/game/SharedDefines.h
+++ b/src/game/SharedDefines.h
@@ -798,14 +798,16 @@ enum Targets
     TARGET_AREAEFFECT_PARTY            = 37,
     TARGET_SCRIPT                      = 38,
     TARGET_SELF_FISHING                = 39,
-    TARGET_TOTEM_EARTH                 = 41,
-    TARGET_TOTEM_WATER                 = 42,
-    TARGET_TOTEM_AIR                   = 43,
-    TARGET_TOTEM_FIRE                  = 44,
+    TARGET_LOCATION_FRONT_LEFT         = 41,
+    TARGET_LOCATION_BACK_LEFT          = 42,
+    TARGET_LOCATION_BACK_RIGHT         = 43,
+    TARGET_LOCATION_FRONT_RIGHT        = 44,
     TARGET_CHAIN_HEAL                  = 45,
     TARGET_SCRIPT_COORDINATES          = 46,
-    TARGET_DYNAMIC_OBJECT              = 47,
-    TARGET_SUMMON                      = 48,
+    TARGET_LOCATION_FRONT              = 47,
+    TARGET_LOCATION_BACK               = 48,
+    TARGET_LOCATION_LEFT               = 49,
+    TARGET_LOCATION_RIGHT              = 50,
     TARGET_AREAEFFECT_CUSTOM_2         = 52,
     TARGET_CURRENT_ENEMY_COORDINATES   = 53,                // set unit coordinates as dest, only 16 target B imlemented
     TARGET_RANDOM_RAID_MEMBER          = 56,
@@ -813,8 +815,12 @@ enum Targets
     TARGET_AREAEFFECT_PARTY_AND_CLASS  = 61,
     TARGET_DUELVSPLAYER_COORDINATES    = 63,
     TARGET_BEHIND_VICTIM               = 65,                // uses in teleport behind spells
+    TARGET_LOCATION_RANDOM_AROUND_CASTER    = 72,
+    TARGET_LOCATION_RADIUS_AROUND_CASTER    = 73,
+    TARGET_LOCATION_RANDOM_IN_AREA     = 74,
     TARGET_SINGLE_ENEMY                = 77,
-    TARGET_SELF2                       = 87,
+    TARGET_LOCATION_AROUND_DEST        = 86,
+    TARGET_LOCATION_AT_DEST            = 87,
     TARGET_NONCOMBAT_PET               = 90,
 };
 
diff --git a/src/game/Spell.cpp b/src/game/Spell.cpp
index 544432d..748f480 100644
--- a/src/game/Spell.cpp
+++ b/src/game/Spell.cpp
@@ -305,6 +305,8 @@ Spell::Spell( Unit* Caster, SpellEntry const *info, bool triggered, uint64 origi
                 m_spellSchoolMask = SpellSchoolMask(1 << pItem->GetProto()->Damage->DamageType);
         }
     }
+    // Set health leech amount to zero
+    m_healthLeech = 0;
 
     if(originalCasterGUID)
         m_originalCasterGUID = originalCasterGUID;
@@ -665,6 +667,77 @@ void Spell::FillTargetMap()
     }
 }
 
+void Spell::prepareDataForTriggerSystem()
+{
+    //==========================================================================================
+    // Now fill data for trigger system, need know:
+    // an spell trigger another or not ( m_canTrigger )
+    // Create base triggers flags for Attacker and Victim ( m_procAttacker and  m_procVictim)
+    //==========================================================================================
+
+    // Fill flag can spell trigger or not
+    if (!m_IsTriggeredSpell) 
+        m_canTrigger = true;          // Normal cast - can trigger
+    else if (!m_triggeredByAuraSpell)
+        m_canTrigger = true;          // Triggered from SPELL_EFFECT_TRIGGER_SPELL - can trigger
+    else                              // Exceptions (some periodic triggers)
+    {
+        m_canTrigger = false;         // Triggered spells can`t trigger another
+        switch (m_spellInfo->SpellFamilyName)
+        {
+            case SPELLFAMILY_MAGE:    // Arcane Missles triggers need do it
+                if (m_spellInfo->SpellFamilyFlags & 0x0000000000200000LL) m_canTrigger = true;
+            break;
+            case SPELLFAMILY_WARLOCK: // For Hellfire Effect / Rain of Fire / Seed of Corruption triggers need do it
+                if (m_spellInfo->SpellFamilyFlags & 0x0000800000000060LL) m_canTrigger = true;
+            break;
+            case SPELLFAMILY_HUNTER:  // Hunter Explosive Trap Effect/Immolation Trap Effect/Frost Trap Aura/Snake Trap Effect
+                if (m_spellInfo->SpellFamilyFlags & 0x0000200000000014LL) m_canTrigger = true;
+            break;
+            case SPELLFAMILY_PALADIN: // For Holy Shock triggers need do it
+                if (m_spellInfo->SpellFamilyFlags & 0x0001000000200000LL) m_canTrigger = true;
+            break;
+        }
+    }
+    // Do not trigger from item cast spell
+    if (m_CastItem)
+       m_canTrigger = false;
+
+    // Get data for type of attack and fill base info for trigger
+    switch (m_spellInfo->DmgClass)
+    {
+        case SPELL_DAMAGE_CLASS_MELEE:
+            m_procAttacker = PROC_FLAG_SUCCESSFUL_MELEE_SPELL_HIT;
+            m_procVictim   = PROC_FLAG_TAKEN_MELEE_SPELL_HIT;
+            break;
+        case SPELL_DAMAGE_CLASS_RANGED: 
+            m_procAttacker = PROC_FLAG_SUCCESSFUL_RANGED_SPELL_HIT;
+            m_procVictim   = PROC_FLAG_TAKEN_RANGED_SPELL_HIT;
+            break;
+        default:
+            if (IsPositiveSpell(m_spellInfo->Id))          // Check for positive spell
+            {
+                m_procAttacker = PROC_FLAG_SUCCESSFUL_POSITIVE_SPELL;
+                m_procVictim   = PROC_FLAG_TAKEN_POSITIVE_SPELL;
+            }
+            else if (m_spellInfo->Id == 5019) // Wands
+            {
+                m_procAttacker = PROC_FLAG_SUCCESSFUL_RANGED_SPELL_HIT;
+                m_procVictim   = PROC_FLAG_TAKEN_RANGED_SPELL_HIT;
+            }
+            else
+            {
+                m_procAttacker = PROC_FLAG_SUCCESSFUL_NEGATIVE_SPELL_HIT;
+                m_procVictim   = PROC_FLAG_TAKEN_NEGATIVE_SPELL_HIT;
+            }
+            break;
+    }
+    // Hunter traps spells (for Entrapment trigger)
+    // Gives your Immolation Trap, Frost Trap, Explosive Trap, and Snake Trap ....
+    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_HUNTER && m_spellInfo->SpellFamilyFlags & 0x0000200000000014LL)
+        m_procAttacker |= PROC_FLAG_ON_TRAP_ACTIVATION;
+}
+
 void Spell::CleanupTargetList()
 {
     m_UniqueTargetInfo.clear();
@@ -820,7 +893,7 @@ void Spell::AddItemTarget(Item* pitem, uint32 effIndex)
     target.effectMask = 1<<effIndex;
     m_UniqueItemInfo.push_back(target);
 }
-
+/*
 void Spell::doTriggers(SpellMissInfo missInfo, uint32 damage, SpellSchoolMask damageSchoolMask, uint32 block, uint32 absorb, bool crit)
 {
     // Do triggers depends from hit result (triggers on hit do in effects)
@@ -896,7 +969,7 @@ void Spell::doTriggers(SpellMissInfo missInfo, uint32 damage, SpellSchoolMask da
                 break;
         }
     }
-}
+}*/
 
 void Spell::DoAllEffectOnTarget(TargetInfo *target)
 {
@@ -913,11 +986,27 @@ void Spell::DoAllEffectOnTarget(TargetInfo *target)
     if (!unit)
         return;
 
+    // Get original caster (if exist) and calculate damage/healing from him data
+    Unit *caster = m_originalCasterGUID ? m_originalCaster : m_caster;
+
+    // Skip if m_originalCaster not avaiable
+    if (!caster)
+        return;
+
     SpellMissInfo missInfo = target->missCondition;
     // Need init unitTarget by default unit (can changed in code on reflect)
     // Or on missInfo!=SPELL_MISS_NONE unitTarget undefined (but need in trigger subsystem)
     unitTarget = unit;
 
+    // Reset damage/healing counter
+    m_damage = 0;
+    m_healing = 0;
+
+    // Fill base trigger info
+    uint32 procAttacker = m_procAttacker;
+    uint32 procVictim   = m_procVictim;
+    uint32 procEx       = PROC_EX_NONE;
+
     if (missInfo==SPELL_MISS_NONE)                          // In case spell hit target, do all effect on that target
         DoSpellHitOnUnit(unit, mask);
     else if (missInfo == SPELL_MISS_REFLECT)                // In case spell reflect from target, do all effect on caster (if hit)
@@ -925,10 +1014,104 @@ void Spell::DoAllEffectOnTarget(TargetInfo *target)
         if (target->reflectResult == SPELL_MISS_NONE)       // If reflected spell hit caster -> do all effect on him
             DoSpellHitOnUnit(m_caster, mask);
     }
+                                               
+    // All calculated do it!
+    // Do healing and triggers
+    if (m_healing)
+    {
+        bool crit = caster->isSpellCrit(NULL, m_spellInfo, m_spellSchoolMask);
+        uint32 addhealth = m_healing;
+        if (crit)
+        {
+            procEx |= PROC_EX_CRITICAL_HIT;
+            addhealth = caster->SpellCriticalBonus(m_spellInfo, addhealth, NULL);
+        }
+        else
+            procEx |= PROC_EX_NORMAL_HIT;
 
-    // Do triggers only on miss/resist/parry/dodge
-    if (missInfo!=SPELL_MISS_NONE)
-        doTriggers(missInfo);
+        caster->SendHealSpellLog(unitTarget, m_spellInfo->Id, addhealth, crit);
+
+        // Do triggers for unit (reflect triggers passed on hit phase for correct drop charge)
+        if (m_canTrigger && missInfo != SPELL_MISS_REFLECT)
+            caster->ProcDamageAndSpell(unitTarget, procAttacker, procVictim, procEx, addhealth, m_attackType, m_spellInfo);
+
+        int32 gain = unitTarget->ModifyHealth( int32(addhealth) );
+
+        unitTarget->getHostilRefManager().threatAssist(caster, float(gain) * 0.5f, m_spellInfo);
+        if(caster->GetTypeId()==TYPEID_PLAYER)
+            if(BattleGround *bg = ((Player*)caster)->GetBattleGround())
+                bg->UpdatePlayerScore(((Player*)caster), SCORE_HEALING_DONE, gain);
+    }
+    // Do damage and triggers
+    else if (m_damage)
+    {
+        // Fill base damage struct (unitTarget - is real spell target)
+        SpellNonMeleeDamage damageInfo(caster, unitTarget, m_spellInfo->Id, m_spellSchoolMask);
+
+        // Add bonuses and fill damageInfo struct
+        caster->CalculateSpellDamage(&damageInfo, m_damage, m_spellInfo);
+
+        // Send log damage message to client
+        caster->SendSpellNonMeleeDamageLog(&damageInfo);
+
+        procEx = createProcExtendMask(&damageInfo, missInfo);
+        procVictim |= PROC_FLAG_TAKEN_ANY_DAMAGE;
+
+        // Do triggers for unit (reflect triggers passed on hit phase for correct drop charge)
+        if (m_canTrigger && missInfo != SPELL_MISS_REFLECT)
+            caster->ProcDamageAndSpell(unitTarget, procAttacker, procVictim, procEx, damageInfo.damage, m_attackType, m_spellInfo);
+
+        caster->DealSpellDamage(&damageInfo, true);
+
+        // Shadow Word: Death - deals damage equal to damage done to caster if victim is not killed
+        if (m_spellInfo->SpellFamilyName == SPELLFAMILY_PRIEST && m_spellInfo->SpellFamilyFlags&0x0000000200000000LL &&  
+            caster != unitTarget && unitTarget->isAlive())
+        {
+            // Redirect damage to caster if victim Alive
+            damageInfo.target = caster;
+            damageInfo.absorb = 0;
+            damageInfo.resist = 0;
+            damageInfo.blocked = 0;
+            // Send log damage message to client
+            caster->SendSpellNonMeleeDamageLog(&damageInfo);
+            caster->DealSpellDamage(&damageInfo, true);
+        }
+        // Judgement of Blood
+        else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_PALADIN && m_spellInfo->SpellFamilyFlags & 0x0000000800000000LL && m_spellInfo->SpellIconID==153)
+        {
+            int32 damagePoint  = damageInfo.damage * 33 / 100;
+            m_caster->CastCustomSpell(m_caster, 32220, &damagePoint, NULL, NULL, true);
+        }
+        // Bloodthirst
+        else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_WARRIOR && m_spellInfo->SpellFamilyFlags & 0x40000000000LL)
+        {
+            uint32 BTAura = 0;
+            switch(m_spellInfo->Id)
+            {
+                case 23881: BTAura = 23885; break;
+                case 23892: BTAura = 23886; break;
+                case 23893: BTAura = 23887; break;
+                case 23894: BTAura = 23888; break;
+                case 25251: BTAura = 25252; break;
+                case 30335: BTAura = 30339; break;
+                default:
+                    sLog.outError("Spell::EffectSchoolDMG: Spell %u not handled in BTAura",m_spellInfo->Id);
+                    break;
+            }
+            if (BTAura)
+                m_caster->CastSpell(m_caster,BTAura,true);
+        }
+    }
+    // Passive spell hits/misses or active spells only misses (only triggers)
+    else
+    {
+        // Fill base damage struct (unitTarget - is real spell target)
+        SpellNonMeleeDamage damageInfo(caster, unitTarget, m_spellInfo->Id, m_spellSchoolMask);
+        procEx = createProcExtendMask(&damageInfo, missInfo);
+        // Do triggers for unit (reflect triggers passed on hit phase for correct drop charge)
+        if (m_canTrigger && missInfo != SPELL_MISS_REFLECT)
+            caster->ProcDamageAndSpell(unit, procAttacker, procVictim, procEx, 0, m_attackType, m_spellInfo);
+    }
 
     // Call scripted function for AI if this spell is casted upon a creature (except pets)
     if(IS_CREATURE_GUID(target->targetGUID))
@@ -945,6 +1128,9 @@ void Spell::DoAllEffectOnTarget(TargetInfo *target)
 
 void Spell::DoSpellHitOnUnit(Unit *unit, const uint32 effectMask)
 {
+    if (m_caster->hasUnitState(UNIT_STAT_DIED)) 
+        return;
+
     if(!unit || !effectMask)
         return;
 
@@ -968,10 +1154,7 @@ void Spell::DoSpellHitOnUnit(Unit *unit, const uint32 effectMask)
                 return;
             }
 
-            // exclude Arcane Missiles Dummy Aura aura for now (attack on hit)
-            // TODO: find way to not need this?
-            if(!(m_spellInfo->SpellFamilyName == SPELLFAMILY_MAGE &&
-                m_spellInfo->SpellFamilyFlags & 0x800LL))
+            if(!IsPositiveSpell(m_spellInfo->Id))
             {
                 unit->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
 
@@ -1172,16 +1355,99 @@ void Spell::SetTargetMap(uint32 i,uint32 cur,std::list<Unit*> &TagUnitMap)
     uint32 unMaxTargets = m_spellInfo->MaxAffectedTargets;
     switch(cur)
     {
-        case TARGET_TOTEM_EARTH:
-        case TARGET_TOTEM_WATER:
-        case TARGET_TOTEM_AIR:
-        case TARGET_TOTEM_FIRE:
+        case TARGET_LOCATION_FRONT_LEFT:
+        case TARGET_LOCATION_BACK_LEFT:
+        case TARGET_LOCATION_BACK_RIGHT:
+        case TARGET_LOCATION_FRONT_RIGHT:
+        case TARGET_LOCATION_FRONT:
+        case TARGET_LOCATION_BACK:
+        case TARGET_LOCATION_LEFT:
+        case TARGET_LOCATION_RIGHT:
+        case TARGET_LOCATION_RANDOM_AROUND_CASTER:
+        case TARGET_LOCATION_RADIUS_AROUND_CASTER:
+        {
+            float x, y, z, angle, dist;
+
+            if (m_spellInfo->EffectRadiusIndex[i])
+                dist = GetSpellRadius(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
+            else
+                dist = 3.0f;
+            if (cur == TARGET_LOCATION_RANDOM_AROUND_CASTER)
+                dist *= rand_norm(); // This case we need to consider caster size
+            else
+                dist -= m_caster->GetObjectSize(); // Size is calculated in GetNearPoint(), but we do not need it 
+
+            switch(cur)
+            {
+                case TARGET_LOCATION_FRONT_LEFT:
+                    angle = -M_PI/4;
+                    break;
+                case TARGET_LOCATION_BACK_LEFT:
+                    angle = -3*M_PI/4;
+                    break;
+                case TARGET_LOCATION_BACK_RIGHT:
+                    angle = 3*M_PI/4;
+                    break;
+                case TARGET_LOCATION_FRONT_RIGHT:
+                    angle = M_PI/4;
+                    break;
+                case TARGET_LOCATION_FRONT:
+                    angle = 0.0f;
+                    break;
+                case TARGET_LOCATION_BACK:
+                    angle = M_PI;
+                    break;
+                case TARGET_LOCATION_LEFT:
+                    angle = -M_PI/2;
+                    break;
+                case TARGET_LOCATION_RIGHT:
+                    angle = M_PI/2;
+                    break;
+                default:
+                    angle = rand_norm()*2*M_PI;
+                    break;
+            }
+
+            m_caster->GetClosePoint(x, y, z, 0, dist, angle);
+            m_targets.setDestination(x, y, z);
+            if (m_targets.getUnitTarget())
+                TagUnitMap.push_back(m_targets.getUnitTarget());
+            else
+                TagUnitMap.push_back(m_caster); 
+        }break;
+        case TARGET_LOCATION_RANDOM_IN_AREA:
+        case TARGET_LOCATION_AROUND_DEST:
+        {
+            float x, y, z, dist, px, py, pz;
+            dist = GetSpellRadius(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
+            if (m_targets.m_targetMask & TARGET_FLAG_DEST_LOCATION)
+            {
+                x = m_targets.m_destX;
+                y = m_targets.m_destY;
+                z = m_targets.m_destZ;
+            }
+            else if (m_targets.getUnitTarget()) // Do not know if possible
+                m_targets.getUnitTarget()->GetPosition(x, y, z);
+            else
+                m_caster->GetPosition(x, y, z);
+
+            m_caster->GetRandomPoint(x, y, z, dist, px, py, pz);
+            m_targets.setDestination(px, py, pz);
+            if (m_targets.getUnitTarget())
+                TagUnitMap.push_back(m_targets.getUnitTarget());
+            else
+                TagUnitMap.push_back(m_caster);
+        }break;
+        case TARGET_LOCATION_AT_DEST:
+        {
+            if (m_targets.getUnitTarget())
+                TagUnitMap.push_back(m_targets.getUnitTarget());
+            else
+                TagUnitMap.push_back(m_caster);
+        }break;
         case TARGET_SELF:
-        case TARGET_SELF2:
-        case TARGET_DYNAMIC_OBJECT:
         case TARGET_AREAEFFECT_CUSTOM:
         case TARGET_AREAEFFECT_CUSTOM_2:
-        case TARGET_SUMMON:
         {
             TagUnitMap.push_back(m_caster);
             break;
@@ -1663,11 +1929,11 @@ void Spell::SetTargetMap(uint32 i,uint32 cur,std::list<Unit*> &TagUnitMap)
                     // IsHostileTo check duel and controlled by enemy
                     if(Target && Target->GetSubGroup()==subgroup && !m_caster->IsHostileTo(Target))
                     {
-                        if( pTarget->IsWithinDistInMap(Target, radius) )
+                        if(Target->getLevel()+10 >= m_spellInfo->spellLevel && pTarget->IsWithinDistInMap(Target, radius))
                             TagUnitMap.push_back(Target);
 
                         if(Pet* pet = Target->GetPet())
-                            if( pTarget->IsWithinDistInMap(pet, radius) )
+                            if(pet->getLevel()+10 >= m_spellInfo->spellLevel && pTarget->IsWithinDistInMap(pet, radius) )
                                 TagUnitMap.push_back(pet);
                     }
                 }
@@ -1682,7 +1948,7 @@ void Spell::SetTargetMap(uint32 i,uint32 cur,std::list<Unit*> &TagUnitMap)
                 TagUnitMap.push_back(pTarget);
 
                 if(Pet* pet = pTarget->GetPet())
-                    if( m_caster->IsWithinDistInMap(pet, radius) )
+                    if(pet->getLevel()+10 >= m_spellInfo->spellLevel && m_caster->IsWithinDistInMap(pet, radius) )
                         TagUnitMap.push_back(pet);
             }
 
@@ -1808,9 +2074,7 @@ void Spell::SetTargetMap(uint32 i,uint32 cur,std::list<Unit*> &TagUnitMap)
                     Player* Target = itr->getSource();
 
                     // IsHostileTo check duel and controlled by enemy
-                    if( Target && targetPlayer->IsWithinDistInMap(Target, radius) &&
-                        targetPlayer->getClass() == Target->getClass() &&
-                        !m_caster->IsHostileTo(Target) )
+                    if( Target && Target->getLevel()+10 >= m_spellInfo->spellLevel && targetPlayer->getClass() == Target->getClass() && !m_caster->IsHostileTo(Target) && targetPlayer->IsWithinDistInMap(Target, radius) )
                     {
                         TagUnitMap.push_back(Target);
                     }
@@ -1950,6 +2214,9 @@ void Spell::prepare(SpellCastTargets * targets, Aura* triggeredByAura)
         return;
     }
 
+    // Prepare data for triggers
+    prepareDataForTriggerSystem();
+
     // calculate cast time (calculated after first CanCast check to prevent charge counting for first CanCast fail)
     m_casttime = GetSpellCastTime(m_spellInfo, this);
 
@@ -2087,15 +2354,6 @@ void Spell::cast(bool skipCheck)
     SendCastResult(castResult);
     SendSpellGo();                                          // we must send smsg_spell_go packet before m_castItem delete in TakeCastItem()...
 
-    // Pass cast spell event to handler (not send triggered by aura spells)
-    if (m_spellInfo->DmgClass != SPELL_DAMAGE_CLASS_MELEE && m_spellInfo->DmgClass != SPELL_DAMAGE_CLASS_RANGED && !m_triggeredByAuraSpell)
-    {
-        m_caster->ProcDamageAndSpell(m_targets.getUnitTarget(), PROC_FLAG_CAST_SPELL, PROC_FLAG_NONE, 0, SPELL_SCHOOL_MASK_NONE, m_spellInfo, m_IsTriggeredSpell);
-
-        // update pointers base at GUIDs to prevent access to non-existed already object
-        UpdatePointers();                                   // pointers can be invalidate at triggered spell casting
-    }
-
     // Okay, everything is prepared. Now we need to distinguish between immediate and evented delayed spells
     if (m_spellInfo->speed > 0.0f)
     {
@@ -2479,7 +2737,24 @@ void Spell::finish(bool ok)
     // other code related only to successfully finished spells
     if(!ok)
         return;
-
+    //holy nova heal
+    if(m_spellInfo->SpellFamilyName == SPELLFAMILY_PRIEST && m_spellInfo->SpellIconID == 1874)
+    {
+        int holy_nova_heal = 0;
+        switch(m_spellInfo->Id)
+        {
+            case 15237: holy_nova_heal = 23455; break;
+            case 15430: holy_nova_heal = 23458; break;
+            case 15431: holy_nova_heal = 23459; break;
+            case 27799: holy_nova_heal = 27803; break;
+            case 27804: holy_nova_heal = 27800; break;
+            case 27801: holy_nova_heal = 27805; break;
+            case 25331: holy_nova_heal = 25329; break;
+            default:break;
+        }
+        if(holy_nova_heal)
+            m_caster->CastSpell(m_caster, holy_nova_heal, true);
+    }
     //handle SPELL_AURA_ADD_TARGET_TRIGGER auras
     Unit::AuraList const& targetTriggers = m_caster->GetAurasByType(SPELL_AURA_ADD_TARGET_TRIGGER);
     for(Unit::AuraList::const_iterator i = targetTriggers.begin(); i != targetTriggers.end(); ++i)
@@ -2499,12 +2774,20 @@ void Spell::finish(bool ok)
                     int32 chance = m_caster->CalculateSpellDamage(auraSpellInfo, auraSpellIdx, (*i)->GetBasePoints(),unit);
 
                     if(roll_chance_i(chance))
-                        m_caster->CastSpell(unit, auraSpellInfo->EffectTriggerSpell[auraSpellIdx], true, NULL, (*i));
+                        for ( int j=0; j != (*i)->m_stackAmount; ++j)
+                            m_caster->CastSpell(unit, auraSpellInfo->EffectTriggerSpell[auraSpellIdx], true, NULL, (*i));
                 }
             }
         }
     }
 
+    // Heal caster for all health leech from all targets
+    if (m_healthLeech)
+    {
+        m_caster->ModifyHealth(m_healthLeech);
+        m_caster->SendHealSpellLog(m_caster, m_spellInfo->Id, uint32(m_healthLeech));
+    }
+
     if (IsMeleeAttackResetSpell())
     {
         m_caster->resetAttackTimer(BASE_ATTACK);
@@ -3245,23 +3528,6 @@ uint8 Spell::CanCast(bool strict)
             }
         }
 
-        // TODO: this check can be applied and for player to prevent cheating when IsPositiveSpell will return always correct result.
-        // check target for pet/charmed casts (not self targeted), self targeted cast used for area effects and etc
-        if(m_caster != target && m_caster->GetTypeId()==TYPEID_UNIT && m_caster->GetCharmerOrOwnerGUID())
-        {
-            // check correctness positive/negative cast target (pet cast real check and cheating check)
-            if(IsPositiveSpell(m_spellInfo->Id))
-            {
-                if(m_caster->IsHostileTo(target))
-                    return SPELL_FAILED_BAD_TARGETS;
-            }
-            else
-            {
-                if(m_caster->IsFriendlyTo(target))
-                    return SPELL_FAILED_BAD_TARGETS;
-            }
-        }
-
         if(IsPositiveSpell(m_spellInfo->Id))
         {
             if(target->IsImmunedToSpell(m_spellInfo,false))
@@ -3458,8 +3724,9 @@ uint8 Spell::CanCast(bool strict)
         }
     }
 
-    if(uint8 castResult = CheckRange(strict))
-        return castResult;
+    if(!m_triggeredByAuraSpell)
+        if(uint8 castResult = CheckRange(strict))
+            return castResult;
 
     {
         if(uint8 castResult = CheckPower())
@@ -3840,6 +4107,26 @@ uint8 Spell::CanCast(bool strict)
 
                 break;
             }
+            case SPELL_EFFECT_SUMMON_WILD:
+            {
+                // fire bomb trigger, can only be used in halaa opvp when flying on a path from a wyvern roost
+                // yeah, hacky, I know, but neither item flags, nor spell attributes contained any useable data (or I was unable to find it)
+                if(m_spellInfo->EffectMiscValue[i] == 18225 && m_caster->GetTypeId() == TYPEID_PLAYER)
+                {
+                    // if not in halaa or not in flight, cannot be used
+                    if(m_caster->GetAreaId() != 3628 || !m_caster->isInFlight())
+                        return SPELL_FAILED_NOT_HERE;
+
+                    // if not on one of the specific taxi paths, then cannot be used
+                    uint32 src_node = ((Player*)m_caster)->m_taxi.GetTaxiSource();
+                    if( src_node != 103 &&
+                        src_node != 105 &&
+                        src_node != 107 &&
+                        src_node != 109 )
+                        return SPELL_FAILED_NOT_HERE;
+                }
+                break;
+            }
             case SPELL_EFFECT_SUMMON_PET:
             {
                 if(m_caster->GetPetGUID())                  //let warlock do a replacement summon
@@ -3888,19 +4175,6 @@ uint8 Spell::CanCast(bool strict)
             case SPELL_EFFECT_LEAP:
             case SPELL_EFFECT_TELEPORT_UNITS_FACE_CASTER:
             {
-                float dis = GetSpellRadius(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
-                float fx = m_caster->GetPositionX() + dis * cos(m_caster->GetOrientation());
-                float fy = m_caster->GetPositionY() + dis * sin(m_caster->GetOrientation());
-                // teleport a bit above terrain level to avoid falling below it
-                float fz = MapManager::Instance().GetBaseMap(m_caster->GetMapId())->GetHeight(fx,fy,m_caster->GetPositionZ(),true);
-                if(fz <= INVALID_HEIGHT)                    // note: this also will prevent use effect in instances without vmaps height enabled
-                    return SPELL_FAILED_TRY_AGAIN;
-
-                float caster_pos_z = m_caster->GetPositionZ();
-                // Control the caster to not climb or drop when +-fz > 8
-                if(!(fz<=caster_pos_z+8 && fz>=caster_pos_z-8))
-                    return SPELL_FAILED_TRY_AGAIN;
-
                 // not allow use this effect at battleground until battleground start
                 if(m_caster->GetTypeId()==TYPEID_PLAYER)
                     if(BattleGround const *bg = ((Player*)m_caster)->GetBattleGround())
@@ -4047,22 +4321,23 @@ int16 Spell::PetCanCast(Unit* target)
             if(!_target->isAlive())
                 return SPELL_FAILED_BAD_TARGETS;
 
-            if(IsPositiveSpell(m_spellInfo->Id))
+            bool duelvsplayertar = false;
+            for(int j=0;j<3;j++)
             {
-                if(m_caster->IsHostileTo(_target))
-                    return SPELL_FAILED_BAD_TARGETS;
+                                                //TARGET_DUELVSPLAYER is positive AND negative
+                duelvsplayertar |= (m_spellInfo->EffectImplicitTargetA[j] == TARGET_DUELVSPLAYER);
             }
-            else
+            if (!duelvsplayertar)
             {
-                bool duelvsplayertar = false;
-                for(int j=0;j<3;j++)
+                if(IsPositiveSpell(m_spellInfo->Id))
                 {
-                                                            //TARGET_DUELVSPLAYER is positive AND negative
-                    duelvsplayertar |= (m_spellInfo->EffectImplicitTargetA[j] == TARGET_DUELVSPLAYER);
+                    if(m_caster->IsHostileTo(_target))
+                        return SPELL_FAILED_BAD_TARGETS;
                 }
-                if(m_caster->IsFriendlyTo(target) && !duelvsplayertar)
+                else
                 {
-                    return SPELL_FAILED_BAD_TARGETS;
+                    if(m_caster->IsFriendlyTo(target))
+                        return SPELL_FAILED_BAD_TARGETS;
                 }
             }
         }
@@ -4082,9 +4357,16 @@ uint8 Spell::CheckCasterAuras() const
 {
     // Flag drop spells totally immuned to caster auras
     // FIXME: find more nice check for all totally immuned spells
-    // AttributesEx3 & 0x10000000?
-    if(m_spellInfo->Id==23336 || m_spellInfo->Id==23334 || m_spellInfo->Id==34991)
-        return 0;
+    switch(m_spellInfo->Id)
+    {
+        case 23336:     // Alliance Flag Drop
+        case 23334:     // Horde Flag Drop
+        case 34991:     // Summon Netherstorm Flag
+        case 22812:     // Barkskin
+            return 0;
+        default:
+            break;
+    }
 
     uint8 school_immune = 0;
     uint32 mechanic_immune = 0;
diff --git a/src/game/Spell.h b/src/game/Spell.h
index 093a915..801e145 100644
--- a/src/game/Spell.h
+++ b/src/game/Spell.h
@@ -451,10 +451,18 @@ class Spell
         // -------------------------------------------
         GameObject* focusObject;
 
+        // Damage and healing in effects need just calculate
+        int32 m_damage;           // Damge   in effects count here
+        int32 m_healing;          // Healing in effects count here
+        int32 m_healthLeech;      // Health leech in effects for all targets count here
+
         //******************************************
         // Spell trigger system
         //******************************************
-        void doTriggers(SpellMissInfo missInfo, uint32 damage=0, SpellSchoolMask damageSchoolMask = SPELL_SCHOOL_MASK_NONE, uint32 block=0, uint32 absorb=0, bool crit=false);
+        bool   m_canTrigger;                  // Can start trigger (m_IsTriggeredSpell can`t use for this)
+        uint32 m_procAttacker;                // Attacker trigger flags
+        uint32 m_procVictim;                  // Victim   trigger flags
+        void   prepareDataForTriggerSystem();
 
         //*****************************************
         // Spell target subsystem
diff --git a/src/game/SpellAuras.cpp b/src/game/SpellAuras.cpp
index 2f29cfc..3fc11a7 100644
--- a/src/game/SpellAuras.cpp
+++ b/src/game/SpellAuras.cpp
@@ -40,6 +40,8 @@
 #include "Creature.h"
 #include "Formulas.h"
 #include "BattleGround.h"
+#include "OutdoorPvP.h"
+#include "OutdoorPvPMgr.h"
 #include "CreatureAI.h"
 #include "Util.h"
 #include "GridNotifiers.h"
@@ -253,8 +255,8 @@ pAuraHandler AuraHandler[TOTAL_AURAS]=
     &Aura::HandleNoImmediateEffect,                         //200 SPELL_AURA_MOD_XP_PCT implemented in Player::GiveXP
     &Aura::HandleAuraAllowFlight,                           //201 SPELL_AURA_FLY                             this aura enable flight mode...
     &Aura::HandleNoImmediateEffect,                         //202 SPELL_AURA_CANNOT_BE_DODGED                implemented in Unit::RollPhysicalOutcomeAgainst
-    &Aura::HandleNoImmediateEffect,                         //203 SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE  implemented in Unit::DoAttackDamage
-    &Aura::HandleNoImmediateEffect,                         //204 SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE implemented in Unit::DoAttackDamage
+    &Aura::HandleNoImmediateEffect,                         //203 SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE  implemented in Unit::CalculateMeleeDamage and Unit::CalculateSpellDamage
+    &Aura::HandleNoImmediateEffect,                         //204 SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE implemented in Unit::CalculateMeleeDamage and Unit::CalculateSpellDamage
     &Aura::HandleNULL,                                      //205 vulnerable to school dmg?
     &Aura::HandleNULL,                                      //206 SPELL_AURA_MOD_SPEED_MOUNTED
     &Aura::HandleAuraModIncreaseFlightSpeed,                //207 SPELL_AURA_MOD_INCREASE_FLIGHT_SPEED
@@ -315,7 +317,7 @@ pAuraHandler AuraHandler[TOTAL_AURAS]=
 };
 
 Aura::Aura(SpellEntry const* spellproto, uint32 eff, int32 *currentBasePoints, Unit *target, Unit *caster, Item* castItem) :
-m_procCharges(0), m_spellmod(NULL), m_effIndex(eff), m_caster_guid(0), m_target(target),
+m_procCharges(0), m_stackAmount(1), m_spellmod(NULL), m_effIndex(eff), m_caster_guid(0), m_target(target),
 m_timeCla(1000), m_castItemGuid(castItem?castItem->GetGUID():0), m_auraSlot(MAX_AURAS),
 m_positive(false), m_permanent(false), m_isPeriodic(false), m_isTrigger(false), m_isAreaAura(false),
 m_isPersistent(false), m_updated(false), m_removeMode(AURA_REMOVE_BY_DEFAULT), m_isRemovedOnShapeLost(true), m_in_use(false),
@@ -858,7 +860,6 @@ void Aura::_AddAura()
         return;
 
     // we can found aura in NULL_AURA_SLOT and then need store state instead check slot != NULL_AURA_SLOT
-    bool samespell = false;
     bool secondaura = false;
     uint8 slot = NULL_AURA_SLOT;
 
@@ -870,15 +871,13 @@ void Aura::_AddAura()
             // allow use single slot only by auras from same caster
             if(itr->second->GetCasterGUID()==GetCasterGUID())
             {
-                samespell = true;
-                if (m_effIndex > itr->second->GetEffIndex())
-                     secondaura = true;
+                secondaura = true;
                 slot = itr->second->GetAuraSlot();
                 break;
             }
         }
 
-        if(samespell)
+        if(secondaura)
             break;
     }
 
@@ -907,7 +906,7 @@ void Aura::_AddAura()
     if((!m_isPassive || (caster && caster->GetTypeId() == TYPEID_UNIT && ((Creature*)caster)->isTotem())) &&
         (m_spellProto->Effect[GetEffIndex()] != SPELL_EFFECT_APPLY_AREA_AURA_ENEMY || m_target != caster))
     {
-        if(!samespell)                                      // new slot need
+        if(!secondaura)                                     // new slot need
         {
             if (IsPositive())                               // empty positive slot
             {
@@ -935,30 +934,24 @@ void Aura::_AddAura()
             SetAuraSlot( slot );
 
             // Not update fields for not first spell's aura, all data already in fields
-            if(!secondaura)
+            if(slot < MAX_AURAS)                        // slot found
             {
-                if(slot < MAX_AURAS)                        // slot found
-                {
-                    SetAura(slot, false);
-                    SetAuraFlag(slot, true);
-                    SetAuraLevel(slot,caster ? caster->getLevel() : sWorld.getConfig(CONFIG_MAX_PLAYER_LEVEL));
-                    UpdateAuraCharges();
-
-                    // update for out of range group members
-                    m_target->UpdateAuraForGroup(slot);
-                }
-
-                UpdateAuraDuration();
+                SetAura(slot, false);
+                SetAuraFlag(slot, true);
+                SetAuraLevel(slot,caster ? caster->getLevel() : sWorld.getConfig(CONFIG_MAX_PLAYER_LEVEL));
+                UpdateAuraCharges();
+                
+                // update for out of range group members
+                m_target->UpdateAuraForGroup(slot);
             }
         }
         else                                                // use found slot
         {
             SetAuraSlot( slot );
-            // Not recalculate stack count for second aura of the same spell
-            if (!secondaura)
-                UpdateSlotCounterAndDuration(true);
         }
 
+        UpdateSlotCounterAndDuration();
+
         // Update Seals information
         if( IsSealSpell(GetSpellProto()) )
             m_target->ModifyAuraState(AURA_STATE_JUDGEMENT, true);
@@ -1009,7 +1002,6 @@ void Aura::_RemoveAura()
         return;
 
     bool samespell = false;
-    bool sameaura = false;
 
     // find other aura in same slot (current already removed from list)
     for(uint8 i = 0; i < 3; i++)
@@ -1020,10 +1012,6 @@ void Aura::_RemoveAura()
             if(itr->second->GetAuraSlot()==slot)
             {
                 samespell = true;
-
-                if(GetEffIndex()==i)
-                    sameaura = true;
-
                 break;
             }
         }
@@ -1075,8 +1063,6 @@ void Aura::_RemoveAura()
                 ((Player*)caster)->SendCooldownEvent(GetSpellProto());
         }
     }
-    else if(sameaura)                                       // decrease count for spell, only for same aura effect, or this spell auras in remove proccess.
-        UpdateSlotCounterAndDuration(false);
 }
 
 void Aura::SetAuraFlag(uint32 slot, bool add)
@@ -1115,35 +1101,13 @@ void Aura::SetAuraApplication(uint32 slot, int8 count)
     m_target->SetUInt32Value(UNIT_FIELD_AURAAPPLICATIONS + index, val);
 }
 
-void Aura::UpdateSlotCounterAndDuration(bool add)
+void Aura::UpdateSlotCounterAndDuration()
 {
     uint8 slot = GetAuraSlot();
     if(slot >= MAX_AURAS)
         return;
 
-    // calculate amount of similar auras by same effect index (similar different spells)
-    int8 count = 0;
-
-    // calculate auras and update durations in case aura adding
-    Unit::AuraList const& aura_list = m_target->GetAurasByType(GetModifier()->m_auraname);
-    for(Unit::AuraList::const_iterator i = aura_list.begin();i != aura_list.end(); ++i)
-    {
-        if( (*i)->GetId()==GetId() && (*i)->GetEffIndex()==m_effIndex &&
-            (*i)->GetCasterGUID()==GetCasterGUID() )
-        {
-            ++count;
-
-            if(add)
-                (*i)->SetAuraDuration(GetAuraDuration());
-        }
-    }
-
-    // at aura add aura not added yet, at aura remove aura already removed
-    // in field stored (count-1)
-    if(!add)
-        --count;
-
-    SetAuraApplication(slot, count);
+    SetAuraApplication(slot, m_stackAmount - 1);
 
     UpdateAuraDuration();
 }
@@ -1177,7 +1141,7 @@ void Aura::HandleAddModifier(bool apply, bool Real)
 
         SpellModifier *mod = new SpellModifier;
         mod->op = SpellModOp(m_modifier.m_miscvalue);
-        mod->value = m_modifier.m_amount;
+        mod->value = m_modifier.m_amount * m_stackAmount;
         mod->type = SpellModType(m_modifier.m_auraname);    // SpellModType value == spell aura types
         mod->spellId = GetId();
         mod->effectId = m_effIndex;
@@ -1646,8 +1610,21 @@ void Aura::TriggerSpell()
 //                    case 40867: break;
 //                    // Prismatic Shield
 //                    case 40879: break;
-//                    // Aura of Desire
-//                    case 41350: break;
+//                  // Aura of Desire
+                    case 41350:
+                    {
+                        Unit::AuraList const& mMod = m_target->GetAurasByType(SPELL_AURA_MOD_INCREASE_ENERGY_PERCENT);
+                        for(Unit::AuraList::const_iterator i = mMod.begin(); i != mMod.end(); ++i)
+                        {
+                            if ((*i)->GetId() == 41350)
+                            {
+                                (*i)->ApplyModifier(false);
+                                (*i)->GetModifier()->m_amount -= 5;
+                                (*i)->ApplyModifier(true);
+                                break;
+                            }
+                        }                        
+                    }break;
 //                    // Dementia
 //                    case 41404: break;
 //                    // Chaos Form
@@ -1867,8 +1844,8 @@ void Aura::TriggerSpell()
                     {
                         switch((*i)->GetModifier()->m_miscvalue)
                         {
-                            case STAT_INTELLECT: intelectLoss += (*i)->GetModifier()->m_amount; break;
-                            case STAT_SPIRIT:    spiritLoss   += (*i)->GetModifier()->m_amount; break;
+                            case STAT_INTELLECT: intelectLoss += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount; break;
+                            case STAT_SPIRIT:    spiritLoss   += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount; break;
                             default: break;
                         }
                     }
@@ -2137,7 +2114,8 @@ void Aura::HandleAuraDummy(bool apply, bool Real)
                             return;
 
                     // final heal
-                    m_target->CastCustomSpell(m_target,33778,&m_modifier.m_amount,NULL,NULL,true,NULL,this,GetCasterGUID());
+                    if(m_target->IsInWorld())
+                        m_target->CastCustomSpell(m_target,33778,&m_modifier.m_amount,NULL,NULL,true,NULL,this,GetCasterGUID());
                 }
                 return;
             }
@@ -2785,7 +2763,7 @@ void Aura::HandleAuraModSkill(bool apply, bool Real)
         return;
 
     uint32 prot=GetSpellProto()->EffectMiscValue[m_effIndex];
-    int32 points = GetModifier()->m_amount;
+    int32 points = GetModifier()->m_amount * m_stackAmount;
 
     ((Player*)m_target)->ModifySkillBonus(prot,(apply ? points: -points),m_modifier.m_auraname==SPELL_AURA_MOD_SKILL_TALENT);
     if(prot == SKILL_DEFENSE)
@@ -2874,7 +2852,7 @@ void Aura::HandleAuraTrackStealthed(bool apply, bool Real)
 
 void Aura::HandleAuraModScale(bool apply, bool Real)
 {
-    m_target->ApplyPercentModFloatValue(OBJECT_FIELD_SCALE_X,m_modifier.m_amount,apply);
+    m_target->ApplyPercentModFloatValue(OBJECT_FIELD_SCALE_X,m_modifier.m_amount * m_stackAmount,apply);
 }
 
 void Aura::HandleModPossess(bool apply, bool Real)
@@ -3118,6 +3096,7 @@ void Aura::HandleFeignDeath(bool apply, bool Real)
 
         m_target->addUnitState(UNIT_STAT_DIED);
         m_target->CombatStop();
+        m_target->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_LOST_SELECTION);
 
         // prevent interrupt message
         if(m_caster_guid==m_target->GetGUID() && m_target->m_currentSpells[CURRENT_GENERIC_SPELL])
@@ -3176,6 +3155,9 @@ void Aura::HandleAuraModDisarm(bool apply, bool Real)
 
 void Aura::HandleAuraModStun(bool apply, bool Real)
 {
+    if(m_target->isInFlight())
+        return;
+
     if(!Real)
         return;
 
@@ -3193,6 +3175,24 @@ void Aura::HandleAuraModStun(bool apply, bool Real)
         else
             m_target->SetUnitMovementFlags(0);    //Clear movement flags
 
+        // Summon the Naj'entus Spine GameObject on target if spell is Impaling Spine
+        if(GetSpellProto()->Id == 39837)
+        {
+            GameObject* pObj = new GameObject;
+            float x, y, z;
+            m_target->GetPosition(x, y, z);
+ 
+            if(!pObj->Create(objmgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), 185584, m_target->GetMap(), x, y, z, 0, 0, 0, 0, 0, 100, 1))
+            {
+                delete pObj;
+                return;
+            }
+ 
+            pObj->SetRespawnTime(GetSpellDuration(GetSpellProto())/1000);
+            m_target->AddGameObject(pObj);
+            MapManager::Instance().GetMap(pObj->GetMapId(), pObj)->Add(pObj);
+        }
+
         WorldPacket data(SMSG_FORCE_MOVE_ROOT, 8);
 
         data.append(m_target->GetPackGUID());
@@ -3255,9 +3255,12 @@ void Aura::HandleModStealth(bool apply, bool Real)
     if(apply)
     {
         // drop flag at stealth in bg
-        if(Real && m_target->GetTypeId()==TYPEID_PLAYER && ((Player*)m_target)->InBattleGround())
-            if(BattleGround *bg = ((Player*)m_target)->GetBattleGround())
-                bg->EventPlayerDroppedFlag((Player*)m_target);
+         m_target->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_LOST_SELECTION);
+
+        // remove player from the objective's active player count at stealth
+        if(Real && m_target->GetTypeId()==TYPEID_PLAYER)
+            if(OutdoorPvP * pvp = ((Player*)m_target)->GetOutdoorPvP())
+                pvp->HandlePlayerActivityChanged((Player*)m_target);
 
         // only at real aura add
         if(Real)
@@ -3302,6 +3305,12 @@ void Aura::HandleModStealth(bool apply, bool Real)
                 }
                 else
                     m_target->SetVisibility(VISIBILITY_ON);
+                if(m_target->GetTypeId() == TYPEID_PLAYER)
+                {
+                    if(OutdoorPvP * pvp = ((Player*)m_target)->GetOutdoorPvP())
+                        pvp->HandlePlayerActivityChanged((Player*)m_target);
+                    m_target->SendUpdateToPlayer((Player*)m_target);
+                }
             }
         }
     }
@@ -3330,15 +3339,16 @@ void Aura::HandleInvisibility(bool apply, bool Real)
     {
         m_target->m_invisibilityMask |= (1 << m_modifier.m_miscvalue);
 
+         m_target->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_LOST_SELECTION);
+
         if(Real && m_target->GetTypeId()==TYPEID_PLAYER)
         {
             // apply glow vision
             m_target->SetFlag(PLAYER_FIELD_BYTES2,PLAYER_FIELD_BYTE2_INVISIBILITY_GLOW);
+            // remove player from the objective's active player count at invisibility
+            if(OutdoorPvP * pvp = ((Player*)m_target)->GetOutdoorPvP())
+                pvp->HandlePlayerActivityChanged((Player*)m_target);
 
-            // drop flag at invisible in bg
-            if(((Player*)m_target)->InBattleGround())
-                if(BattleGround *bg = ((Player*)m_target)->GetBattleGround())
-                    bg->EventPlayerDroppedFlag((Player*)m_target);
         }
 
         // apply only if not in GM invisibility and not stealth
@@ -3370,6 +3380,13 @@ void Aura::HandleInvisibility(bool apply, bool Real)
                 // if have stealth aura then already have stealth visibility
                 if(!m_target->HasAuraType(SPELL_AURA_MOD_STEALTH))
                     m_target->SetVisibility(VISIBILITY_ON);
+                if(m_target->GetTypeId() == TYPEID_PLAYER)
+                {
+                    if(OutdoorPvP * pvp = ((Player*)m_target)->GetOutdoorPvP())
+                        pvp->HandlePlayerActivityChanged((Player*)m_target);
+
+                    m_target->SendUpdateToPlayer((Player*)m_target);
+                }
             }
         }
     }
@@ -3486,15 +3503,11 @@ void Aura::HandleAuraModSilence(bool apply, bool Real)
                     return;
 
                 // Search Mana Tap auras on caster
-                int32 energy = 0;
-                Unit::AuraList const& m_dummyAuras = caster->GetAurasByType(SPELL_AURA_DUMMY);
-                for(Unit::AuraList::const_iterator i = m_dummyAuras.begin(); i != m_dummyAuras.end(); ++i)
-                    if ((*i)->GetId() == 28734)
-                        ++energy;
-                if (energy)
+                Aura * dummy = caster->GetDummyAura(28734);
+                if (dummy)
                 {
-                    energy *= 10;
-                    caster->CastCustomSpell(caster, 25048, &energy, NULL, NULL, true);
+                    int32 bp = dummy->m_stackAmount * 10;
+                    caster->CastCustomSpell(caster, 25048, &bp, NULL, NULL, true);
                     caster->RemoveAurasDueToSpell(28734);
                 }
             }
@@ -3547,7 +3560,7 @@ void Aura::HandleModThreat(bool apply, bool Real)
         if(m_modifier.m_miscvalue & int32(1<<x))
         {
             if(m_target->GetTypeId() == TYPEID_PLAYER)
-                ApplyPercentModFloatVar(m_target->m_threatModifier[x], m_positive ? m_modifier.m_amount : -m_modifier.m_amount, apply);
+                ApplyPercentModFloatVar(m_target->m_threatModifier[x], m_positive ? m_modifier.m_amount * m_stackAmount : -m_modifier.m_amount * m_stackAmount, apply);
         }
     }
 }
@@ -3568,9 +3581,9 @@ void Aura::HandleAuraModTotalThreat(bool apply, bool Real)
 
     float threatMod = 0.0f;
     if(apply)
-        threatMod = float(m_modifier.m_amount);
+        threatMod = float(m_modifier.m_amount * m_stackAmount);
     else
-        threatMod =  float(-m_modifier.m_amount);
+        threatMod =  float(-m_modifier.m_amount * m_stackAmount);
 
     m_target->getHostilRefManager().threatAssist(caster, threatMod);
 }
@@ -3630,9 +3643,15 @@ void Aura::HandleAuraModIncreaseFlightSpeed(bool apply, bool Real)
     {
         WorldPacket data;
         if(apply)
+        {
             data.Initialize(SMSG_MOVE_SET_CAN_FLY, 12);
+            ((Player*)m_target)->SetCanFly(true);
+        }
         else
+        {
             data.Initialize(SMSG_MOVE_UNSET_CAN_FLY, 12);
+            ((Player*)m_target)->SetCanFly(false);
+        }
         data.append(m_target->GetPackGUID());
         data << uint32(0);                                      // unknown
         m_target->SendMessageToSet(&data, true);
@@ -3809,6 +3828,8 @@ void Aura::HandleAuraModEffectImmunity(bool apply, bool Real)
                     }
                 }
             }
+            else
+                sOutdoorPvPMgr.HandleDropFlag((Player*)m_target,GetSpellProto()->Id);
         }
     }
 
@@ -3837,6 +3858,9 @@ void Aura::HandleAuraModStateImmunity(bool apply, bool Real)
 
 void Aura::HandleAuraModSchoolImmunity(bool apply, bool Real)
 {
+     if(apply && m_modifier.m_miscvalue == SPELL_SCHOOL_MASK_NORMAL)
+          m_target->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_LOST_SELECTION);
+
     m_target->ApplySpellImmune(GetId(),IMMUNITY_SCHOOL,m_modifier.m_miscvalue,apply);
 
     if(Real && apply && GetSpellProto()->AttributesEx & SPELL_ATTR_EX_DISPEL_AURAS_ON_IMMUNITY)
@@ -4008,6 +4032,40 @@ void Aura::HandlePeriodicDamage(bool apply, bool Real)
 
     Unit *caster = GetCaster();
 
+    // Blood Frenzy, remove when no longer bleeding
+    if (Real && !apply && m_spellProto->SpellFamilyName==SPELLFAMILY_WARRIOR && (m_spellProto->SpellFamilyFlags & 0x1000000020LL) )
+    {
+         // search for another rend or deep wounds
+         bool found = false;
+         Unit::AuraList const& auras = m_target->GetAurasByType(SPELL_AURA_PERIODIC_DAMAGE);
+         for(Unit::AuraList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+         {
+              SpellEntry const* itr_spell = (*itr)->GetSpellProto();
+              if(itr_spell && itr_spell->SpellFamilyName==SPELLFAMILY_WARRIOR && (itr_spell->SpellFamilyFlags & 0x1000000020LL) )
+              {
+                   found = true;
+                   break;
+              }
+         }
+         if(!found)
+         {
+              Unit::AuraList const& auras = m_target->GetAurasByType(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN);
+              for(Unit::AuraList::const_iterator itr = auras.begin(); itr != auras.end();)
+              {
+                   SpellEntry const* itr_spell = (*itr)->GetSpellProto();
+                   if(itr_spell && itr_spell->SpellIconID == 2005 )
+                   {
+                        m_target->RemoveAurasDueToSpell(itr_spell->Id);
+                        itr = auras.begin();
+                   }
+                   else
+                   {
+                       itr++;
+                   }
+              }
+         }
+    }
+
     switch (m_spellProto->SpellFamilyName)
     {
         case SPELLFAMILY_GENERIC:
@@ -4132,6 +4190,7 @@ void Aura::HandlePeriodicDamage(bool apply, bool Real)
                     m_modifier.m_amount += int32(caster->GetTotalAttackPowerValue(BASE_ATTACK) * 3 / 100);
                 return;
             }
+            
             break;
         }
         case SPELLFAMILY_HUNTER:
@@ -4183,6 +4242,10 @@ void Aura::HandlePeriodicDamage(bool apply, bool Real)
             break;
         }
         default:
+           // Parasitic Shadowfiend - handle summoning of two Shadowfiends on DoT expire
+           if((m_spellProto->Id == 41917) && !apply && Real)
+                 m_target->CastSpell(m_target, 41915, true);
+            
             break;
     }
 }
@@ -4225,9 +4288,9 @@ void Aura::HandleAuraModResistanceExclusive(bool apply, bool Real)
     {
         if(m_modifier.m_miscvalue & int32(1<<x))
         {
-            m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + x), BASE_VALUE, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + x), BASE_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
             if(m_target->GetTypeId() == TYPEID_PLAYER)
-                m_target->ApplyResistanceBuffModsMod(SpellSchools(x),m_positive,m_modifier.m_amount, apply);
+                m_target->ApplyResistanceBuffModsMod(SpellSchools(x),m_positive,m_modifier.m_amount * m_stackAmount, apply);
         }
     }
 }
@@ -4238,9 +4301,9 @@ void Aura::HandleAuraModResistance(bool apply, bool Real)
     {
         if(m_modifier.m_miscvalue & int32(1<<x))
         {
-            m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + x), TOTAL_VALUE, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + x), TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
             if(m_target->GetTypeId() == TYPEID_PLAYER || ((Creature*)m_target)->isPet())
-                m_target->ApplyResistanceBuffModsMod(SpellSchools(x),m_positive,m_modifier.m_amount, apply);
+                m_target->ApplyResistanceBuffModsMod(SpellSchools(x),m_positive,m_modifier.m_amount * m_stackAmount, apply);
         }
     }
 
@@ -4260,14 +4323,14 @@ void Aura::HandleAuraModBaseResistancePCT(bool apply, bool Real)
     {
         //pets only have base armor
         if(((Creature*)m_target)->isPet() && (m_modifier.m_miscvalue & SPELL_SCHOOL_MASK_NORMAL))
-            m_target->HandleStatModifier(UNIT_MOD_ARMOR, BASE_PCT, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_ARMOR, BASE_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
     }
     else
     {
         for(int8 x = SPELL_SCHOOL_NORMAL; x < MAX_SPELL_SCHOOL;x++)
         {
             if(m_modifier.m_miscvalue & int32(1<<x))
-                m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + x), BASE_PCT, float(m_modifier.m_amount), apply);
+                m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + x), BASE_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
         }
     }
 }
@@ -4278,11 +4341,11 @@ void Aura::HandleModResistancePercent(bool apply, bool Real)
     {
         if(m_modifier.m_miscvalue & int32(1<<i))
         {
-            m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + i), TOTAL_PCT, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + i), TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
             if(m_target->GetTypeId() == TYPEID_PLAYER || ((Creature*)m_target)->isPet())
             {
-                m_target->ApplyResistanceBuffModsPercentMod(SpellSchools(i),true,m_modifier.m_amount, apply);
-                m_target->ApplyResistanceBuffModsPercentMod(SpellSchools(i),false,m_modifier.m_amount, apply);
+                m_target->ApplyResistanceBuffModsPercentMod(SpellSchools(i),true,m_modifier.m_amount * m_stackAmount, apply);
+                m_target->ApplyResistanceBuffModsPercentMod(SpellSchools(i),false,m_modifier.m_amount * m_stackAmount, apply);
             }
         }
     }
@@ -4295,13 +4358,13 @@ void Aura::HandleModBaseResistance(bool apply, bool Real)
     {
         //only pets have base stats
         if(((Creature*)m_target)->isPet() && (m_modifier.m_miscvalue & SPELL_SCHOOL_MASK_NORMAL))
-            m_target->HandleStatModifier(UNIT_MOD_ARMOR, TOTAL_VALUE, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_ARMOR, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
     }
     else
     {
         for(int i = SPELL_SCHOOL_NORMAL; i < MAX_SPELL_SCHOOL; i++)
             if(m_modifier.m_miscvalue & (1<<i))
-                m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + i), TOTAL_VALUE, float(m_modifier.m_amount), apply);
+                m_target->HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + i), TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
     }
 }
 
@@ -4323,9 +4386,9 @@ void Aura::HandleAuraModStat(bool apply, bool Real)
         if (m_modifier.m_miscvalue < 0 || m_modifier.m_miscvalue == i)
         {
             //m_target->ApplyStatMod(Stats(i), m_modifier.m_amount,apply);
-            m_target->HandleStatModifier(UnitMods(UNIT_MOD_STAT_START + i), TOTAL_VALUE, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UnitMods(UNIT_MOD_STAT_START + i), TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
             if(m_target->GetTypeId() == TYPEID_PLAYER || ((Creature*)m_target)->isPet())
-                m_target->ApplyStatBuffMod(Stats(i),m_modifier.m_amount,apply);
+                m_target->ApplyStatBuffMod(Stats(i),m_modifier.m_amount * m_stackAmount,apply);
         }
     }
 }
@@ -4345,7 +4408,7 @@ void Aura::HandleModPercentStat(bool apply, bool Real)
     for (int32 i = STAT_STRENGTH; i < MAX_STATS; ++i)
     {
         if(m_modifier.m_miscvalue == i || m_modifier.m_miscvalue == -1)
-            m_target->HandleStatModifier(UnitMods(UNIT_MOD_STAT_START + i), BASE_PCT, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UnitMods(UNIT_MOD_STAT_START + i), BASE_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
     }
 }
 
@@ -4423,9 +4486,9 @@ void Aura::HandleModTotalPercentStat(bool apply, bool Real)
     {
         if(m_modifier.m_miscvalue == i || m_modifier.m_miscvalue == -1)
         {
-            m_target->HandleStatModifier(UnitMods(UNIT_MOD_STAT_START + i), TOTAL_PCT, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UnitMods(UNIT_MOD_STAT_START + i), TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
             if(m_target->GetTypeId() == TYPEID_PLAYER || ((Creature*)m_target)->isPet())
-                m_target->ApplyStatPercentBuffMod(Stats(i), m_modifier.m_amount, apply );
+                m_target->ApplyStatPercentBuffMod(Stats(i), m_modifier.m_amount * m_stackAmount, apply );
         }
     }
 
@@ -4523,7 +4586,7 @@ void Aura::HandleModRegen(bool apply, bool Real)            // eating
         if(m_periodicTimer <= 0)
         {
             m_periodicTimer += 5000;
-            int32 gain = m_target->ModifyHealth(m_modifier.m_amount);
+            int32 gain = m_target->ModifyHealth(m_modifier.m_amount * m_stackAmount);
             Unit *caster = GetCaster();
             if (caster)
             {
@@ -4539,6 +4602,18 @@ void Aura::HandleModRegen(bool apply, bool Real)            // eating
 
 void Aura::HandleModPowerRegen(bool apply, bool Real)       // drinking
 {
+    // remove old auras from drinking
+    if (apply && (GetSpellProto()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED))
+    {
+        Unit::AuraList const& m_ModPowerRegen = m_target->GetAurasByType(SPELL_AURA_MOD_POWER_REGEN);
+        for(Unit::AuraList::const_iterator i = m_ModPowerRegen.begin(); i != m_ModPowerRegen.end(); ++i)
+            if ( ((*i)->GetSpellProto()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED) && GetSpellProto() != (*i)->GetSpellProto() )
+            {
+                m_target->RemoveAurasDueToSpell( (*i)->GetSpellProto()->Id );
+                break;
+            }
+    }
+
     if ((GetSpellProto()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED) && apply && !m_target->IsSitState())
         m_target->SetStandState(PLAYER_STATE_SIT);
 
@@ -4639,7 +4714,7 @@ void Aura::HandleAuraModIncreaseHealth(bool apply, bool Real)
     }
 
     // generic case
-    m_target->HandleStatModifier(UNIT_MOD_HEALTH, TOTAL_VALUE, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_HEALTH, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void  Aura::HandleAuraModIncreaseMaxHealth(bool apply, bool Real)
@@ -4647,7 +4722,7 @@ void  Aura::HandleAuraModIncreaseMaxHealth(bool apply, bool Real)
     uint32 oldhealth = m_target->GetHealth();
     double healthPercentage = (double)oldhealth / (double)m_target->GetMaxHealth();
 
-    m_target->HandleStatModifier(UNIT_MOD_HEALTH, TOTAL_VALUE, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_HEALTH, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
 
     // refresh percentage
     if(oldhealth > 0)
@@ -4666,7 +4741,7 @@ void Aura::HandleAuraModIncreaseEnergy(bool apply, bool Real)
     if(int32(powerType) != m_modifier.m_miscvalue)
         return;
 
-    m_target->HandleStatModifier(UnitMods(UNIT_MOD_POWER_START + powerType), TOTAL_VALUE, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UnitMods(UNIT_MOD_POWER_START + powerType), TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void Aura::HandleAuraModIncreaseEnergyPercent(bool apply, bool Real)
@@ -4675,13 +4750,13 @@ void Aura::HandleAuraModIncreaseEnergyPercent(bool apply, bool Real)
     if(int32(powerType) != m_modifier.m_miscvalue)
         return;
 
-    m_target->HandleStatModifier(UnitMods(UNIT_MOD_POWER_START + powerType), TOTAL_PCT, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UnitMods(UNIT_MOD_POWER_START + powerType), TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void Aura::HandleAuraModIncreaseHealthPercent(bool apply, bool Real)
 {
     //m_target->ApplyMaxHealthPercentMod(m_modifier.m_amount,apply);
-    m_target->HandleStatModifier(UNIT_MOD_HEALTH, TOTAL_PCT, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_HEALTH, TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 /********************************/
@@ -4745,9 +4820,9 @@ void Aura::HandleAuraModCritPercent(bool apply, bool Real)
 
     if (GetSpellProto()->EquippedItemClass == -1)
     {
-        ((Player*)m_target)->HandleBaseModValue(CRIT_PERCENTAGE,         FLAT_MOD, float (m_modifier.m_amount), apply);
-        ((Player*)m_target)->HandleBaseModValue(OFFHAND_CRIT_PERCENTAGE, FLAT_MOD, float (m_modifier.m_amount), apply);
-        ((Player*)m_target)->HandleBaseModValue(RANGED_CRIT_PERCENTAGE,  FLAT_MOD, float (m_modifier.m_amount), apply);
+        ((Player*)m_target)->HandleBaseModValue(CRIT_PERCENTAGE,         FLAT_MOD, float (m_modifier.m_amount * m_stackAmount), apply);
+        ((Player*)m_target)->HandleBaseModValue(OFFHAND_CRIT_PERCENTAGE, FLAT_MOD, float (m_modifier.m_amount * m_stackAmount), apply);
+        ((Player*)m_target)->HandleBaseModValue(RANGED_CRIT_PERCENTAGE,  FLAT_MOD, float (m_modifier.m_amount * m_stackAmount), apply);
     }
     else
     {
@@ -4757,13 +4832,13 @@ void Aura::HandleAuraModCritPercent(bool apply, bool Real)
 
 void Aura::HandleModHitChance(bool apply, bool Real)
 {
-    m_target->m_modMeleeHitChance += apply ? m_modifier.m_amount : (-m_modifier.m_amount);
-    m_target->m_modRangedHitChance += apply ? m_modifier.m_amount : (-m_modifier.m_amount);
+    m_target->m_modMeleeHitChance += apply ? m_modifier.m_amount * m_stackAmount : (-m_modifier.m_amount * m_stackAmount);
+    m_target->m_modRangedHitChance += apply ? m_modifier.m_amount * m_stackAmount : (-m_modifier.m_amount * m_stackAmount);
 }
 
 void Aura::HandleModSpellHitChance(bool apply, bool Real)
 {
-    m_target->m_modSpellHitChance += apply ? m_modifier.m_amount: (-m_modifier.m_amount);
+    m_target->m_modSpellHitChance += apply ? m_modifier.m_amount * m_stackAmount: (-m_modifier.m_amount * m_stackAmount);
 }
 
 void Aura::HandleModSpellCritChance(bool apply, bool Real)
@@ -4778,7 +4853,7 @@ void Aura::HandleModSpellCritChance(bool apply, bool Real)
     }
     else
     {
-        m_target->m_baseSpellCritChance += apply ? m_modifier.m_amount:(-m_modifier.m_amount);
+        m_target->m_baseSpellCritChance += apply ? m_modifier.m_amount * m_stackAmount:(-m_modifier.m_amount * m_stackAmount);
     }
 }
 
@@ -4802,49 +4877,47 @@ void Aura::HandleModSpellCritChanceShool(bool apply, bool Real)
 
 void Aura::HandleModCastingSpeed(bool apply, bool Real)
 {
-    m_target->ApplyCastTimePercentMod(m_modifier.m_amount,apply);
+    m_target->ApplyCastTimePercentMod(m_modifier.m_amount * m_stackAmount,apply);
 }
 
 void Aura::HandleModMeleeRangedSpeedPct(bool apply, bool Real)
 {
-    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,m_modifier.m_amount,apply);
-    m_target->ApplyAttackTimePercentMod(OFF_ATTACK,m_modifier.m_amount,apply);
-    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK, m_modifier.m_amount, apply);
+    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,m_modifier.m_amount * m_stackAmount,apply);
+    m_target->ApplyAttackTimePercentMod(OFF_ATTACK,m_modifier.m_amount * m_stackAmount,apply);
+    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK, m_modifier.m_amount * m_stackAmount, apply);
 }
 
 void Aura::HandleModCombatSpeedPct(bool apply, bool Real)
 {
-    m_target->ApplyCastTimePercentMod(m_modifier.m_amount,apply);
-    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,m_modifier.m_amount,apply);
-    m_target->ApplyAttackTimePercentMod(OFF_ATTACK,m_modifier.m_amount,apply);
-    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK, m_modifier.m_amount, apply);
+    m_target->ApplyCastTimePercentMod(m_modifier.m_amount * m_stackAmount,apply);
+    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,m_modifier.m_amount * m_stackAmount,apply);
+    m_target->ApplyAttackTimePercentMod(OFF_ATTACK,m_modifier.m_amount * m_stackAmount,apply);
+    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK, m_modifier.m_amount * m_stackAmount, apply);
 }
 
 void Aura::HandleModAttackSpeed(bool apply, bool Real)
 {
-    if(!m_target->isAlive() )
-        return;
-
-    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,m_modifier.m_amount,apply);
+    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,m_modifier.m_amount * m_stackAmount,apply);
+    m_target->UpdateDamagePhysical(BASE_ATTACK);
 }
 
 void Aura::HandleHaste(bool apply, bool Real)
 {
-    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,  m_modifier.m_amount,apply);
-    m_target->ApplyAttackTimePercentMod(OFF_ATTACK,   m_modifier.m_amount,apply);
-    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK,m_modifier.m_amount,apply);
+    m_target->ApplyAttackTimePercentMod(BASE_ATTACK,  m_modifier.m_amount * m_stackAmount,apply);
+    m_target->ApplyAttackTimePercentMod(OFF_ATTACK,   m_modifier.m_amount * m_stackAmount,apply);
+    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK,m_modifier.m_amount * m_stackAmount,apply);
 }
 
 void Aura::HandleAuraModRangedHaste(bool apply, bool Real)
 {
-    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK, m_modifier.m_amount, apply);
+    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK, m_modifier.m_amount * m_stackAmount, apply);
 }
 
 void Aura::HandleRangedAmmoHaste(bool apply, bool Real)
 {
     if(m_target->GetTypeId() != TYPEID_PLAYER)
         return;
-    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK,m_modifier.m_amount, apply);
+    m_target->ApplyAttackTimePercentMod(RANGED_ATTACK,m_modifier.m_amount * m_stackAmount, apply);
 }
 
 /********************************/
@@ -4853,7 +4926,7 @@ void Aura::HandleRangedAmmoHaste(bool apply, bool Real)
 
 void Aura::HandleAuraModAttackPower(bool apply, bool Real)
 {
-    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void Aura::HandleAuraModRangedAttackPower(bool apply, bool Real)
@@ -4861,7 +4934,7 @@ void Aura::HandleAuraModRangedAttackPower(bool apply, bool Real)
     if((m_target->getClassMask() & CLASSMASK_WAND_USERS)!=0)
         return;
 
-    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void Aura::HandleAuraAttackPowerAttacker(bool apply, bool Real)
@@ -4900,7 +4973,7 @@ void Aura::HandleAuraAttackPowerAttacker(bool apply, bool Real)
 void Aura::HandleAuraModAttackPowerPercent(bool apply, bool Real)
 {
     //UNIT_FIELD_ATTACK_POWER_MULTIPLIER = multiplier - 1
-    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_PCT, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void Aura::HandleAuraModRangedAttackPowerPercent(bool apply, bool Real)
@@ -4909,7 +4982,7 @@ void Aura::HandleAuraModRangedAttackPowerPercent(bool apply, bool Real)
         return;
 
     //UNIT_FIELD_RANGED_ATTACK_POWER_MULTIPLIER = multiplier - 1
-    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_PCT, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void Aura::HandleAuraModRangedAttackPowerOfStatPercent(bool apply, bool Real)
@@ -4959,9 +5032,9 @@ void Aura::HandleModDamageDone(bool apply, bool Real)
         // apply generic physical damage bonuses including wand case
         if (GetSpellProto()->EquippedItemClass == -1 || m_target->GetTypeId() != TYPEID_PLAYER)
         {
-            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_VALUE, float(m_modifier.m_amount), apply);
-            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_VALUE, float(m_modifier.m_amount), apply);
-            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_RANGED, TOTAL_VALUE, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_RANGED, TOTAL_VALUE, float(m_modifier.m_amount * m_stackAmount), apply);
         }
         else
         {
@@ -4971,9 +5044,9 @@ void Aura::HandleModDamageDone(bool apply, bool Real)
         if(m_target->GetTypeId() == TYPEID_PLAYER)
         {
             if(m_positive)
-                m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS,m_modifier.m_amount,apply);
+                m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS,m_modifier.m_amount * m_stackAmount,apply);
             else
-                m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_NEG,m_modifier.m_amount,apply);
+                m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_NEG,m_modifier.m_amount * m_stackAmount,apply);
         }
     }
 
@@ -4999,7 +5072,7 @@ void Aura::HandleModDamageDone(bool apply, bool Real)
             for(int i = SPELL_SCHOOL_HOLY; i < MAX_SPELL_SCHOOL; i++)
             {
                 if((m_modifier.m_miscvalue & (1<<i)) != 0)
-                    m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS+i,m_modifier.m_amount,apply);
+                    m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS+i,m_modifier.m_amount * m_stackAmount,apply);
             }
         }
         else
@@ -5007,7 +5080,7 @@ void Aura::HandleModDamageDone(bool apply, bool Real)
             for(int i = SPELL_SCHOOL_HOLY; i < MAX_SPELL_SCHOOL; i++)
             {
                 if((m_modifier.m_miscvalue & (1<<i)) != 0)
-                    m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_NEG+i,m_modifier.m_amount,apply);
+                    m_target->ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_NEG+i,m_modifier.m_amount * m_stackAmount,apply);
             }
         }
         Pet* pet = m_target->GetPet();
@@ -5042,9 +5115,9 @@ void Aura::HandleModDamagePercentDone(bool apply, bool Real)
         // apply generic physical damage bonuses including wand case
         if (GetSpellProto()->EquippedItemClass == -1 || m_target->GetTypeId() != TYPEID_PLAYER)
         {
-            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT, float(m_modifier.m_amount), apply);
-            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT, float(m_modifier.m_amount), apply);
-            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT, float(m_modifier.m_amount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
+            m_target->HandleStatModifier(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
         }
         else
         {
@@ -5083,7 +5156,7 @@ void Aura::HandleModOffhandDamagePercent(bool apply, bool Real)
 
     sLog.outDebug("AURA MOD OFFHAND DAMAGE");
 
-    m_target->HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT, float(m_modifier.m_amount), apply);
+    m_target->HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 /********************************/
@@ -5096,7 +5169,7 @@ void Aura::HandleModPowerCostPCT(bool apply, bool Real)
     if(!Real)
         return;
 
-    float amount = m_modifier.m_amount/100.0f;
+    float amount = m_modifier.m_amount * m_stackAmount /100.0f;
     for(int i = 0; i < MAX_SPELL_SCHOOL; ++i)
         if(m_modifier.m_miscvalue & (1<<i))
             m_target->ApplyModSignedFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER+i,amount,apply);
@@ -5110,7 +5183,7 @@ void Aura::HandleModPowerCost(bool apply, bool Real)
 
     for(int i = 0; i < MAX_SPELL_SCHOOL; ++i)
         if(m_modifier.m_miscvalue & (1<<i))
-            m_target->ApplyModInt32Value(UNIT_FIELD_POWER_COST_MODIFIER+i,m_modifier.m_amount,apply);
+            m_target->ApplyModInt32Value(UNIT_FIELD_POWER_COST_MODIFIER+i,m_modifier.m_amount * m_stackAmount,apply);
 }
 
 /*********************************************************/
@@ -5312,9 +5385,15 @@ void Aura::HandleAuraAllowFlight(bool apply, bool Real)
     // allow fly
     WorldPacket data;
     if(apply)
+    {
         data.Initialize(SMSG_MOVE_SET_CAN_FLY, 12);
+        ((Player*)m_target)->SetCanFly(true);
+    }
     else
+    {
         data.Initialize(SMSG_MOVE_UNSET_CAN_FLY, 12);
+        ((Player*)m_target)->SetCanFly(false);
+    }
     data.append(m_target->GetPackGUID());
     data << uint32(0);                                      // unk
     m_target->SendMessageToSet(&data, true);
@@ -5331,7 +5410,7 @@ void Aura::HandleModRating(bool apply, bool Real)
 
     for (uint32 rating = 0; rating < MAX_COMBAT_RATING; ++rating)
         if (m_modifier.m_miscvalue & (1 << rating))
-            ((Player*)m_target)->ApplyRatingMod(CombatRating(rating), m_modifier.m_amount, apply);
+            ((Player*)m_target)->ApplyRatingMod(CombatRating(rating), m_modifier.m_amount * m_stackAmount, apply);
 }
 
 void Aura::HandleForceMoveForward(bool apply, bool Real)
@@ -5362,11 +5441,11 @@ void Aura::HandleModTargetResistance(bool apply, bool Real)
 
     // show armor penetration
     if (m_target->GetTypeId() == TYPEID_PLAYER && (m_modifier.m_miscvalue & SPELL_SCHOOL_MASK_NORMAL))
-        m_target->ApplyModInt32Value(PLAYER_FIELD_MOD_TARGET_PHYSICAL_RESISTANCE,m_modifier.m_amount, apply);
+        m_target->ApplyModInt32Value(PLAYER_FIELD_MOD_TARGET_PHYSICAL_RESISTANCE,m_modifier.m_amount * m_stackAmount, apply);
 
     // show as spell penetration only full spell penetration bonuses (all resistances except armor and holy
     if (m_target->GetTypeId() == TYPEID_PLAYER && (m_modifier.m_miscvalue & SPELL_SCHOOL_MASK_SPELL)==SPELL_SCHOOL_MASK_SPELL)
-        m_target->ApplyModInt32Value(PLAYER_FIELD_MOD_TARGET_RESISTANCE,m_modifier.m_amount, apply);
+        m_target->ApplyModInt32Value(PLAYER_FIELD_MOD_TARGET_RESISTANCE,m_modifier.m_amount * m_stackAmount, apply);
 }
 
 //HandleNoImmediateEffect auras implementation to support new stat system
@@ -5387,7 +5466,7 @@ void Aura::HandleShieldBlockValue(bool apply, bool Real)
         modType = PCT_MOD;
 
     if(m_target->GetTypeId() == TYPEID_PLAYER)
-        ((Player*)m_target)->HandleBaseModValue(SHIELD_BLOCK_VALUE, modType, float(m_modifier.m_amount), apply);
+        ((Player*)m_target)->HandleBaseModValue(SHIELD_BLOCK_VALUE, modType, float(m_modifier.m_amount * m_stackAmount), apply);
 }
 
 void Aura::HandleAuraRetainComboPoints(bool apply, bool Real)
@@ -5405,14 +5484,16 @@ void Aura::HandleAuraRetainComboPoints(bool apply, bool Real)
     // remove only if aura expire by time (in case combo points amount change aura removed without combo points lost)
     if( !apply && m_duration==0 && target->GetComboTarget())
         if(Unit* unit = ObjectAccessor::GetUnit(*m_target,target->GetComboTarget()))
-            target->AddComboPoints(unit, -m_modifier.m_amount);
+            target->AddComboPoints(unit, -m_modifier.m_amount * m_stackAmount);
 }
 
 void Aura::HandleModUnattackable( bool Apply, bool Real )
 {
     if(Real && Apply)
+     {
         m_target->CombatStop();
-
+        m_target->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_LOST_SELECTION);
+     }
     m_target->ApplyModFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE,Apply);
 }
 
@@ -5569,6 +5650,21 @@ void Aura::PeriodicTick()
                         }
                         break;
                     }
+                    case 41337:// aura of anger
+                    {                        
+                        Unit::AuraList const& mMod = m_target->GetAurasByType(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE);
+                        for(Unit::AuraList::const_iterator i = mMod.begin(); i != mMod.end(); ++i)
+                        {
+                            if ((*i)->GetId() == 41337)
+                            {
+                                (*i)->ApplyModifier(false);
+                                (*i)->GetModifier()->m_amount += 5;
+                                (*i)->ApplyModifier(true);
+                                break;
+                            }
+                        }                        
+                        m_modifier.m_amount += 100;
+                    }break;
                     default:
                         break;
                 }
@@ -5614,6 +5710,8 @@ void Aura::PeriodicTick()
             else
                 pdamage = uint32(m_target->GetMaxHealth()*amount/100);
 
+            pdamage *= m_stackAmount;
+
             //As of 2.2 resilience reduces damage from DoT ticks as much as the chance to not be critically hit
             // Reduce dot damage from resilience for players
             if (m_target->GetTypeId()==TYPEID_PLAYER)
@@ -5639,11 +5737,15 @@ void Aura::PeriodicTick()
             Unit* target = m_target;                        // aura can be deleted in DealDamage
             SpellEntry const* spellProto = GetSpellProto();
 
-            pCaster->DealDamage(m_target, (pdamage <= absorb+resist) ? 0 : (pdamage-absorb-resist), &cleanDamage, DOT, GetSpellSchoolMask(GetSpellProto()), GetSpellProto(), true);
-
-            // DO NOT ACCESS MEMBERS OF THE AURA FROM NOW ON (DealDamage can delete aura)
-
-            pCaster->ProcDamageAndSpell(target, PROC_FLAG_HIT_SPELL, PROC_FLAG_TAKE_DAMAGE, (pdamage <= absorb+resist) ? 0 : (pdamage-absorb-resist), GetSpellSchoolMask(spellProto), spellProto);
+            // Set trigger flag
+            uint32 procAttacker = PROC_FLAG_ON_DO_PERIODIC;//   | PROC_FLAG_SUCCESSFUL_HARMFUL_SPELL_HIT;
+            uint32 procVictim   = PROC_FLAG_ON_TAKE_PERIODIC;// | PROC_FLAG_TAKEN_HARMFUL_SPELL_HIT;
+            pdamage = (pdamage <= absorb+resist) ? 0 : (pdamage-absorb-resist);
+            if (pdamage)
+                procVictim|=PROC_FLAG_TAKEN_ANY_DAMAGE;
+            pCaster->ProcDamageAndSpell(target, procAttacker, procVictim, PROC_EX_NORMAL_HIT, pdamage, BASE_ATTACK, spellProto);
+            
+            pCaster->DealDamage(target, pdamage, &cleanDamage, DOT, GetSpellSchoolMask(spellProto), spellProto, true);
             break;
         }
         case SPELL_AURA_PERIODIC_LEECH:
@@ -5732,6 +5834,8 @@ void Aura::PeriodicTick()
                 }
             }
 
+            pdamage *= m_stackAmount;
+
             //As of 2.2 resilience reduces damage from DoT ticks as much as the chance to not be critically hit
             // Reduce dot damage from resilience for players
             if (m_target->GetTypeId()==TYPEID_PLAYER)
@@ -5752,11 +5856,15 @@ void Aura::PeriodicTick()
             SpellEntry const* spellProto = GetSpellProto();
             float multiplier = spellProto->EffectMultipleValue[GetEffIndex()] > 0 ? spellProto->EffectMultipleValue[GetEffIndex()] : 1;
 
-            uint32 new_damage = pCaster->DealDamage(m_target, (pdamage <= absorb+resist) ? 0 : (pdamage-absorb-resist), &cleanDamage, DOT, GetSpellSchoolMask(GetSpellProto()), GetSpellProto(), false);
+            // Set trigger flag
+            uint32 procAttacker = PROC_FLAG_ON_DO_PERIODIC;//   | PROC_FLAG_SUCCESSFUL_HARMFUL_SPELL_HIT;
+            uint32 procVictim   = PROC_FLAG_ON_TAKE_PERIODIC;// | PROC_FLAG_TAKEN_HARMFUL_SPELL_HIT;
+            pdamage = (pdamage <= absorb+resist) ? 0 : (pdamage-absorb-resist);
+            if (pdamage)
+                procVictim|=PROC_FLAG_TAKEN_ANY_DAMAGE;
+            pCaster->ProcDamageAndSpell(target, procAttacker, procVictim, PROC_EX_NORMAL_HIT, pdamage, BASE_ATTACK, spellProto);
+            int32 new_damage = pCaster->DealDamage(target, pdamage, &cleanDamage, DOT, GetSpellSchoolMask(spellProto), spellProto, false);
 
-            // DO NOT ACCESS MEMBERS OF THE AURA FROM NOW ON (DealDamage can delete aura)
-
-            pCaster->ProcDamageAndSpell(target, PROC_FLAG_HIT_SPELL, PROC_FLAG_TAKE_DAMAGE, new_damage, GetSpellSchoolMask(spellProto), spellProto);
             if (!target->isAlive() && pCaster->IsNonMeleeSpellCasted(false))
             {
                 for (uint32 i = CURRENT_FIRST_NON_MELEE_SPELL; i < CURRENT_MAX_SPELL; i++)
@@ -5801,6 +5909,8 @@ void Aura::PeriodicTick()
 
             pdamage = pCaster->SpellHealingBonus(GetSpellProto(), pdamage, DOT, m_target);
 
+            pdamage *= m_stackAmount;
+
             sLog.outDetail("PeriodicTick: %u (TypeId: %u) heal of %u (TypeId: %u) for %u health inflicted by %u",
                 GUID_LOPART(GetCasterGUID()), GuidHigh2TypeId(GUID_HIPART(GetCasterGUID())), m_target->GetGUIDLow(), m_target->GetTypeId(), pdamage, GetId());
 
@@ -5857,9 +5967,11 @@ void Aura::PeriodicTick()
                 }
             }
 
+            uint32 procAttacker = PROC_FLAG_ON_DO_PERIODIC;//   | PROC_FLAG_SUCCESSFUL_HEAL;
+            uint32 procVictim   = 0;//ROC_FLAG_ON_TAKE_PERIODIC | PROC_FLAG_TAKEN_HEAL;
             // ignore item heals
-            if(procSpell && !haveCastItem)
-                pCaster->ProcDamageAndSpell(target,PROC_FLAG_HEAL, PROC_FLAG_HEALED, pdamage, SPELL_SCHOOL_MASK_NONE, spellProto);
+//            if(procSpell && !haveCastItem)
+//                pCaster->ProcDamageAndSpell(target, procAttacker, procVictim, PROC_EX_NORMAL_HIT, pdamage, BASE_ATTACK, spellProto);
             break;
         }
         case SPELL_AURA_PERIODIC_MANA_LEECH:
@@ -5882,6 +5994,8 @@ void Aura::PeriodicTick()
             // ignore non positive values (can be result apply spellmods to aura damage
             uint32 pdamage = m_modifier.m_amount > 0 ? m_modifier.m_amount : 0;
 
+            pdamage *= m_stackAmount;
+
             sLog.outDetail("PeriodicTick: %u (TypeId: %u) power leech of %u (TypeId: %u) for %u dmg inflicted by %u",
                 GUID_LOPART(GetCasterGUID()), GuidHigh2TypeId(GUID_HIPART(GetCasterGUID())), m_target->GetGUIDLow(), m_target->GetTypeId(), pdamage, GetId());
 
@@ -5894,6 +6008,12 @@ void Aura::PeriodicTick()
             if(m_target->getPowerType() != power)
                 break;
 
+            // mark of  kaz'rogal part 1/2
+            bool explode = false;
+            if(GetSpellProto()->Id == 31447)
+                if(pdamage>m_target->GetPower(POWER_MANA))
+                    explode = true;
+
             int32 drain_amount = m_target->GetPower(power) > pdamage ? pdamage : m_target->GetPower(power);
 
             // resilience reduce mana draining effect at spell crit damage reduction (added in 2.4)
@@ -5902,6 +6022,10 @@ void Aura::PeriodicTick()
 
             m_target->ModifyPower(power, -drain_amount);
 
+            // mark of kaz'rogal part 2/2
+            if(explode)
+                pCaster->CastSpell(m_target,31463,true,0,this);
+
             float gain_multiplier = 0;
 
             if(pCaster->GetMaxPower(power) > 0)
@@ -5937,6 +6061,8 @@ void Aura::PeriodicTick()
             // ignore non positive values (can be result apply spellmods to aura damage
             uint32 pdamage = m_modifier.m_amount > 0 ? m_modifier.m_amount : 0;
 
+            pdamage *= m_stackAmount;
+
             sLog.outDetail("PeriodicTick: %u (TypeId: %u) energize %u (TypeId: %u) for %u dmg inflicted by %u",
                 GUID_LOPART(GetCasterGUID()), GuidHigh2TypeId(GUID_HIPART(GetCasterGUID())), m_target->GetGUIDLow(), m_target->GetTypeId(), pdamage, GetId());
 
@@ -5971,6 +6097,8 @@ void Aura::PeriodicTick()
 
             uint32 pdamage = uint32(m_target->GetMaxPower(POWER_MANA) * amount/100);
 
+            pdamage *= m_stackAmount;
+
             sLog.outDetail("PeriodicTick: %u (TypeId: %u) energize %u (TypeId: %u) for %u mana inflicted by %u",
                 GUID_LOPART(GetCasterGUID()), GuidHigh2TypeId(GUID_HIPART(GetCasterGUID())), m_target->GetGUIDLow(), m_target->GetTypeId(), pdamage, GetId());
 
@@ -6005,6 +6133,8 @@ void Aura::PeriodicTick()
 
             int32 pdamage = m_modifier.m_amount > 0 ? m_modifier.m_amount : 0;
 
+            pdamage *= m_stackAmount;
+
             Powers powerType = Powers(m_modifier.m_miscvalue);
 
             if(!m_target->isAlive() || m_target->getPowerType() != powerType)
@@ -6018,8 +6148,22 @@ void Aura::PeriodicTick()
 
             gain = uint32(gain * GetSpellProto()->EffectMultipleValue[GetEffIndex()]);
 
+            SpellEntry const* spellProto = GetSpellProto();
             //maybe has to be sent different to client, but not by SMSG_PERIODICAURALOG
-            pCaster->SpellNonMeleeDamageLog(m_target, GetId(), gain);
+            SpellNonMeleeDamage damageInfo(pCaster, m_target, spellProto->Id, spellProto->SchoolMask);
+            pCaster->CalculateSpellDamage(&damageInfo, gain, spellProto);
+            pCaster->SendSpellNonMeleeDamageLog(&damageInfo);
+
+            // Set trigger flag
+            uint32 procAttacker = PROC_FLAG_ON_DO_PERIODIC;//   | PROC_FLAG_SUCCESSFUL_HARMFUL_SPELL_HIT;
+            uint32 procVictim   = PROC_FLAG_ON_TAKE_PERIODIC;// | PROC_FLAG_TAKEN_HARMFUL_SPELL_HIT;
+            uint32 procEx       = createProcExtendMask(&damageInfo, SPELL_MISS_NONE);
+            if (damageInfo.damage)
+                procVictim|=PROC_FLAG_TAKEN_ANY_DAMAGE;
+
+            pCaster->ProcDamageAndSpell(damageInfo.target, procAttacker, procVictim, procEx, damageInfo.damage, BASE_ATTACK, spellProto);
+
+            pCaster->DealSpellDamage(&damageInfo, true);
             break;
         }
         // Here tick dummy auras
diff --git a/src/game/SpellAuras.h b/src/game/SpellAuras.h
index 295981a..5d897ef 100644
--- a/src/game/SpellAuras.h
+++ b/src/game/SpellAuras.h
@@ -231,6 +231,7 @@ class MANGOS_DLL_SPEC Aura
         time_t GetAuraApplyTime() { return m_applyTime; }
         void UpdateAuraDuration();
         void SendAuraDurationForCaster(Player* caster);
+        void UpdateSlotCounterAndDuration();
 
         uint64 const& GetCasterGUID() const { return m_caster_guid; }
         Unit* GetCaster() const;
@@ -284,6 +285,8 @@ class MANGOS_DLL_SPEC Aura
 
         int32 m_procCharges;
 
+        int32 m_stackAmount;
+
         virtual Unit* GetTriggerTarget() const { return m_target; }
 
         // add/remove SPELL_AURA_MOD_SHAPESHIFT (36) linked auras
@@ -331,7 +334,6 @@ class MANGOS_DLL_SPEC Aura
         uint32 m_PeriodicEventId;
         DiminishingGroup m_AuraDRGroup;
     private:
-        void UpdateSlotCounterAndDuration(bool add);
         void CleanupTriggeredSpells();
         void SetAura(uint32 slot, bool remove) { m_target->SetUInt32Value(UNIT_FIELD_AURA + slot, remove ? 0 : GetId()); }
         void SetAuraFlag(uint32 slot, bool add);
diff --git a/src/game/SpellEffects.cpp b/src/game/SpellEffects.cpp
index 614d6d2..1bb9886 100644
--- a/src/game/SpellEffects.cpp
+++ b/src/game/SpellEffects.cpp
@@ -48,6 +48,7 @@
 #include "BattleGround.h"
 #include "BattleGroundEY.h"
 #include "BattleGroundWS.h"
+#include "OutdoorPvPMgr.h"
 #include "VMapFactory.h"
 #include "Language.h"
 #include "SocialMgr.h"
@@ -335,6 +336,13 @@ void Spell::EffectSchoolDMG(uint32 effect_idx)
                             damage = 200;
                         break;
                     }
+                    // must only affect demons
+                    case 45072:
+                    {
+                        if(unitTarget->GetCreatureType() != CREATURE_TYPE_DEMON)
+                            return;
+                        break;
+                    }
                 }
                 break;
             }
@@ -541,61 +549,7 @@ void Spell::EffectSchoolDMG(uint32 effect_idx)
         }
 
         if(damage >= 0)
-        {
-            uint32 finalDamage;
-            if(m_originalCaster)                            // m_caster only passive source of cast
-                finalDamage = m_originalCaster->SpellNonMeleeDamageLog(unitTarget, m_spellInfo->Id, damage, m_IsTriggeredSpell, true);
-            else
-                finalDamage = m_caster->SpellNonMeleeDamageLog(unitTarget, m_spellInfo->Id, damage, m_IsTriggeredSpell, true);
-
-            // post effects
-            switch(m_spellInfo->SpellFamilyName)
-            {
-                case SPELLFAMILY_WARRIOR:
-                {
-                    // Bloodthirst
-                    if(m_spellInfo->SpellFamilyFlags & 0x40000000000LL)
-                    {
-                        uint32 BTAura = 0;
-                        switch(m_spellInfo->Id)
-                        {
-                            case 23881: BTAura = 23885; break;
-                            case 23892: BTAura = 23886; break;
-                            case 23893: BTAura = 23887; break;
-                            case 23894: BTAura = 23888; break;
-                            case 25251: BTAura = 25252; break;
-                            case 30335: BTAura = 30339; break;
-                            default:
-                                sLog.outError("Spell::EffectSchoolDMG: Spell %u not handled in BTAura",m_spellInfo->Id);
-                                break;
-                        }
-
-                        if (BTAura)
-                            m_caster->CastSpell(m_caster,BTAura,true);
-                    }
-                    break;
-                }
-                case SPELLFAMILY_PRIEST:
-                {
-                    // Shadow Word: Death
-                    if(finalDamage > 0 && (m_spellInfo->SpellFamilyFlags & 0x0000000200000000LL) && unitTarget->isAlive())
-                        // deals damage equal to damage done to caster if victim is not killed
-                        m_caster->SpellNonMeleeDamageLog( m_caster, m_spellInfo->Id, finalDamage, m_IsTriggeredSpell, false);
-
-                    break;
-                }
-                case SPELLFAMILY_PALADIN:
-                {
-                    // Judgement of Blood
-                    if(finalDamage > 0 && (m_spellInfo->SpellFamilyFlags & 0x0000000800000000LL) && m_spellInfo->SpellIconID==153)
-                    {
-                        int32 damagePoint  = finalDamage * 33 / 100;
-                        m_caster->CastCustomSpell(m_caster, 32220, &damagePoint, NULL, NULL, true);
-                    }
-                    break;
-                }
-            }
-        }
+            m_damage+= damage;
     }
 }
 
@@ -915,16 +869,12 @@ void Spell::EffectDummy(uint32 i)
                 }
                 case 28730:                                 // Arcane Torrent (Mana)
                 {
-                    int32 count = 0;
-                    Unit::AuraList const& m_dummyAuras = m_caster->GetAurasByType(SPELL_AURA_DUMMY);
-                    for(Unit::AuraList::const_iterator i = m_dummyAuras.begin(); i != m_dummyAuras.end(); ++i)
-                        if ((*i)->GetId() == 28734)
-                            ++count;
-                    if (count)
-                    {
-                        m_caster->RemoveAurasDueToSpell(28734);
-                        int32 bp = damage * count;
+                    Aura * dummy = m_caster->GetDummyAura(28734);
+                    if (dummy)
+                    {                        
+                        int32 bp = damage * dummy->m_stackAmount;
                         m_caster->CastCustomSpell(m_caster, 28733, &bp, NULL, NULL, true);
+                        m_caster->RemoveAurasDueToSpell(28734);
                     }
                     return;
                 }
@@ -1355,7 +1305,7 @@ void Spell::EffectDummy(uint32 i)
                 }
 
                 if(found)
-                    m_caster->SpellNonMeleeDamageLog(unitTarget, m_spellInfo->Id, damage, m_IsTriggeredSpell, true);
+                    m_damage+= damage;
                 return;
             }
             // Kill command
@@ -2307,7 +2257,7 @@ void Spell::EffectPowerBurn(uint32 i)
         modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_MULTIPLE_VALUE, multiplier);
 
     new_damage = int32(new_damage*multiplier);
-    m_caster->SpellNonMeleeDamageLog(unitTarget, m_spellInfo->Id, new_damage, m_IsTriggeredSpell, true);
+    m_damage+=new_damage;
 }
 
 void Spell::EffectHeal( uint32 /*i*/ )
@@ -2331,7 +2281,7 @@ void Spell::EffectHeal( uint32 /*i*/ )
             Unit::AuraList const& mDummyAuras = m_caster->GetAurasByType(SPELL_AURA_DUMMY);
             for(Unit::AuraList::const_iterator i = mDummyAuras.begin();i != mDummyAuras.end(); ++i)
                 if((*i)->GetId() == 45062)
-                    damageAmount+=(*i)->GetModifier()->m_amount;
+                    damageAmount+=(*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
             if (damageAmount)
                 m_caster->RemoveAurasDueToSpell(45062);
 
@@ -2375,27 +2325,7 @@ void Spell::EffectHeal( uint32 /*i*/ )
         else
             addhealth = caster->SpellHealingBonus(m_spellInfo, addhealth,HEAL, unitTarget);
 
-        bool crit = caster->isSpellCrit(unitTarget, m_spellInfo, m_spellSchoolMask, m_attackType);
-        if (crit)
-            addhealth = caster->SpellCriticalBonus(m_spellInfo, addhealth, unitTarget);
-        caster->SendHealSpellLog(unitTarget, m_spellInfo->Id, addhealth, crit);
-
-        int32 gain = unitTarget->ModifyHealth( int32(addhealth) );
-        unitTarget->getHostilRefManager().threatAssist(m_caster, float(gain) * 0.5f, m_spellInfo);
-
-        if(caster->GetTypeId()==TYPEID_PLAYER)
-            if(BattleGround *bg = ((Player*)caster)->GetBattleGround())
-                bg->UpdatePlayerScore(((Player*)caster), SCORE_HEALING_DONE, gain);
-
-        // ignore item heals
-        if(m_CastItem)
-            return;
-
-        uint32 procHealer = PROC_FLAG_HEAL;
-        if (crit)
-            procHealer |= PROC_FLAG_CRIT_HEAL;
-
-        m_caster->ProcDamageAndSpell(unitTarget,procHealer,PROC_FLAG_HEALED,addhealth,SPELL_SCHOOL_MASK_NONE,m_spellInfo,m_IsTriggeredSpell);
+        m_healing+=addhealth;
     }
 }
 
@@ -2472,6 +2402,8 @@ void Spell::EffectHealthLeech(uint32 i)
         if(m_caster->GetTypeId() == TYPEID_PLAYER)
             m_caster->SendHealSpellLog(m_caster, m_spellInfo->Id, uint32(new_damage));
     }
+//    m_healthLeech+=tmpvalue;
+//    m_damage+=new_damage;
 }
 
 void Spell::DoCreateItem(uint32 i, uint32 itemtype)
@@ -2597,7 +2529,7 @@ void Spell::DoCreateItem(uint32 i, uint32 itemtype)
                 return;
         }
 
-        if(BattleGround* bg = sBattleGroundMgr.GetBattleGround(bgType))
+        if(BattleGround* bg = sBattleGroundMgr.GetBattleGroundTemplate(bgType))
             bg->SendRewardMarkByMail(player,newitemid,no_space);
     }
 }
@@ -2844,7 +2776,7 @@ void Spell::EffectOpenLock(uint32 /*i*/)
             if(BattleGround *bg = player->GetBattleGround())
             {
                 // check if it's correct bg
-                if(bg && bg->GetTypeID() == BATTLEGROUND_AB)
+                if(bg->GetTypeID() == BATTLEGROUND_AB || bg->GetTypeID() == BATTLEGROUND_AV)
                     bg->EventPlayerClickedOnFlag(player, gameObjTarget);
                 return;
             }
@@ -2860,6 +2792,10 @@ void Spell::EffectOpenLock(uint32 /*i*/)
                 return;
             }
         }
+        // handle outdoor pvp object opening, return true if go was registered for handling
+        // these objects must have been spawned by outdoorpvp!
+        else if(gameObjTarget->GetGOInfo()->type == GAMEOBJECT_TYPE_GOOBER && sOutdoorPvPMgr.HandleOpenGo(player, gameObjTarget->GetGUID()))
+            return;
         lockId = gameObjTarget->GetLockId();
         guid = gameObjTarget->GetGUID();
     }
@@ -4329,35 +4265,9 @@ void Spell::EffectWeaponDmg(uint32 i)
     // prevent negative damage
     uint32 eff_damage = uint32(bonus > 0 ? bonus : 0);
 
-    const uint32 nohitMask = HITINFO_ABSORB | HITINFO_RESIST | HITINFO_MISS;
-
-    uint32 hitInfo = 0;
-    VictimState victimState = VICTIMSTATE_NORMAL;
-    uint32 blocked_dmg = 0;
-    uint32 absorbed_dmg = 0;
-    uint32 resisted_dmg = 0;
-    CleanDamage cleanDamage =  CleanDamage(0, BASE_ATTACK, MELEE_HIT_NORMAL );
-
-    m_caster->DoAttackDamage(unitTarget, &eff_damage, &cleanDamage, &blocked_dmg, m_spellSchoolMask, &hitInfo, &victimState, &absorbed_dmg, &resisted_dmg, m_attackType, m_spellInfo, m_IsTriggeredSpell);
-
-    if ((hitInfo & nohitMask) && m_attackType != RANGED_ATTACK)  // not send ranged miss/etc
-        m_caster->SendAttackStateUpdate(hitInfo & nohitMask, unitTarget, 1, m_spellSchoolMask, eff_damage, absorbed_dmg, resisted_dmg, VICTIMSTATE_NORMAL, blocked_dmg);
-
-    bool criticalhit = (hitInfo & HITINFO_CRITICALHIT);
-    m_caster->SendSpellNonMeleeDamageLog(unitTarget, m_spellInfo->Id, eff_damage, m_spellSchoolMask, absorbed_dmg, resisted_dmg, false, blocked_dmg, criticalhit);
-
-    if (eff_damage > (absorbed_dmg + resisted_dmg + blocked_dmg))
-    {
-        eff_damage -= (absorbed_dmg + resisted_dmg + blocked_dmg);
-    }
-    else
-    {
-        cleanDamage.damage += eff_damage;
-        eff_damage = 0;
-    }
-
-    // SPELL_SCHOOL_NORMAL use for weapon-like threat and rage calculation
-    m_caster->DealDamage(unitTarget, eff_damage, &cleanDamage, SPELL_DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, true);
+    // Add melee damage bonuses (also check for negative)
+    m_caster->MeleeDamageBonus(unitTarget, &eff_damage, m_attackType, m_spellInfo);
+    m_damage+= eff_damage;
 
     // Hemorrhage
     if(m_spellInfo->SpellFamilyName==SPELLFAMILY_ROGUE && (m_spellInfo->SpellFamilyFlags & 0x2000000))
@@ -4421,10 +4331,7 @@ void Spell::EffectHealMaxHealth(uint32 /*i*/)
 
     uint32 heal = m_caster->GetMaxHealth();
 
-    int32 gain = unitTarget->ModifyHealth(heal);
-    unitTarget->getHostilRefManager().threatAssist(m_caster, float(gain) * 0.5f, m_spellInfo);
-
-    m_caster->SendHealSpellLog(unitTarget, m_spellInfo->Id, heal);
+    m_healing+=heal;
 }
 
 void Spell::EffectInterruptCast(uint32 /*i*/)
@@ -5436,25 +5343,59 @@ void Spell::EffectMomentMove(uint32 i)
         uint32 mapid = m_caster->GetMapId();
         float dis = GetSpellRadius(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
 
-        // before caster
-        float fx,fy,fz;
-        unitTarget->GetClosePoint(fx,fy,fz,unitTarget->GetObjectSize(),dis);
-        float ox,oy,oz;
-        unitTarget->GetPosition(ox,oy,oz);
-
-        float fx2,fy2,fz2;                                  // getObjectHitPos overwrite last args in any result case
-        if(VMAP::VMapFactory::createOrGetVMapManager()->getObjectHitPos(mapid, ox,oy,oz+0.5, fx,fy,oz+0.5,fx2,fy2,fz2, -0.5))
-        {
-            fx = fx2;
-            fy = fy2;
-            fz = fz2;
-            unitTarget->UpdateGroundPositionZ(fx,fy,fz);
-        }
+            // Start Info //
+            float cx,cy,cz;
+            float dx,dy,dz;
+            float angle = unitTarget->GetOrientation();
+            unitTarget->GetPosition(cx,cy,cz);
+            
+            //Check use of vamps//
+            bool useVmap = false;
+            bool swapZone = true;
+            if( MapManager::Instance().GetMap(mapid, unitTarget)->GetHeight(cx, cy, cz, false) <  MapManager::Instance().GetMap(mapid, unitTarget)->GetHeight(cx, cy, cz, true) )
+                useVmap = true;
+            
+            //Going foward 0.5f until max distance
+            for(float i=0.5f; i<dis; i+=0.5f)
+            {
+                unitTarget->GetNearPoint2D(dx,dy,i,angle);
+                dz = MapManager::Instance().GetMap(mapid, unitTarget)->GetHeight(dx, dy, cz, useVmap);
+                
+                //Prevent climbing and go around object maybe 2.0f is to small? use 3.0f?
+                if( (dz-cz) < 2.0f && (dz-cz) > -2.0f && (unitTarget->IsWithinLOS(dx, dy, dz)))
+                {
+                    //No climb, the z differenze between this and prev step is ok. Store this destination for future use or check.
+                    cx = dx;
+                    cy = dy;
+                    cz = dz;
+                }
+                else
+                {
+                    //Something wrong with los or z differenze... maybe we are going from outer world inside a building or viceversa
+                    if(swapZone)
+                    {
+                        //so... change use of vamp and go back 1 step backward and recheck again.
+                        swapZone = false;
+                        useVmap = !useVmap;
+                        i-=0.5f;
+                    }
+                    else
+                    {
+                        //bad recheck result... so break this and use last good coord for teleport player...
+                        dz += 0.5f;
+                        break;
+                    }
+                }
+            }
+            
+            //Prevent Falling during swap building/outerspace
+            unitTarget->UpdateGroundPositionZ(cx, cy, cz);
+        
 
         if(unitTarget->GetTypeId() == TYPEID_PLAYER)
-            ((Player*)unitTarget)->TeleportTo(mapid, fx, fy, fz, unitTarget->GetOrientation(), TELE_TO_NOT_LEAVE_COMBAT | TELE_TO_NOT_UNSUMMON_PET | (unitTarget==m_caster ? TELE_TO_SPELL : 0));
+            ((Player*)unitTarget)->TeleportTo(mapid, cx, cy, cz, unitTarget->GetOrientation(), TELE_TO_NOT_LEAVE_COMBAT | TELE_TO_NOT_UNSUMMON_PET | (unitTarget==m_caster ? TELE_TO_SPELL : 0));
         else
-            MapManager::Instance().GetMap(mapid, unitTarget)->CreatureRelocation((Creature*)unitTarget, fx, fy, fz, unitTarget->GetOrientation());
+            MapManager::Instance().GetMap(mapid, unitTarget)->CreatureRelocation((Creature*)unitTarget, cx, cy, cz, unitTarget->GetOrientation());
     }
 }
 
diff --git a/src/game/SpellMgr.cpp b/src/game/SpellMgr.cpp
index ef84b1d..fe1207d 100644
--- a/src/game/SpellMgr.cpp
+++ b/src/game/SpellMgr.cpp
@@ -530,6 +530,17 @@ bool IsSingleTargetSpells(SpellEntry const *spellInfo1, SpellEntry const *spellI
     return false;
 }
 
+bool IsAuraAddedBySpell(uint32 auraType, uint32 spellId)
+{
+    SpellEntry const *spellproto = sSpellStore.LookupEntry(spellId);
+    if (!spellproto) return false;
+
+    for (int i = 0; i < 3; i++)
+        if (spellproto->EffectApplyAuraName[i] == auraType)
+            return true;
+    return false;
+}
+
 uint8 GetErrorAtShapeshiftedCast (SpellEntry const *spellInfo, uint32 form)
 {
     // talents that learn spells can have stance requirements that need ignore
@@ -806,8 +817,8 @@ void SpellMgr::LoadSpellProcEvents()
 
     uint32 count = 0;
 
-    //                                                0      1           2         3        4                5                6          7        8
-    QueryResult *result = WorldDatabase.Query("SELECT entry, SchoolMask, Category, SkillID, SpellFamilyName, SpellFamilyMask, procFlags, ppmRate, cooldown FROM spell_proc_event");
+    //                                                0      1           2                3                4          5       6        7             8
+    QueryResult *result = WorldDatabase.Query("SELECT entry, SchoolMask, SpellFamilyName, SpellFamilyMask, procFlags, procEx, ppmRate, CustomChance, Cooldown FROM spell_proc_event");
     if( !result )
     {
 
@@ -821,7 +832,7 @@ void SpellMgr::LoadSpellProcEvents()
     }
 
     barGoLink bar( result->GetRowCount() );
-
+    uint32 customProc = 0;
     do
     {
         Field *fields = result->Fetch();
@@ -830,7 +841,8 @@ void SpellMgr::LoadSpellProcEvents()
 
         uint16 entry = fields[0].GetUInt16();
 
-        if (!sSpellStore.LookupEntry(entry))
+        const SpellEntry *spell = sSpellStore.LookupEntry(entry);
+        if (!spell)
         {
             sLog.outErrorDb("Spell %u listed in `spell_proc_event` does not exist", entry);
             continue;
@@ -839,23 +851,35 @@ void SpellMgr::LoadSpellProcEvents()
         SpellProcEventEntry spe;
 
         spe.schoolMask      = fields[1].GetUInt32();
-        spe.category        = fields[2].GetUInt32();
-        spe.skillId         = fields[3].GetUInt32();
-        spe.spellFamilyName = fields[4].GetUInt32();
-        spe.spellFamilyMask = fields[5].GetUInt64();
-        spe.procFlags       = fields[6].GetUInt32();
-        spe.ppmRate         = fields[7].GetFloat();
+        spe.spellFamilyName = fields[2].GetUInt32();
+        spe.spellFamilyMask = fields[3].GetUInt64();
+        spe.procFlags       = fields[4].GetUInt32();
+        spe.procEx          = fields[5].GetUInt32();
+        spe.ppmRate         = fields[6].GetFloat();
+        spe.customChance    = fields[7].GetFloat();
         spe.cooldown        = fields[8].GetUInt32();
 
         mSpellProcEventMap[entry] = spe;
 
+        if (spell->procFlags==0)
+        {
+            if (spe.procFlags == 0)
+            {
+                sLog.outErrorDb("Spell %u listed in `spell_proc_event` probally not triggered spell", entry);
+                continue;
+            }
+            customProc++;
+        }
         ++count;
     } while( result->NextRow() );
 
     delete result;
 
     sLog.outString();
-    sLog.outString( ">> Loaded %u spell proc event conditions", count  );
+    if (customProc)
+        sLog.outString( ">> Loaded %u custom spell proc event conditions +%u custom",  count, customProc );
+    else
+        sLog.outString( ">> Loaded %u spell proc event conditions", count );
 
     /*
     // Commented for now, as it still produces many errors (still quite many spells miss spell_proc_event)
@@ -887,6 +911,7 @@ void SpellMgr::LoadSpellProcEvents()
     */
 }
 
+/*
 bool SpellMgr::IsSpellProcEventCanTriggeredBy( SpellProcEventEntry const * spellProcEvent, SpellEntry const * procSpell, uint32 procFlags )
 {
     if((procFlags & spellProcEvent->procFlags) == 0)
@@ -925,6 +950,73 @@ bool SpellMgr::IsSpellProcEventCanTriggeredBy( SpellProcEventEntry const * spell
 
     return true;
 }
+*/
+
+bool SpellMgr::IsSpellProcEventCanTriggeredBy(SpellProcEventEntry const * spellProcEvent, uint32 EventProcFlag, SpellEntry const * procSpell, uint32 procFlags, uint32 procExtra, bool active)
+{
+    // No extra req need
+    uint32 procEvent_procEx = PROC_EX_NONE;
+
+    // check prockFlags for condition
+    if((procFlags & EventProcFlag) == 0)
+        return false;
+
+    // Always trigger for this
+    if (EventProcFlag & (PROC_FLAG_KILLED | PROC_FLAG_KILL_AND_GET_XP))
+        return true;
+
+    if (spellProcEvent)     // Exist event data
+    {
+        // Store extra req
+        procEvent_procEx = spellProcEvent->procEx;
+
+        // For melee triggers
+        if (procSpell == NULL)
+        {
+            // Check (if set) for school (melee attack have Normal school)
+            if(spellProcEvent->schoolMask && (spellProcEvent->schoolMask & SPELL_SCHOOL_MASK_NORMAL) == 0)
+                return false;
+        }
+        else // For spells need check school/spell family/family mask
+        {
+            // Check (if set) for school
+            if(spellProcEvent->schoolMask && (spellProcEvent->schoolMask & procSpell->SchoolMask) == 0)
+                return false;
+        
+            // Check (if set) for spellFamilyName
+            if(spellProcEvent->spellFamilyName && (spellProcEvent->spellFamilyName != procSpell->SpellFamilyName))
+                return false;
+    
+            // spellFamilyName is Ok need check for spellFamilyMask if present
+            if(spellProcEvent->spellFamilyMask)
+            {
+                if ((spellProcEvent->spellFamilyMask & procSpell->SpellFamilyFlags) == 0)
+                    return false;
+                active = true; // Spell added manualy -> so its active spell
+            }
+        }
+    }
+    // Check for extra req (if none) and hit/crit
+    if (procEvent_procEx == PROC_EX_NONE)
+    {
+        // No extra req, so can trigger only for active (damage/healing present) and hit/crit
+        if((procExtra & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)) && active)
+            return true;
+    }
+    else // Passive spells hits here only if resist/reflect/immune/evade
+    {
+        // Exist req for PROC_EX_EX_TRIGGER_ALWAYS
+        if (procEvent_procEx & PROC_EX_EX_TRIGGER_ALWAYS)
+            return true;
+        // Passive spells can`t trigger if need hit
+        if ((procEvent_procEx & PROC_EX_NORMAL_HIT) && !active)
+            return false;
+        // Check Extra Requirement like (hit/crit/miss/resist/parry/dodge/block/immune/reflect/absorb and other)
+        if (procEvent_procEx & procExtra)
+            return true;
+    }
+    return false;
+}
 
 void SpellMgr::LoadSpellElixirs()
 {
diff --git a/src/game/SpellMgr.h b/src/game/SpellMgr.h
index e67191b..d0bd1d6 100644
--- a/src/game/SpellMgr.h
+++ b/src/game/SpellMgr.h
@@ -323,6 +323,8 @@ bool IsPositiveTarget(uint32 targetA, uint32 targetB);
 bool IsSingleTargetSpell(SpellEntry const *spellInfo);
 bool IsSingleTargetSpells(SpellEntry const *spellInfo1, SpellEntry const *spellInfo2);
 
+bool IsAuraAddedBySpell(uint32 auraType, uint32 spellId);
+
 bool IsSpellAllowedInLocation(SpellEntry const *spellInfo,uint32 map_id,uint32 zone_id,uint32 area_id);
 
 inline bool IsAreaEffectTarget( Targets target )
@@ -441,50 +443,86 @@ typedef std::map<uint32, uint64> SpellAffectMap;
 // Spell proc event related declarations (accessed using SpellMgr functions)
 enum ProcFlags
 {
-    PROC_FLAG_NONE                  = 0x00000000,           // None
-    PROC_FLAG_HIT_MELEE             = 0x00000001,           // On melee hit
-    PROC_FLAG_STRUCK_MELEE          = 0x00000002,           // On being struck melee
-    PROC_FLAG_KILL_XP_GIVER         = 0x00000004,           // On kill target giving XP or honor
-    PROC_FLAG_SPECIAL_DROP          = 0x00000008,           //
-    PROC_FLAG_DODGE                 = 0x00000010,           // On dodge melee attack
-    PROC_FLAG_PARRY                 = 0x00000020,           // On parry melee attack
-    PROC_FLAG_BLOCK                 = 0x00000040,           // On block attack
-    PROC_FLAG_TOUCH                 = 0x00000080,           // On being touched (for bombs, probably?)
-    PROC_FLAG_TARGET_LOW_HEALTH     = 0x00000100,           // On deal damage to enemy with 20% or less health
-    PROC_FLAG_LOW_HEALTH            = 0x00000200,           // On health dropped below 20%
-    PROC_FLAG_STRUCK_RANGED         = 0x00000400,           // On being struck ranged
-    PROC_FLAG_HIT_SPECIAL           = 0x00000800,           // (!)Removed, may be reassigned in future
-    PROC_FLAG_CRIT_MELEE            = 0x00001000,           // On crit melee
-    PROC_FLAG_STRUCK_CRIT_MELEE     = 0x00002000,           // On being critically struck in melee
-    PROC_FLAG_CAST_SPELL            = 0x00004000,           // On cast spell
-    PROC_FLAG_TAKE_DAMAGE           = 0x00008000,           // On take damage
-    PROC_FLAG_CRIT_SPELL            = 0x00010000,           // On crit spell
-    PROC_FLAG_HIT_SPELL             = 0x00020000,           // On hit spell
-    PROC_FLAG_STRUCK_CRIT_SPELL     = 0x00040000,           // On being critically struck by a spell
-    PROC_FLAG_HIT_RANGED            = 0x00080000,           // On getting ranged hit
-    PROC_FLAG_STRUCK_SPELL          = 0x00100000,           // On being struck by a spell
-    PROC_FLAG_TRAP                  = 0x00200000,           // On trap activation (?)
-    PROC_FLAG_CRIT_RANGED           = 0x00400000,           // On getting ranged crit
-    PROC_FLAG_STRUCK_CRIT_RANGED    = 0x00800000,           // On being critically struck by a ranged attack
-    PROC_FLAG_RESIST_SPELL          = 0x01000000,           // On resist enemy spell
-    PROC_FLAG_TARGET_RESISTS        = 0x02000000,           // On enemy resisted spell
-    PROC_FLAG_TARGET_DODGE_OR_PARRY = 0x04000000,           // On enemy dodges/parries
-    PROC_FLAG_HEAL                  = 0x08000000,           // On heal
-    PROC_FLAG_CRIT_HEAL             = 0x10000000,           // On critical healing effect
-    PROC_FLAG_HEALED                = 0x20000000,           // On healing
-    PROC_FLAG_TARGET_BLOCK          = 0x40000000,           // On enemy blocks
-    PROC_FLAG_MISS                  = 0x80000000            // On miss melee attack
+   PROC_FLAG_NONE                          = 0x00000000,
+
+   PROC_FLAG_KILLED                        = 0x00000001,    // 00 Killed by agressor
+   PROC_FLAG_KILL_AND_GET_XP               = 0x00000002,    // 01 Kill that yields experience or honor
+
+   PROC_FLAG_SUCCESSFUL_MILEE_HIT          = 0x00000004,    // 02 Successful melee attack
+   PROC_FLAG_TAKEN_MELEE_HIT               = 0x00000008,    // 03 Taken damage from melee strike hit
+
+   PROC_FLAG_SUCCESSFUL_MELEE_SPELL_HIT    = 0x00000010,    // 04 Successful attack by Spell that use melee weapon
+   PROC_FLAG_TAKEN_MELEE_SPELL_HIT         = 0x00000020,    // 05 Taken damage by Spell that use melee weapon
+
+   PROC_FLAG_SUCCESSFUL_RANGED_HIT         = 0x00000040,    // 06 Successful Ranged attack (all ranged attack deal as spell so newer set :( )
+   PROC_FLAG_TAKEN_RANGED_HIT              = 0x00000080,    // 07 Taken damage from ranged attack (all ranged attack deal as spell so newer set :( )
+
+   PROC_FLAG_SUCCESSFUL_RANGED_SPELL_HIT   = 0x00000100,    // 08 Successful Ranged attack by Spell that use ranged weapon
+   PROC_FLAG_TAKEN_RANGED_SPELL_HIT        = 0x00000200,    // 09 Taken damage by Spell that use ranged weapon
+
+   PROC_FLAG_SUCCESSFUL_POSITIVE_AOE_HIT   = 0x00000400,    // 10 Successful AoE (not 100% shure unused)
+   PROC_FLAG_TAKEN_POSITIVE_AOE            = 0x00000800,    // 11 Taken AoE      (not 100% shure unused)
+
+   PROC_FLAG_SUCCESSFUL_AOE_SPELL_HIT      = 0x00001000,    // 12 Successful AoE damage spell hit (not 100% shure unused)
+   PROC_FLAG_TAKEN_AOE_SPELL_HIT           = 0x00002000,    // 13 Taken AoE damage spell hit      (not 100% shure unused)
+
+   PROC_FLAG_SUCCESSFUL_POSITIVE_SPELL     = 0x00004000,    // 14 Successful cast positive spell (by default only on healing)
+   PROC_FLAG_TAKEN_POSITIVE_SPELL          = 0x00008000,    // 15 Taken positive spell hit (by default only on healing)
+
+   PROC_FLAG_SUCCESSFUL_NEGATIVE_SPELL_HIT = 0x00010000,    // 16 Successful negative spell cast (by default only on damage)
+   PROC_FLAG_TAKEN_NEGATIVE_SPELL_HIT      = 0x00020000,    // 17 Taken negative spell (by default only on damage)
+
+   PROC_FLAG_ON_DO_PERIODIC                = 0x00040000,    // 18 Successful do periodic (damage / healing, determined from 14-17 flags)
+   PROC_FLAG_ON_TAKE_PERIODIC              = 0x00080000,    // 19 Taken spell periodic (damage / healing, determined from 14-17 flags)
+
+   PROC_FLAG_TAKEN_ANY_DAMAGE              = 0x00100000,    // 20 Taken any damage
+   PROC_FLAG_ON_TRAP_ACTIVATION            = 0x00200000,    // 21 On trap activation 
+
+   PROC_FLAG_TAKEN_OFFHAND_HIT             = 0x00400000,    // 22 Taken off-hand melee attacks(not used)
+   PROC_FLAG_SUCCESSFUL_OFFHAND_HIT        = 0x00800000     // 23 Successful off-hand melee attacks
+};
+
+#define MELEE_BASED_TRIGGER_MASK (PROC_FLAG_SUCCESSFUL_MILEE_HIT        | \
+                                  PROC_FLAG_TAKEN_MELEE_HIT             | \
+                                  PROC_FLAG_SUCCESSFUL_MELEE_SPELL_HIT  | \
+                                  PROC_FLAG_TAKEN_MELEE_SPELL_HIT       | \
+                                  PROC_FLAG_SUCCESSFUL_RANGED_HIT       | \
+                                  PROC_FLAG_TAKEN_RANGED_HIT            | \
+                                  PROC_FLAG_SUCCESSFUL_RANGED_SPELL_HIT | \
+                                  PROC_FLAG_TAKEN_RANGED_SPELL_HIT)
+
+enum ProcFlagsEx
+{
+   PROC_EX_NONE                = 0x0000000,                 // If none can tigger on Hit/Crit only (passive spells MUST defined by SpellFamily flag)
+   PROC_EX_NORMAL_HIT          = 0x0000001,                 // If set only from normal hit (only damage spells)
+   PROC_EX_CRITICAL_HIT        = 0x0000002,
+   PROC_EX_MISS                = 0x0000004,
+   PROC_EX_RESIST              = 0x0000008,
+   PROC_EX_DODGE               = 0x0000010,
+   PROC_EX_PARRY               = 0x0000020,
+   PROC_EX_BLOCK               = 0x0000040,
+   PROC_EX_EVADE               = 0x0000080,
+   PROC_EX_IMMUNE              = 0x0000100,
+   PROC_EX_DEFLECT             = 0x0000200,
+   PROC_EX_ABSORB              = 0x0000400,
+   PROC_EX_REFLECT             = 0x0000800,
+   PROC_EX_INTERRUPT           = 0x0001000,                 // Melle hit result can be Interrupt (not used)
+   PROC_EX_RESERVED1           = 0x0002000,
+   PROC_EX_RESERVED2           = 0x0004000,
+   PROC_EX_RESERVED3           = 0x0008000,
+   PROC_EX_EX_TRIGGER_ALWAYS   = 0x0010000,                 // If set trigger always ( no matter another flags) used for drop charges
+   PROC_EX_EX_ONE_TIME_TRIGGER = 0x0020000                  // If set trigger always but only one time
 };
 
 struct SpellProcEventEntry
 {
     uint32      schoolMask;                                 // if nonzero - bit mask for matching proc condition based on spell candidate's school: Fire=2, Mask=1<<(2-1)=2
-    uint32      category;                                   // if nonzero - match proc condition based on candidate spell's category
-    uint32      skillId;                                    // if nonzero - for matching proc condition based on candidate spell's skillId from SkillLineAbility.dbc (Shadow Bolt = Destruction)
     uint32      spellFamilyName;                            // if nonzero - for matching proc condition based on candidate spell's SpellFamilyNamer value
     uint64      spellFamilyMask;                            // if nonzero - for matching proc condition based on candidate spell's SpellFamilyFlags (like auras 107 and 108 do)
     uint32      procFlags;                                  // bitmask for matching proc event
+    uint32      procEx;                                     // proc Extend info (see ProcFlagsEx)
     float       ppmRate;                                    // for melee (ranged?) damage spells - proc rate per minute. if zero, falls back to flat chance from Spell.dbc
+    float       customChance;                               // Owerride chance (in most cases for debug only)
     uint32      cooldown;                                   // hidden cooldown used for some spell proc events, applied to _triggered_spell_
 };
 
@@ -683,7 +721,7 @@ class SpellMgr
             return NULL;
         }
 
-        static bool IsSpellProcEventCanTriggeredBy( SpellProcEventEntry const * spellProcEvent, SpellEntry const * procSpell, uint32 procFlags );
+        static bool IsSpellProcEventCanTriggeredBy( SpellProcEventEntry const * spellProcEvent, uint32 EventProcFlag, SpellEntry const * procSpell, uint32 procFlags, uint32 procExtra, bool active);
 
         // Spell target coordinates
         SpellTargetPosition const* GetSpellTargetPosition(uint32 spell_id) const
diff --git a/src/game/StatSystem.cpp b/src/game/StatSystem.cpp
index f215701..689c372 100644
--- a/src/game/StatSystem.cpp
+++ b/src/game/StatSystem.cpp
@@ -153,7 +153,7 @@ void Player::UpdateArmor()
     {
         Modifier* mod = (*i)->GetModifier();
         if(mod->m_miscvalue & SPELL_SCHOOL_MASK_NORMAL)
-            value += int32(GetStat(Stats((*i)->GetMiscBValue())) * mod->m_amount / 100.0f);
+            value += int32(GetStat(Stats((*i)->GetMiscBValue())) * mod->m_amount * (*i)->m_stackAmount / 100.0f);
     }
 
     value *= GetModifierValue(unitMod, TOTAL_PCT);
@@ -311,7 +311,7 @@ void Player::UpdateAttackPowerAndDamage(bool ranged )
     {
         AuraList const& mRAPbyIntellect = GetAurasByType(SPELL_AURA_MOD_RANGED_ATTACK_POWER_OF_STAT_PERCENT);
         for(AuraList::const_iterator i = mRAPbyIntellect.begin();i != mRAPbyIntellect.end(); ++i)
-            attPowerMod += int32(GetStat(Stats((*i)->GetModifier()->m_miscvalue)) * (*i)->GetModifier()->m_amount / 100.0f);
+            attPowerMod += int32(GetStat(Stats((*i)->GetModifier()->m_miscvalue)) * (*i)->GetModifier()->m_amount * (*i)->m_stackAmount / 100.0f);
     }
 
     float attPowerMultiplier = GetModifierValue(unitMod, TOTAL_PCT) - 1.0f;
@@ -393,6 +393,12 @@ void Player::CalculateMinMaxDamage(WeaponAttackType attType, bool normalized, fl
         weapon_maxdamage += GetAmmoDPS() * att_speed;
     }
 
+    if (attType == BASE_ATTACK)
+    {
+        int32 ModSpeed = GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKSPEED);
+        base_pct = base_pct * 100.0f/(100.0f+float(ModSpeed));
+    }
+
     min_damage = ((base_value + weapon_mindamage) * base_pct + total_value) * total_pct;
     max_damage = ((base_value + weapon_maxdamage) * base_pct + total_value) * total_pct;
 }
@@ -570,10 +576,10 @@ void Player::UpdateExpertise(WeaponAttackType attack)
     {
         // item neutral spell
         if((*itr)->GetSpellProto()->EquippedItemClass == -1)
-            expertise += (*itr)->GetModifier()->m_amount;
+            expertise += (*itr)->GetModifier()->m_amount * (*itr)->m_stackAmount;
         // item dependent spell
         else if(weapon && weapon->IsFitToSpellRequirements((*itr)->GetSpellProto()))
-            expertise += (*itr)->GetModifier()->m_amount;
+            expertise += (*itr)->GetModifier()->m_amount * (*itr)->m_stackAmount;
     }
 
     if(expertise < 0)
@@ -603,7 +609,7 @@ void Player::UpdateManaRegen()
     for(AuraList::const_iterator i = regenAura.begin();i != regenAura.end(); ++i)
     {
         Modifier* mod = (*i)->GetModifier();
-        power_regen_mp5 += GetStat(Stats(mod->m_miscvalue)) * mod->m_amount / 500.0f;
+        power_regen_mp5 += GetStat(Stats(mod->m_miscvalue)) * mod->m_amount * (*i)->m_stackAmount / 500.0f;
     }
 
     // Bonus from some dummy auras
@@ -731,6 +737,9 @@ void Creature::UpdateDamagePhysical(WeaponAttackType attType)
     float weapon_mindamage = GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE);
     float weapon_maxdamage = GetWeaponDamageRange(BASE_ATTACK, MAXDAMAGE);
 
+    int32 ModSpeed = GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKSPEED);
+    base_pct = base_pct * 100.0f/(100.0f+float(ModSpeed));
+
     float mindamage = ((base_value + weapon_mindamage) * base_pct + total_value) * total_pct ;
     float maxdamage = ((base_value + weapon_maxdamage) * base_pct + total_value) * total_pct ;
 
@@ -936,6 +945,9 @@ void Pet::UpdateDamagePhysical(WeaponAttackType attType)
     float weapon_mindamage = GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE);
     float weapon_maxdamage = GetWeaponDamageRange(BASE_ATTACK, MAXDAMAGE);
 
+    int32 ModSpeed = GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKSPEED);
+    base_pct = base_pct * 100.0f/(100.0f+float(ModSpeed));
+
     float mindamage = ((base_value + weapon_mindamage) * base_pct + total_value) * total_pct;
     float maxdamage = ((base_value + weapon_maxdamage) * base_pct + total_value) * total_pct;
 
diff --git a/src/game/TaxiHandler.cpp b/src/game/TaxiHandler.cpp
index 7673622..3dbdb52 100644
--- a/src/game/TaxiHandler.cpp
+++ b/src/game/TaxiHandler.cpp
@@ -192,10 +192,29 @@ void WorldSession::HandleActivateTaxiFarOpcode ( WorldPacket & recv_data )
     GetPlayer()->ActivateTaxiPathTo(nodes, 0, npc);
 }
 
-void WorldSession::HandleTaxiNextDestinationOpcode(WorldPacket& /*recv_data*/)
+void WorldSession::HandleTaxiNextDestinationOpcode(WorldPacket& recv_data)
 {
     sLog.outDebug( "WORLD: Received CMSG_MOVE_SPLINE_DONE" );
 
+    MovementInfo movementInfo;
+    uint32 MovementFlags;
+
+    recv_data >> MovementFlags;
+    recv_data >> movementInfo.unk1;
+    recv_data >> movementInfo.time;
+    recv_data >> movementInfo.x;
+    recv_data >> movementInfo.y;
+    recv_data >> movementInfo.z;
+    recv_data >> movementInfo.o;
+
+ 
+    while(GetPlayer()->GetMotionMaster()->GetCurrentMovementGeneratorType()==FLIGHT_MOTION_TYPE)
+        GetPlayer()->GetMotionMaster()->MovementExpired(false);
+
+    GetPlayer()->SetPosition(movementInfo.x, movementInfo.y, movementInfo.z, movementInfo.o);
+    GetPlayer()->m_movementInfo = movementInfo;
+    GetPlayer()->m_anti_lastmovetime = movementInfo.time;   
+
     // in taxi flight packet received in 2 case:
     // 1) end taxi path in far (multi-node) flight
     // 2) switch from one map to other in case multim-map taxi path
@@ -204,6 +223,7 @@ void WorldSession::HandleTaxiNextDestinationOpcode(WorldPacket& /*recv_data*/)
     if(!curDest)
         return;
 
+
     TaxiNodesEntry const* curDestNode = sTaxiNodesStore.LookupEntry(curDest);
 
     // far teleport case
diff --git a/src/game/Unit.cpp b/src/game/Unit.cpp
index 339a590..f18addc 100644
--- a/src/game/Unit.cpp
+++ b/src/game/Unit.cpp
@@ -41,6 +41,7 @@
 #include "BattleGround.h"
 #include "InstanceSaveMgr.h"
 #include "GridNotifiersImpl.h"
+#include "OutdoorPvP.h"
 #include "CellImpl.h"
 #include "Path.h"
 
@@ -58,6 +59,8 @@ float baseMoveSpeed[MAX_MOVE_TYPE] =
     4.5f,                                                   // MOVE_FLYBACK
 };
 
+void InitTriggerAuraData();
+
 // auraTypes contains attacker auras capable of proc'ing cast auras
 static Unit::AuraTypeSet GenerateAttakerProcCastAuraTypes()
 {
@@ -111,6 +114,8 @@ static Unit::AuraTypeSet victimProcEffectAuraTypes   = GenerateVictimProcEffectA
 // auraTypes contains auras capable of proc'ing for attacker and victim
 static Unit::AuraTypeSet GenerateProcAuraTypes()
 {
+    InitTriggerAuraData();
+
     Unit::AuraTypeSet auraTypes;
     auraTypes.insert(attackerProcCastAuraTypes.begin(),attackerProcCastAuraTypes.end());
     auraTypes.insert(attackerProcEffectAuraTypes.begin(),attackerProcEffectAuraTypes.end());
@@ -435,19 +440,6 @@ bool Unit::HasAuraType(AuraType auraType) const
     return (!m_modAuras[auraType].empty());
 }
 
-/* Called by DealDamage for auras that have a chance to be dispelled on damage taken. */
-void Unit::RemoveSpellbyDamageTaken(AuraType auraType, uint32 damage)
-{
-    if(!HasAuraType(auraType))
-        return;
-
-    // The chance to dispell an aura depends on the damage taken with respect to the casters level.
-    uint32 max_dmg = getLevel() > 8 ? 25 * getLevel() - 150 : 50;
-    float chance = float(damage) / max_dmg * 100.0f;
-    if (roll_chance_f(chance))
-        RemoveSpellsCausingAura(auraType);
-}
-
 uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDamage, DamageEffectType damagetype, SpellSchoolMask damageSchoolMask, SpellEntry const *spellProto, bool durabilityLoss)
 {
     if (!pVictim->isAlive() || pVictim->isInFlight() || pVictim->GetTypeId() == TYPEID_UNIT && ((Creature*)pVictim)->IsInEvadeMode())
@@ -495,11 +487,6 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
         return 0;
     }
 
-    pVictim->RemoveSpellbyDamageTaken(SPELL_AURA_MOD_FEAR, damage);
-    // root type spells do not dispell the root effect
-    if(!spellProto || spellProto->Mechanic != MECHANIC_ROOT)
-        pVictim->RemoveSpellbyDamageTaken(SPELL_AURA_MOD_ROOT, damage);
-
     if(pVictim->GetTypeId() != TYPEID_PLAYER)
     {
         // no xp,health if type 8 /critters/
@@ -598,25 +585,6 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
         ((Creature*)pVictim)->SetLootRecipient(this);
     if (health <= damage)
     {
-        // battleground things
-        if(pVictim->GetTypeId() == TYPEID_PLAYER && (((Player*)pVictim)->InBattleGround()))
-        {
-            Player *killed = ((Player*)pVictim);
-            Player *killer = NULL;
-            if(GetTypeId() == TYPEID_PLAYER)
-                killer = ((Player*)this);
-            else if(GetTypeId() == TYPEID_UNIT && ((Creature*)this)->isPet())
-            {
-                Unit *owner = GetOwner();
-                if(owner && owner->GetTypeId() == TYPEID_PLAYER)
-                    killer = ((Player*)owner);
-            }
-
-            if(killer)
-                if(BattleGround *bg = killed->GetBattleGround())
-                    bg->HandleKillPlayer(killed, killer);   // drop flags and etc
-        }
-
         DEBUG_LOG("DealDamage: victim just died");
 
         // find player: owner of controlled `this` or `this` itself maybe
@@ -627,8 +595,12 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
         // Reward player, his pets, and group/raid members
         // call kill spell proc event (before real die and combat stop to triggering auras removed at death/combat stop)
         if(player && player!=pVictim)
+        {
             if(player->RewardPlayerAndGroupAtKill(pVictim))
-                player->ProcDamageAndSpell(pVictim,PROC_FLAG_KILL_XP_GIVER,PROC_FLAG_NONE);
+                player->ProcDamageAndSpell(pVictim, PROC_FLAG_KILL_AND_GET_XP, PROC_FLAG_KILLED, PROC_EX_NONE, 0);
+            else
+                player->ProcDamageAndSpell(pVictim, PROC_FLAG_NONE, PROC_FLAG_KILLED,PROC_EX_NONE, 0);
+        }
 
         DEBUG_LOG("DealDamageAttackStop");
 
@@ -653,11 +625,45 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
                 }
             }
         }
+        else if(pVictim->GetTypeId() == TYPEID_UNIT)
+        {
+            Player *killer = NULL;
+            if(GetTypeId() == TYPEID_PLAYER)
+                killer = ((Player*)this);
+            else if(GetTypeId() == TYPEID_UNIT && ((Creature*)this)->isPet())
+            {
+                if(Unit *owner = GetOwner())
+                    if(owner->GetTypeId() == TYPEID_PLAYER)
+                        killer = ((Player*)owner);
+            }
+
+            if(killer)
+                if(BattleGround *bg = killer->GetBattleGround())
+                    bg->HandleKillUnit((Creature*)pVictim,killer);
+        }
 
         DEBUG_LOG("SET JUST_DIED");
         if(!spiritOfRedemtionTalentReady)
             pVictim->setDeathState(JUST_DIED);
 
+        // outdoor pvp things, do these after setting the death state, else the player activity notify won't work... doh...
+        // handle player kill only if not suicide (spirit of redemption for example)
+        if(GetTypeId() == TYPEID_PLAYER && this != pVictim)
+        {
+            if(OutdoorPvP * pvp = ((Player*)this)->GetOutdoorPvP())
+            {
+                pvp->HandleKill((Player*)this,pVictim);
+            }
+        }
+
+        if(pVictim->GetTypeId() == TYPEID_PLAYER)
+        {
+            if(OutdoorPvP * pvp = ((Player*)pVictim)->GetOutdoorPvP())
+            {
+                pvp->HandlePlayerActivityChanged((Player*)pVictim);
+            }
+        }
+
         DEBUG_LOG("DealDamageHealth1");
 
         if(spiritOfRedemtionTalentReady)
@@ -755,6 +761,25 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
 
             he->DuelComplete(DUEL_INTERUPTED);
         }
+
+        // battleground things (do this at the end, so the death state flag will be properly set to handle in the bg->handlekill)
+        if(pVictim->GetTypeId() == TYPEID_PLAYER && (((Player*)pVictim)->InBattleGround()))
+        {
+            Player *killed = ((Player*)pVictim);
+            Player *killer = NULL;
+            if(GetTypeId() == TYPEID_PLAYER)
+                killer = ((Player*)this);
+            else if(GetTypeId() == TYPEID_UNIT && ((Creature*)this)->isPet())
+            {
+                Unit *owner = GetOwner();
+                if(owner && owner->GetTypeId() == TYPEID_PLAYER)
+                    killer = ((Player*)owner);
+            }
+
+            if(killer)
+                if(BattleGround *bg = killed->GetBattleGround())
+                    bg->HandleKillPlayer(killed, killer);   // drop flags and etc
+        }
     }
     else                                                    // if (health <= damage)
     {
@@ -762,18 +787,6 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
 
         pVictim->ModifyHealth(- (int32)damage);
 
-        // Check if health is below 20% (apply damage before to prevent case when after ProcDamageAndSpell health < damage
-        if(pVictim->GetHealth()*5 < pVictim->GetMaxHealth())
-        {
-            uint32 procVictim = PROC_FLAG_NONE;
-
-            // if just dropped below 20% (for CheatDeath)
-            if((pVictim->GetHealth()+damage)*5 > pVictim->GetMaxHealth())
-                procVictim = PROC_FLAG_LOW_HEALTH;
-
-            ProcDamageAndSpell(pVictim,PROC_FLAG_TARGET_LOW_HEALTH,procVictim);
-        }
-
         if(damagetype != DOT)
         {
             if(getVictim())
@@ -794,9 +807,11 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
         if(pVictim->getTransForm() && pVictim->hasUnitState(UNIT_STAT_CONFUSED))
             pVictim->RemoveAurasDueToSpell(pVictim->getTransForm());
 
-        if(damagetype == DIRECT_DAMAGE|| damagetype == SPELL_DIRECT_DAMAGE)
-            pVictim->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_DIRECT_DAMAGE);
-
+        if(damagetype == DIRECT_DAMAGE || damagetype == SPELL_DIRECT_DAMAGE)
+        {
+            if (!spellProto || !(spellProto->AuraInterruptFlags&AURA_INTERRUPT_FLAG_DIRECT_DAMAGE))
+                pVictim->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_DIRECT_DAMAGE);
+        }
         if (pVictim->GetTypeId() != TYPEID_PLAYER)
         {
             if(spellProto && IsDamageToThreatSpell(spellProto))
@@ -837,6 +852,8 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
         {
             const SpellEntry *se = i->second->GetSpellProto();
             next = i; ++next;
+            if (spellProto && spellProto->Id == se->Id) // Not drop auras added by self
+                continue;
             if( se->AuraInterruptFlags & AURA_INTERRUPT_FLAG_DAMAGE )
             {
                 bool remove = true;
@@ -851,6 +868,16 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
                     // FIXME: this may cause the auras with proc chance to be rerolled several times
                     next = vAuras.begin();
                 }
+            } 
+            else if ( (se->Attributes & 0x40000000LL) && (!spellProto || se->Id != spellProto->Id) )
+            {
+                uint32 max_dmg = pVictim->getLevel() > 8 ? 25 * pVictim->getLevel() - 150 : 50;
+                float chance = float(damage) / max_dmg * 100.0f;
+                if (roll_chance_f(chance))
+                {
+                    pVictim->RemoveAurasDueToSpell(i->second->GetId());
+                    next = vAuras.begin();
+                }
             }
         }
 
@@ -1041,6 +1068,7 @@ void Unit::CastSpell(float x, float y, float z, SpellEntry const *spellInfo, boo
     spell->prepare(&targets, triggredByAura);
 }
 
+/*
 void Unit::DealFlatDamage(Unit *pVictim, SpellEntry const *spellInfo, uint32 *damage, CleanDamage *cleanDamage, bool *crit, bool isTriggeredSpell)
 {
     // TODO this in only generic way, check for exceptions
@@ -1129,7 +1157,7 @@ void Unit::DealFlatDamage(Unit *pVictim, SpellEntry const *spellInfo, uint32 *da
                     AuraList const& mDamageDoneVersus = GetAurasByType(SPELL_AURA_MOD_CRIT_PERCENT_VERSUS);
                     for(AuraList::const_iterator i = mDamageDoneVersus.begin();i != mDamageDoneVersus.end(); ++i)
                         if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-                            bonusDmg = uint32(bonusDmg * ((*i)->GetModifier()->m_amount+100.0f)/100.0f);
+                            bonusDmg = uint32(bonusDmg * ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount +100.0f)/100.0f);
 
                     *damage += bonusDmg;
 
@@ -1453,6 +1481,577 @@ uint32 Unit::SpellNonMeleeDamageLog(Unit *pVictim, uint32 spellID, uint32 damage
         return 0;
     }
 }
+*/
+
+// Obsolete func need remove, here only for comotability vs another patches
+uint32 Unit::SpellNonMeleeDamageLog(Unit *pVictim, uint32 spellID, uint32 damage, bool isTriggeredSpell, bool useSpellDamage)
+{
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellID);
+    SpellNonMeleeDamage damageInfo(this, pVictim, spellInfo->Id, spellInfo->SchoolMask);
+    CalculateSpellDamage(&damageInfo, damage, spellInfo);
+    SendSpellNonMeleeDamageLog(&damageInfo);
+    DealSpellDamage(&damageInfo, true);
+    return damageInfo.damage;
+}
+
+void Unit::CalculateSpellDamage(SpellNonMeleeDamage *damageInfo, int32 damage, SpellEntry const *spellInfo, WeaponAttackType attackType)
+{
+    SpellSchoolMask damageSchoolMask = SpellSchoolMask(damageInfo->schoolMask);
+    Unit *pVictim = damageInfo->target;
+
+    if (damage < 0)
+        return;
+    
+    if(!this || !pVictim)
+        return;
+    if(!this->isAlive() || !pVictim->isAlive())
+        return;
+
+    uint32 crTypeMask = pVictim->GetCreatureTypeMask();
+    // Check spell crit chance
+    bool crit = isSpellCrit(pVictim, spellInfo, damageSchoolMask, attackType);
+    bool blocked = false; 
+    // Per-school calc
+    switch (spellInfo->DmgClass)
+    {
+        // Melee and Ranged Spells 
+        case SPELL_DAMAGE_CLASS_RANGED:
+        case SPELL_DAMAGE_CLASS_MELEE:
+        {
+            // Physical Damage
+            if ( damageSchoolMask & SPELL_SCHOOL_MASK_NORMAL )
+            {
+                //Calculate armor mitigation
+                damage = CalcArmorReducedDamage(pVictim, damage);
+                // Get blocked status
+                blocked = isSpellBlocked(pVictim, spellInfo, attackType);
+            } 
+            // Magical Damage
+            else 
+            {
+                // Calculate damage bonus
+                damage = SpellDamageBonus(pVictim, spellInfo, damage, SPELL_DIRECT_DAMAGE);
+            }
+            if (crit)
+            {
+                damageInfo->HitInfo|= SPELL_HIT_TYPE_CRIT;
+
+                // Calculate crit bonus
+                uint32 crit_bonus = damage;
+                // Apply crit_damage bonus for melee spells
+                if(Player* modOwner = GetSpellModOwner())
+                    modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_CRIT_DAMAGE_BONUS, crit_bonus);
+                damage += crit_bonus;
+
+                // Apply SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE or SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE
+                int32 critPctDamageMod=0;
+                if(attackType == RANGED_ATTACK)
+                    critPctDamageMod += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE);
+                else
+                {
+                    critPctDamageMod += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE);
+                    critPctDamageMod += GetTotalAuraModifier(SPELL_AURA_MOD_CRIT_DAMAGE_BONUS_MELEE);
+                }
+                // Increase crit damage from SPELL_AURA_MOD_CRIT_PERCENT_VERSUS
+                critPctDamageMod += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_CRIT_PERCENT_VERSUS, crTypeMask);
+          
+                if (critPctDamageMod!=0)
+                    damage = int32((damage) * float((100.0f + critPctDamageMod)/100.0f));
+            
+                // Resilience - reduce crit damage
+                if (pVictim->GetTypeId()==TYPEID_PLAYER)
+                    damage -= ((Player*)pVictim)->GetMeleeCritDamageReduction(damage);
+            }
+            // Spell weapon based damage CAN BE crit & blocked at same time
+            if (blocked)
+            {
+                damageInfo->blocked = uint32(pVictim->GetShieldBlockValue());
+                if (damage < damageInfo->blocked) 
+                    damageInfo->blocked = damage;
+                damage-=damageInfo->blocked;
+            }
+        }
+        break;
+        // Magical Attacks
+        case SPELL_DAMAGE_CLASS_NONE:
+        case SPELL_DAMAGE_CLASS_MAGIC:
+        {
+            // Calculate damage bonus
+            damage = SpellDamageBonus(pVictim, spellInfo, damage, SPELL_DIRECT_DAMAGE);
+            // If crit add critical bonus
+            if (crit)
+            {
+                damageInfo->HitInfo|= SPELL_HIT_TYPE_CRIT;
+                damage = SpellCriticalBonus(spellInfo, damage, pVictim);
+                // Resilience - reduce crit damage
+                if (pVictim->GetTypeId()==TYPEID_PLAYER)
+                    damage -= ((Player*)pVictim)->GetSpellCritDamageReduction(damage);
+            }
+        }
+        break;
+    }
+
+    // Calculate absorb resist
+    if(damage > 0)
+    {
+        CalcAbsorbResist(pVictim, damageSchoolMask, SPELL_DIRECT_DAMAGE, damage, &damageInfo->absorb, &damageInfo->resist);
+        damage-= damageInfo->absorb + damageInfo->resist;
+    }
+    else
+        damage = 0;
+    damageInfo->damage = damage;
+}
+
+void Unit::DealSpellDamage(SpellNonMeleeDamage *damageInfo, bool durabilityLoss)
+{
+    if (damageInfo==0)
+        return;
+
+    Unit *pVictim = damageInfo->target;
+
+    if(!this || !pVictim)
+        return;
+
+    if (!pVictim->isAlive() || pVictim->isInFlight() || pVictim->GetTypeId() == TYPEID_UNIT && ((Creature*)pVictim)->IsInEvadeMode())
+        return;
+
+    SpellEntry const *spellProto = sSpellStore.LookupEntry(damageInfo->SpellID);
+    if (spellProto == NULL)
+    {
+        sLog.outDebug("Unit::DealSpellDamage have wrong damageInfo->SpellID: %u", damageInfo->SpellID);
+        return;
+    }
+
+    //You don't lose health from damage taken from another player while in a sanctuary
+    //You still see it in the combat log though
+    if(pVictim != this && GetTypeId() == TYPEID_PLAYER && pVictim->GetTypeId() == TYPEID_PLAYER)
+    {
+        const AreaTableEntry *area = GetAreaEntryByAreaID(pVictim->GetAreaId());
+        if(area && area->flags & 0x800)                     //sanctuary
+            return;
+    }
+
+    // update at damage Judgement aura duration that applied by attacker at victim
+    if(damageInfo->damage && spellProto->Id == 35395)
+    {
+        AuraMap& vAuras = pVictim->GetAuras();
+        for(AuraMap::iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
+        {
+            SpellEntry const *spellInfo = (*itr).second->GetSpellProto();
+            if( spellInfo->AttributesEx3 & 0x40000 && spellInfo->SpellFamilyName == SPELLFAMILY_PALADIN && ((*itr).second->GetCasterGUID() == GetGUID()))
+            {
+                (*itr).second->SetAuraDuration((*itr).second->GetAuraMaxDuration());
+                (*itr).second->UpdateAuraDuration();
+            }
+        }
+    }
+    // Call default DealDamage
+    CleanDamage cleanDamage(damageInfo->cleanDamage, BASE_ATTACK, MELEE_HIT_NORMAL);
+    DealDamage(pVictim, damageInfo->damage, &cleanDamage, SPELL_DIRECT_DAMAGE, SpellSchoolMask(damageInfo->schoolMask), spellProto, durabilityLoss);
+}
+
+//TODO for melee need create structure as in 
+void Unit::CalculateMeleeDamage(Unit *pVictim, uint32 damage, CalcDamageInfo *damageInfo, WeaponAttackType attackType)
+{
+    damageInfo->attacker         = this;
+    damageInfo->target           = pVictim;
+    damageInfo->damageSchoolMask = GetMeleeDamageSchoolMask();
+    damageInfo->attackType       = attackType;
+    damageInfo->damage           = 0;
+    damageInfo->cleanDamage      = 0;
+    damageInfo->absorb           = 0;
+    damageInfo->resist           = 0;
+    damageInfo->blocked_amount   = 0;
+
+    damageInfo->TargetState      = 0;
+    damageInfo->HitInfo          = 0;
+    damageInfo->procAttacker     = PROC_FLAG_NONE;
+    damageInfo->procVictim       = PROC_FLAG_NONE;
+    damageInfo->procEx           = PROC_EX_NONE;
+    damageInfo->hitOutCome       = MELEE_HIT_EVADE;
+
+    if(!this || !pVictim)
+        return;
+    if(!this->isAlive() || !pVictim->isAlive())
+        return;
+
+    // Select HitInfo/procAttacker/procVictim flag based on attack type
+    switch (attackType)
+    {
+        case BASE_ATTACK:
+            damageInfo->procAttacker = PROC_FLAG_SUCCESSFUL_MILEE_HIT;
+            damageInfo->procVictim   = PROC_FLAG_TAKEN_MELEE_HIT;
+            damageInfo->HitInfo      = HITINFO_NORMALSWING2;
+            break;
+        case OFF_ATTACK:
+            damageInfo->procAttacker = PROC_FLAG_SUCCESSFUL_MILEE_HIT | PROC_FLAG_SUCCESSFUL_OFFHAND_HIT;
+            damageInfo->procVictim   = PROC_FLAG_TAKEN_MELEE_HIT;//|PROC_FLAG_TAKEN_OFFHAND_HIT // not used
+            damageInfo->HitInfo = HITINFO_LEFTSWING;
+            break;
+        case RANGED_ATTACK:
+            damageInfo->procAttacker = PROC_FLAG_SUCCESSFUL_RANGED_HIT;
+            damageInfo->procVictim   = PROC_FLAG_TAKEN_RANGED_HIT;
+            damageInfo->HitInfo = 0x08;// test
+            break;
+        default:
+            break;
+    }
+
+    // Physical Immune check
+    if(damageInfo->target->IsImmunedToDamage(SpellSchoolMask(damageInfo->damageSchoolMask),true))
+    {
+       damageInfo->HitInfo       |= HITINFO_NORMALSWING;
+       damageInfo->TargetState    = VICTIMSTATE_IS_IMMUNE;
+
+       damageInfo->procEx |=PROC_EX_IMMUNE;
+       damageInfo->damage         = 0;
+       damageInfo->cleanDamage    = 0;
+       return;
+    }
+    damage += CalculateDamage (damageInfo->attackType, false); 
+    // Add melee damage bonus
+    MeleeDamageBonus(damageInfo->target, &damage, damageInfo->attackType);
+    // Calculate armor reduction
+    damageInfo->damage = CalcArmorReducedDamage(damageInfo->target, damage);
+    damageInfo->cleanDamage += damage - damageInfo->damage;
+    
+    damageInfo->hitOutCome = RollMeleeOutcomeAgainst(damageInfo->target, damageInfo->attackType);
+
+    // Disable parry or dodge for ranged attack
+    if(damageInfo->attackType == RANGED_ATTACK)
+    {
+        if (damageInfo->hitOutCome == MELEE_HIT_PARRY) damageInfo->hitOutCome = MELEE_HIT_NORMAL;
+        if (damageInfo->hitOutCome == MELEE_HIT_DODGE) damageInfo->hitOutCome = MELEE_HIT_MISS;
+    }
+
+    switch(damageInfo->hitOutCome)
+    {
+        case MELEE_HIT_EVADE:
+        {
+            damageInfo->HitInfo    |= HITINFO_MISS|HITINFO_SWINGNOHITSOUND;
+            damageInfo->TargetState = VICTIMSTATE_EVADES;
+
+            damageInfo->procEx|=PROC_EX_EVADE;
+            damageInfo->damage = 0;
+            damageInfo->cleanDamage = 0;
+            return;
+        }
+        case MELEE_HIT_MISS:
+        {
+            damageInfo->HitInfo    |= HITINFO_MISS;
+            damageInfo->TargetState = VICTIMSTATE_NORMAL;
+
+            damageInfo->procEx|=PROC_EX_MISS;
+            damageInfo->damage = 0;
+            damageInfo->cleanDamage = 0;
+            break;
+        }
+        case MELEE_HIT_NORMAL:
+            damageInfo->TargetState = VICTIMSTATE_NORMAL;
+            damageInfo->procEx|=PROC_EX_NORMAL_HIT;
+            break;
+        case MELEE_HIT_CRIT:
+        {
+            damageInfo->HitInfo     |= HITINFO_CRITICALHIT;
+            damageInfo->TargetState  = VICTIMSTATE_NORMAL;
+
+            damageInfo->procEx|=PROC_EX_CRITICAL_HIT;
+            // Crit bonus calc
+            damageInfo->damage += damageInfo->damage;
+            int32 mod=0;
+            // Apply SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE or SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE
+            if(damageInfo->attackType == RANGED_ATTACK)
+                mod += damageInfo->target->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE);
+            else
+            {
+                mod += damageInfo->target->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE);
+                mod += GetTotalAuraModifier(SPELL_AURA_MOD_CRIT_DAMAGE_BONUS_MELEE);
+            }
+        
+            uint32 crTypeMask = damageInfo->target->GetCreatureTypeMask();
+
+            // Increase crit damage from SPELL_AURA_MOD_CRIT_PERCENT_VERSUS
+            mod += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_CRIT_PERCENT_VERSUS, crTypeMask);
+            if (mod!=0)
+                damageInfo->damage = int32((damageInfo->damage) * float((100.0f + mod)/100.0f));
+
+            // Resilience - reduce crit damage
+            if (pVictim->GetTypeId()==TYPEID_PLAYER)
+            {
+                uint32 resilienceReduction = ((Player*)pVictim)->GetMeleeCritDamageReduction(damageInfo->damage);
+                damageInfo->damage      -= resilienceReduction;
+                damageInfo->cleanDamage += resilienceReduction;
+            }
+            break;
+        }
+        case MELEE_HIT_PARRY:
+            damageInfo->TargetState  = VICTIMSTATE_PARRY;
+            damageInfo->procEx|=PROC_EX_PARRY;
+            damageInfo->cleanDamage += damageInfo->damage;
+            damageInfo->damage = 0;
+            break;
+
+        case MELEE_HIT_DODGE:
+            damageInfo->TargetState  = VICTIMSTATE_DODGE;
+            damageInfo->procEx|=PROC_EX_DODGE;
+            damageInfo->cleanDamage += damageInfo->damage;
+            damageInfo->damage = 0;
+            break;
+        case MELEE_HIT_BLOCK:
+        {
+            damageInfo->TargetState = VICTIMSTATE_NORMAL;
+            damageInfo->procEx|=PROC_EX_BLOCK;
+            damageInfo->blocked_amount = damageInfo->target->GetShieldBlockValue();
+            if (damageInfo->blocked_amount >= damageInfo->damage)
+            {
+                damageInfo->TargetState = VICTIMSTATE_BLOCKS;
+                damageInfo->blocked_amount = damageInfo->damage;
+            }
+            damageInfo->damage      -= damageInfo->blocked_amount;
+            damageInfo->cleanDamage += damageInfo->blocked_amount;
+            break;
+        }
+        case MELEE_HIT_GLANCING:
+        {
+            damageInfo->HitInfo     |= HITINFO_GLANCING;
+            damageInfo->TargetState  = VICTIMSTATE_NORMAL;
+            damageInfo->procEx|=PROC_EX_NORMAL_HIT;
+            float reducePercent = 1.0f;                     //damage factor
+            // calculate base values and mods
+            float baseLowEnd = 1.3;
+            float baseHighEnd = 1.2;
+            switch(getClass())                              // lowering base values for casters
+            {
+                case CLASS_SHAMAN:
+                case CLASS_PRIEST:
+                case CLASS_MAGE:
+                case CLASS_WARLOCK:
+                case CLASS_DRUID:
+                    baseLowEnd  -= 0.7;
+                    baseHighEnd -= 0.3;
+                    break;
+            }
+
+            float maxLowEnd = 0.6;
+            switch(getClass())                              // upper for melee classes
+            {
+                case CLASS_WARRIOR:
+                case CLASS_ROGUE:
+                    maxLowEnd = 0.91;                       //If the attacker is a melee class then instead the lower value of 0.91
+            }
+
+            // calculate values
+            int32 diff = damageInfo->target->GetDefenseSkillValue() - GetWeaponSkillValue(damageInfo->attackType);
+            float lowEnd  = baseLowEnd - ( 0.05f * diff );
+            float highEnd = baseHighEnd - ( 0.03f * diff );
+
+            // apply max/min bounds
+            if ( lowEnd < 0.01f )                           //the low end must not go bellow 0.01f
+                lowEnd = 0.01f;
+            else if ( lowEnd > maxLowEnd )                  //the smaller value of this and 0.6 is kept as the low end
+                lowEnd = maxLowEnd;
+
+            if ( highEnd < 0.2f )                           //high end limits
+                highEnd = 0.2f;
+            if ( highEnd > 0.99f )
+                highEnd = 0.99f;
+
+            if(lowEnd > highEnd)                            // prevent negative range size
+                lowEnd = highEnd;
+
+            reducePercent = lowEnd + rand_norm() * ( highEnd - lowEnd );
+ 
+            damageInfo->cleanDamage += damageInfo->damage-uint32(reducePercent *  damageInfo->damage);
+            damageInfo->damage   = uint32(reducePercent *  damageInfo->damage);
+            break;
+        }
+        case MELEE_HIT_CRUSHING:
+        {
+            damageInfo->HitInfo     |= HITINFO_CRUSHING;
+            damageInfo->TargetState  = VICTIMSTATE_NORMAL;
+            damageInfo->procEx|=PROC_EX_NORMAL_HIT;
+            // 150% normal damage
+            damageInfo->damage += (damageInfo->damage / 2);
+            break;
+        }
+        default:
+
+            break;
+    }
+
+    // Calculate absorb resist
+    if(int32(damageInfo->damage) > 0)
+    {
+        damageInfo->procVictim |= PROC_FLAG_TAKEN_ANY_DAMAGE;
+        // Calculate absorb & resists
+        CalcAbsorbResist(damageInfo->target, SpellSchoolMask(damageInfo->damageSchoolMask), DIRECT_DAMAGE, damageInfo->damage, &damageInfo->absorb, &damageInfo->resist);
+        damageInfo->damage-=damageInfo->absorb + damageInfo->resist;
+        if (damageInfo->absorb)
+        {
+            damageInfo->HitInfo|=HITINFO_ABSORB;
+            damageInfo->procEx|=PROC_EX_ABSORB;
+        }
+        if (damageInfo->resist)
+            damageInfo->HitInfo|=HITINFO_RESIST;
+
+    }
+    else // Umpossible get negative result but....
+        damageInfo->damage = 0;
+}
+
+void Unit::DealMeleeDamage(CalcDamageInfo *damageInfo, bool durabilityLoss)
+{
+    if (damageInfo==0) return;
+    Unit *pVictim = damageInfo->target;
+
+    if(!this || !pVictim)
+        return;
+
+    if (!pVictim->isAlive() || pVictim->isInFlight() || pVictim->GetTypeId() == TYPEID_UNIT && ((Creature*)pVictim)->IsInEvadeMode())
+        return;
+
+    //You don't lose health from damage taken from another player while in a sanctuary
+    //You still see it in the combat log though
+    if(pVictim != this && GetTypeId() == TYPEID_PLAYER && pVictim->GetTypeId() == TYPEID_PLAYER)
+    {
+        const AreaTableEntry *area = GetAreaEntryByAreaID(pVictim->GetAreaId());
+        if(area && area->flags & 0x800)                     //sanctuary
+            return;
+    }
+
+    // Hmmmm dont like this emotes cloent must by self do all animations
+    if (damageInfo->HitInfo&HITINFO_CRITICALHIT)
+        pVictim->HandleEmoteCommand(EMOTE_ONESHOT_WOUNDCRITICAL);
+    if(damageInfo->blocked_amount && damageInfo->TargetState!=VICTIMSTATE_BLOCKS)
+        pVictim->HandleEmoteCommand(EMOTE_ONESHOT_PARRYSHIELD);
+
+    if(damageInfo->TargetState == VICTIMSTATE_PARRY)
+    {
+        // Get attack timers
+        float offtime  = float(pVictim->getAttackTimer(OFF_ATTACK));
+        float basetime = float(pVictim->getAttackTimer(BASE_ATTACK));
+        // Reduce attack time
+        if (pVictim->haveOffhandWeapon() && offtime < basetime)
+        {
+            float percent20 = pVictim->GetAttackTime(OFF_ATTACK) * 0.20;
+            float percent60 = 3 * percent20;
+            if(offtime > percent20 && offtime <= percent60)
+            {
+                pVictim->setAttackTimer(OFF_ATTACK, uint32(percent20));
+            }
+            else if(offtime > percent60)
+            {
+                offtime -= 2 * percent20;
+                pVictim->setAttackTimer(OFF_ATTACK, uint32(offtime));
+            }
+        }
+        else
+        {
+            float percent20 = pVictim->GetAttackTime(BASE_ATTACK) * 0.20;
+            float percent60 = 3 * percent20;
+            if(basetime > percent20 && basetime <= percent60)
+            {
+                pVictim->setAttackTimer(BASE_ATTACK, uint32(percent20));
+            }
+            else if(basetime > percent60)
+            {
+                basetime -= 2 * percent20;
+                pVictim->setAttackTimer(BASE_ATTACK, uint32(basetime));
+            }
+        }
+    }
+
+    // Call default DealDamage
+    CleanDamage cleanDamage(damageInfo->cleanDamage,damageInfo->attackType,damageInfo->hitOutCome);
+    DealDamage(pVictim, damageInfo->damage, &cleanDamage, DIRECT_DAMAGE, SpellSchoolMask(damageInfo->damageSchoolMask), NULL, durabilityLoss);
+
+    // If this is a creature and it attacks from behind it has a probability to daze it's victim
+    if( (damageInfo->hitOutCome==MELEE_HIT_CRIT || damageInfo->hitOutCome==MELEE_HIT_CRUSHING || damageInfo->hitOutCome==MELEE_HIT_NORMAL || damageInfo->hitOutCome==MELEE_HIT_GLANCING) &&
+        GetTypeId() != TYPEID_PLAYER && !((Creature*)this)->GetCharmerOrOwnerGUID() && !pVictim->HasInArc(M_PI, this) )
+    {
+        // -probability is between 0% and 40%
+        // 20% base chance
+        float Probability = 20;
+
+        //there is a newbie protection, at level 10 just 7% base chance; assuming linear function
+        if( pVictim->getLevel() < 30 )
+            Probability = 0.65f*pVictim->getLevel()+0.5;
+
+        uint32 VictimDefense=pVictim->GetDefenseSkillValue();
+        uint32 AttackerMeleeSkill=GetUnitMeleeSkill();
+
+        Probability *= AttackerMeleeSkill/(float)VictimDefense;
+
+        if(Probability > 40)
+            Probability = 40;
+
+        if(roll_chance_f(Probability))
+            CastSpell(pVictim, 1604, true);
+    }
+
+    // update at damage Judgement aura duration that applied by attacker at victim
+    if(damageInfo->damage)
+    {
+        AuraMap& vAuras = pVictim->GetAuras();
+        for(AuraMap::iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
+        {
+            SpellEntry const *spellInfo = (*itr).second->GetSpellProto();
+            if( spellInfo->AttributesEx3 & 0x40000 && spellInfo->SpellFamilyName == SPELLFAMILY_PALADIN && ((*itr).second->GetCasterGUID() == GetGUID()))
+            {
+                (*itr).second->SetAuraDuration((*itr).second->GetAuraMaxDuration());
+                (*itr).second->UpdateAuraDuration();
+            }
+        }
+    }
+
+    // If not miss
+    if (!(damageInfo->HitInfo & HITINFO_MISS))
+    {
+        if(GetTypeId() == TYPEID_PLAYER && pVictim->isAlive())
+        {
+            for(int i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
+                ((Player*)this)->CastItemCombatSpell(((Player*)this)->GetItemByPos(INVENTORY_SLOT_BAG_0,i), pVictim, damageInfo->attackType);
+        }
+
+        // victim's damage shield
+        std::set<Aura*> alreadyDone;
+        uint32 removedAuras = pVictim->m_removedAuras;
+        AuraList const& vDamageShields = pVictim->GetAurasByType(SPELL_AURA_DAMAGE_SHIELD);
+        for(AuraList::const_iterator i = vDamageShields.begin(), next = vDamageShields.begin(); i != vDamageShields.end(); i = next)
+        {
+           next++;
+           if (alreadyDone.find(*i) == alreadyDone.end())
+           {
+               alreadyDone.insert(*i);
+               uint32 damage=(*i)->GetModifier()->m_amount;
+               SpellEntry const *spellProto = sSpellStore.LookupEntry((*i)->GetId());
+               if(!spellProto)
+                   continue;
+               //Calculate absorb resist ??? no data in opcode for this possibly unable to absorb or resist?
+               //uint32 absorb;
+               //uint32 resist;
+               //CalcAbsorbResist(pVictim, SpellSchools(spellProto->School), SPELL_DIRECT_DAMAGE, damage, &absorb, &resist);
+               //damage-=absorb + resist;
+               
+               WorldPacket data(SMSG_SPELLDAMAGESHIELD,(8+8+4+4));
+               data << uint64(pVictim->GetGUID());
+               data << uint64(GetGUID());
+               data << uint32(spellProto->SchoolMask);
+               data << uint32(damage);
+               pVictim->SendMessageToSet(&data, true ); 
+
+               pVictim->DealDamage(this, damage, 0, SPELL_DIRECT_DAMAGE, GetSpellSchoolMask(spellProto), spellProto, true);
+
+               if (pVictim->m_removedAuras > removedAuras)
+               {
+                   removedAuras = pVictim->m_removedAuras;
+                   next = vDamageShields.begin();
+               }
+           }
+        }
+    }
+}
+
 
 void Unit::HandleEmoteCommand(uint32 anim_id)
 {
@@ -1707,6 +2306,7 @@ void Unit::CalcAbsorbResist(Unit *pVictim,SpellSchoolMask schoolMask, DamageEffe
     *absorb = damage - RemainingDamage - *resist;
 }
 
+/*
 void Unit::DoAttackDamage (Unit *pVictim, uint32 *damage, CleanDamage *cleanDamage, uint32 *blocked_amount, SpellSchoolMask damageSchoolMask, uint32 *hitInfo, VictimState *victimState, uint32 *absorbDamage, uint32 *resistDamage, WeaponAttackType attType, SpellEntry const *spellCasted, bool isTriggeredSpell)
 {
     MeleeHitOutcome outcome;
@@ -1807,7 +2407,7 @@ void Unit::DoAttackDamage (Unit *pVictim, uint32 *damage, CleanDamage *cleanDama
                 AuraList const& mDamageDoneVersus = GetAurasByType(SPELL_AURA_MOD_CRIT_PERCENT_VERSUS);
                 for(AuraList::const_iterator i = mDamageDoneVersus.begin();i != mDamageDoneVersus.end(); ++i)
                     if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-                        crit_bonus = uint32(crit_bonus * ((*i)->GetModifier()->m_amount+100.0f)/100.0f);
+                        crit_bonus = uint32(crit_bonus * ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount +100.0f)/100.0f);
             }
 
             *damage += crit_bonus;
@@ -2142,7 +2742,7 @@ void Unit::DoAttackDamage (Unit *pVictim, uint32 *damage, CleanDamage *cleanDama
         if (alreadyDone.find(*i) == alreadyDone.end())
         {
             alreadyDone.insert(*i);
-            pVictim->SpellNonMeleeDamageLog(this, (*i)->GetId(), (*i)->GetModifier()->m_amount, false, false);
+            pVictim->SpellNonMeleeDamageLog(this, (*i)->GetId(), (*i)->GetModifier()->m_amount * (*i)->m_stackAmount, false, false);
             if (pVictim->m_removedAuras > removedAuras)
             {
                 removedAuras = pVictim->m_removedAuras;
@@ -2150,7 +2750,7 @@ void Unit::DoAttackDamage (Unit *pVictim, uint32 *damage, CleanDamage *cleanDama
             }
         }
     }
-}
+}*/
 
 void Unit::AttackerStateUpdate (Unit *pVictim, WeaponAttackType attType, bool extra )
 {
@@ -2192,65 +2792,19 @@ void Unit::AttackerStateUpdate (Unit *pVictim, WeaponAttackType attType, bool ex
         return;
     }
 
-    VictimState victimState = VICTIMSTATE_NORMAL;
-
-    CleanDamage cleanDamage = CleanDamage(0, BASE_ATTACK, MELEE_HIT_NORMAL );
-    uint32   blocked_dmg = 0;
-    uint32   absorbed_dmg = 0;
-    uint32   resisted_dmg = 0;
-
-    SpellSchoolMask meleeSchoolMask = GetMeleeDamageSchoolMask();
-
-    if(pVictim->IsImmunedToDamage(meleeSchoolMask,true))    // use charges
-    {
-        SendAttackStateUpdate (HITINFO_NORMALSWING, pVictim, 1, meleeSchoolMask, 0, 0, 0, VICTIMSTATE_IS_IMMUNE, 0);
-
-        // not recent extra attack only at any non extra attack (miss case)
-        if(!extra && extraAttacks)
-        {
-            while(m_extraAttacks)
-            {
-                AttackerStateUpdate(pVictim, BASE_ATTACK, true);
-                if(m_extraAttacks > 0)
-                    --m_extraAttacks;
-            }
-        }
-
-        return;
-    }
-
-    uint32 damage = CalculateDamage (attType, false);
-
-    DoAttackDamage (pVictim, &damage, &cleanDamage, &blocked_dmg, meleeSchoolMask, &hitInfo, &victimState, &absorbed_dmg, &resisted_dmg, attType);
-
-    if (hitInfo & HITINFO_MISS)
-        //send miss
-        SendAttackStateUpdate (hitInfo, pVictim, 1, meleeSchoolMask, damage, absorbed_dmg, resisted_dmg, victimState, blocked_dmg);
-    else
-    {
-        //do animation
-        SendAttackStateUpdate (hitInfo, pVictim, 1, meleeSchoolMask, damage, absorbed_dmg, resisted_dmg, victimState, blocked_dmg);
-
-        if (damage > (absorbed_dmg + resisted_dmg + blocked_dmg))
-            damage -= (absorbed_dmg + resisted_dmg + blocked_dmg);
-        else
-            damage = 0;
-
-        DealDamage (pVictim, damage, &cleanDamage, DIRECT_DAMAGE, meleeSchoolMask, NULL, true);
-
-        if(GetTypeId() == TYPEID_PLAYER && pVictim->isAlive())
-        {
-            for(int i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
-                ((Player*)this)->CastItemCombatSpell(((Player*)this)->GetItemByPos(INVENTORY_SLOT_BAG_0,i),pVictim,attType);
-        }
-    }
+    CalcDamageInfo damageInfo;
+    CalculateMeleeDamage(pVictim, 0, &damageInfo, attType);
+    // Send log damage message to client
+    SendAttackStateUpdate(&damageInfo);
+    ProcDamageAndSpell(damageInfo.target, damageInfo.procAttacker, damageInfo.procVictim, damageInfo.procEx, damageInfo.damage, damageInfo.attackType);
+    DealMeleeDamage(&damageInfo,true);
 
     if (GetTypeId() == TYPEID_PLAYER)
         DEBUG_LOG("AttackerStateUpdate: (Player) %u attacked %u (TypeId: %u) for %u dmg, absorbed %u, blocked %u, resisted %u.",
-            GetGUIDLow(), pVictim->GetGUIDLow(), pVictim->GetTypeId(), damage, absorbed_dmg, blocked_dmg, resisted_dmg);
+            GetGUIDLow(), pVictim->GetGUIDLow(), pVictim->GetTypeId(), damageInfo.damage, damageInfo.absorb, damageInfo.blocked_amount, damageInfo.resist);
     else
         DEBUG_LOG("AttackerStateUpdate: (NPC)    %u attacked %u (TypeId: %u) for %u dmg, absorbed %u, blocked %u, resisted %u.",
-            GetGUIDLow(), pVictim->GetGUIDLow(), pVictim->GetTypeId(), damage, absorbed_dmg, blocked_dmg, resisted_dmg);
+            GetGUIDLow(), pVictim->GetGUIDLow(), pVictim->GetTypeId(), damageInfo.damage, damageInfo.absorb, damageInfo.blocked_amount, damageInfo.resist);
 
     // extra attack only at any non extra attack (normal case)
     if(!extra && extraAttacks)
@@ -2264,6 +2818,7 @@ void Unit::AttackerStateUpdate (Unit *pVictim, WeaponAttackType attType, bool ex
     }
 }
 
+/*
 MeleeHitOutcome Unit::RollPhysicalOutcomeAgainst (Unit const *pVictim, WeaponAttackType attType, SpellEntry const *spellInfo)
 {
     // Miss chance based on melee
@@ -2322,7 +2877,7 @@ MeleeHitOutcome Unit::RollPhysicalOutcomeAgainst (Unit const *pVictim, WeaponAtt
     DEBUG_LOG("PHYSICAL OUTCOME: miss %f crit %f dodge %f parry %f block %f",miss_chance,crit_chance,dodge_chance,parry_chance, block_chance);
 
     return RollMeleeOutcomeAgainst(pVictim, attType, int32(crit_chance*100), int32(miss_chance*100),int32(dodge_chance*100),int32(parry_chance*100),int32(block_chance*100), true);
-}
+}*/
 
 MeleeHitOutcome Unit::RollMeleeOutcomeAgainst(const Unit *pVictim, WeaponAttackType attType) const
 {
@@ -2593,7 +3148,18 @@ void Unit::SendAttackStop(Unit* victim)
     ((Creature*)victim)->AI().EnterEvadeMode(this);*/
 }
 
-/*
+bool Unit::isSpellBlocked(Unit *pVictim, SpellEntry const *spellProto, WeaponAttackType attackType)
+{
+    if (pVictim->HasInArc(M_PI,this))
+    {
+        float blockChance = GetUnitBlockChance();
+        blockChance += (GetWeaponSkillValue(attackType) - pVictim->GetMaxSkillValueForLevel() )*0.04;
+        if (roll_chance_f(blockChance))
+            return true;
+    }
+    return false;
+}
+
 // Melee based spells can be miss, parry or dodge on this step
 // Crit or block - determined on damage calculation phase! (and can be both in some time)
 float Unit::MeleeSpellMissChance(Unit *pVictim, WeaponAttackType attType, int32 skillDiff, SpellEntry const *spell)
@@ -2717,7 +3283,7 @@ SpellMissInfo Unit::MeleeSpellHitResult(Unit *pVictim, SpellEntry const *spell)
         return SPELL_MISS_PARRY;
 
     return SPELL_MISS_NONE;
-}*/
+}
 
 // TODO need use unit spell resistances in calculations
 SpellMissInfo Unit::MagicSpellHitResult(Unit *pVictim, SpellEntry const *spell)
@@ -2787,6 +3353,14 @@ SpellMissInfo Unit::MagicSpellHitResult(Unit *pVictim, SpellEntry const *spell)
     return SPELL_MISS_NONE;
 }
 
+// Calculate spell hit result can be:
+// Every spell can: Evade/Immune/Reflect/Sucesful hit
+// For melee based spells:
+//   Miss
+//   Dodge
+//   Parry
+// For spells
+//   Resist 
 SpellMissInfo Unit::SpellHitResult(Unit *pVictim, SpellEntry const *spell, bool CanReflect)
 {
     // Return evade for units in evade mode
@@ -2809,62 +3383,24 @@ SpellMissInfo Unit::SpellHitResult(Unit *pVictim, SpellEntry const *spell, bool
     // Try victim reflect spell
     if (CanReflect)
     {
-        // specialized first
+        int32 reflectchance = pVictim->GetTotalAuraModifier(SPELL_AURA_REFLECT_SPELLS);
         Unit::AuraList const& mReflectSpellsSchool = pVictim->GetAurasByType(SPELL_AURA_REFLECT_SPELLS_SCHOOL);
         for(Unit::AuraList::const_iterator i = mReflectSpellsSchool.begin(); i != mReflectSpellsSchool.end(); ++i)
-        {
             if((*i)->GetModifier()->m_miscvalue & GetSpellSchoolMask(spell))
-            {
-                int32 reflectchance = (*i)->GetModifier()->m_amount;
-                if (reflectchance > 0 && roll_chance_i(reflectchance))
-                {
-                    if((*i)->m_procCharges > 0)
-                    {
-                        --(*i)->m_procCharges;
-                        if((*i)->m_procCharges==0)
-                            pVictim->RemoveAurasDueToSpell((*i)->GetId());
-                    }
-                    return SPELL_MISS_REFLECT;
-                }
-            }
-        }
-
-        // generic reflection
-        Unit::AuraList const& mReflectSpells = pVictim->GetAurasByType(SPELL_AURA_REFLECT_SPELLS);
-        for(Unit::AuraList::const_iterator i = mReflectSpells.begin(); i != mReflectSpells.end(); ++i)
+                reflectchance += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
+        if (reflectchance > 0 && roll_chance_i(reflectchance))
         {
-            int32 reflectchance = (*i)->GetModifier()->m_amount;
-            if (reflectchance > 0 && roll_chance_i(reflectchance))
-            {
-                if((*i)->m_procCharges > 0)
-                {
-                    --(*i)->m_procCharges;
-                    if((*i)->m_procCharges==0)
-                        pVictim->RemoveAurasDueToSpell((*i)->GetId());
-                }
-                return SPELL_MISS_REFLECT;
-            }
+            // Start triggers for remove charges if need (trigger only for victim, and mark as active spell)
+            ProcDamageAndSpell(pVictim, PROC_FLAG_NONE, PROC_FLAG_TAKEN_NEGATIVE_SPELL_HIT, PROC_EX_REFLECT, 1, BASE_ATTACK, spell);
+            return SPELL_MISS_REFLECT;
         }
     }
 
-    // Temporary solution for melee based spells and spells vs SPELL_SCHOOL_NORMAL (hit result calculated after)
-    for (int i=0;i<3;i++)
-    {
-        if (spell->Effect[i] == SPELL_EFFECT_WEAPON_DAMAGE ||
-            spell->Effect[i] == SPELL_EFFECT_WEAPON_PERCENT_DAMAGE ||
-            spell->Effect[i] == SPELL_EFFECT_NORMALIZED_WEAPON_DMG ||
-            spell->Effect[i] == SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL)
-            return SPELL_MISS_NONE;
-    }
-
-    // TODO need use this code for spell hit result calculation
-    // now code commented for compotability
     switch (spell->DmgClass)
     {
         case SPELL_DAMAGE_CLASS_RANGED:
         case SPELL_DAMAGE_CLASS_MELEE:
-//             return MeleeSpellHitResult(pVictim, spell);
-            return SPELL_MISS_NONE;
+            return MeleeSpellHitResult(pVictim, spell);
         case SPELL_DAMAGE_CLASS_NONE:
         case SPELL_DAMAGE_CLASS_MAGIC:
             return MagicSpellHitResult(pVictim, spell);
@@ -3448,7 +3984,7 @@ int32 Unit::GetTotalAuraModifier(AuraType auratype) const
 
     AuraList const& mTotalAuraList = GetAurasByType(auratype);
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
-        modifier += (*i)->GetModifier()->m_amount;
+        modifier += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
 
     return modifier;
 }
@@ -3459,7 +3995,7 @@ float Unit::GetTotalAuraMultiplier(AuraType auratype) const
 
     AuraList const& mTotalAuraList = GetAurasByType(auratype);
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
-        multipler *= (100.0f + (*i)->GetModifier()->m_amount)/100.0f;
+        multipler *= (100.0f + (*i)->GetModifier()->m_amount * (*i)->m_stackAmount)/100.0f;
 
     return multipler;
 }
@@ -3470,8 +4006,11 @@ int32 Unit::GetMaxPositiveAuraModifier(AuraType auratype) const
 
     AuraList const& mTotalAuraList = GetAurasByType(auratype);
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
-        if ((*i)->GetModifier()->m_amount > modifier)
-            modifier = (*i)->GetModifier()->m_amount;
+    {
+        int32 amount = (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
+        if (amount > modifier)
+            modifier = amount;
+    }
 
     return modifier;
 }
@@ -3482,8 +4021,11 @@ int32 Unit::GetMaxNegativeAuraModifier(AuraType auratype) const
 
     AuraList const& mTotalAuraList = GetAurasByType(auratype);
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
-        if ((*i)->GetModifier()->m_amount < modifier)
-            modifier = (*i)->GetModifier()->m_amount;
+    {
+        int32 amount = (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
+        if (amount < modifier)
+            modifier = amount;
+    }
 
     return modifier;
 }
@@ -3497,7 +4039,7 @@ int32 Unit::GetTotalAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask)
     {
         Modifier* mod = (*i)->GetModifier();
         if (mod->m_miscvalue & misc_mask)
-            modifier += mod->m_amount;
+            modifier += mod->m_amount * (*i)->m_stackAmount;
     }
     return modifier;
 }
@@ -3511,7 +4053,7 @@ float Unit::GetTotalAuraMultiplierByMiscMask(AuraType auratype, uint32 misc_mask
     {
         Modifier* mod = (*i)->GetModifier();
         if (mod->m_miscvalue & misc_mask)
-            multipler *= (100.0f + mod->m_amount)/100.0f;
+            multipler *= (100.0f + mod->m_amount * (*i)->m_stackAmount)/100.0f;
     }
     return multipler;
 }
@@ -3524,8 +4066,9 @@ int32 Unit::GetMaxPositiveAuraModifierByMiscMask(AuraType auratype, uint32 misc_
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
     {
         Modifier* mod = (*i)->GetModifier();
-        if (mod->m_miscvalue & misc_mask && mod->m_amount > modifier)
-            modifier = mod->m_amount;
+        int32 amount = mod->m_amount * (*i)->m_stackAmount;
+        if (mod->m_miscvalue & misc_mask && amount > modifier)
+            modifier = amount;
     }
 
     return modifier;
@@ -3539,8 +4082,9 @@ int32 Unit::GetMaxNegativeAuraModifierByMiscMask(AuraType auratype, uint32 misc_
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
     {
         Modifier* mod = (*i)->GetModifier();
-        if (mod->m_miscvalue & misc_mask && mod->m_amount < modifier)
-            modifier = mod->m_amount;
+        int32 amount = mod->m_amount * (*i)->m_stackAmount;
+        if (mod->m_miscvalue & misc_mask && amount < modifier)
+            modifier = amount;
     }
 
     return modifier;
@@ -3555,7 +4099,7 @@ int32 Unit::GetTotalAuraModifierByMiscValue(AuraType auratype, int32 misc_value)
     {
         Modifier* mod = (*i)->GetModifier();
         if (mod->m_miscvalue == misc_value)
-            modifier += mod->m_amount;
+            modifier += mod->m_amount * (*i)->m_stackAmount;
     }
     return modifier;
 }
@@ -3569,7 +4113,7 @@ float Unit::GetTotalAuraMultiplierByMiscValue(AuraType auratype, int32 misc_valu
     {
         Modifier* mod = (*i)->GetModifier();
         if (mod->m_miscvalue == misc_value)
-            multipler *= (100.0f + mod->m_amount)/100.0f;
+            multipler *= (100.0f + mod->m_amount * (*i)->m_stackAmount)/100.0f;
     }
     return multipler;
 }
@@ -3582,8 +4126,9 @@ int32 Unit::GetMaxPositiveAuraModifierByMiscValue(AuraType auratype, int32 misc_
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
     {
         Modifier* mod = (*i)->GetModifier();
-        if (mod->m_miscvalue == misc_value && mod->m_amount > modifier)
-            modifier = mod->m_amount;
+        int32 amount = mod->m_amount * (*i)->m_stackAmount;
+        if (mod->m_miscvalue == misc_value && amount > modifier)
+            modifier = amount;
     }
 
     return modifier;
@@ -3597,8 +4142,9 @@ int32 Unit::GetMaxNegativeAuraModifierByMiscValue(AuraType auratype, int32 misc_
     for(AuraList::const_iterator i = mTotalAuraList.begin();i != mTotalAuraList.end(); ++i)
     {
         Modifier* mod = (*i)->GetModifier();
-        if (mod->m_miscvalue == misc_value && mod->m_amount < modifier)
-            modifier = mod->m_amount;
+        int32 amount = mod->m_amount * (*i)->m_stackAmount;
+        if (mod->m_miscvalue == misc_value && amount < modifier)
+            modifier = amount;
     }
 
     return modifier;
@@ -3607,7 +4153,7 @@ int32 Unit::GetMaxNegativeAuraModifierByMiscValue(AuraType auratype, int32 misc_
 bool Unit::AddAura(Aura *Aur)
 {
     // ghost spell check, allow apply any auras at player loading in ghost mode (will be cleanup after load)
-    if( !isAlive() && Aur->GetId() != 20584 && Aur->GetId() != 8326 && Aur->GetId() != 2584 &&
+    if( !isAlive() && Aur->GetId() != 20584 && Aur->GetId() != 8326 && Aur->GetId() != SPELL_WAITING_FOR_RESURRECT &&
         (GetTypeId()!=TYPEID_PLAYER || !((Player*)this)->GetSession()->PlayerLoading()) )
     {
         delete Aur;
@@ -3637,8 +4183,10 @@ bool Unit::AddAura(Aura *Aur)
             // replace aura if next will > spell StackAmount
             if(aurSpellInfo->StackAmount)
             {
-                if(m_Auras.count(spair) >= aurSpellInfo->StackAmount)
-                    RemoveAura(i,AURA_REMOVE_BY_STACK);
+                Aur->m_stackAmount = i->second->m_stackAmount;
+                if(Aur->m_stackAmount < aurSpellInfo->StackAmount)
+                    ++Aur->m_stackAmount;
+                RemoveAura(i,AURA_REMOVE_BY_STACK);
             }
             // if StackAmount==0 not allow auras from same caster
             else
@@ -4021,7 +4569,19 @@ void Unit::RemoveSingleAuraFromStack(uint32 spellId, uint32 effindex)
 {
     AuraMap::iterator iter = m_Auras.find(spellEffectPair(spellId, effindex));
     if(iter != m_Auras.end())
+    {
+        if(iter->second->m_stackAmount > 1)
+        {
+            // reapply modifier with reduced stack amount
+            iter->second->ApplyModifier(false,true);
+            --iter->second->m_stackAmount;
+            iter->second->ApplyModifier(true,true);
+
+            iter->second->UpdateSlotCounterAndDuration();
+            return; // not remove aura if stack amount > 1
+        }
         RemoveAura(iter);
+    }
 }
 
 void Unit::RemoveAurasDueToSpell(uint32 spellId, Aura* except)
@@ -4126,6 +4686,9 @@ void Unit::RemoveAura(AuraMap::iterator &i, AuraRemoveMode mode)
 
     sLog.outDebug("Aura %u now is remove mode %d",Aur->GetModifier()->m_auraname, mode);
     Aur->ApplyModifier(false,true);
+
+    Aur->m_stackAmount = 0;
+
     Aur->_RemoveAura();
     delete Aur;
 
@@ -4148,6 +4711,22 @@ void Unit::RemoveAllAuras()
     }
 }
 
+void Unit::RemoveArenaAuras(bool onleave)
+{
+    // in join, remove positive buffs, on end, remove negative
+    // used to remove positive visible auras in arenas
+    for(AuraMap::iterator iter = m_Auras.begin(); iter != m_Auras.end();)
+    {
+        if ( !(iter->second->GetSpellProto()->AttributesEx4 & (1<<21)) // don't remove stances, shadowform, pally/hunter auras
+            && !iter->second->IsPassive()                               // don't remove passive auras
+            && (!(iter->second->GetSpellProto()->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY) || !(iter->second->GetSpellProto()->Attributes & SPELL_ATTR_UNK8))   // not unaffected by invulnerability auras or not having that unknown flag (that seemed the most probable)
+            && (iter->second->IsPositive() ^ onleave))                   // remove positive buffs on enter, negative buffs on leave
+            RemoveAura(iter);
+        else
+            ++iter;
+    }
+}
+
 void Unit::RemoveAllAurasOnDeath()
 {
     // used just after dieing to remove all visible auras
@@ -4336,6 +4915,24 @@ void Unit::RemoveAllGameObjects()
     }
 }
 
+void Unit::SendSpellNonMeleeDamageLog(SpellNonMeleeDamage *log)
+{
+    WorldPacket data(SMSG_SPELLNONMELEEDAMAGELOG, (16+4+4+1+4+4+1+1+4+4+1)); // we guess size
+    data.append(log->target->GetPackGUID());
+    data.append(log->attacker->GetPackGUID());
+    data << uint32(log->SpellID);
+    data << uint32(log->damage);                             //damage amount
+    data << uint8 (log->schoolMask);                         //damage school
+    data << uint32(log->absorb);                             //AbsorbedDamage
+    data << uint32(log->resist);                             //resist
+    data << uint8 (log->phusicalLog);                        // damsge type? flag
+    data << uint8 (log->unused);                             //unused
+    data << uint32(log->blocked);                            //blocked
+    data << uint32(log->HitInfo);
+    data << uint8 (0);                                       // flag to use extend data
+    SendMessageToSet( &data, true );
+}
+
 void Unit::SendSpellNonMeleeDamageLog(Unit *target,uint32 SpellID,uint32 Damage, SpellSchoolMask damageSchoolMask,uint32 AbsorbedDamage, uint32 Resist,bool PhysicalDamage, uint32 Blocked, bool CriticalHit)
 {
     sLog.outDebug("Sending: SMSG_SPELLNONMELEEDAMAGELOG");
@@ -4355,6 +4952,17 @@ void Unit::SendSpellNonMeleeDamageLog(Unit *target,uint32 SpellID,uint32 Damage,
     SendMessageToSet( &data, true );
 }
 
+void Unit::ProcDamageAndSpell(Unit *pVictim, uint32 procAttacker, uint32 procVictim, uint32 procExtra, uint32 amount, WeaponAttackType attType, SpellEntry const *procSpell)
+{
+     // Not much to do if no flags are set.
+    if (procAttacker)
+        ProcDamageAndSpellFor(false,pVictim,procAttacker, procExtra,attType, procSpell, amount);
+    // Now go on with a victim's events'n'auras
+    // Not much to do if no flags are set or there is no victim
+    if(pVictim && pVictim->isAlive() && procVictim)
+        pVictim->ProcDamageAndSpellFor(true,this,procVictim, procExtra, attType, procSpell, amount);
+}
+
 void Unit::SendSpellMiss(Unit *target, uint32 spellID, SpellMissInfo missInfo)
 {
     WorldPacket data(SMSG_SPELLLOGMISS, (4+8+1+4+8+1));
@@ -4369,6 +4977,29 @@ void Unit::SendSpellMiss(Unit *target, uint32 spellID, SpellMissInfo missInfo)
     SendMessageToSet(&data, true);
 }
 
+void Unit::SendAttackStateUpdate(CalcDamageInfo *damageInfo)
+{
+    WorldPacket data(SMSG_ATTACKERSTATEUPDATE, (16+84));    // we guess size
+    data << (uint32)damageInfo->HitInfo;
+    data.append(GetPackGUID());
+    data.append(damageInfo->target->GetPackGUID());
+    data << (uint32)(damageInfo->damage);     // Full damage
+
+    data << (uint8)1;                         // Sub damage count
+    //===  Sub damage description
+    data << (uint32)(damageInfo->damageSchoolMask); // School of sub damage
+    data << (float)damageInfo->damage;        // sub damage
+    data << (uint32)damageInfo->damage;       // Sub Damage
+    data << (uint32)damageInfo->absorb;       // Absorb
+    data << (uint32)damageInfo->resist;       // Resist
+    //=================================================
+    data << (uint32)damageInfo->TargetState;
+    data << (uint32)0;
+    data << (uint32)0;
+    data << (uint32)damageInfo->blocked_amount;
+    SendMessageToSet( &data, true );/**/
+}
+
 void Unit::SendAttackStateUpdate(uint32 HitInfo, Unit *target, uint8 SwingType, SpellSchoolMask damageSchoolMask, uint32 Damage, uint32 AbsorbDamage, uint32 Resist, VictimState TargetState, uint32 BlockedAmount)
 {
     sLog.outDebug("WORLD: Sending SMSG_ATTACKERSTATEUPDATE");
@@ -4402,7 +5033,7 @@ void Unit::SendAttackStateUpdate(uint32 HitInfo, Unit *target, uint8 SwingType,
 
     SendMessageToSet( &data, true );
 }
-
+/*
 void Unit::ProcDamageAndSpell(Unit *pVictim, uint32 procAttacker, uint32 procVictim, uint32 damage, SpellSchoolMask damageSchoolMask, SpellEntry const *procSpell, bool isTriggeredSpell, WeaponAttackType attType)
 {
     sLog.outDebug("ProcDamageAndSpell: attacker flags are 0x%x, victim flags 0x%x", procAttacker, procVictim);
@@ -4536,9 +5167,9 @@ void Unit::CastMeleeProcDamageAndSpell(Unit* pVictim, uint32 damage, SpellSchool
 
     if(procAttacker != PROC_FLAG_NONE || procVictim != PROC_FLAG_NONE)
         ProcDamageAndSpell(pVictim, procAttacker, procVictim, damage, damageSchoolMask, spellCasted, isTriggeredSpell, attType);
-}
+}*/
 
-bool Unit::HandleHasteAuraProc(Unit *pVictim, SpellEntry const *hasteSpell, uint32 /*effIndex*/, uint32 damage, Aura* triggeredByAura, SpellEntry const * procSpell, uint32 /*procFlag*/, uint32 cooldown)
+bool Unit::HandleHasteAuraProc(Unit *pVictim, SpellEntry const *hasteSpell, uint32 /*effIndex*/, uint32 damage, Aura* triggeredByAura, SpellEntry const * procSpell, uint32 /*procFlag*/, uint32 /*procEx*/, uint32 cooldown)
 {
     Item* castItem = triggeredByAura->GetCastItemGUID() && GetTypeId()==TYPEID_PLAYER
         ? ((Player*)this)->GetItemByGuid(triggeredByAura->GetCastItemGUID()) : NULL;
@@ -4599,7 +5230,7 @@ bool Unit::HandleHasteAuraProc(Unit *pVictim, SpellEntry const *hasteSpell, uint
     return true;
 }
 
-bool Unit::HandleDummyAuraProc(Unit *pVictim, SpellEntry const *dummySpell, uint32 effIndex, uint32 damage, Aura* triggeredByAura, SpellEntry const * procSpell, uint32 procFlag, uint32 cooldown)
+bool Unit::HandleDummyAuraProc(Unit *pVictim, SpellEntry const *dummySpell, uint32 effIndex, uint32 damage, Aura* triggeredByAura, SpellEntry const * procSpell, uint32 procFlag, uint32 procEx, uint32 cooldown)
 {
     Item* castItem = triggeredByAura->GetCastItemGUID() && GetTypeId()==TYPEID_PLAYER
         ? ((Player*)this)->GetItemByGuid(triggeredByAura->GetCastItemGUID()) : NULL;
@@ -4709,19 +5340,6 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, SpellEntry const *dummySpell, uint
                     if(!procSpell)
                         return false;
 
-                    // not from DoT
-                    bool found = false;
-                    for(int j = 0; j < 3; ++j)
-                    {
-                        if(procSpell->EffectApplyAuraName[j]==SPELL_AURA_PERIODIC_DAMAGE||procSpell->EffectApplyAuraName[j]==SPELL_AURA_PERIODIC_DAMAGE_PERCENT)
-                        {
-                            found = true;
-                            break;
-                        }
-                    }
-                    if(found)
-                        return false;
-
                     switch(GetFirstSchoolInMask(GetSpellSchoolMask(procSpell)))
                     {
                         case SPELL_SCHOOL_NORMAL:
@@ -4987,6 +5605,16 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, SpellEntry const *dummySpell, uint
                 triggered_spell_id = 29077;
                 break;
             }
+            // Incanter's Regalia set (add trigger chance to Mana Shield)
+            if (dummySpell->SpellFamilyFlags & 0x0000000000008000LL)
+            {
+                if(GetTypeId() != TYPEID_PLAYER)
+                    return false;
+
+                target = this;
+                triggered_spell_id = 37436;
+                break;
+            }
             switch(dummySpell->Id)
             {
                 // Ignite
@@ -5015,14 +5643,14 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, SpellEntry const *dummySpell, uint
                 case 11129:
                 {
                     //last charge and crit
-                    if( triggeredByAura->m_procCharges <= 1 && (procFlag & PROC_FLAG_CRIT_SPELL) )
+                    if (triggeredByAura->m_procCharges <= 1 && (procEx & PROC_EX_CRITICAL_HIT) )
                     {
                         RemoveAurasDueToSpell(28682);       //-> remove Combustion auras
                         return true;                        // charge counting (will removed)
                     }
 
                     CastSpell(this, 28682, true, castItem, triggeredByAura);
-                    return(procFlag & PROC_FLAG_CRIT_SPELL);// charge update only at crit hits, no hidden cooldowns
+                    return (procEx & PROC_EX_CRITICAL_HIT);// charge update only at crit hits, no hidden cooldowns
                 }
             }
             break;
@@ -5039,6 +5667,34 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, SpellEntry const *dummySpell, uint
                 triggered_spell_id = 22858;
                 break;
             }
+            else if (dummySpell->SpellIconID == 1697)  // Second Wind
+            {
+                // only for spells and hit/crit (trigger start always) and not start from self casted spells (5530 Mace Stun Effect for example)
+                if (procSpell == 0 || !(procEx & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)) || this == pVictim)
+                    return false;
+                // Need stun or root mechanic
+                if (procSpell->Mechanic != MECHANIC_ROOT && procSpell->Mechanic != MECHANIC_STUN)
+                {
+                    int32 i;
+                    for (i=0; i<3; i++)
+                        if (procSpell->EffectMechanic[i] == MECHANIC_ROOT || procSpell->EffectMechanic[i] == MECHANIC_STUN)
+                            break;
+                    if (i == 3)
+                        return false;
+                }
+
+                switch (dummySpell->Id)
+                {
+                    case 29838: triggered_spell_id=29842; break;
+                    case 29834: triggered_spell_id=29841; break;
+                    default:
+                        sLog.outError("Unit::HandleDummyAuraProc: non handled spell id: %u (SW)",dummySpell->Id);
+                    return false;
+                }
+
+                target = this;
+                break;
+            }
             break;
         }
         case SPELLFAMILY_WARLOCK:
@@ -5048,7 +5704,6 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, SpellEntry const *dummySpell, uint
             {
                 Modifier* mod = triggeredByAura->GetModifier();
                 // if damage is more than need or target die from damage deal finish spell
-                // FIX ME: not triggered currently at death
                 if( mod->m_amount <= damage || GetHealth() <= damage )
                 {
                     // remember guid before aura delete
@@ -5390,16 +6045,14 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, SpellEntry const *dummySpell, uint
                 switch(triggeredByAura->GetEffIndex())
                 {
                     case 0:
-                        // prevent chain triggering
-                        if(procSpell && procSpell->Id==31893 )
-                            return false;
-
                         triggered_spell_id = 31893;
                         break;
                     case 1:
                     {
                         // damage
-                        basepoints0 = triggeredByAura->GetModifier()->m_amount * damage / 100;
+                        damage += CalculateDamage(BASE_ATTACK, false) * 35 / 100; // add spell damage from prev effect (35%)
+                        basepoints0 =  triggeredByAura->GetModifier()->m_amount * damage / 100;
+
                         target = this;
                         triggered_spell_id = 32221;
                         break;
@@ -5747,7 +6400,7 @@ bool Unit::HandleDummyAuraProc(Unit *pVictim, SpellEntry const *dummySpell, uint
 
     return true;
 }
-
+/*
 bool Unit::HandleProcTriggerSpell(Unit *pVictim, uint32 damage, Aura* triggeredByAura, SpellEntry const *procSpell, uint32 procFlags,WeaponAttackType attackType, uint32 cooldown)
 {
     SpellEntry const* auraSpellInfo = triggeredByAura->GetSpellProto();
@@ -6084,14 +6737,12 @@ bool Unit::HandleProcTriggerSpell(Unit *pVictim, uint32 damage, Aura* triggeredB
                         ((Player*)this)->AddSpellCooldown(37657,0,time(NULL)+(roll_chance_i(50) ? 2 : 3));
 
                         // counting
-                        uint32 count = 0;
-                        AuraList const& dummyAura = GetAurasByType(SPELL_AURA_DUMMY);
-                        for(AuraList::const_iterator itr = dummyAura.begin(); itr != dummyAura.end(); ++itr)
-                            if((*itr)->GetId()==37658)
-                                ++count;
+                        Aura * dummy = GetDummyAura(37658);
+                        if (!dummy)
+                            return false;
 
                         // release at 3 aura in stack
-                        if(count <= 2)
+                        if(dummy->m_stackAmount <= 2)
                             return true;                    // main triggered spell casted anyway
 
                         RemoveAurasDueToSpell(37658);
@@ -6415,6 +7066,650 @@ bool Unit::HandleProcTriggerSpell(Unit *pVictim, uint32 damage, Aura* triggeredB
 
     return true;
 }
+*/
+
+bool Unit::HandleProcTriggerSpell(Unit *pVictim, uint32 damage, Aura* triggeredByAura, SpellEntry const *procSpell, uint32 procFlags, uint32 procEx, uint32 cooldown)
+{
+    // Get triggered aura spell info
+    SpellEntry const* auraSpellInfo = triggeredByAura->GetSpellProto();
+
+    // Basepoints of trigger aura
+    int32 triggerAmount = triggeredByAura->GetModifier()->m_amount;
+
+    // Set trigger spell id, target, custom basepoints
+    uint32 trigger_spell_id = auraSpellInfo->EffectTriggerSpell[triggeredByAura->GetEffIndex()];
+    Unit*  target = NULL;
+    int32  basepoints0 = 0;
+
+    Item* castItem = triggeredByAura->GetCastItemGUID() && GetTypeId()==TYPEID_PLAYER 
+        ? ((Player*)this)->GetItemByGuid(triggeredByAura->GetCastItemGUID()) : NULL;
+
+    // Try handle uncnown trigger spells
+    if (sSpellStore.LookupEntry(trigger_spell_id)==NULL)
+    switch (auraSpellInfo->SpellFamilyName)
+    {
+     //=====================================================================
+     // Generic class
+     // ====================================================================
+     // .....
+     //=====================================================================
+     case SPELLFAMILY_GENERIC:
+//     if (auraSpellInfo->Id==34082)      // Advantaged State (DND)
+//          trigger_spell_id = ???;
+     if (auraSpellInfo->Id == 23780)      // Aegis of Preservation (Aegis of Preservation trinket)
+          trigger_spell_id = 23781;
+//     else if (auraSpellInfo->Id==43504) // Alterac Valley OnKill Proc Aura
+//          trigger_spell_id = ;
+//     else if (auraSpellInfo->Id==37030) // Chaotic Temperament
+//          trigger_spell_id = ;
+     else if (auraSpellInfo->Id==43820)   // Charm of the Witch Doctor (Amani Charm of the Witch Doctor trinket)
+     {
+          // Pct value stored in dummy
+          basepoints0 = pVictim->GetCreateHealth() * auraSpellInfo->EffectBasePoints[1] / 100;
+          target = pVictim;
+          break;
+     }
+//     else if (auraSpellInfo->Id==41248) // Consuming Strikes
+//          trigger_spell_id = 41249;
+//     else if (auraSpellInfo->Id==41054) // Copy Weapon
+//          trigger_spell_id = 41055;
+//     else if (auraSpellInfo->Id==31255) // Deadly Swiftness (Rank 1)
+//          trigger_spell_id = ;
+//     else if (auraSpellInfo->Id==5301)  // Defensive State (DND)
+//          trigger_spell_id = ;
+//     else if (auraSpellInfo->Id==13358) // Defensive State (DND)
+//          trigger_spell_id = ;
+//     else if (auraSpellInfo->Id==16092) // Defensive State (DND)
+//          trigger_spell_id = ;
+//     else if (auraSpellInfo->Id==24949) // Defensive State 2 (DND)
+//          trigger_spell_id = ;
+//     else if (auraSpellInfo->Id==40329) // Demo Shout Sensor
+//          trigger_spell_id = ;
+     // Desperate Defense (Stonescythe Whelp, Stonescythe Alpha, Stonescythe Ambusher)
+     else if (auraSpellInfo->Id == 33896)
+         trigger_spell_id = 33898;
+//     else if (auraSpellInfo->Id==18943) // Double Attack
+//          trigger_spell_id = ;
+//     else if (auraSpellInfo->Id==19194) // Double Attack
+//          trigger_spell_id = ;
+//     else if (auraSpellInfo->Id==19817) // Double Attack
+//          trigger_spell_id = ;
+//     else if (auraSpellInfo->Id==19818) // Double Attack
+//          trigger_spell_id = ;
+//     else if (auraSpellInfo->Id==22835) // Drunken Rage
+//          trigger_spell_id = 14822;
+ /*
+     else if (auraSpellInfo->SpellIconID==191) // Elemental Response
+     {
+         switch (auraSpellInfo->Id && auraSpellInfo->AttributesEx==0)
+         {
+         case 34191:
+         case 34329:
+         case 34524:
+         case 34582:
+         case 36733:break;
+         default:
+             sLog.outError("Unit::HandleProcTriggerSpell: Spell %u miss posibly Elemental Response",auraSpellInfo->Id);
+             return false;
+         }
+         //This generic aura self-triggers a different spell for each school of magic that lands on the wearer:
+         switch (procSpell->School)
+         {
+             case SPELL_SCHOOL_FIRE:   trigger_spell_id = 34192;break;//Fire:     34192
+             case SPELL_SCHOOL_FROST:  trigger_spell_id = 34193;break;//Frost:    34193
+             case SPELL_SCHOOL_ARCANE: trigger_spell_id = 34194;break;//Arcane:   34194
+             case SPELL_SCHOOL_NATURE: trigger_spell_id = 34195;break;//Nature:   34195
+             case SPELL_SCHOOL_SHADOW: trigger_spell_id = 34196;break;//Shadow:   34196
+             case SPELL_SCHOOL_HOLY:   trigger_spell_id = 34197;break;//Holy:     34197
+             case SPELL_SCHOOL_NORMAL: trigger_spell_id = 34198;break;//Physical: 34198
+             default:
+                 sLog.outError("Unit::HandleProcTriggerSpell: Spell %u Elemental Response wrong school",auraSpellInfo->Id);
+             return false;
+         }
+     }*/
+//     else if (auraSpellInfo->Id==6542)  // Enraged Defense
+//          trigger_spell_id = ;
+//     else if (auraSpellInfo->Id==40364) // Entangling Roots Sensor
+//          trigger_spell_id = ;
+//     else if (auraSpellInfo->Id==33207) // Gossip NPC Periodic - Fidget
+//          trigger_spell_id = ;
+//     else if (auraSpellInfo->Id==35321) // Gushing Wound
+//          trigger_spell_id = ;
+//     else if (auraSpellInfo->Id==38363) // Gushing Wound
+//          trigger_spell_id = ;
+//     else if (auraSpellInfo->Id==39215) // Gushing Wound
+//          trigger_spell_id = ;
+//     else if (auraSpellInfo->Id==40250) // Improved Duration
+//          trigger_spell_id = ;
+     else if (auraSpellInfo->Id==27522)   // Mana Drain Trigger
+     {
+         // On successful melee or ranged attack gain $29471s1 mana and if possible drain $27526s1 mana from the target.
+         if (this && this->isAlive())
+             CastSpell(this, 29471, true, castItem, triggeredByAura);
+         if (pVictim && pVictim->isAlive())
+             CastSpell(pVictim, 27526, true, castItem, triggeredByAura);
+         return true;
+     }
+     else if (auraSpellInfo->Id==24905)   // Moonkin Form (Passive)
+     {
+         // Elune's Touch (instead non-existed triggered spell) 30% from AP
+         trigger_spell_id = 33926;
+         basepoints0 = GetTotalAttackPowerValue(BASE_ATTACK) * 30 / 100;
+         target = this;
+     }
+//     else if (auraSpellInfo->Id==43453) // Rune Ward 
+//          trigger_spell_id = ;
+//     else if (auraSpellInfo->Id==7137)  // Shadow Charge (Rank 1)
+//          trigger_spell_id = ;
+       // Shaleskin (Shaleskin Flayer, Shaleskin Ripper) 30023 trigger
+//     else if (auraSpellInfo->Id==36576)
+//          trigger_spell_id = ;
+//     else if (auraSpellInfo->Id==34783) // Spell Reflection
+//          trigger_spell_id = ;
+//     else if (auraSpellInfo->Id==36096) // Spell Reflection
+//          trigger_spell_id = ;
+//     else if (auraSpellInfo->Id==36207) // Steal Weapon
+//          trigger_spell_id = ;
+//     else if (auraSpellInfo->Id==35205) // Vanish
+     break;
+     //=====================================================================
+     // Mage
+     //=====================================================================
+     // Blazing Speed (Rank 1,2) trigger = 18350
+     //=====================================================================
+     case SPELLFAMILY_MAGE:
+     // Blazing Speed
+     if (auraSpellInfo->SpellIconID == 2127)
+     {
+         switch (auraSpellInfo->Id)
+         {
+             case 31641:  // Rank 1
+             case 31642:  // Rank 2
+                 trigger_spell_id = 31643;
+             break;
+             default:
+                 sLog.outError("Unit::HandleProcTriggerSpell: Spell %u miss posibly Blazing Speed",auraSpellInfo->Id);
+             return false;
+         }
+     }
+     break;
+     //=====================================================================
+     // Warrior
+     //=====================================================================
+     // Rampage (Rank 1-3) trigger = 18350
+     //=====================================================================
+     case SPELLFAMILY_WARRIOR:
+     // Rampage
+     if (auraSpellInfo->SpellIconID == 2006 && auraSpellInfo->SpellFamilyFlags==0x100000)
+     {
+         switch(auraSpellInfo->Id)
+         {
+             case 29801: trigger_spell_id = 30029; break;       // Rank 1
+             case 30030: trigger_spell_id = 30031; break;       // Rank 2
+             case 30033: trigger_spell_id = 30032; break;       // Rank 3
+             default:
+                 sLog.outError("Unit::HandleProcTriggerSpell: Spell %u not handled in Rampage",auraSpellInfo->Id);
+             return false;
+         }
+     }
+     break;
+     //=====================================================================
+     // Warlock
+     //=====================================================================
+     // Pyroclasm             trigger = 18350
+     // Drain Soul (Rank 1-5) trigger = 0
+     //=====================================================================
+     case SPELLFAMILY_WARLOCK:
+     {
+         // Pyroclasm
+         if (auraSpellInfo->SpellIconID == 1137)
+         {
+             if(!pVictim || !pVictim->isAlive() || pVictim == this || procSpell == NULL)
+                 return false;
+             // Calculate spell tick count for spells
+             uint32 tick = 1; // Default tick = 1
+
+             // Hellfire have 15 tick
+             if (procSpell->SpellFamilyFlags&0x0000000000000040LL)
+                 tick = 15;
+             // Rain of Fire have 4 tick
+             else if (procSpell->SpellFamilyFlags&0x0000000000000020LL)
+                 tick = 4;
+             else 
+                 return false;
+
+             // Calculate chance = baseChance / tick
+             float chance = 0;
+             switch (auraSpellInfo->Id)
+             {
+                 case 18096: chance = 13.0f / tick; break;
+                 case 18073: chance = 26.0f / tick; break;
+             }
+             // Roll chance
+             if (!roll_chance_f(chance))
+                 return false;
+
+             trigger_spell_id = 18093;
+         }
+         // Drain Soul
+         else if (auraSpellInfo->SpellFamilyFlags & 0x0000000000004000LL)
+         {
+             Unit::AuraList const& mAddFlatModifier = GetAurasByType(SPELL_AURA_ADD_FLAT_MODIFIER);
+             for(Unit::AuraList::const_iterator i = mAddFlatModifier.begin(); i != mAddFlatModifier.end(); ++i)
+             {
+                 if ((*i)->GetModifier()->m_miscvalue == SPELLMOD_CHANCE_OF_SUCCESS && (*i)->GetSpellProto()->SpellIconID == 113)
+                 {
+                     int32 value2 = CalculateSpellDamage((*i)->GetSpellProto(),2,(*i)->GetSpellProto()->EffectBasePoints[2],this);
+                     basepoints0 = value2 * GetMaxPower(POWER_MANA) / 100;
+                 }
+             }
+             if ( basepoints0 == 0 )
+                 return false;
+             trigger_spell_id = 18371;
+         }
+         break;
+     }
+     //=====================================================================
+     // Priest
+     //=====================================================================
+     // Greater Heal Refund         trigger = 18350
+     // Blessed Recovery (Rank 1-3) trigger = 18350
+     // Shadowguard (1-7)           trigger = 28376
+     //=====================================================================
+     case SPELLFAMILY_PRIEST:
+     {
+         // Greater Heal Refund
+         if (auraSpellInfo->Id==37594)
+             trigger_spell_id = 37595;
+         // Shadowguard
+         else if(auraSpellInfo->SpellFamilyFlags==0x100080000000LL && auraSpellInfo->SpellVisual==7958)
+         {
+             switch(auraSpellInfo->Id)
+             {
+                 case 18137: trigger_spell_id = 28377; break;   // Rank 1
+                 case 19308: trigger_spell_id = 28378; break;   // Rank 2
+                 case 19309: trigger_spell_id = 28379; break;   // Rank 3
+                 case 19310: trigger_spell_id = 28380; break;   // Rank 4
+                 case 19311: trigger_spell_id = 28381; break;   // Rank 5
+                 case 19312: trigger_spell_id = 28382; break;   // Rank 6
+                 case 25477: trigger_spell_id = 28385; break;   // Rank 7
+                 default:
+                     sLog.outError("Unit::HandleProcTriggerSpell: Spell %u not handled in SG", auraSpellInfo->Id);
+                 return false;
+             }
+         }
+         // Blessed Recovery
+         else if (auraSpellInfo->SpellIconID == 1875)
+         {
+             switch (auraSpellInfo->Id)
+             {
+                 case 27811: trigger_spell_id = 27813; break;
+                 case 27815: trigger_spell_id = 27817; break;
+                 case 27816: trigger_spell_id = 27818; break;
+                 default:
+                     sLog.outError("Unit::HandleProcTriggerSpell: Spell %u not handled in BR", auraSpellInfo->Id);
+                 return false;
+             }
+             basepoints0 = damage * triggerAmount / 100 / 3;
+             target = this;
+         }
+         break;
+     }
+     //=====================================================================
+     // Druid
+     // ====================================================================
+     // Druid Forms Trinket  trigger = 18350
+     // Entangling Roots     trigger = 30023
+     // Leader of the Pack   trigger = 18350
+     //=====================================================================
+     case SPELLFAMILY_DRUID:
+     {
+         // Druid Forms Trinket
+         if (auraSpellInfo->Id==37336)
+         {
+             switch(m_form)
+             {
+                 case 0:              trigger_spell_id = 37344;break;
+                 case FORM_CAT:       trigger_spell_id = 37341;break;
+                 case FORM_BEAR:
+                 case FORM_DIREBEAR:  trigger_spell_id = 37340;break;
+                 case FORM_TREE:      trigger_spell_id = 37342;break;
+                 case FORM_MOONKIN:   trigger_spell_id = 37343;break;
+                 default:
+                     return false;
+             }
+         }
+//         else if (auraSpellInfo->Id==40363)// Entangling Roots ()
+//             trigger_spell_id = ????;
+         // Leader of the Pack
+         else if (auraSpellInfo->Id == 24932)
+         {
+             if (triggerAmount == 0)
+                 return false;
+             basepoints0 = triggerAmount * GetMaxHealth() / 100;
+             trigger_spell_id = 34299;
+         }
+         break;
+     }
+     //=====================================================================
+     // Hunter
+     // ====================================================================
+     // ......
+     //=====================================================================
+     case SPELLFAMILY_HUNTER:
+     break;
+     //=====================================================================
+     // Paladin
+     // ====================================================================
+     // Blessed Life                   trigger = 31934
+     // Healing Discount               trigger = 18350
+     // Illumination (Rank 1-5)        trigger = 18350
+     // Judgement of Light (Rank 1-5)  trigger = 5373
+     // Judgement of Wisdom (Rank 1-4) trigger = 1826
+     // Lightning Capacitor            trigger = 18350
+     //=====================================================================
+     case SPELLFAMILY_PALADIN:
+     {
+ /*         // Blessed Life
+         if (auraSpellInfo->SpellIconID == 2137)
+         {
+             switch (auraSpellInfo->Id)
+             {
+                 case 31828: // Rank 1
+                 case 31829: // Rank 2
+                 case 31830: // Rank 3
+                 break;
+                 default:
+                     sLog.outError("Unit::HandleProcTriggerSpell: Spell %u miss posibly Blessed Life", auraSpellInfo->Id);
+                 return false;
+             }
+         }*/
+         // Healing Discount
+         if (auraSpellInfo->Id==37705)
+         {
+             trigger_spell_id = 37706;
+             target = this;
+         }
+         // Judgement of Light and Judgement of Wisdom
+         else if (auraSpellInfo->SpellFamilyFlags & 0x0000000000080000LL)
+         {
+             switch (auraSpellInfo->Id)
+             {
+                 // Judgement of Light
+                 case 20185: trigger_spell_id = 20267;break; // Rank 1
+                 case 20344: trigger_spell_id = 20341;break; // Rank 2
+                 case 20345: trigger_spell_id = 20342;break; // Rank 3
+                 case 20346: trigger_spell_id = 20343;break; // Rank 4
+                 case 27162: trigger_spell_id = 27163;break; // Rank 5
+                 // Judgement of Wisdom
+                 case 20186: trigger_spell_id = 20268;break; // Rank 1
+                 case 20354: trigger_spell_id = 20352;break; // Rank 2
+                 case 20355: trigger_spell_id = 20353;break; // Rank 3
+                 case 27164: trigger_spell_id = 27165;break; // Rank 4
+                 default:
+                     sLog.outError("Unit::HandleProcTriggerSpell: Spell %u miss posibly Judgement of Light/Wisdom", auraSpellInfo->Id);
+                 return false;
+             }
+             pVictim->CastSpell(pVictim, trigger_spell_id, true, castItem, triggeredByAura);
+             return true;                        // no hidden cooldown
+         }
+         // Illumination
+         else if (auraSpellInfo->SpellIconID==241)
+         {
+             if(!procSpell)
+                 return false;
+             // procspell is triggered spell but we need mana cost of original casted spell
+             uint32 originalSpellId = procSpell->Id;
+             // Holy Shock
+             if(procSpell->SpellFamilyFlags & 0x00200000)
+             {
+                 switch(procSpell->Id)
+                 {
+                     case 25914: originalSpellId = 20473; break;
+                     case 25913: originalSpellId = 20929; break;
+                     case 25903: originalSpellId = 20930; break;
+                     case 27175: originalSpellId = 27174; break;
+                     case 33074: originalSpellId = 33072; break;
+                     default:
+                         sLog.outError("Unit::HandleProcTriggerSpell: Spell %u not handled in HShock",procSpell->Id);
+                     return false;
+                 }
+             }
+             SpellEntry const *originalSpell = sSpellStore.LookupEntry(originalSpellId);
+             if(!originalSpell)
+             {
+                 sLog.outError("Unit::HandleProcTriggerSpell: Spell %u unknown but selected as original in Illu",originalSpellId);
+                 return false;
+             }
+             // percent stored in effect 1 (class scripts) base points
+             basepoints0 = originalSpell->manaCost*(auraSpellInfo->EffectBasePoints[1]+1)/100;
+             trigger_spell_id = 20272;
+             target = this;
+         }
+         // Lightning Capacitor
+         else if (auraSpellInfo->Id==37657)
+         {
+             if(!pVictim || !pVictim->isAlive())
+                 return false;
+             // stacking
+             CastSpell(this, 37658, true, NULL, triggeredByAura);
+             // counting
+             Aura * dummy = GetDummyAura(37658);
+             if (!dummy)
+                 return false;
+             // release at 3 aura in stack (cont contain in basepoint of trigger aura)
+             if(dummy->m_stackAmount <= 2)
+                 return true;
+             
+             RemoveAurasDueToSpell(37658);
+             trigger_spell_id = 37661;
+             target = pVictim;             
+         }
+         break;
+     }
+     //=====================================================================
+     // Shaman
+     //====================================================================
+     // Lightning Shield             trigger = 18350
+     // Mana Surge                   trigger = 18350
+     // Nature's Guardian (Rank 1-5) trigger = 18350
+     //=====================================================================
+     case SPELLFAMILY_SHAMAN:
+     {
+         //Lightning Shield (overwrite non existing triggered spell call in spell.dbc
+         if(auraSpellInfo->SpellFamilyFlags==0x00000400 && auraSpellInfo->SpellVisual==37)
+         {
+             switch(auraSpellInfo->Id)
+             {
+                 case   324: trigger_spell_id = 26364; break;  // Rank 1
+                 case   325: trigger_spell_id = 26365; break;  // Rank 2
+                 case   905: trigger_spell_id = 26366; break;  // Rank 3
+                 case   945: trigger_spell_id = 26367; break;  // Rank 4
+                 case  8134: trigger_spell_id = 26369; break;  // Rank 5
+                 case 10431: trigger_spell_id = 26370; break;  // Rank 6
+                 case 10432: trigger_spell_id = 26363; break;  // Rank 7
+                 case 25469: trigger_spell_id = 26371; break;  // Rank 8
+                 case 25472: trigger_spell_id = 26372; break;  // Rank 9
+                 default:
+                     sLog.outError("Unit::HandleProcTriggerSpell: Spell %u not handled in LShield", auraSpellInfo->Id);
+                 return false;
+             }
+         }
+         // Lightning Shield (The Ten Storms set)
+         else if (auraSpellInfo->Id == 23551)
+         {
+             trigger_spell_id = 23552;
+             target = pVictim;
+         }
+         // Damage from Lightning Shield (The Ten Storms set)
+         else if (auraSpellInfo->Id == 23552)
+             trigger_spell_id = 27635;
+         // Mana Surge (The Earthfury set)
+         else if (auraSpellInfo->Id == 23572)
+         {
+             if(!procSpell)
+                 return false;
+             basepoints0 = procSpell->manaCost * 35 / 100;
+             trigger_spell_id = 23571;
+             target = this;
+         }
+         else if (auraSpellInfo->SpellIconID == 2013) //Nature's Guardian
+         {
+             // Check health condition - should drop to less 30% (damage deal after this!)
+             if (!(10*(int32(GetHealth() - damage)) < 3 * GetMaxHealth()))
+                 return false;
+
+             if(pVictim && pVictim->isAlive())
+                 pVictim->getThreatManager().modifyThreatPercent(this,-10);
+
+             basepoints0 = triggerAmount * GetMaxHealth() / 100;
+             trigger_spell_id = 31616;
+             target = this;
+         }
+         break;
+     }
+     // default
+     default:
+         break;
+    }
+
+    // All ok. Check current trigger spell
+    SpellEntry const* triggerEntry = sSpellStore.LookupEntry(trigger_spell_id);
+    if ( triggerEntry == NULL )
+    {
+        // Not cast unknown spell
+        // sLog.outError("Unit::HandleProcTriggerSpell: Spell %u have 0 in EffectTriggered[%d], not handled custom case?",auraSpellInfo->Id,triggeredByAura->GetEffIndex());
+        return false;
+    }
+
+    // not allow proc extra attack spell at extra attack
+    if( m_extraAttacks && IsSpellHaveEffect(triggerEntry, SPELL_EFFECT_ADD_EXTRA_ATTACKS) )
+        return false;
+
+    // Costum requirements (not listed in procEx) Warning! damage dealing after this
+    // Custom triggered spells
+    switch (auraSpellInfo->Id)
+    {
+        // Persistent Shield (Scarab Brooch trinket)
+        // This spell originally trigger 13567 - Dummy Trigger (vs dummy efect)
+        case 26467:
+        {
+            basepoints0 = damage * 15 / 100;
+            target = pVictim;
+            trigger_spell_id = 26470;
+            break;
+        }
+        // Cheat Death
+        case 28845:
+        {
+            // When your health drops below 20% ....
+            if (GetHealth() - damage > GetMaxHealth() / 5 || GetHealth() < GetMaxHealth() / 5)
+                return false;
+            break;
+        }
+        // Deadly Swiftness (Rank 1)
+        case 31255:
+        {
+            // whenever you deal damage to a target who is below 20% health.
+            if (pVictim->GetHealth() > pVictim->GetMaxHealth() / 5)
+                return false;
+
+            target = this;
+            trigger_spell_id = 22588;
+        }
+        // Greater Heal Refund (Avatar Raiment set)
+        case 37594:
+        {
+            // Not give if target alredy have full health
+            if (pVictim->GetHealth() == pVictim->GetMaxHealth())
+                return false;
+            // If your Greater Heal brings the target to full health, you gain $37595s1 mana.
+            if (pVictim->GetHealth() + damage < pVictim->GetMaxHealth())
+                return false;
+            break;
+        }
+        // Bonus Healing (Crystal Spire of Karabor mace)
+        case 40971:
+        {
+            // If your target is below $s1% health
+            if (pVictim->GetHealth() > pVictim->GetMaxHealth() * triggerAmount / 100)
+                return false;
+            break;
+        }
+        // Evasive Maneuvers (Commendation of Kael`thas trinket)
+        case 45057:
+        {
+            // reduce you below $s1% health
+            if (GetHealth() - damage > GetMaxHealth() * triggerAmount / 100)
+                return false;
+            break;
+        }
+    }
+
+    // Costum basepoints/target for exist spell
+    // dummy basepoints or other customs
+    switch(trigger_spell_id)
+    {
+        // Cast positive spell on enemy target
+        case 7099:  // Curse of Mending
+        case 39647: // Curse of Mending
+        case 29494: // Temptation
+        case 20233: // Improved Lay on Hands (cast on target)
+        {
+            target = pVictim;
+            break;
+        }
+        // Combo points add triggers (need add combopoint only for main tatget, and after possible combopoints reset) 
+        case 15250: // Rogue Setup
+        {
+            if(!pVictim || pVictim != getVictim())   // applied only for main target
+                return false;
+            break;                                   // continue normal case
+        }
+        // Finish movies that add combo
+        case 14189: // Seal Fate (Netherblade set)
+        case 14157: // Ruthlessness
+        {
+            // Need add combopoint AFTER finish movie (or they dropped in finish phase)
+            break;
+        }
+        // Shamanistic Rage triggered spell
+        case 30824:
+        {
+            basepoints0 = int32(GetTotalAttackPowerValue(BASE_ATTACK) * triggerAmount / 100);
+            trigger_spell_id = 30824;
+            break;
+        }
+        // Enlightenment (trigger only from mana cost spells)
+        case 35095:
+        {
+            if(!procSpell || procSpell->powerType!=POWER_MANA || procSpell->manaCost==0 && procSpell->ManaCostPercentage==0 && procSpell->manaCostPerlevel==0)
+                return false;
+            break;
+        }
+    }
+
+    if( cooldown && GetTypeId()==TYPEID_PLAYER && ((Player*)this)->HasSpellCooldown(trigger_spell_id))
+        return false;
+
+    // try detect target manually if not set
+    if ( target == NULL )
+       target = !(procFlags & PROC_FLAG_SUCCESSFUL_POSITIVE_SPELL) && IsPositiveSpell(trigger_spell_id) ? this : pVictim;
+
+    // default case
+    if(!target || target!=this && !target->isAlive())
+        return false;
+
+    if(basepoints0)
+        CastCustomSpell(target,trigger_spell_id,&basepoints0,NULL,NULL,true,castItem,triggeredByAura);
+    else
+        CastSpell(target,trigger_spell_id,true,castItem,triggeredByAura);
+
+    if( cooldown && GetTypeId()==TYPEID_PLAYER )
+        ((Player*)this)->AddSpellCooldown(trigger_spell_id,0,time(NULL) + cooldown);
+
+    return true;
+}
 
 bool Unit::HandleOverrideClassScriptAuraProc(Unit *pVictim, int32 scriptId, uint32 damage, Aura *triggeredByAura, SpellEntry const *procSpell, uint32 cooldown)
 {
@@ -7215,7 +8510,7 @@ uint32 Unit::SpellDamageBonus(Unit *pVictim, SpellEntry const *spellProto, uint3
             (*i)->GetSpellProto()->EquippedItemInventoryTypeMask == 0 )
                                                             // 0 == any inventory type (not wand then)
         {
-            DoneTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+            DoneTotalMod *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount +100.0f)/100.0f;
         }
     }
 
@@ -7223,13 +8518,13 @@ uint32 Unit::SpellDamageBonus(Unit *pVictim, SpellEntry const *spellProto, uint3
     AuraList const& mDamageDoneVersus = GetAurasByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS);
     for(AuraList::const_iterator i = mDamageDoneVersus.begin();i != mDamageDoneVersus.end(); ++i)
         if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-            DoneTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+            DoneTotalMod *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount +100.0f)/100.0f;
 
     // ..taken
     AuraList const& mModDamagePercentTaken = pVictim->GetAurasByType(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN);
     for(AuraList::const_iterator i = mModDamagePercentTaken.begin(); i != mModDamagePercentTaken.end(); ++i)
         if( (*i)->GetModifier()->m_miscvalue & GetSpellSchoolMask(spellProto) )
-            TakenTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+            TakenTotalMod *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount +100.0f)/100.0f;
 
     // .. taken pct: scripted (increases damage of * against targets *)
     AuraList const& mOverrideClassScript = GetAurasByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
@@ -7501,14 +8796,14 @@ uint32 Unit::SpellDamageBonus(Unit *pVictim, SpellEntry const *spellProto, uint3
     float LvlPenalty = CalculateLevelPenalty(spellProto);
 
     // Spellmod SpellDamage
-    float SpellModSpellDamage = 100.0f;
+    float CoefficientPtc = ((float)CastingTime/3500.0f)*DotFactor*100.0f;
 
     if(Player* modOwner = GetSpellModOwner())
-        modOwner->ApplySpellMod(spellProto->Id,SPELLMOD_SPELL_BONUS_DAMAGE,SpellModSpellDamage);
+        modOwner->ApplySpellMod(spellProto->Id,SPELLMOD_SPELL_BONUS_DAMAGE,CoefficientPtc);
 
-    SpellModSpellDamage /= 100.0f;
+    CoefficientPtc /= 100.0f;
 
-    float DoneActualBenefit = DoneAdvertisedBenefit * (CastingTime / 3500.0f) * DotFactor * SpellModSpellDamage * LvlPenalty;
+    float DoneActualBenefit = DoneAdvertisedBenefit * CoefficientPtc * LvlPenalty;
     float TakenActualBenefit = TakenAdvertisedBenefit * (CastingTime / 3500.0f) * DotFactor * LvlPenalty;
 
     float tmpDamage = (float(pdamage)+DoneActualBenefit)*DoneTotalMod;
@@ -7540,7 +8835,7 @@ int32 Unit::SpellBaseDamageBonus(SpellSchoolMask schoolMask)
                                                             // -1 == any item class (not wand then)
         (*i)->GetSpellProto()->EquippedItemInventoryTypeMask == 0 )
                                                             // 0 == any inventory type (not wand then)
-            DoneAdvertisedBenefit += (*i)->GetModifier()->m_amount;
+            DoneAdvertisedBenefit += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
 
     if (GetTypeId() == TYPEID_PLAYER)
     {
@@ -7558,14 +8853,14 @@ int32 Unit::SpellBaseDamageBonus(SpellSchoolMask schoolMask)
                 if(eff < 2 && iSpellProto->EffectApplyAuraName[eff+1]==SPELL_AURA_MOD_SPELL_HEALING_OF_STAT_PERCENT)
                     usedStat = Stats(iSpellProto->EffectMiscValue[eff+1]);
 
-                DoneAdvertisedBenefit += int32(GetStat(usedStat) * (*i)->GetModifier()->m_amount / 100.0f);
+                DoneAdvertisedBenefit += int32(GetStat(usedStat) * (*i)->GetModifier()->m_amount * (*i)->m_stackAmount / 100.0f);
             }
         }
         // ... and attack power
         AuraList const& mDamageDonebyAP = GetAurasByType(SPELL_AURA_MOD_SPELL_DAMAGE_OF_ATTACK_POWER);
         for(AuraList::const_iterator i =mDamageDonebyAP.begin();i != mDamageDonebyAP.end(); ++i)
             if ((*i)->GetModifier()->m_miscvalue & schoolMask)
-                DoneAdvertisedBenefit += int32(GetTotalAttackPowerValue(BASE_ATTACK) * (*i)->GetModifier()->m_amount / 100.0f);
+                DoneAdvertisedBenefit += int32(GetTotalAttackPowerValue(BASE_ATTACK) * (*i)->GetModifier()->m_amount * (*i)->m_stackAmount / 100.0f);
 
     }
     return DoneAdvertisedBenefit;
@@ -7580,13 +8875,13 @@ int32 Unit::SpellBaseDamageBonusForVictim(SpellSchoolMask schoolMask, Unit *pVic
     AuraList const& mDamageDoneCreature = GetAurasByType(SPELL_AURA_MOD_DAMAGE_DONE_CREATURE);
     for(AuraList::const_iterator i = mDamageDoneCreature.begin();i != mDamageDoneCreature.end(); ++i)
         if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-            TakenAdvertisedBenefit += (*i)->GetModifier()->m_amount;
+            TakenAdvertisedBenefit += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
 
     // ..taken
     AuraList const& mDamageTaken = pVictim->GetAurasByType(SPELL_AURA_MOD_DAMAGE_TAKEN);
     for(AuraList::const_iterator i = mDamageTaken.begin();i != mDamageTaken.end(); ++i)
         if(((*i)->GetModifier()->m_miscvalue & schoolMask) != 0)
-            TakenAdvertisedBenefit += (*i)->GetModifier()->m_amount;
+            TakenAdvertisedBenefit += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
 
     return TakenAdvertisedBenefit;
 }
@@ -7789,6 +9084,11 @@ uint32 Unit::SpellHealingBonus(SpellEntry const *spellProto, uint32 healamount,
         // Exception
         switch (spellProto->SpellFamilyName)
         {
+            case  SPELLFAMILY_GENERIC:      
+                // Frenzied Regeneration triggered Spell
+                if( spellProto->Id == 22845 )
+                    CastingTime = 0;
+                break;      
             case  SPELLFAMILY_SHAMAN:
                 // Healing stream from totem (add 6% per tick from hill bonus owner)
                 if (spellProto->SpellFamilyFlags & 0x000000002000LL)
@@ -7837,14 +9137,14 @@ uint32 Unit::SpellHealingBonus(SpellEntry const *spellProto, uint32 healamount,
         float LvlPenalty = CalculateLevelPenalty(spellProto);
 
         // Spellmod SpellDamage
-        float SpellModSpellDamage = 100.0f;
+        float CoefficientPtc = ((float)CastingTime/3500.0f)*DotFactor*100.0f;
 
         if(Player* modOwner = GetSpellModOwner())
-            modOwner->ApplySpellMod(spellProto->Id,SPELLMOD_SPELL_BONUS_DAMAGE,SpellModSpellDamage);
+            modOwner->ApplySpellMod(spellProto->Id,SPELLMOD_SPELL_BONUS_DAMAGE,CoefficientPtc);
 
-        SpellModSpellDamage /= 100.0f;
+        CoefficientPtc /= 100.0f;
 
-        ActualBenefit = (float)AdvertisedBenefit * ((float)CastingTime / 3500.0f) * DotFactor * SpellModSpellDamage * LvlPenalty;
+        ActualBenefit = (float)AdvertisedBenefit * CoefficientPtc * LvlPenalty;
     }
 
     // use float as more appropriate for negative values and percent applying
@@ -7854,7 +9154,7 @@ uint32 Unit::SpellHealingBonus(SpellEntry const *spellProto, uint32 healamount,
     // Healing done percent
     AuraList const& mHealingDonePct = GetAurasByType(SPELL_AURA_MOD_HEALING_DONE_PERCENT);
     for(AuraList::const_iterator i = mHealingDonePct.begin();i != mHealingDonePct.end(); ++i)
-        heal *= (100.0f + (*i)->GetModifier()->m_amount) / 100.0f;
+        heal *= (100.0f + (*i)->GetModifier()->m_amount * (*i)->m_stackAmount) / 100.0f;
 
     // apply spellmod to Done amount
     if(Player* modOwner = GetSpellModOwner())
@@ -7895,7 +9195,7 @@ int32 Unit::SpellBaseHealingBonus(SpellSchoolMask schoolMask)
     AuraList const& mHealingDone = GetAurasByType(SPELL_AURA_MOD_HEALING_DONE);
     for(AuraList::const_iterator i = mHealingDone.begin();i != mHealingDone.end(); ++i)
         if(((*i)->GetModifier()->m_miscvalue & schoolMask) != 0)
-            AdvertisedBenefit += (*i)->GetModifier()->m_amount;
+            AdvertisedBenefit += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
 
     // Healing bonus of spirit, intellect and strength
     if (GetTypeId() == TYPEID_PLAYER)
@@ -7906,14 +9206,14 @@ int32 Unit::SpellBaseHealingBonus(SpellSchoolMask schoolMask)
         {
             // stat used dependent from misc value (stat index)
             Stats usedStat = Stats((*i)->GetSpellProto()->EffectMiscValue[(*i)->GetEffIndex()]);
-            AdvertisedBenefit += int32(GetStat(usedStat) * (*i)->GetModifier()->m_amount / 100.0f);
+            AdvertisedBenefit += int32(GetStat(usedStat) * (*i)->GetModifier()->m_amount * (*i)->m_stackAmount / 100.0f);
         }
 
         // ... and attack power
         AuraList const& mHealingDonebyAP = GetAurasByType(SPELL_AURA_MOD_SPELL_HEALING_OF_ATTACK_POWER);
         for(AuraList::const_iterator i = mHealingDonebyAP.begin();i != mHealingDonebyAP.end(); ++i)
             if ((*i)->GetModifier()->m_miscvalue & schoolMask)
-                AdvertisedBenefit += int32(GetTotalAttackPowerValue(BASE_ATTACK) * (*i)->GetModifier()->m_amount / 100.0f);
+                AdvertisedBenefit += int32(GetTotalAttackPowerValue(BASE_ATTACK) * (*i)->GetModifier()->m_amount * (*i)->m_stackAmount / 100.0f);
     }
     return AdvertisedBenefit;
 }
@@ -7924,44 +9224,23 @@ int32 Unit::SpellBaseHealingBonusForVictim(SpellSchoolMask schoolMask, Unit *pVi
     AuraList const& mDamageTaken = pVictim->GetAurasByType(SPELL_AURA_MOD_HEALING);
     for(AuraList::const_iterator i = mDamageTaken.begin();i != mDamageTaken.end(); ++i)
         if(((*i)->GetModifier()->m_miscvalue & schoolMask) != 0)
-            AdvertisedBenefit += (*i)->GetModifier()->m_amount;
+            AdvertisedBenefit += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
     return AdvertisedBenefit;
 }
 
 bool Unit::IsImmunedToDamage(SpellSchoolMask shoolMask, bool useCharges)
 {
-    // no charges dependent checks
+    //If m_immuneToSchool type contain this school type, IMMUNE damage.
     SpellImmuneList const& schoolList = m_spellImmune[IMMUNITY_SCHOOL];
     for (SpellImmuneList::const_iterator itr = schoolList.begin(); itr != schoolList.end(); ++itr)
         if(itr->type & shoolMask)
             return true;
 
-    // charges dependent checks
+    //If m_immuneToDamage type contain magic, IMMUNE damage.
     SpellImmuneList const& damageList = m_spellImmune[IMMUNITY_DAMAGE];
     for (SpellImmuneList::const_iterator itr = damageList.begin(); itr != damageList.end(); ++itr)
-    {
         if(itr->type & shoolMask)
-        {
-            if(useCharges)
-            {
-                AuraList const& auraDamageImmunity = GetAurasByType(SPELL_AURA_DAMAGE_IMMUNITY);
-                for(AuraList::const_iterator auraItr = auraDamageImmunity.begin(); auraItr != auraDamageImmunity.end(); ++auraItr)
-                {
-                    if((*auraItr)->GetId()==itr->spellId)
-                    {
-                        if((*auraItr)->m_procCharges > 0)
-                        {
-                            --(*auraItr)->m_procCharges;
-                            if((*auraItr)->m_procCharges==0)
-                                RemoveAurasDueToSpell(itr->spellId);
-                        }
-                        break;
-                    }
-                }
-            }
             return true;
-        }
-    }
 
     return false;
 }
@@ -7971,8 +9250,6 @@ bool Unit::IsImmunedToSpell(SpellEntry const* spellInfo, bool useCharges)
     if (!spellInfo)
         return false;
 
-    // no charges first
-
     //FIX ME this hack: don't get feared if stunned
     if (spellInfo->Mechanic == MECHANIC_FEAR )
     {
@@ -7980,7 +9257,6 @@ bool Unit::IsImmunedToSpell(SpellEntry const* spellInfo, bool useCharges)
             return true;
     }
 
-    // not have spells with charges currently
     SpellImmuneList const& dispelList = m_spellImmune[IMMUNITY_DISPEL];
     for(SpellImmuneList::const_iterator itr = dispelList.begin(); itr != dispelList.end(); ++itr)
         if(itr->type == spellInfo->Dispel)
@@ -7988,7 +9264,6 @@ bool Unit::IsImmunedToSpell(SpellEntry const* spellInfo, bool useCharges)
 
     if( !(spellInfo->AttributesEx & SPELL_ATTR_EX_UNAFFECTED_BY_SCHOOL_IMMUNE))               // unaffected by school immunity
     {
-        // not have spells with charges currently
         SpellImmuneList const& schoolList = m_spellImmune[IMMUNITY_SCHOOL];
         for(SpellImmuneList::const_iterator itr = schoolList.begin(); itr != schoolList.end(); ++itr)
             if( !(IsPositiveSpell(itr->spellId) && IsPositiveSpell(spellInfo->Id)) &&
@@ -7996,30 +9271,11 @@ bool Unit::IsImmunedToSpell(SpellEntry const* spellInfo, bool useCharges)
                 return true;
     }
 
-    // charges dependent checks
-
     SpellImmuneList const& mechanicList = m_spellImmune[IMMUNITY_MECHANIC];
     for(SpellImmuneList::const_iterator itr = mechanicList.begin(); itr != mechanicList.end(); ++itr)
     {
         if(itr->type == spellInfo->Mechanic)
         {
-            if(useCharges)
-            {
-                AuraList const& auraMechImmunity = GetAurasByType(SPELL_AURA_MECHANIC_IMMUNITY);
-                for(AuraList::const_iterator auraItr = auraMechImmunity.begin(); auraItr != auraMechImmunity.end(); ++auraItr)
-                {
-                    if((*auraItr)->GetId()==itr->spellId)
-                    {
-                        if((*auraItr)->m_procCharges > 0)
-                        {
-                            --(*auraItr)->m_procCharges;
-                            if((*auraItr)->m_procCharges==0)
-                                RemoveAurasDueToSpell(itr->spellId);
-                        }
-                        break;
-                    }
-                }
-            }
             return true;
         }
     }
@@ -8077,7 +9333,7 @@ void Unit::MeleeDamageBonus(Unit *pVictim, uint32 *pdamage,WeaponAttackType attT
     AuraList const& mDamageDoneCreature = this->GetAurasByType(SPELL_AURA_MOD_DAMAGE_DONE_CREATURE);
     for(AuraList::const_iterator i = mDamageDoneCreature.begin();i != mDamageDoneCreature.end(); ++i)
         if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-            DoneFlatBenefit += (*i)->GetModifier()->m_amount;
+            DoneFlatBenefit += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
 
     // ..done
     // SPELL_AURA_MOD_DAMAGE_DONE included in weapon damage
@@ -8092,7 +9348,7 @@ void Unit::MeleeDamageBonus(Unit *pVictim, uint32 *pdamage,WeaponAttackType attT
         AuraList const& mCreatureAttackPower = GetAurasByType(SPELL_AURA_MOD_RANGED_ATTACK_POWER_VERSUS);
         for(AuraList::const_iterator i = mCreatureAttackPower.begin();i != mCreatureAttackPower.end(); ++i)
             if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-                APbonus += (*i)->GetModifier()->m_amount;
+                APbonus += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
     }
     else
     {
@@ -8102,7 +9358,7 @@ void Unit::MeleeDamageBonus(Unit *pVictim, uint32 *pdamage,WeaponAttackType attT
         AuraList const& mCreatureAttackPower = GetAurasByType(SPELL_AURA_MOD_MELEE_ATTACK_POWER_VERSUS);
         for(AuraList::const_iterator i = mCreatureAttackPower.begin();i != mCreatureAttackPower.end(); ++i)
             if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-                APbonus += (*i)->GetModifier()->m_amount;
+                APbonus += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
     }
 
     if (APbonus!=0)                                         // Can be negative
@@ -8127,7 +9383,7 @@ void Unit::MeleeDamageBonus(Unit *pVictim, uint32 *pdamage,WeaponAttackType attT
     AuraList const& mDamageTaken = pVictim->GetAurasByType(SPELL_AURA_MOD_DAMAGE_TAKEN);
     for(AuraList::const_iterator i = mDamageTaken.begin();i != mDamageTaken.end(); ++i)
         if((*i)->GetModifier()->m_miscvalue & SPELL_SCHOOL_MASK_NORMAL)
-            TakenFlatBenefit += (*i)->GetModifier()->m_amount;
+            TakenFlatBenefit += (*i)->GetModifier()->m_amount * (*i)->m_stackAmount;
 
     if(attType!=RANGED_ATTACK)
         TakenFlatBenefit += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN);
@@ -8145,13 +9401,13 @@ void Unit::MeleeDamageBonus(Unit *pVictim, uint32 *pdamage,WeaponAttackType attT
     AuraList const& mDamageDoneVersus = this->GetAurasByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS);
     for(AuraList::const_iterator i = mDamageDoneVersus.begin();i != mDamageDoneVersus.end(); ++i)
         if(creatureTypeMask & uint32((*i)->GetModifier()->m_miscvalue))
-            DoneTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+            DoneTotalMod *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount+100.0f)/100.0f;
 
     // ..taken
     AuraList const& mModDamagePercentTaken = pVictim->GetAurasByType(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN);
     for(AuraList::const_iterator i = mModDamagePercentTaken.begin(); i != mModDamagePercentTaken.end(); ++i)
         if((*i)->GetModifier()->m_miscvalue & SPELL_SCHOOL_MASK_NORMAL)
-            TakenTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+            TakenTotalMod *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount+100.0f)/100.0f;
 
     // .. taken pct: dummy auras
     AuraList const& mDummyAuras = pVictim->GetAurasByType(SPELL_AURA_DUMMY);
@@ -8209,13 +9465,13 @@ void Unit::MeleeDamageBonus(Unit *pVictim, uint32 *pdamage,WeaponAttackType attT
     {
         AuraList const& mModMeleeDamageTakenPercent = pVictim->GetAurasByType(SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN_PCT);
         for(AuraList::const_iterator i = mModMeleeDamageTakenPercent.begin(); i != mModMeleeDamageTakenPercent.end(); ++i)
-            TakenTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+            TakenTotalMod *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount+100.0f)/100.0f;
     }
     else
     {
         AuraList const& mModRangedDamageTakenPercent = pVictim->GetAurasByType(SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN_PCT);
         for(AuraList::const_iterator i = mModRangedDamageTakenPercent.begin(); i != mModRangedDamageTakenPercent.end(); ++i)
-            TakenTotalMod *= ((*i)->GetModifier()->m_amount+100.0f)/100.0f;
+            TakenTotalMod *= ((*i)->GetModifier()->m_amount * (*i)->m_stackAmount+100.0f)/100.0f;
     }
 
     float tmpDamage = float(int32(*pdamage) + DoneFlatBenefit) * DoneTotalMod;
@@ -9961,6 +11217,7 @@ bool Unit::isFrozen() const
     return false;
 }
 
+/*
 struct ProcTriggeredData
 {
     ProcTriggeredData(SpellEntry const * _spellInfo, uint32 _spellParam, Aura* _triggeredByAura, uint32 _cooldown)
@@ -10245,6 +11502,485 @@ void Unit::ProcDamageAndSpellFor( bool isVictim, Unit * pTarget, uint32 procFlag
         }
     }
 }
+*/
+struct ProcTriggeredData
+{
+    ProcTriggeredData(SpellProcEventEntry const * _spellProcEvent, Aura* _triggeredByAura)
+        : spellProcEvent(_spellProcEvent), triggeredByAura(_triggeredByAura),
+        triggeredByAura_SpellPair(Unit::spellEffectPair(triggeredByAura->GetId(),triggeredByAura->GetEffIndex()))
+        {}
+    SpellProcEventEntry const *spellProcEvent;
+    Aura* triggeredByAura;
+    Unit::spellEffectPair triggeredByAura_SpellPair;
+};
+
+typedef std::list< ProcTriggeredData > ProcTriggeredList;
+typedef std::list< uint32> RemoveSpellList;
+
+// List of auras that CAN be trigger but may not exist in spell_proc_event
+// in most case need for drop charges
+// in some types of aura need do additional check
+// for example SPELL_AURA_MECHANIC_IMMUNITY - need check for mechanic
+static bool isTriggerAura[TOTAL_AURAS];
+static bool isNonTriggerAura[TOTAL_AURAS];
+void InitTriggerAuraData()
+{
+    for (int i=0;i<TOTAL_AURAS;i++)
+    {
+      isTriggerAura[i]=false;
+      isNonTriggerAura[i] = false;
+    }
+    isTriggerAura[SPELL_AURA_DUMMY] = true;
+    isTriggerAura[SPELL_AURA_MOD_CONFUSE] = true;
+    isTriggerAura[SPELL_AURA_MOD_THREAT] = true;
+    isTriggerAura[SPELL_AURA_MOD_STUN] = true; // Aura not have charges but need remove him on trigger
+    isTriggerAura[SPELL_AURA_MOD_DAMAGE_DONE] = true;
+    isTriggerAura[SPELL_AURA_MOD_DAMAGE_TAKEN] = true;
+    isTriggerAura[SPELL_AURA_MOD_RESISTANCE] = true;
+    isTriggerAura[SPELL_AURA_MOD_ROOT] = true;
+    isTriggerAura[SPELL_AURA_REFLECT_SPELLS] = true;
+    isTriggerAura[SPELL_AURA_DAMAGE_IMMUNITY] = true;
+    isTriggerAura[SPELL_AURA_PROC_TRIGGER_SPELL] = true;
+    isTriggerAura[SPELL_AURA_PROC_TRIGGER_DAMAGE] = true;
+    isTriggerAura[SPELL_AURA_MOD_CASTING_SPEED] = true;
+    isTriggerAura[SPELL_AURA_MOD_POWER_COST_SCHOOL_PCT] = true;
+    isTriggerAura[SPELL_AURA_MOD_POWER_COST_SCHOOL] = true;
+    isTriggerAura[SPELL_AURA_REFLECT_SPELLS_SCHOOL] = true;
+    isTriggerAura[SPELL_AURA_MECHANIC_IMMUNITY] = true;
+    isTriggerAura[SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN] = true;
+    isTriggerAura[SPELL_AURA_SPELL_MAGNET] = true;
+    isTriggerAura[SPELL_AURA_MOD_ATTACK_POWER] = true;
+    isTriggerAura[SPELL_AURA_ADD_CASTER_HIT_TRIGGER] = true;
+    isTriggerAura[SPELL_AURA_OVERRIDE_CLASS_SCRIPTS] = true;
+    isTriggerAura[SPELL_AURA_MOD_MECHANIC_RESISTANCE] = true;
+    isTriggerAura[SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS] = true;
+    isTriggerAura[SPELL_AURA_MOD_HASTE] = true;
+    isTriggerAura[SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE]=true;
+    isTriggerAura[SPELL_AURA_PRAYER_OF_MENDING] = true;
+
+    isNonTriggerAura[SPELL_AURA_MOD_POWER_REGEN]=true;
+    isNonTriggerAura[SPELL_AURA_RESIST_PUSHBACK]=true;
+}
+
+uint32 createProcExtendMask(SpellNonMeleeDamage *damageInfo, SpellMissInfo missCondition)
+{
+    uint32 procEx = PROC_EX_NONE;
+    // Check victim state
+    if (missCondition!=SPELL_MISS_NONE)
+    switch (missCondition)
+    {
+        case SPELL_MISS_MISS:    procEx|=PROC_EX_MISS;   break;
+        case SPELL_MISS_RESIST:  procEx|=PROC_EX_RESIST; break;
+        case SPELL_MISS_DODGE:   procEx|=PROC_EX_DODGE;  break;
+        case SPELL_MISS_PARRY:   procEx|=PROC_EX_PARRY;  break;
+        case SPELL_MISS_BLOCK:   procEx|=PROC_EX_BLOCK;  break;
+        case SPELL_MISS_EVADE:   procEx|=PROC_EX_EVADE;  break;
+        case SPELL_MISS_IMMUNE:  procEx|=PROC_EX_IMMUNE; break;
+        case SPELL_MISS_IMMUNE2: procEx|=PROC_EX_IMMUNE; break;
+        case SPELL_MISS_DEFLECT: procEx|=PROC_EX_DEFLECT;break;
+        case SPELL_MISS_ABSORB:  procEx|=PROC_EX_ABSORB; break;
+        case SPELL_MISS_REFLECT: procEx|=PROC_EX_REFLECT;break;
+        default:
+            break;
+    }
+    else
+    {
+        // On block
+        if (damageInfo->blocked)
+            procEx|=PROC_EX_BLOCK;
+        // On absorb
+        if (damageInfo->absorb)
+            procEx|=PROC_EX_ABSORB;
+        // On crit
+        if (damageInfo->HitInfo & SPELL_HIT_TYPE_CRIT)
+            procEx|=PROC_EX_CRITICAL_HIT;
+        else
+            procEx|=PROC_EX_NORMAL_HIT;
+    }
+    return procEx;
+}
+
+static int deep = 0;
+void Unit::ProcDamageAndSpellFor( bool isVictim, Unit * pTarget, uint32 procFlag, uint32 procExtra, WeaponAttackType attType, SpellEntry const * procSpell, uint32 damage )
+{
+    deep ++;
+    if (deep > 5)
+    {
+        sLog.outError("Prevent possible stack owerflow in Unit::ProcDamageAndSpellFor");
+        if (procSpell)
+            sLog.outError("  Spell %u", procSpell->Id);
+        deep--;
+        return;
+    }
+    // For melee/ranged based attack need update skills and set some Aura states
+    if (procFlag & MELEE_BASED_TRIGGER_MASK)
+    {
+        // Update skills here for players
+        if (GetTypeId() == TYPEID_PLAYER)
+        {
+            // On melee based hit/miss/resist need update skill (for victim and attacker)
+            if (procExtra&(PROC_EX_NORMAL_HIT|PROC_EX_MISS|PROC_EX_RESIST))
+            {
+                if (pTarget->GetTypeId() != TYPEID_PLAYER && pTarget->GetCreatureType() != CREATURE_TYPE_CRITTER)
+                    ((Player*)this)->UpdateCombatSkills(pTarget, attType, MELEE_HIT_MISS, isVictim);
+            }
+            // Update defence if player is victim and parry/dodge/block
+            if (isVictim && procExtra&(PROC_EX_DODGE|PROC_EX_PARRY|PROC_EX_BLOCK))
+                ((Player*)this)->UpdateDefense();
+        }
+        // If exist crit/parry/dodge/block need update aura state (for victim and attacker)
+        if (procExtra & (PROC_EX_CRITICAL_HIT|PROC_EX_PARRY|PROC_EX_DODGE|PROC_EX_BLOCK))
+        {
+            // for victim
+            if (isVictim)
+            {
+                // if victim and dodge attack
+                if (procExtra&PROC_EX_DODGE)
+                {
+                    //Update AURA_STATE on dodge
+                    if (getClass() != CLASS_ROGUE) // skip Rogue Riposte
+                    {
+                        ModifyAuraState(AURA_STATE_DEFENSE, true);
+                        StartReactiveTimer( REACTIVE_DEFENSE );
+                    }
+                }
+                // if victim and parry attack
+                if (procExtra & PROC_EX_PARRY)
+                {
+                    // For Hunters only Counterattack (skip Mongoose bite)
+                    if (getClass() == CLASS_HUNTER)
+                    {
+                        ModifyAuraState(AURA_STATE_HUNTER_PARRY, true);
+                        StartReactiveTimer( REACTIVE_HUNTER_PARRY );
+                    }
+                    else
+                    {
+                        ModifyAuraState(AURA_STATE_DEFENSE, true);
+                        StartReactiveTimer( REACTIVE_DEFENSE );
+                    }
+                }
+                // if and victim block attack
+                if (procExtra & PROC_EX_BLOCK)
+                {
+                    ModifyAuraState(AURA_STATE_DEFENSE,true);
+                    StartReactiveTimer( REACTIVE_DEFENSE );
+                }
+            }
+            else //For attacker
+            {
+                // Overpower on victim dodge
+                if (procExtra&PROC_EX_DODGE && GetTypeId() == TYPEID_PLAYER && getClass() == CLASS_WARRIOR)
+                {
+                    ((Player*)this)->AddComboPoints(pTarget, 1);
+                    StartReactiveTimer( REACTIVE_OVERPOWER );
+                }
+                // Enable AURA_STATE_CRIT on crit
+                if (procExtra & PROC_EX_CRITICAL_HIT)
+                {
+                    ModifyAuraState(AURA_STATE_CRIT, true);
+                    StartReactiveTimer( REACTIVE_CRIT );
+                    if(getClass()==CLASS_HUNTER)
+                    {
+                        ModifyAuraState(AURA_STATE_HUNTER_CRIT_STRIKE, true);
+                        StartReactiveTimer( REACTIVE_HUNTER_CRIT );
+                    }
+                }
+            }
+        }
+    }
+
+    RemoveSpellList removedSpells;
+    ProcTriggeredList procTriggered;
+    // Fill procTriggered list 
+    for(AuraMap::const_iterator itr = GetAuras().begin(); itr!= GetAuras().end(); ++itr)
+    {
+        SpellEntry const *spellProto = itr->second->GetSpellProto();
+        if (spellProto==NULL)
+           continue;
+        // Get proc Event Entry
+        SpellProcEventEntry const *spellProcEvent = spellmgr.GetSpellProcEvent(spellProto->Id);
+
+        // Aura info stored here
+        Modifier *mod = itr->second->GetModifier();
+        // Skip this auras
+        if (isNonTriggerAura[mod->m_auraname])
+            continue;
+        // If not trigger by default and spellProcEvent==NULL - skip
+        if (!isTriggerAura[mod->m_auraname] && spellProcEvent==NULL)
+           continue;
+
+        // Get EventProcFlag
+        uint32 EventProcFlag;
+        if (spellProcEvent && spellProcEvent->procFlags) // if exist get custom spellProcEvent->procFlags
+            EventProcFlag = spellProcEvent->procFlags;
+        else
+            EventProcFlag = spellProto->procFlags;       // else get from spell proto
+        // Continue if no trigger exist
+        if (!EventProcFlag)
+            continue;
+
+        // Check spellProcEvent data requirements
+        if(!SpellMgr::IsSpellProcEventCanTriggeredBy(spellProcEvent, EventProcFlag, procSpell, procFlag, procExtra, damage > 0))
+            continue;
+        // Aura added by spell can`t trogger from self (prevent drop cahres/do triggers)
+        // But except periodic triggers (can triggered from self)
+        if(procSpell && procSpell->Id == spellProto->Id && !(spellProto->procFlags&PROC_FLAG_ON_TAKE_PERIODIC))
+            continue;
+
+        // Check if current equipment allows aura to proc
+        if(!isVictim && GetTypeId() == TYPEID_PLAYER)
+        {
+            if(spellProto->EquippedItemClass == ITEM_CLASS_WEAPON)
+            {
+                Item *item = NULL;
+                if(attType == BASE_ATTACK)
+                    item = ((Player*)this)->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+                else if (attType == OFF_ATTACK)
+                    item = ((Player*)this)->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+                else
+                    item = ((Player*)this)->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_RANGED);
+
+                if (!((Player*)this)->IsUseEquipedWeapon(attType==BASE_ATTACK))
+                    continue;
+
+                if(!item || item->IsBroken() || item->GetProto()->Class != ITEM_CLASS_WEAPON || !((1<<item->GetProto()->SubClass) & spellProto->EquippedItemSubClassMask))
+                    continue;
+            }
+            else if(spellProto->EquippedItemClass == ITEM_CLASS_ARMOR)
+            {
+                // Check if player is wearing shield
+                Item *item = ((Player*)this)->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+                if(!item || item->IsBroken() || item->GetProto()->Class != ITEM_CLASS_ARMOR || !((1<<item->GetProto()->SubClass) & spellProto->EquippedItemSubClassMask))
+                    continue;
+            }
+        }
+        // Get chance from spell
+        float chance = (float)spellProto->procChance;
+        // If in spellProcEvent exist custom chance, chance = spellProcEvent->customChance;
+        if(spellProcEvent && spellProcEvent->customChance)
+            chance = spellProcEvent->customChance;
+        // If PPM exist calculate chance from PPM
+        if(!isVictim && spellProcEvent && spellProcEvent->ppmRate != 0)
+        {
+            uint32 WeaponSpeed = GetAttackTime(attType);
+            chance = GetPPMProcChance(WeaponSpeed, spellProcEvent->ppmRate);
+        }
+        // Apply chance modifer aura
+        if(Player* modOwner = GetSpellModOwner())
+            modOwner->ApplySpellMod(spellProto->Id,SPELLMOD_CHANCE_OF_SUCCESS,chance);
+
+        if(roll_chance_f(chance))
+            procTriggered.push_back( ProcTriggeredData(spellProcEvent, itr->second) );
+    }
+    // Handle effects proceed this time
+    for(ProcTriggeredList::iterator i = procTriggered.begin(); i != procTriggered.end(); ++i)
+    {
+        // Some auras can be deleted in function called in this loop (except first, ofc)
+        // Until storing auars in std::multimap to hard check deleting by another way
+        if(i != procTriggered.begin())
+        {
+            bool found = false;
+            AuraMap::const_iterator lower = GetAuras().lower_bound(i->triggeredByAura_SpellPair);
+            AuraMap::const_iterator upper = GetAuras().upper_bound(i->triggeredByAura_SpellPair);
+            for(AuraMap::const_iterator itr = lower; itr!= upper; ++itr)
+            {
+                if(itr->second==i->triggeredByAura)
+                {
+                    found = true;
+                    break;
+                }
+            }
+            if(!found)
+            {
+//                sLog.outDebug("Spell aura %u (id:%u effect:%u) has been deleted before call spell proc event handler", i->triggeredByAura->GetModifier()->m_auraname, i->triggeredByAura_SpellPair.first, i->triggeredByAura_SpellPair.second);
+//                sLog.outDebug("It can be deleted one from early proccesed auras:");
+//                for(ProcTriggeredList::iterator i2 = procTriggered.begin(); i != i2; ++i2)
+//                    sLog.outDebug("     Spell aura %u (id:%u effect:%u)", i->triggeredByAura->GetModifier()->m_auraname,i2->triggeredByAura_SpellPair.first,i2->triggeredByAura_SpellPair.second);
+//                    sLog.outDebug("     <end of list>");
+                continue;
+            }
+        }
+
+        SpellProcEventEntry const *spellProcEvent = i->spellProcEvent;
+        Aura *triggeredByAura = i->triggeredByAura;
+        Modifier *auraModifier = triggeredByAura->GetModifier();
+        SpellEntry const *spellInfo = triggeredByAura->GetSpellProto();
+        uint32 effIndex = triggeredByAura->GetEffIndex();
+        bool useCharges = triggeredByAura->m_procCharges > 0;
+        // For players set spell cooldown if need
+        uint32 cooldown = 0;
+        if (GetTypeId() == TYPEID_PLAYER && spellProcEvent && spellProcEvent->cooldown)
+            cooldown = spellProcEvent->cooldown;
+
+        switch(auraModifier->m_auraname)
+        {
+            case SPELL_AURA_PROC_TRIGGER_SPELL:
+            {
+                sLog.outDebug("ProcDamageAndSpell: casting spell %u (triggered by %s aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+                // Don`t drop charge or add cooldown for not started trigger
+                if (!HandleProcTriggerSpell(pTarget, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))
+                    continue;
+                break;
+            }
+            case SPELL_AURA_PROC_TRIGGER_DAMAGE:
+            {
+                sLog.outDebug("ProcDamageAndSpell: doing %u damage from spell id %u (triggered by %s aura of spell %u)", auraModifier->m_amount, spellInfo->Id, (isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+                SpellNonMeleeDamage damageInfo(this, pTarget, spellInfo->Id, spellInfo->SchoolMask);
+                CalculateSpellDamage(&damageInfo, auraModifier->m_amount, spellInfo);
+                SendSpellNonMeleeDamageLog(&damageInfo);
+                DealSpellDamage(&damageInfo, true);
+                break;
+            }
+            case SPELL_AURA_MANA_SHIELD:
+            case SPELL_AURA_DUMMY:
+            {
+                sLog.outDebug("ProcDamageAndSpell: casting spell id %u (triggered by %s dummy aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+                if (!HandleDummyAuraProc(pTarget, spellInfo, effIndex, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))
+                    continue;
+                break;
+            }
+            case SPELL_AURA_MOD_HASTE:
+            {
+                sLog.outDebug("ProcDamageAndSpell: casting spell id %u (triggered by %s haste aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+                if (!HandleHasteAuraProc(pTarget, spellInfo, effIndex, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))
+                    continue;
+                break;
+            }
+            case SPELL_AURA_OVERRIDE_CLASS_SCRIPTS:
+            {
+                sLog.outDebug("ProcDamageAndSpell: casting spell id %u (triggered by %s aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+                if (!HandleOverrideClassScriptAuraProc(pTarget, auraModifier->m_miscvalue, damage, triggeredByAura, procSpell, cooldown))
+                    continue;
+                break;
+            }
+            case SPELL_AURA_PRAYER_OF_MENDING:
+            {
+                sLog.outDebug("ProcDamageAndSpell(mending): casting spell id %u (triggered by %s dummy aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+
+                // aura can be deleted at casts
+                int32 heal = auraModifier->m_amount;
+                uint64 caster_guid = triggeredByAura->GetCasterGUID();
+
+                // jumps (already -1 after triggering)
+                int32 jumps = triggeredByAura->m_procCharges;
+
+                // current aura expire
+                triggeredByAura->m_procCharges = 0;  // will removed
+
+                // next target selection
+                if(jumps > 0 && GetTypeId()==TYPEID_PLAYER && IS_PLAYER_GUID(caster_guid))
+                {
+                    float radius;
+                    if (spellInfo->EffectRadiusIndex[effIndex])
+                        radius = GetSpellRadius(sSpellRadiusStore.LookupEntry(spellInfo->EffectRadiusIndex[effIndex]));
+                    else
+                        radius = GetSpellMaxRange(sSpellRangeStore.LookupEntry(spellInfo->rangeIndex));
+
+                    if(Player* caster = ((Player*)triggeredByAura->GetCaster()))
+                    {
+                        caster->ApplySpellMod(spellInfo->Id, SPELLMOD_RADIUS, radius, NULL);
+
+                        if(Player* target = ((Player*)this)->GetNextRandomRaidMember(radius))
+                        {
+                            // aura will applied from caster, but spell casted from current aura holder
+                            SpellModifier *mod = new SpellModifier;
+                            mod->op = SPELLMOD_CHARGES;
+                            mod->value = jumps-5;               // negative
+                            mod->type = SPELLMOD_FLAT;
+                            mod->spellId = spellInfo->Id;
+                            mod->effectId = effIndex;
+                            mod->lastAffected = NULL;
+                            mod->mask = spellInfo->SpellFamilyFlags;
+                            mod->charges = 0;
+
+                            caster->AddSpellMod(mod, true);
+                            CastCustomSpell(target,spellInfo->Id,&heal,NULL,NULL,true,NULL,triggeredByAura,caster->GetGUID());
+                            caster->AddSpellMod(mod, false);
+                        }
+                    }
+                }
+                // heal
+                CastCustomSpell(this, 33110, &heal, NULL, NULL, true, NULL, NULL, caster_guid);
+                break;
+            }
+            case SPELL_AURA_MOD_STUN:
+                // Remove by default, but if charge exist drop it
+                if (triggeredByAura->m_procCharges == 0)
+                   removedSpells.push_back(triggeredByAura->GetId());
+                break;
+            case SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS:
+            case SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS:
+                // Hunter's Mark (1-4 Rangs)
+                if (spellInfo->SpellFamilyName == SPELLFAMILY_HUNTER && (spellInfo->SpellFamilyFlags&0x0000000000000400LL))
+                {
+                    uint32 basevalue = triggeredByAura->GetBasePoints();
+                    auraModifier->m_amount += basevalue/10;
+                    if (auraModifier->m_amount > basevalue*4)
+                        auraModifier->m_amount = basevalue*4;
+                }
+                break;
+            case SPELL_AURA_MOD_CASTING_SPEED:
+                // Skip melee hits or instant cast spells
+                if (procSpell == NULL || GetSpellCastTime(procSpell) == 0)
+                    continue;
+                break;
+            case SPELL_AURA_REFLECT_SPELLS_SCHOOL:
+                // Skip Melee hits and spells ws wrong school
+                if (procSpell == NULL || (auraModifier->m_miscvalue & procSpell->SchoolMask) == 0)
+                    continue;
+                break;
+            case SPELL_AURA_MOD_POWER_COST_SCHOOL_PCT:
+            case SPELL_AURA_MOD_POWER_COST_SCHOOL:
+                // Skip melee hits and spells ws wrong school or zero cost
+                if (procSpell == NULL || 
+                    (procSpell->manaCost == 0 && procSpell->ManaCostPercentage == 0) || // Cost check
+                    (auraModifier->m_miscvalue & procSpell->SchoolMask) == 0)         // School check
+                    continue;
+                break;
+            case SPELL_AURA_MECHANIC_IMMUNITY:
+                // Compare mechanic
+                if (procSpell==NULL || procSpell->Mechanic != auraModifier->m_miscvalue)
+                    continue;
+                break;
+            case SPELL_AURA_MOD_MECHANIC_RESISTANCE:
+                // Compare mechanic
+                if (procSpell==NULL || procSpell->Mechanic != auraModifier->m_miscvalue)
+                    continue;
+                break;
+            default:
+                // nothing do, just charges counter
+                break;
+        }
+        // Remove charge (aura can be removed by triggers)
+        if(useCharges)
+        {
+            // need found aura on drop (can be dropped by triggers)
+            AuraMap::const_iterator lower = GetAuras().lower_bound(i->triggeredByAura_SpellPair);
+            AuraMap::const_iterator upper = GetAuras().upper_bound(i->triggeredByAura_SpellPair);
+            for(AuraMap::const_iterator itr = lower; itr!= upper; ++itr)
+            {
+                if(itr->second == i->triggeredByAura)
+                {
+                     triggeredByAura->m_procCharges -=1;
+                     triggeredByAura->UpdateAuraCharges();
+                     if (triggeredByAura->m_procCharges <= 0) 
+                          removedSpells.push_back(triggeredByAura->GetId());
+                    break;
+                }
+            }
+        }
+    }
+    if (removedSpells.size())
+    {
+        // Sort spells and remove dublicates
+        removedSpells.sort();
+        removedSpells.unique();
+        // Remove auras from removedAuras
+        for(RemoveSpellList::const_iterator i = removedSpells.begin(); i != removedSpells.end();i++)
+            RemoveAurasDueToSpell(*i);
+    }
+    deep--;
+}
 
 SpellSchoolMask Unit::GetMeleeDamageSchoolMask() const
 {
diff --git a/src/game/Unit.h b/src/game/Unit.h
index 6eb6438..f221792 100644
--- a/src/game/Unit.h
+++ b/src/game/Unit.h
@@ -74,7 +74,7 @@ enum SpellAuraInterruptFlags
     AURA_INTERRUPT_FLAG_MOUNTING            = 0x00020000,   // 17   removed by mounting
     AURA_INTERRUPT_FLAG_NOT_SEATED          = 0x00040000,   // 18   removed by standing up
     AURA_INTERRUPT_FLAG_CHANGE_MAP          = 0x00080000,   // 19   leaving map/getting teleported
-    AURA_INTERRUPT_FLAG_UNK20               = 0x00100000,   // 20
+    AURA_INTERRUPT_FLAG_LOST_SELECTION      = 0x00100000,   // 20      removed by auras that make you invulnerable, or make lost selection on you
     AURA_INTERRUPT_FLAG_UNK21               = 0x00200000,   // 21
     AURA_INTERRUPT_FLAG_UNK22               = 0x00400000,   // 22
     AURA_INTERRUPT_FLAG_ENTER_PVP_COMBAT    = 0x00800000,   // 23   removed by entering pvp combat
@@ -512,6 +512,7 @@ enum NPCFlags
     UNIT_NPC_FLAG_GUILD_BANKER          = 0x00800000,       // cause client to send 997 opcode
     UNIT_NPC_FLAG_SPELLCLICK            = 0x01000000,       // cause client to send 1015 opcode (spell click)
     UNIT_NPC_FLAG_GUARD                 = 0x10000000,       // custom flag for guards
+    UNIT_NPC_FLAG_OUTDOORPVP            = 0x20000000,       // custom flag for outdoor pvp creatures
 };
 
 enum MovementFlags
@@ -578,6 +579,50 @@ struct CleanDamage
     MeleeHitOutcome hitOutCome;
 };
 
+// Struct for use in Unit::CalculateMeleeDamage 
+// Need create structure like in SMSG_ATTACKERSTATEUPDATE opcode
+struct CalcDamageInfo
+{
+    Unit  *attacker;             // Attacker
+    Unit  *target;               // Target for damage
+    uint32 damageSchoolMask;
+    uint32 damage;
+    uint32 absorb;
+    uint32 resist;
+    uint32 blocked_amount;
+    uint32 HitInfo;
+    uint32 TargetState;
+// Helper
+    WeaponAttackType attackType; // 
+    uint32 procAttacker;
+    uint32 procVictim;
+    uint32 procEx;
+    uint32 cleanDamage;          // Used only fo rage calcultion
+    MeleeHitOutcome hitOutCome;  // TODO: remove this field (need use TargetState)
+};
+
+// Spell damage info structure based on structure sending in SMSG_SPELLNONMELEEDAMAGELOG opcode
+struct SpellNonMeleeDamage{
+ SpellNonMeleeDamage(Unit *_attacker, Unit *_target, uint32 _SpellID, uint32 _schoolMask) :
+    attacker(_attacker), target(_target), SpellID(_SpellID), damage(0), schoolMask(_schoolMask), 
+    absorb(0), resist(0), phusicalLog(false), unused(false), blocked(0), HitInfo(0), cleanDamage(0) {}
+ Unit   *target;
+ Unit   *attacker;
+ uint32 SpellID;
+ uint32 damage;
+ uint32 schoolMask;
+ uint32 absorb;
+ uint32 resist;
+ bool   phusicalLog;
+ bool   unused;
+ uint32 blocked;
+ uint32 HitInfo;
+ // Used for help
+ uint32 cleanDamage;
+};
+
+uint32 createProcExtendMask(SpellNonMeleeDamage *damageInfo, SpellMissInfo missCondition);
+
 struct UnitActionBarEntry
 {
     uint32 Type;
@@ -834,15 +879,23 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
 
         uint16 GetMaxSkillValueForLevel(Unit const* target = NULL) const { return (target ? getLevelForTarget(target) : getLevel()) * 5; }
         uint32 DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDamage, DamageEffectType damagetype, SpellSchoolMask damageSchoolMask, SpellEntry const *spellProto, bool durabilityLoss);
-        void DealFlatDamage(Unit *pVictim, SpellEntry const *spellInfo, uint32 *damage, CleanDamage *cleanDamage, bool *crit = false, bool isTriggeredSpell = false);
-        void DoAttackDamage(Unit *pVictim, uint32 *damage, CleanDamage *cleanDamage, uint32 *blocked_amount, SpellSchoolMask damageSchoolMask, uint32 *hitInfo, VictimState *victimState, uint32 *absorbDamage, uint32 *resistDamage, WeaponAttackType attType, SpellEntry const *spellCasted = NULL, bool isTriggeredSpell = false);
 
-        void CastMeleeProcDamageAndSpell(Unit* pVictim, uint32 damage, SpellSchoolMask damageSchoolMask, WeaponAttackType attType, MeleeHitOutcome outcome, SpellEntry const *spellCasted = NULL, bool isTriggeredSpell = false);
-        void ProcDamageAndSpell(Unit *pVictim, uint32 procAttacker, uint32 procVictim, uint32 damage = 0, SpellSchoolMask damageSchoolMask = SPELL_SCHOOL_MASK_NONE, SpellEntry const *procSpell = NULL, bool isTriggeredSpell = false, WeaponAttackType attType = BASE_ATTACK);
+        void ProcDamageAndSpell(Unit *pVictim, uint32 procAttacker, uint32 procVictim, uint32 procEx, uint32 amount, WeaponAttackType attType = BASE_ATTACK, SpellEntry const *procSpell = NULL);
+        void ProcDamageAndSpellFor( bool isVictim, Unit * pTarget, uint32 procFlag, uint32 procExtra, WeaponAttackType attType, SpellEntry const * procSpell, uint32 damage );
+
         void HandleEmoteCommand(uint32 anim_id);
         void AttackerStateUpdate (Unit *pVictim, WeaponAttackType attType = BASE_ATTACK, bool extra = false );
 
         float MeleeMissChanceCalc(const Unit *pVictim, WeaponAttackType attType) const;
+
+        void CalculateMeleeDamage(Unit *pVictim, uint32 damage, CalcDamageInfo *damageInfo, WeaponAttackType attackType = BASE_ATTACK);
+        void DealMeleeDamage(CalcDamageInfo *damageInfo, bool durabilityLoss);
+
+        void CalculateSpellDamage(SpellNonMeleeDamage *damageInfo, int32 damage, SpellEntry const *spellInfo, WeaponAttackType attackType = BASE_ATTACK);
+        void DealSpellDamage(SpellNonMeleeDamage *damageInfo, bool durabilityLoss);
+
+        float  MeleeSpellMissChance(Unit *pVictim, WeaponAttackType attType, int32 skillDiff, SpellEntry const *spell);
+        SpellMissInfo MeleeSpellHitResult(Unit *pVictim, SpellEntry const *spell);
         SpellMissInfo MagicSpellHitResult(Unit *pVictim, SpellEntry const *spell);
         SpellMissInfo SpellHitResult(Unit *pVictim, SpellEntry const *spell, bool canReflect = false);
 
@@ -857,7 +910,7 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
         uint32 GetWeaponSkillValue(WeaponAttackType attType, Unit const* target = NULL) const;
         float GetWeaponProcChance() const;
         float GetPPMProcChance(uint32 WeaponSpeed, float PPM) const;
-        MeleeHitOutcome RollPhysicalOutcomeAgainst (const Unit *pVictim, WeaponAttackType attType, SpellEntry const *spellInfo);
+
         MeleeHitOutcome RollMeleeOutcomeAgainst (const Unit *pVictim, WeaponAttackType attType) const;
         MeleeHitOutcome RollMeleeOutcomeAgainst (const Unit *pVictim, WeaponAttackType attType, int32 crit_chance, int32 miss_chance, int32 dodge_chance, int32 parry_chance, int32 block_chance, bool SpellCasted ) const;
 
@@ -910,8 +963,6 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
 
         bool isFrozen() const;
 
-        void RemoveSpellbyDamageTaken(AuraType auraType, uint32 damage);
-
         bool isTargetableForAttack() const;
         virtual bool IsInWater() const;
         virtual bool IsUnderWater() const;
@@ -931,7 +982,9 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
 
         void DeMorph();
 
+        void SendAttackStateUpdate(CalcDamageInfo *damageInfo);
         void SendAttackStateUpdate(uint32 HitInfo, Unit *target, uint8 SwingType, SpellSchoolMask damageSchoolMask, uint32 Damage, uint32 AbsorbDamage, uint32 Resist, VictimState TargetState, uint32 BlockedAmount);
+        void SendSpellNonMeleeDamageLog(SpellNonMeleeDamage *log);
         void SendSpellNonMeleeDamageLog(Unit *target,uint32 SpellID,uint32 Damage, SpellSchoolMask damageSchoolMask,uint32 AbsorbedDamage, uint32 Resist,bool PhysicalDamage, uint32 Blocked, bool CriticalHit = false);
         void SendSpellMiss(Unit *target, uint32 spellID, SpellMissInfo missInfo);
 
@@ -1004,6 +1057,7 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
         void RemoveAurasWithDispelType( DispelType type );
 
         void RemoveAllAuras();
+        void RemoveArenaAuras(bool onleave = false);
         void RemoveAllAurasOnDeath();
         void DelayAura(uint32 spellId, uint32 effindex, int32 delaytime);
 
@@ -1175,7 +1229,8 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
         int32 SpellBaseHealingBonusForVictim(SpellSchoolMask schoolMask, Unit *pVictim);
         uint32 SpellDamageBonus(Unit *pVictim, SpellEntry const *spellProto, uint32 damage, DamageEffectType damagetype);
         uint32 SpellHealingBonus(SpellEntry const *spellProto, uint32 healamount, DamageEffectType damagetype, Unit *pVictim);
-        bool   isSpellCrit(Unit *pVictim, SpellEntry const *spellProto, SpellSchoolMask schoolMask, WeaponAttackType attackType);
+        bool   isSpellBlocked(Unit *pVictim, SpellEntry const *spellProto, WeaponAttackType attackType = BASE_ATTACK);
+        bool   isSpellCrit(Unit *pVictim, SpellEntry const *spellProto, SpellSchoolMask schoolMask, WeaponAttackType attackType = BASE_ATTACK);
         uint32 SpellCriticalBonus(SpellEntry const *spellProto, uint32 damage, Unit *pVictim);
 
         void SetLastManaUse(uint32 spellCastTime) { m_lastManaUse = spellCastTime; }
@@ -1313,11 +1368,11 @@ class MANGOS_DLL_SPEC Unit : public WorldObject
         void SendAttackStop(Unit* victim);                  // only from AttackStop(Unit*)
         void SendAttackStart(Unit* pVictim);                // only from Unit::AttackStart(Unit*)
 
-        void ProcDamageAndSpellFor( bool isVictim, Unit * pTarget, uint32 procFlag, AuraTypeSet const& procAuraTypes, WeaponAttackType attType, SpellEntry const * procSpell, uint32 damage, SpellSchoolMask damageSchoolMask );
-        bool HandleDummyAuraProc(Unit *pVictim, SpellEntry const *spellProto, uint32 effIndex, uint32 damage, Aura* triggredByAura, SpellEntry const * procSpell, uint32 procFlag,uint32 cooldown);
-        bool HandleProcTriggerSpell(Unit *pVictim,uint32 damage, Aura* triggredByAura, SpellEntry const *procSpell, uint32 procFlags,WeaponAttackType attType,uint32 cooldown);
-        bool HandleHasteAuraProc(Unit *pVictim, SpellEntry const *spellProto, uint32 effIndex, uint32 damage, Aura* triggredByAura, SpellEntry const * procSpell, uint32 procFlag,uint32 cooldown);
-        bool HandleOverrideClassScriptAuraProc(Unit *pVictim, int32 scriptId, uint32 damage, Aura* triggredByAura, SpellEntry const *procSpell,uint32 cooldown);
+        bool HandleDummyAuraProc(Unit *pVictim, SpellEntry const *spellProto, uint32 effIndex, uint32 damage, Aura* triggredByAura, SpellEntry const * procSpell, uint32 procFlag, uint32 procEx, uint32 cooldown);
+        bool HandleHasteAuraProc(Unit *pVictim, SpellEntry const *spellProto, uint32 effIndex, uint32 damage, Aura* triggredByAura, SpellEntry const * procSpell, uint32 procFlag, uint32 procEx, uint32 cooldown);
+        bool HandleProcTriggerSpell(Unit *pVictim,uint32 damage, Aura* triggredByAura, SpellEntry const *procSpell, uint32 procFlags, uint32 procEx, uint32 cooldown);
+        bool HandleOverrideClassScriptAuraProc(Unit *pVictim, int32 scriptId, uint32 damage, Aura* triggredByAura, SpellEntry const *procSpell, uint32 cooldown);
+
 
         uint32 m_state;                                     // Even derived shouldn't modify
         uint32 m_CombatTimer;
diff --git a/src/game/World.cpp b/src/game/World.cpp
index 5c0d0b6..cac5ff8 100644
--- a/src/game/World.cpp
+++ b/src/game/World.cpp
@@ -41,6 +41,7 @@
 #include "Database/DBCStores.h"
 #include "LootMgr.h"
 #include "ItemEnchantmentMgr.h"
+#include "AuctionHouseBot.h"
 #include "MapManager.h"
 #include "ScriptCalls.h"
 #include "CreatureAIRegistry.h"
@@ -57,6 +58,8 @@
 #include "InstanceSaveMgr.h"
 #include "WaypointManager.h"
 #include "Util.h"
+#include "OutdoorPvPMgr.h"
+#include "Language.h"
 
 INSTANTIATE_SINGLETON_1( World );
 
@@ -483,7 +486,11 @@ void World::LoadConfigSettings(bool reload)
         sLog.outError("TargetPosRecalculateRange (%f) must be <= %f. Using %f instead.",rate_values[RATE_TARGET_POS_RECALCULATION_RANGE],ATTACK_DISTANCE,ATTACK_DISTANCE);
         rate_values[RATE_TARGET_POS_RECALCULATION_RANGE] = ATTACK_DISTANCE;
     }
-
+    // movement anticheat
+    m_EnableMvAnticheat = sConfig.GetBoolDefault("Anticheat.Movement.Enable",true);     
+    m_AlarmKickMvAnticheat = sConfig.GetBoolDefault("Anticheat.Movement.Kick",false);
+    m_AlarmCountMvAnticheat = sConfig.GetIntDefault("Anticheat.Movement.AlarmCount", 5);
+    m_AlarmTimeMvAnticheat = sConfig.GetIntDefault("Anticheat.Movement.AlarmTime", 5000); 
     rate_values[RATE_DURABILITY_LOSS_DAMAGE] = sConfig.GetFloatDefault("DurabilityLossChance.Damage",0.5f);
     if(rate_values[RATE_DURABILITY_LOSS_DAMAGE] < 0.0f)
     {
@@ -794,6 +801,13 @@ void World::LoadConfigSettings(bool reload)
     m_configs[CONFIG_LISTEN_RANGE_TEXTEMOTE] = sConfig.GetIntDefault("ListenRange.TextEmote", 25);
     m_configs[CONFIG_LISTEN_RANGE_YELL]      = sConfig.GetIntDefault("ListenRange.Yell", 300);
 
+    m_configs[CONFIG_ARENA_MAX_RATING_DIFFERENCE] = sConfig.GetIntDefault("Arena.MaxRatingDifference", 0);
+    m_configs[CONFIG_ARENA_RATING_DISCARD_TIMER] = sConfig.GetIntDefault("Arena.RatingDiscardTimer",300000);
+    m_configs[CONFIG_ARENA_AUTO_DISTRIBUTE_POINTS] = sConfig.GetBoolDefault("Arena.AutoDistributePoints", false);
+    m_configs[CONFIG_ARENA_AUTO_DISTRIBUTE_INTERVAL_DAYS] = sConfig.GetIntDefault("Arena.AutoDistributeInterval", 7);
+
+    m_configs[CONFIG_BATTLEGROUND_PREMATURE_FINISH_TIMER] = sConfig.GetIntDefault("BattleGround.PrematureFinishTimer", 0);
+
     m_VisibleUnitGreyDistance = sConfig.GetFloatDefault("Visibility.Distance.Grey.Unit", 1);
     if(m_VisibleUnitGreyDistance >  MAX_VISIBILITY_DISTANCE)
     {
@@ -1151,6 +1165,9 @@ void World::SetInitialWorldSettings()
 
     WorldDatabase.PExecute("INSERT INTO uptime (startstring, starttime, uptime) VALUES('%s', %ld, 0)", isoDate, m_startTime );
 
+	static uint32 abtimer = 0;
+	abtimer = sConfig.GetIntDefault("AutoBroadcast.Timer", 60000);
+	
     m_timers[WUPDATE_OBJECTS].SetInterval(0);
     m_timers[WUPDATE_SESSIONS].SetInterval(0);
     m_timers[WUPDATE_WEATHERS].SetInterval(1000);
@@ -1158,6 +1175,7 @@ void World::SetInitialWorldSettings()
     m_timers[WUPDATE_UPTIME].SetInterval(m_configs[CONFIG_UPTIME_UPDATE]*MINUTE*1000);
                                                             //Update "uptime" table based on configuration entry in minutes.
     m_timers[WUPDATE_CORPSES].SetInterval(20*MINUTE*1000);  //erase corpses every 20 minutes
+	m_timers[WUPDATE_AUTOBROADCAST].SetInterval(abtimer);
 
     //to set mailtimer to return mails every day between 4 and 5 am
     //mailtimer is increased when updating auctions
@@ -1179,6 +1197,10 @@ void World::SetInitialWorldSettings()
     ///- Initialize Battlegrounds
     sLog.outString( "Starting BattleGround System" );
     sBattleGroundMgr.CreateInitialBattleGrounds();
+    sBattleGroundMgr.InitAutomaticArenaPointDistribution();
+
+    sLog.outString( "Starting Outdoor PvP System" );
+    sOutdoorPvPMgr.InitOutdoorPvP();
 
     //Not sure if this can be moved up in the sequence (with static data loading) as it uses MapManager
     sLog.outString( "Loading Transports..." );
@@ -1194,6 +1216,8 @@ void World::SetInitialWorldSettings()
     uint32 nextGameEvent = gameeventmgr.Initialize();
     m_timers[WUPDATE_EVENTS].SetInterval(nextGameEvent);    //depend on next event
 
+    AuctionHouseBotInit();
+
     sLog.outString( "WORLD: World initialized" );
 }
 
@@ -1262,6 +1286,7 @@ void World::Update(time_t diff)
     /// <ul><li> Handle auctions when the timer has passed
     if (m_timers[WUPDATE_AUCTIONS].Passed())
     {
+        AuctionHouseBot();
         m_timers[WUPDATE_AUCTIONS].Reset();
 
         ///- Update mails (return old mails with item, or delete them)
@@ -1373,6 +1398,8 @@ void World::Update(time_t diff)
             ScriptsProcess();
 
         sBattleGroundMgr.Update(diff);
+
+        sOutdoorPvPMgr.Update(diff);
     }
 
     // execute callbacks from sql queries that were queued recently
@@ -1395,6 +1422,17 @@ void World::Update(time_t diff)
         m_timers[WUPDATE_EVENTS].Reset();
     }
 
+	static uint32 autobroadcaston = 0;
+	autobroadcaston = sConfig.GetIntDefault("AutoBroadcast.On", 0);
+	if(autobroadcaston == 1)
+	{
+		if (m_timers[WUPDATE_AUTOBROADCAST].Passed())
+		{
+			m_timers[WUPDATE_AUTOBROADCAST].Reset();
+			SendRNDBroadcast();
+		}
+	}
+	
     /// </ul>
     ///- Move all creatures with "delayed move" and remove and delete all objects with "delayed remove"
     MapManager::Instance().DoDelayedMovesAndRemoves();
@@ -2124,6 +2162,24 @@ void World::SendWorldText(int32 string_id, ...)
             delete data_cache[i][j];
 }
 
+/// Send a System Message to all players (except self if mentioned)
+void World::SendGlobalText(const char* text, WorldSession *self)
+{
+    WorldPacket data;
+
+    // need copy to prevent corruption by strtok call in LineFromMessage original string
+    char* buf = strdup(text);
+    char* pos = buf;
+
+    while(char* line = ChatHandler::LineFromMessage(pos))
+    {
+        ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_SYSTEM, LANG_UNIVERSAL, NULL, 0, line, NULL);
+        SendGlobalMessage(&data, self);
+    }
+
+    free(buf);
+}
+
 /// Send a packet to all players (or players selected team) in the zone (except self if mentioned)
 void World::SendZoneMessage(uint32 zone, WorldPacket *packet, WorldSession *self, uint32 team)
 {
@@ -2455,6 +2511,45 @@ void World::ProcessCliCommands()
     zprint("mangos>");
 }
 
+void World::SendRNDBroadcast()
+{
+	std::string msg;
+	QueryResult *result = WorldDatabase.PQuery("SELECT `text` FROM `autobroadcast` ORDER BY RAND() LIMIT 1");
+	
+	if(!result)
+		return;
+	
+	msg = result->Fetch()[0].GetString();
+	delete result;
+
+	static uint32 abcenter = 0;
+    abcenter = sConfig.GetIntDefault("AutoBroadcast.Center", 0);
+    if(abcenter == 0)
+    {
+		sWorld.SendWorldText(LANG_AUTO_BROADCAST, msg.c_str());
+
+		sLog.outString("AutoBroadcast: '%s'",msg.c_str());
+	}
+	if(abcenter == 1)
+	{
+		WorldPacket data(SMSG_NOTIFICATION, (msg.size()+1));
+		data << msg;
+		sWorld.SendGlobalMessage(&data);
+
+		sLog.outString("AutoBroadcast: '%s'",msg.c_str());
+	}
+	if(abcenter == 2)
+	{
+		sWorld.SendWorldText(LANG_AUTO_BROADCAST, msg.c_str());
+
+		WorldPacket data(SMSG_NOTIFICATION, (msg.size()+1));
+		data << msg;
+		sWorld.SendGlobalMessage(&data);
+
+		sLog.outString("AutoBroadcast: '%s'",msg.c_str());
+	}
+}
+
 void World::InitResultQueue()
 {
     m_resultQueue = new SqlResultQueue;
diff --git a/src/game/World.h b/src/game/World.h
index 2dad314..8977b48 100644
--- a/src/game/World.h
+++ b/src/game/World.h
@@ -59,7 +59,8 @@ enum WorldTimers
     WUPDATE_UPTIME      = 4,
     WUPDATE_CORPSES     = 5,
     WUPDATE_EVENTS      = 6,
-    WUPDATE_COUNT       = 7
+    WUPDATE_AUTOBROADCAST = 7,
+	WUPDATE_COUNT 		= 8
 };
 
 /// Configuration elements
@@ -160,6 +161,11 @@ enum WorldConfigs
     CONFIG_LISTEN_RANGE_SAY,
     CONFIG_LISTEN_RANGE_TEXTEMOTE,
     CONFIG_LISTEN_RANGE_YELL,
+    CONFIG_ARENA_MAX_RATING_DIFFERENCE,
+    CONFIG_ARENA_RATING_DISCARD_TIMER,
+    CONFIG_ARENA_AUTO_DISTRIBUTE_POINTS,
+    CONFIG_ARENA_AUTO_DISTRIBUTE_INTERVAL_DAYS,
+    CONFIG_BATTLEGROUND_PREMATURE_FINISH_TIMER,
     CONFIG_VALUE_COUNT
 };
 
@@ -318,6 +324,7 @@ class World
 
         WorldSession* FindSession(uint32 id) const;
         void AddSession(WorldSession *s);
+		void SendRNDBroadcast();
         bool RemoveSession(uint32 id);
         /// Get the number of current active sessions
         void UpdateMaxSessionCounters();
@@ -381,6 +388,7 @@ class World
         void LoadConfigSettings(bool reload = false);
 
         void SendWorldText(int32 string_id, ...);
+        void SendGlobalText(const char* text, WorldSession *self);
         void SendGlobalMessage(WorldPacket *packet, WorldSession *self = 0, uint32 team = 0);
         void SendZoneMessage(uint32 zone, WorldPacket *packet, WorldSession *self = 0, uint32 team = 0);
         void SendZoneText(uint32 zone, const char *text, WorldSession *self = 0, uint32 team = 0);
@@ -439,6 +447,11 @@ class World
         static float GetMaxVisibleDistanceInFlight()    { return m_MaxVisibleDistanceInFlight;    }
         static float GetVisibleUnitGreyDistance()       { return m_VisibleUnitGreyDistance;       }
         static float GetVisibleObjectGreyDistance()     { return m_VisibleObjectGreyDistance;     }
+        //movement anticheat enable flag
+        bool GetEnableMvAnticheat()     {return m_EnableMvAnticheat;}       
+        bool GetAlarmKickMvAnticheat()  {return m_AlarmKickMvAnticheat;}    
+        uint32 GetAlarmCountMvAnticheat() {return m_AlarmCountMvAnticheat;}    
+        uint32 GetAlarmTimeMvAnticheat()  {return m_AlarmTimeMvAnticheat;} 
 
         void ProcessCliCommands();
         void QueueCliCommand( CliCommandHolder::Print* zprintf, char const* input ) { cliCmdQueue.add(new CliCommandHolder(input, zprintf)); }
@@ -494,7 +507,11 @@ class World
         static float m_MaxVisibleDistanceInFlight;
         static float m_VisibleUnitGreyDistance;
         static float m_VisibleObjectGreyDistance;
-
+        //movement anticheat enable flag
+        bool m_EnableMvAnticheat;
+        bool m_AlarmKickMvAnticheat;
+        uint32 m_AlarmCountMvAnticheat;
+        uint32 m_AlarmTimeMvAnticheat;    
         // CLI command holder to be thread safe
         ZThread::LockedQueue<CliCommandHolder*, ZThread::FastMutex> cliCmdQueue;
         SqlResultQueue *m_resultQueue;
diff --git a/src/game/WorldSession.cpp b/src/game/WorldSession.cpp
index 60c0605..9840e1e 100644
--- a/src/game/WorldSession.cpp
+++ b/src/game/WorldSession.cpp
@@ -36,7 +36,8 @@
 #include "MapManager.h"
 #include "ObjectAccessor.h"
 #include "BattleGroundMgr.h"
-#include "Language.h"                                       // for CMSG_CANCEL_MOUNT_AURA handler
+#include "OutdoorPvPMgr.h"
+#include "Language.h"                                       // for CMSG_DISMOUNT handler
 #include "Chat.h"
 #include "SocialMgr.h"
 
@@ -304,6 +305,8 @@ void WorldSession::LogoutPlayer(bool Save)
         if(_player->InBattleGround())
             _player->LeaveBattleground();
 
+        sOutdoorPvPMgr.HandlePlayerLeaveZone(_player,_player->GetZoneId());
+
         for (int i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
         {
             if(int32 bgTypeId = _player->GetBattleGroundQueueId(i))
diff --git a/src/game/debugcmds.cpp b/src/game/debugcmds.cpp
index 83754be..a1ce726 100644
--- a/src/game/debugcmds.cpp
+++ b/src/game/debugcmds.cpp
@@ -30,6 +30,7 @@
 #include "GossipDef.h"
 #include "Language.h"
 #include "MapManager.h"
+#include "BattleGroundMgr.h"
 #include <fstream>
 
 bool ChatHandler::HandleDebugInArcCommand(const char* /*args*/)
@@ -515,3 +516,9 @@ bool ChatHandler::HandleGetItemState(const char* args)
 
     return true;
 }
+
+bool ChatHandler::HandleDebugArenaCommand(const char * /*args*/)
+{
+    sBattleGroundMgr.ToggleArenaTesting();
+    return true;
+}
diff --git a/src/mangosd/mangosd.conf.dist.in b/src/mangosd/mangosd.conf.dist.in
index d43f220..9a92ef2 100644
--- a/src/mangosd/mangosd.conf.dist.in
+++ b/src/mangosd/mangosd.conf.dist.in
@@ -294,6 +294,78 @@ GmLogTimestamp = 0
 RaLogFile = ""
 LogColors = ""
 
+# Chat log parameters
+ChatLogEnable = 0
+
+# If this is enabled, all $d in file names are replaced with current date
+# This does include innormative lexics log
+ChatLogDateSplit = 1
+
+# If this is enabled, UTF8 header is written into new files
+ChatLogUTFHeader = 1
+
+# If this is enabled, chat log will ignore messages with unprintable chars
+ChatLogIgnoreUnprintable = 1
+
+# Chat log files
+ChatLogChatFile = main_chat-$d.log
+ChatLogPartyFile = party_chat-$d.log
+ChatLogGuildFile = guild_chat-$d.log
+ChatLogWhisperFile = whisper_chat-$d.log
+ChatLogChannelFile = channel_chat-$d.log
+ChatLogRaidFile = raid_chat-$d.log
+ChatLogBattleGroundFile = bg_chat-$d.log
+
+# Chat log screen logging
+ChatLogChatScreen = 0
+ChatLogPartyScreen = 0
+ChatLogGuildScreen = 0
+ChatLogWhisperScreen = 0
+ChatLogChannelScreen = 0
+ChatLogRaidScreen = 0
+ChatLogBattleGroundScreen = 0
+
+# Lexics cutter parameters
+LexicsCutterEnable = 1
+
+LexicsCutterInnormativeCut = 1
+LexicsCutterCutReplacement = &!@^%!^&*!!!
+LexicsCutterLogFile = innormative-$d.log
+LexicsCutterScreenLog = 0
+LexicsCutterAnalogsFile = letter_analogs.txt
+LexicsCutterWordsFile = innormative_words.txt
+
+# Where to cut lexics
+LexicsCutInChat = 1
+LexicsCutInParty = 1
+LexicsCutInGuild = 1
+LexicsCutInWhisper = 1
+LexicsCutInChannel = 1
+LexicsCutInRaid = 1
+LexicsCutInBattleGround = 1
+
+# Ignore word spaces like: W O R D
+LexicsCutterIgnoreSpaces = 1
+
+# Ignore repeats like: WWOOOORRRRRD
+LexicsCutterIgnoreRepeats = 1
+
+# --- Action:
+# ---   0: log only
+# ---   1: sheep
+# ---   2: stun
+# ---   3: kill
+# ---   4: leave 5 health
+# ---   5: disable chat
+# ---   6: stuck (works as stun + 50% health) [by KAPATEJIb]
+# ---   7: resurrection sickness [by Koshei]
+# ---   8: shear [by Koshei]
+LexicsCutterAction = 0
+LexicsCutterActionDuration = 60000
+
+# Do not perform action on GM if this is enabled
+LexicsCutterNoActionOnGM = 1
+
 ###################################################################################################################
 # SERVER SETTINGS
 #
@@ -1079,3 +1151,252 @@ Ra.IP = 0.0.0.0
 Ra.Port = 3443
 Ra.MinLevel = 3
 Ra.Secure = 1
+
+###################################################################################################################
+# AUTO BROADCAST
+#
+#    AutoBroadcast.On
+#        Enable auto broadcast
+#        Default: 0 - off
+#                 1 - on
+#
+#    AutoBroadcast.Center
+#        Display method
+#        Default: 0 - announce
+#                 1 - notify
+#                 2 - both
+#
+#    AutoBroadcast.Timer
+#        Timer for auto broadcast
+#
+###################################################################################################################
+
+AutoBroadcast.On = 0
+AutoBroadcast.Center = 0
+AutoBroadcast.Timer = 60000
+ 
+ ###################################################################################################################
+ # AUCTION HOUSE BOT SETTINGS
+ # 
+ #    Auction House Bot character data
+ #        AuctionHouseBot.Account is the account number (in realmd->account table) of the player you want to run as the auction bot.
+ # 	    AuctionHouseBot.GUID is the GUID (in characters->characters table) of the player you want to run as the auction bot. 
+ #    Default: 0 (Auction House Bot disabled)
+ #
+ #    AuctionHouseBot.NoMail
+ #        This is a flag to disable mail for successfull auctions. 
+ #        A value of 0 will allow mail for successful auctions to be sent, which is the default.
+ #        Non-zero (e.g. AuctionHouseBot.NoMail = 1) will stop successful auction mail.
+ #    Default: 0 (Send auction successful mail)
+ # 
+ #    AuctionHouseBot.AllianceItems
+ #        This is the number of items you want to keep in the Alliance auction house.
+ #    AuctionHouseBot.HordeItems
+ #        This is the number of items you want to keep in the Horde auction house.
+ #    AuctionHouseBot.NeutralItems
+ #        This is the number of items you want to keep in the Neutral auction house.
+ #    Default: 0 (No items generated)
+ #        Note: If you enable AllowTwoSide.Interaction.Trade, ALL auction houses are linked to the neutral auction house.
+ #
+ #    AuctionHouseBot.MinAllianceItems
+ #        This is the minimum number of items you want to keep in the Alliance auction house.
+ #    AuctionHouseBot.MinHordeItems
+ #        This is the minimum number of items you want to keep in the Horde auction house.
+ #    AuctionHouseBot.MinNeutralItems
+ #        This is the minimum number of items you want to keep in the Neutral auction house.
+ #    Default: -1 (minimum will be the same as maximum)
+ # 
+ #    AuctionHouseBot.MinTime
+ #        Sets the minimum number of hours for an auction.
+ #    Default: 8
+ #
+ #    AuctionHouseBot.MaxTime
+ #        Sets the maximum number of hours for an auction.
+ #    Default: 24
+ #
+ #    Item distribution
+ #        Sets the percentage of the auction items that should be trade goods of white quality.
+ #        A value of 0 will disable.
+ #    AuctionHouseBot.PercentWhiteTradeGoods
+ #        Sets the percentage of the White Trade Goods auction items
+ #    Default: 30
+ #    AuctionHouseBot.PercentGreenTradeGoods
+ #        Sets the percentage of the Green Trade Goods auction items
+ #    Default: 13
+ #    AuctionHouseBot.PercentBlueTradeGoods
+ #        Sets the percentage of the Blue Trade Goods auction items
+ #    Default: 9
+ #    AuctionHouseBot.PercentPurpleTradeGoods
+ #        Sets the percentage of the Purple Trade Goods auction items
+ #    Default: 1
+ #        Note: All of the above values (AuctionHouseBot Percent TradeGoods) must add together to make 100 percent.
+ #
+ #    AuctionHouseBot.PercentWhiteItems
+ #        Sets the percentage of the non trade White auction items
+ #    Default: 6
+ #    AuctionHouseBot.PercentGreenItems
+ #        Sets the percentage of the non trade Green auction items
+ #    Default: 30
+ #    AuctionHouseBot.PercentBlueItems
+ #        Sets the percentage of the non trade Blue auction items
+ #    Default: 9
+ #    AuctionHouseBot.PercentPurpleItems
+ #        Sets the percentage of the non trade Purple auction items
+ #    Default: 2
+ #        Note: All of the above values (AuctionHouseBot Percent Items) must add together to make 100 percent.
+ #
+ #    Minimum and maximim price mark-up for items.  Percentage of vendor sale price.
+ #        Example: If a vendor would sell an item for 1g and MinPrice = 150 and MaxPrice = 250,
+ #        then that item would be randomly priced between 1g 50s and 2g 50s.
+ #    AuctionHouseBot.MinPriceWhite
+ #        Minimum price of White items.
+ #    Default: 150
+ #    AuctionHouseBot.MaxPriceWhite
+ #        Maximum price of White items.
+ #    Default: 250
+ #    AuctionHouseBot.MinPriceGreen
+ #        Minimum price of Green items.
+ #    Default: 200
+ #    AuctionHouseBot.MaxPriceGreen
+ #        Maximum price of Green items.
+ #    Default: 300
+ #    AuctionHouseBot.MinPriceBlue
+ #        Minimum price of Blue items.
+ #    Default: 250
+ #    AuctionHouseBot.MaxPriceBlue
+ #        Maximum price of Blue items.
+ #    Default: 350
+ #    AuctionHouseBot.MinPricePurple
+ #        Minimum price of Purple items.
+ #    Default: 300
+ #    AuctionHouseBot.MaxPricePurple
+ #        Maximum price of Purple items.
+ #    Default: 450
+ #
+ #    AuctionHouseBot.BidPrice
+ #    Starting bid price as a percentage of the randomly chosen buyout price
+ #    AuctionHouseBot.BidPriceWhite
+ #    Default: 100 (Bid and buyout price the same)
+ #    AuctionHouseBot.BidPriceGreen
+ #    Default: 100 (Bid and buyout price the same)
+ #    AuctionHouseBot.BidPriceBlue
+ #    Default: 100 (Bid and buyout price the same)
+ #    +AuctionHouseBot.BidPricePurple
+ #    Default: 100 (Bid and buyout price the same)
+ #
+ #    AuctionHouseBot.MaxStack
+ #        Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality,
+ #        which will allow the bot to create items in stack as large as the item allows.
+ #    AuctionHouseBot.MaxStackWhite
+ #    Default: 0
+ #    AuctionHouseBot.MaxStackGreen
+ #    Default: 3
+ #    AuctionHouseBot.MaxStackBlue
+ #    Default: 2
+ #    AuctionHouseBot.MaxStackPurple
+ #    Default: 1
+ #
+ ###################################################################################################################
+ 
+ AuctionHouseBot.Account = 0
+ AuctionHouseBot.GUID = 0
+ AuctionHouseBot.NoMail = 0
+ AuctionHouseBot.AllianceItems = 0
+ AuctionHouseBot.HordeItems = 0
+ AuctionHouseBot.NeutralItems = 0
+ AuctionHouseBot.MinAllianceItems = -1
+ AuctionHouseBot.MinHordeItems = -1
+ AuctionHouseBot.MinNeutralItems = -1
+ AuctionHouseBot.MinTime = 8
+ AuctionHouseBot.MaxTime = 24
+ AuctionHouseBot.PercentWhiteTradeGoods = 30
+ AuctionHouseBot.PercentGreenTradeGoods = 13
+ AuctionHouseBot.PercentBlueTradeGoods = 9
+ AuctionHouseBot.PercentPurpleTradeGoods = 1
+ AuctionHouseBot.PercentWhiteItems = 6
+ AuctionHouseBot.PercentGreenItems = 30
+ AuctionHouseBot.PercentBlueItems = 9
+ AuctionHouseBot.PercentPurpleItems = 2
+ AuctionHouseBot.MinPriceWhite = 150
+ AuctionHouseBot.MaxPriceWhite = 250
+ AuctionHouseBot.MinPriceGreen = 200
+ AuctionHouseBot.MaxPriceGreen = 300
+ AuctionHouseBot.MinPriceBlue = 250
+ AuctionHouseBot.MaxPriceBlue = 350
+ AuctionHouseBot.MinPricePurple = 300
+ AuctionHouseBot.MaxPricePurple = 450
+ AuctionHouseBot.BidPriceWhite = 100
+ AuctionHouseBot.BidPriceGreen = 100
+ AuctionHouseBot.BidPriceBlue = 100
+ AuctionHouseBot.BidPricePurple = 100
+ AuctionHouseBot.MaxStackWhite = 0
+ AuctionHouseBot.MaxStackGreen = 3
+ AuctionHouseBot.MaxStackBlue = 2
+ AuctionHouseBot.MaxStackPurple = 1
+ 
+ ###################################################################################################################
+ #
+ # Rated arena matches config
+ #
+ # MaxRatingDifference: the maximum rating difference between two groups in rated matches
+ #             Default: 0 (disable, rating difference is discarded)  
+ #
+ # RatingDiscardTimer: after the specified milliseconds has passed, 
+ #                     rating information will be discarded when selecting teams for matches
+ #                     also initiates an update by this timer
+ #             Default: 60000
+ #
+ # AutoDistributePoints: set if arena points should be distributed automatically, or by GM command
+ #             Default: 0 (disable) (recommended): use gm command or sql query to distribute the points
+ #                      1 (enable): arena points are distributed automatically
+ #
+ # AutoDistributeInterval: how often should the distribution take place 
+ #                         if automatic distribution is enabled
+ #                         in days
+ #             Default: 7 (weekly)
+ #
+ ###################################################################################################################
+ 
+ Arena.MaxRatingDifference = 0
+ Arena.RatingDiscardTimer = 60000
+ Arena.AutoDistributePoints = 0
+ Arena.AutoDistributeInterval = 7
+ 
+ ###################################################################################################################
+ #
+ # Battleground config
+ #
+ # PrematureFinishTimer: the time to end the bg if there are less than minplayersperteam on one side
+ #                       in milliseconds
+ #              Default: 300000
+ #                       0 - disable
+ #
+ ###################################################################################################################
+ 
+ BattleGround.PrematureFinishTimer = 300000
+ 
+ ###################################################################################################################
+ # MOVEMENT ANTICHEAT
+ #
+ #    Anticheat.Movement.Enable
+ #        Enable Movement Anticheat
+ #        Default: 1 - on
+ #                 0 - off
+ #
+ #    Anticheat.Movement.Kick
+ #        Enable Kick cheater
+ #        Default: 1 - on
+ #                 0 - off
+ #
+ #    Anticheat.Movement.AlarmCount
+ #        Count alarms after that player kicked (default 5)
+ #
+ #    Anticheat.Movement.AlarmTime
+ #        maximum time between alarms for count it (default 5000)
+ #
+ ###################################################################################################################
+ 
+ Anticheat.Movement.Enable = 1
+ Anticheat.Movement.Kick = 1
+ Anticheat.Movement.AlarmCount = 5
+ Anticheat.Movement.AlarmTime = 5000   
diff --git a/src/shared/Database/DBCStructure.h b/src/shared/Database/DBCStructure.h
index 61d4f9e..42e92ec 100644
--- a/src/shared/Database/DBCStructure.h
+++ b/src/shared/Database/DBCStructure.h
@@ -418,9 +418,10 @@ struct MapEntry
 
     // Helpers
     uint32 Expansion() const { return addon; }
-    bool Instanceable() const { return map_type == MAP_INSTANCE || map_type == MAP_RAID; }
-    // NOTE: this duplicate of Instanceable(), but Instanceable() can be changed when BG also will be instanceable
+
+
     bool IsDungeon() const { return map_type == MAP_INSTANCE || map_type == MAP_RAID; }
+    bool Instanceable() const { return map_type == MAP_INSTANCE || map_type == MAP_RAID || map_type == MAP_BATTLEGROUND || map_type == MAP_ARENA; }
     bool IsRaid() const { return map_type == MAP_RAID; }
     bool IsBattleGround() const { return map_type == MAP_BATTLEGROUND; }
     bool IsBattleArena() const { return map_type == MAP_ARENA; }
diff --git a/src/shared/Database/DatabaseMysql.cpp b/src/shared/Database/DatabaseMysql.cpp
index e8a944f..c08fd4e 100644
--- a/src/shared/Database/DatabaseMysql.cpp
+++ b/src/shared/Database/DatabaseMysql.cpp
@@ -165,6 +165,22 @@ bool DatabaseMysql::Initialize(const char *infoString)
         PExecute("SET NAMES `utf8`");
         PExecute("SET CHARACTER SET `utf8`");
 
+#if MYSQL_VERSION_ID >= 50003
+//  #if MYSQL_VERSIOB_ID >= 50013
+        my_bool my_true = (my_bool)1;
+        if (mysql_options(mMysql, MYSQL_OPT_RECONNECT, &my_true))
+        {
+            sLog.outDetail("Failed to turn on MYSQL_OPT_RECONNECT.");
+        }
+        else
+        {
+            sLog.outDetail("Successfully turned on MYSQL_OPT_RECONNECT.");
+        }
+#else
+        sLog.outDetail("Your mySQL client lib version does not support reconnecting after a timeout.");
+        sLog.outDetail("If this causes you any trouble we advice you to upgrade");
+        sLog.outDetail("your mySQL client libs to at least mySQL 5.0.13 to resolve this problem.");
+#endif
         return true;
     }
     else
diff --git a/win/VC71/game.vcproj b/win/VC71/game.vcproj
index aa6ae72..6fd49d6 100644
--- a/win/VC71/game.vcproj
+++ b/win/VC71/game.vcproj
@@ -240,6 +240,18 @@
 			<File
 				RelativePath="..\..\src\game\ChatHandler.cpp">
 			</File>
+            <File
+                RelativePath="..\..\src\game\ChatLexicsCutter.cpp">
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLexicsCutter.h">
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLog.cpp">
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLog.h">
+            </File>
 			<File
 				RelativePath="..\..\src\game\CombatHandler.cpp">
 			</File>
@@ -352,6 +364,70 @@
 				RelativePath="..\..\src\game\ObjectGridLoader.h">
 			</File>
 			<File
+				RelativePath="..\..\src\game\OutdoorPvP.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvP.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPEP.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPEP.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPHP.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPHP.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPMgr.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPMgr.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPNA.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPNA.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPSI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPSI.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPTF.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPTF.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPZM.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPZM.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\Path.h">
 			</File>
 			<File
@@ -472,6 +548,12 @@
 				RelativePath="..\..\src\game\ArenaTeam.h">
 			</File>
 			<File
+				RelativePath="..\..\src\game\AuctionHouseBot.cpp">
+			</File>
+			<File
+				RelativePath="..\..\src\game\AuctionHouseBot.h">
+			</File>
+			<File
 				RelativePath="..\..\src\game\AuctionHouseObject.h">
 			</File>
 			<File
@@ -643,6 +725,14 @@
 				RelativePath="..\..\src\game\ObjectPosSelector.h">
 			</File>
 			<File
+				RelativePath="..\..\src\game\OutdoorPvPObjectiveAI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPObjectiveAI.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\Pet.cpp">
 			</File>
 			<File
diff --git a/win/VC80/game.vcproj b/win/VC80/game.vcproj
index e3ed6b5..6a75b85 100644
--- a/win/VC80/game.vcproj
+++ b/win/VC80/game.vcproj
@@ -494,6 +494,22 @@
 				RelativePath="..\..\src\game\ChatHandler.cpp"
 				>
 			</File>
+            <File
+                RelativePath="..\..\src\game\ChatLexicsCutter.cpp"
+                >
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLexicsCutter.h"
+                >
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLog.cpp"
+                >
+            </File>
+            <File
+                RelativePath="..\..\src\game\ChatLog.h"
+                >
+            </File>
 			<File
 				RelativePath="..\..\src\game\CombatHandler.cpp"
 				>
@@ -643,6 +659,70 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\game\OutdoorPvP.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvP.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPEP.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPEP.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPHP.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPHP.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPMgr.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPMgr.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPNA.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPNA.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPSI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPSI.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPTF.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPTF.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPZM.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPZM.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\Path.h"
 				>
 			</File>
@@ -803,6 +883,14 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\game\AuctionHouseBot.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\AuctionHouseBot.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\AuctionHouseObject.h"
 				>
 			</File>
@@ -1031,6 +1119,14 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\game\OutdoorPvPObjectiveAI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPObjectiveAI.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\Pet.cpp"
 				>
 			</File>
diff --git a/win/VC90/game.vcproj b/win/VC90/game.vcproj
index 58e3675..2e467d6 100644
--- a/win/VC90/game.vcproj
+++ b/win/VC90/game.vcproj
@@ -496,6 +496,22 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\game\ChatLexicsCutter.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\ChatLexicsCutter.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\ChatLog.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\ChatLog.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\CombatHandler.cpp"
 				>
 			</File>
@@ -644,6 +660,70 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\game\OutdoorPvP.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvP.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPEP.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPEP.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPHP.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPHP.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPMgr.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPMgr.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPNA.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPNA.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPSI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPSI.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPTF.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPTF.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPZM.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPZM.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\Path.h"
 				>
 			</File>
@@ -804,6 +884,14 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\game\AuctionHouseBot.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\AuctionHouseBot.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\AuctionHouseObject.h"
 				>
 			</File>
@@ -1032,6 +1120,14 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\game\OutdoorPvPObjectiveAI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPObjectiveAI.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\Pet.cpp"
 				>
 			</File>
