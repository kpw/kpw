diff --git a/src/game/Creature.cpp b/src/game/Creature.cpp
index 899a7ab..f4f6704 100644
--- a/src/game/Creature.cpp
+++ b/src/game/Creature.cpp
@@ -42,6 +42,7 @@
 #include "GridNotifiers.h"
 #include "GridNotifiersImpl.h"
 #include "CellImpl.h"
+#include "OutdoorPvPMgr.h"
 
 // apply implementation of the singletons
 #include "Policies/SingletonImp.h"
@@ -737,6 +738,10 @@ void Creature::prepareGossipMenu( Player *pPlayer,uint32 gossipid )
                     case GOSSIP_OPTION_TABARDDESIGNER:
                     case GOSSIP_OPTION_AUCTIONEER:
                         break;                              // no checks
+                    case GOSSIP_OPTION_OUTDOORPVP:
+                        if ( !sOutdoorPvPMgr.CanTalkTo(pPlayer,this,(*gso)) )
+                            cantalking = false;
+                        break;
                     default:
                         sLog.outErrorDb("Creature %u (entry: %u) have unknown gossip option %u",GetDBTableGUIDLow(),GetEntry(),gso->Action);
                         break;
@@ -830,6 +835,9 @@ void Creature::OnGossipSelect(Player* player, uint32 option)
             player->PlayerTalkClass->SendTalking(textid);
             break;
         }
+        case GOSSIP_OPTION_OUTDOORPVP:
+            sOutdoorPvPMgr.HandleGossipOption(player, GetGUID(), gossip->GossipId);
+            break;
         case GOSSIP_OPTION_SPIRITHEALER:
             if (player->isDead())
                 CastSpell(this,17251,true,NULL,NULL,player->GetGUID());
diff --git a/src/game/Creature.h b/src/game/Creature.h
index eae23ff..6996a10 100644
--- a/src/game/Creature.h
+++ b/src/game/Creature.h
@@ -53,7 +53,8 @@ enum Gossip_Option
     GOSSIP_OPTION_STABLEPET         = 14,                   //UNIT_NPC_FLAG_STABLE            = 8192,
     GOSSIP_OPTION_ARMORER           = 15,                   //UNIT_NPC_FLAG_ARMORER           = 16384,
     GOSSIP_OPTION_UNLEARNTALENTS    = 16,                   //UNIT_NPC_FLAG_TRAINER (bonus option for GOSSIP_OPTION_TRAINER)
-    GOSSIP_OPTION_UNLEARNPETSKILLS  = 17                    //UNIT_NPC_FLAG_TRAINER (bonus option for GOSSIP_OPTION_TRAINER)
+    GOSSIP_OPTION_UNLEARNPETSKILLS  = 17,                   //UNIT_NPC_FLAG_TRAINER (bonus option for GOSSIP_OPTION_TRAINER)
+    GOSSIP_OPTION_OUTDOORPVP        = 18                    //UNIT_NPC_FLAG_OUTDOORPVP (option for outdoor pvp creatures)
 };
 
 enum Gossip_Guard
diff --git a/src/game/CreatureAIRegistry.cpp b/src/game/CreatureAIRegistry.cpp
index b76a721..ca2ddfc 100644
--- a/src/game/CreatureAIRegistry.cpp
+++ b/src/game/CreatureAIRegistry.cpp
@@ -23,6 +23,7 @@
 #include "GuardAI.h"
 #include "PetAI.h"
 #include "TotemAI.h"
+#include "OutdoorPvPObjectiveAI.h"
 #include "RandomMovementGenerator.h"
 #include "CreatureAIImpl.h"
 #include "MovementGeneratorImpl.h"
@@ -40,6 +41,7 @@ namespace AIRegistry
         (new CreatureAIFactory<GuardAI>("GuardAI"))->RegisterSelf();
         (new CreatureAIFactory<PetAI>("PetAI"))->RegisterSelf();
         (new CreatureAIFactory<TotemAI>("TotemAI"))->RegisterSelf();
+        (new CreatureAIFactory<OutdoorPvPObjectiveAI>("OutdoorPvPObjectiveAI"))->RegisterSelf();
 
         (new MovementGeneratorFactory<RandomMovementGenerator<Creature> >(RANDOM_MOTION_TYPE))->RegisterSelf();
         (new MovementGeneratorFactory<WaypointMovementGenerator<Creature> >(WAYPOINT_MOTION_TYPE))->RegisterSelf();
diff --git a/src/game/GameObject.cpp b/src/game/GameObject.cpp
index dc2aee4..1cb91f8 100644
--- a/src/game/GameObject.cpp
+++ b/src/game/GameObject.cpp
@@ -36,6 +36,7 @@
 #include "InstanceData.h"
 #include "BattleGround.h"
 #include "Util.h"
+#include "OutdoorPvPMgr.h"
 
 GameObject::GameObject() : WorldObject()
 {
@@ -89,7 +90,7 @@ void GameObject::RemoveFromWorld()
     Object::RemoveFromWorld();
 }
 
-bool GameObject::Create(uint32 guidlow, uint32 name_id, Map *map, float x, float y, float z, float ang, float rotation0, float rotation1, float rotation2, float rotation3, uint32 animprogress, uint32 go_state)
+bool GameObject::Create(uint32 guidlow, uint32 name_id, Map *map, float x, float y, float z, float ang, float rotation0, float rotation1, float rotation2, float rotation3, uint32 animprogress, uint32 go_state, uint32 ArtKit)
 {
     Relocate(x,y,z,ang);
     SetMapId(map->GetId());
@@ -142,6 +143,8 @@ bool GameObject::Create(uint32 guidlow, uint32 name_id, Map *map, float x, float
 
     SetGoAnimProgress(animprogress);
 
+    SetUInt32Value (GAMEOBJECT_ARTKIT, ArtKit);
+
     // Spell charges for GAMEOBJECT_TYPE_SPELLCASTER (22)
     if (goinfo->type == GAMEOBJECT_TYPE_SPELLCASTER)
         m_charges = goinfo->spellcaster.charges;
@@ -518,6 +521,7 @@ void GameObject::SaveToDB(uint32 mapid, uint8 spawnMask)
     data.animprogress = GetGoAnimProgress();
     data.go_state = GetGoState();
     data.spawnMask = spawnMask;
+    data.ArtKit = GetUInt32Value (GAMEOBJECT_ARTKIT);
 
     // updated in DB
     std::ostringstream ss;
@@ -568,11 +572,12 @@ bool GameObject::LoadFromDB(uint32 guid, Map *map)
 
     uint32 animprogress = data->animprogress;
     uint32 go_state = data->go_state;
+    uint32 ArtKit = data->ArtKit;
 
     m_DBTableGuid = guid;
     if (map->GetInstanceId() != 0) guid = objmgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT);
 
-    if (!Create(guid,entry, map, x, y, z, ang, rotation0, rotation1, rotation2, rotation3, animprogress, go_state) )
+    if (!Create(guid,entry, map, x, y, z, ang, rotation0, rotation1, rotation2, rotation3, animprogress, go_state, ArtKit) )
         return false;
 
     switch(GetGOInfo()->type)
@@ -829,6 +834,14 @@ void GameObject::UseDoorOrButton(uint32 time_to_restore)
 
 }
 
+void GameObject::SetGoArtKit(uint32 kit)
+{
+    SetUInt32Value(GAMEOBJECT_ARTKIT, kit);
+    GameObjectData *data = const_cast<GameObjectData*>(objmgr.GetGOData(m_DBTableGuid));
+    if(data)
+        data->ArtKit = kit;
+}
+
 void GameObject::SwitchDoorOrButton(bool activate)
 {
     if(activate)
@@ -1233,7 +1246,10 @@ void GameObject::Use(Unit* user)
     SpellEntry const *spellInfo = sSpellStore.LookupEntry( spellId );
     if(!spellInfo)
     {
-        sLog.outError("WORLD: unknown spell id %u at use action for gameobject (Entry: %u GoType: %u )", spellId,GetEntry(),GetGoType());
+        if(user->GetTypeId()!=TYPEID_PLAYER || !sOutdoorPvPMgr.HandleCustomSpell((Player*)user,spellId,this))
+            sLog.outError("WORLD: unknown spell id %u at use action for gameobject (Entry: %u GoType: %u )", spellId,GetEntry(),GetGoType());
+        else
+            sLog.outDebug("WORLD: %u non-dbc spell was handled by OutdoorPvP", spellId);
         return;
     }
 
diff --git a/src/game/GameObject.h b/src/game/GameObject.h
index 1fab149..d9bc54c 100644
--- a/src/game/GameObject.h
+++ b/src/game/GameObject.h
@@ -381,6 +381,7 @@ struct GameObjectData
     uint32 animprogress;
     uint32 go_state;
     uint8 spawnMask;
+    uint32 ArtKit;
 };
 
 // GCC have alternative #pragma pack() syntax and old gcc version not support pack(pop), also any gcc version not support it at some platform
@@ -416,7 +417,7 @@ class MANGOS_DLL_SPEC GameObject : public WorldObject
         void AddToWorld();
         void RemoveFromWorld();
 
-        bool Create(uint32 guidlow, uint32 name_id, Map *map, float x, float y, float z, float ang, float rotation0, float rotation1, float rotation2, float rotation3, uint32 animprogress, uint32 go_state);
+        bool Create(uint32 guidlow, uint32 name_id, Map *map, float x, float y, float z, float ang, float rotation0, float rotation1, float rotation2, float rotation3, uint32 animprogress, uint32 go_state, uint32 ArtKit = 0);
         void Update(uint32 p_time);
         static GameObject* GetGameObject(WorldObject& object, uint64 guid);
         GameObjectInfo const* GetGOInfo() const;
@@ -502,7 +503,7 @@ class MANGOS_DLL_SPEC GameObject : public WorldObject
         uint32 GetGoState() const { return GetUInt32Value(GAMEOBJECT_STATE); }
         void SetGoState(uint32 state) { SetUInt32Value(GAMEOBJECT_STATE, state); }
         uint32 GetGoArtKit() const { return GetUInt32Value(GAMEOBJECT_ARTKIT); }
-        void SetGoArtKit(uint32 artkit) { SetUInt32Value(GAMEOBJECT_ARTKIT, artkit); }
+        void SetGoArtKit(uint32 artkit);
         uint32 GetGoAnimProgress() const { return GetUInt32Value(GAMEOBJECT_ANIMPROGRESS); }
         void SetGoAnimProgress(uint32 animprogress) { SetUInt32Value(GAMEOBJECT_ANIMPROGRESS, animprogress); }
 
diff --git a/src/game/Language.h b/src/game/Language.h
index 7dcee62..b84e10a 100644
--- a/src/game/Language.h
+++ b/src/game/Language.h
@@ -631,6 +631,63 @@ enum MangosStrings
     LANG_ARENA_FIFTEEN_SECONDS          = 703,
     LANG_ARENA_BEGUN                    = 704,
 
+    // opvp hp
+    LANG_OPVP_HP_CAPTURE_OVERLOOK_H     = 9001,
+    LANG_OPVP_HP_CAPTURE_OVERLOOK_A     = 9002,
+    LANG_OPVP_HP_CAPTURE_STADIUM_H      = 9003,
+    LANG_OPVP_HP_CAPTURE_STADIUM_A      = 9004,
+    LANG_OPVP_HP_CAPTURE_BROKENHILL_H   = 9005,
+    LANG_OPVP_HP_CAPTURE_BROKENHILL_A   = 9006,
+    LANG_OPVP_HP_LOOSE_OVERLOOK_H       = 9007,
+    LANG_OPVP_HP_LOOSE_OVERLOOK_A       = 9008,
+    LANG_OPVP_HP_LOOSE_STADIUM_H        = 9009,
+    LANG_OPVP_HP_LOOSE_STADIUM_A        = 9010,
+    LANG_OPVP_HP_LOOSE_BROKENHILL_H     = 9011,
+    LANG_OPVP_HP_LOOSE_BROKENHILL_A     = 9012,
+    // opvp zm
+    LANG_OPVP_ZM_CAPTURE_WEST_H         = 9013,
+    LANG_OPVP_ZM_CAPTURE_WEST_A         = 9014,
+    LANG_OPVP_ZM_CAPTURE_EAST_H         = 9015,
+    LANG_OPVP_ZM_CAPTURE_EAST_A         = 9016,
+    LANG_OPVP_ZM_CAPTURE_GY_H           = 9017,
+    LANG_OPVP_ZM_CAPTURE_GY_A           = 9018,
+    LANG_OPVP_ZM_LOOSE_WEST_H           = 9019,
+    LANG_OPVP_ZM_LOOSE_WEST_A           = 9020,
+    LANG_OPVP_ZM_LOOSE_EAST_H           = 9021,
+    LANG_OPVP_ZM_LOOSE_EAST_A           = 9022,
+    LANG_OPVP_ZM_LOOSE_GY_H             = 9023,
+    LANG_OPVP_ZM_LOOSE_GY_A             = 9024,
+    // opvp na
+    LANG_OPVP_NA_CAPTURE_H              = 9025,
+    LANG_OPVP_NA_CAPTURE_A              = 9026,
+    LANG_OPVP_NA_LOOSE_H                = 9027,
+    LANG_OPVP_NA_LOOSE_A                = 9028,
+    // opvp tf
+    LANG_OPVP_TF_CAPTURE_H              = 9029,
+    LANG_OPVP_TF_CAPTURE_A              = 9030,
+    LANG_OPVP_TF_LOOSE_H                = 9031,
+    LANG_OPVP_TF_LOOSE_A                = 9032,
+    // opvp ep
+    LANG_OPVP_EP_CAPTURE_NPT_H          = 9033,
+    LANG_OPVP_EP_CAPTURE_NPT_A          = 9034,
+    LANG_OPVP_EP_CAPTURE_EWT_H          = 9035,
+    LANG_OPVP_EP_CAPTURE_EWT_A          = 9036,
+    LANG_OPVP_EP_CAPTURE_CGT_H          = 9037,
+    LANG_OPVP_EP_CAPTURE_CGT_A          = 9038,
+    LANG_OPVP_EP_CAPTURE_PWT_H          = 9039,
+    LANG_OPVP_EP_CAPTURE_PWT_A          = 9040,
+    LANG_OPVP_EP_LOOSE_NPT_H            = 9041,
+    LANG_OPVP_EP_LOOSE_NPT_A            = 9042,
+    LANG_OPVP_EP_LOOSE_EWT_H            = 9043,
+    LANG_OPVP_EP_LOOSE_EWT_A            = 9044,
+    LANG_OPVP_EP_LOOSE_CGT_H            = 9045,
+    LANG_OPVP_EP_LOOSE_CGT_A            = 9046,
+    LANG_OPVP_EP_LOOSE_PWT_H            = 9047,
+    LANG_OPVP_EP_LOOSE_PWT_A            = 9048,
+    // opvp si
+    LANG_OPVP_SI_CAPTURE_H              = 9049,
+    LANG_OPVP_SI_CAPTURE_A              = 9050,
+
     LANG_WAIT_BEFORE_SPEAKING           = 705,
     LANG_NOT_EQUIPPED_ITEM              = 706,
     LANG_PLAYER_DND                     = 707,
diff --git a/src/game/Makefile.am b/src/game/Makefile.am
index ad3315d..17a1dcc 100644
--- a/src/game/Makefile.am
+++ b/src/game/Makefile.am
@@ -177,6 +177,24 @@ libmangosgame_a_SOURCES = \
     ObjectPosSelector.h \
     Opcodes.cpp \
     Opcodes.h \
+    OutdoorPvP.cpp \
+    OutdoorPvP.h \
+    OutdoorPvPEP.cpp \
+    OutdoorPvPEP.h \
+    OutdoorPvPHP.cpp \
+    OutdoorPvPHP.h \
+    OutdoorPvPMgr.cpp \
+    OutdoorPvPMgr.h \
+    OutdoorPvPNA.cpp \
+    OutdoorPvPNA.h \
+    OutdoorPvPObjectiveAI.cpp \
+    OutdoorPvPObjectiveAI.h \
+    OutdoorPvPSI.cpp \
+    OutdoorPvPSI.h \
+    OutdoorPvPTF.cpp \
+    OutdoorPvPTF.h \
+    OutdoorPvPZM.cpp \
+    OutdoorPvPZM.h \
     Path.h \
     PetAI.cpp \
     PetAI.h \
diff --git a/src/game/MiscHandler.cpp b/src/game/MiscHandler.cpp
index 4bdbbd3..2f614e0 100644
--- a/src/game/MiscHandler.cpp
+++ b/src/game/MiscHandler.cpp
@@ -38,6 +38,7 @@
 #include "ObjectAccessor.h"
 #include "Object.h"
 #include "BattleGround.h"
+#include "OutdoorPvP.h"
 #include "SpellAuras.h"
 #include "Pet.h"
 #include "SocialMgr.h"
@@ -562,6 +563,11 @@ void WorldSession::HandleTogglePvP( WorldPacket & recv_data )
         if(!GetPlayer()->pvpInfo.inHostileArea && GetPlayer()->IsPvP())
             GetPlayer()->pvpInfo.endTimer = time(NULL);     // start toggle-off
     }
+
+    if(OutdoorPvP * pvp = _player->GetOutdoorPvP())
+    {
+        pvp->HandlePlayerActivityChanged(_player);
+    }
 }
 
 void WorldSession::HandleZoneUpdateOpcode( WorldPacket & recv_data )
@@ -573,10 +579,13 @@ void WorldSession::HandleZoneUpdateOpcode( WorldPacket & recv_data )
 
     sLog.outDetail("WORLD: Recvd ZONE_UPDATE: %u", newZone);
 
-    if(newZone != _player->GetZoneId())
-        GetPlayer()->SendInitWorldStates();                 // only if really enters to new zone, not just area change, works strange...
-
+    // this check is definitely BAD, either we init for the old zone, or we doesn't init at all.
+    // Let's try with check commented out. Let the client decide when to re-init states.
+    // EDIT: and this works like a charm.
+//    if(newZone != _player->GetZoneId())
     GetPlayer()->UpdateZone(newZone);
+
+    GetPlayer()->SendInitWorldStates(true,newZone);                 // only if really enters to new zone, not just area change, works strange...
 }
 
 void WorldSession::HandleSetTargetOpcode( WorldPacket & recv_data )
@@ -1006,6 +1015,12 @@ void WorldSession::HandleAreaTriggerOpcode(WorldPacket & recv_data)
         return;
     }
 
+    if(OutdoorPvP * pvp = GetPlayer()->GetOutdoorPvP())
+    {
+        if(pvp->HandleAreaTrigger(_player, Trigger_ID))
+            return;
+    }
+
     // NULL if all values default (non teleport trigger)
     AreaTrigger const* at = objmgr.GetAreaTrigger(Trigger_ID);
     if(!at)
diff --git a/src/game/Object.cpp b/src/game/Object.cpp
index 0b6bb20..2511104 100644
--- a/src/game/Object.cpp
+++ b/src/game/Object.cpp
@@ -540,6 +540,8 @@ void Object::_BuildValuesUpdate(uint8 updatetype, ByteBuffer * data, UpdateMask
                 IsActivateToQuest = true;
                 updateMask->SetBit(GAMEOBJECT_DYN_FLAGS);
             }
+            if (GetUInt32Value(GAMEOBJECT_ARTKIT))
+                updateMask->SetBit(GAMEOBJECT_ARTKIT);
         }
     }
     else                                                    //case UPDATETYPE_VALUES
@@ -569,7 +571,7 @@ void Object::_BuildValuesUpdate(uint8 updatetype, ByteBuffer * data, UpdateMask
             {
                 // remove custom flag before send
                 if( index == UNIT_NPC_FLAGS )
-                    *data << uint32(m_uint32Values[ index ] & ~UNIT_NPC_FLAG_GUARD);
+                    *data << uint32(m_uint32Values[ index ] & ~(UNIT_NPC_FLAG_GUARD + UNIT_NPC_FLAG_OUTDOORPVP));
                 // FIXME: Some values at server stored in float format but must be sent to client in uint32 format
                 else if(index >= UNIT_FIELD_BASEATTACKTIME && index <= UNIT_FIELD_RANGEDATTACKTIME)
                 {
diff --git a/src/game/ObjectMgr.cpp b/src/game/ObjectMgr.cpp
index 724880f..c291fab 100644
--- a/src/game/ObjectMgr.cpp
+++ b/src/game/ObjectMgr.cpp
@@ -1159,6 +1159,7 @@ void ObjectMgr::LoadGameobjects()
         data.spawntimesecs  = fields[11].GetInt32();
         data.animprogress   = fields[12].GetUInt32();
         data.go_state       = fields[13].GetUInt32();
+        data.ArtKit         = 0;
         data.spawnMask      = fields[14].GetUInt8();
         int16 gameEvent     = fields[15].GetInt16();
 
@@ -4857,6 +4858,54 @@ bool ObjectMgr::AddGraveYardLink(uint32 id, uint32 zoneId, uint32 team, bool inD
     return true;
 }
 
+void ObjectMgr::RemoveGraveYardLink(uint32 id, uint32 zoneId, uint32 team, bool inDB)
+{
+    GraveYardMap::iterator graveLow  = mGraveYardMap.lower_bound(zoneId);
+    GraveYardMap::iterator graveUp   = mGraveYardMap.upper_bound(zoneId);
+    if(graveLow==graveUp)
+    {
+        //sLog.outErrorDb("Table `game_graveyard_zone` incomplete: Zone %u Team %u does not have a linked graveyard.",zoneId,team);
+        return;
+    }
+
+    bool found = false;
+
+    GraveYardMap::iterator itr;
+
+    for(itr = graveLow; itr != graveUp; ++itr)
+    {
+        GraveYardData & data = itr->second;
+
+        // skip not matching safezone id
+        if(data.safeLocId != id)
+            continue;
+
+        // skip enemy faction graveyard at same map (normal area, city, or battleground)
+        // team == 0 case can be at call from .neargrave
+        if(data.team != 0 && team != 0 && data.team != team)
+            continue;
+
+        found = true;
+        break;
+    }
+
+    // no match, return
+    if(!found)
+        return;
+
+    // remove from links
+    mGraveYardMap.erase(itr);
+
+    // remove link from DB
+    if(inDB)
+    {
+        WorldDatabase.PExecute("DELETE FROM game_graveyard_zone WHERE id = '%u' AND ghost_zone = '%u' AND faction = '%u'",id,zoneId,team);
+    }
+
+    return;
+}
+
+
 void ObjectMgr::LoadAreaTriggerTeleports()
 {
     mAreaTriggers.clear();                                  // need for reload case
diff --git a/src/game/ObjectMgr.h b/src/game/ObjectMgr.h
index c9b4e9b..c9ea935 100644
--- a/src/game/ObjectMgr.h
+++ b/src/game/ObjectMgr.h
@@ -440,6 +440,7 @@ class ObjectMgr
 
         WorldSafeLocsEntry const *GetClosestGraveYard(float x, float y, float z, uint32 MapId, uint32 team);
         bool AddGraveYardLink(uint32 id, uint32 zone, uint32 team, bool inDB = true);
+        void RemoveGraveYardLink(uint32 id, uint32 zone, uint32 team, bool inDB = false);
         void LoadGraveyardZones();
         GraveYardData const* FindGraveYardData(uint32 id, uint32 zone);
 
diff --git a/src/game/OutdoorPvP.cpp b/src/game/OutdoorPvP.cpp
new file mode 100644
index 0000000..a043398
--- /dev/null
+++ b/src/game/OutdoorPvP.cpp
@@ -0,0 +1,726 @@
+#include "OutdoorPvP.h"
+#include "OutdoorPvPMgr.h"
+#include "ObjectAccessor.h"
+#include "ObjectMgr.h"
+#include "Map.h"
+#include "MapManager.h"
+#include "OutdoorPvPObjectiveAI.h"
+#include "Group.h"
+#include "WorldPacket.h"
+
+OutdoorPvPObjective::OutdoorPvPObjective(OutdoorPvP * pvp) 
+: m_PvP(pvp), m_AllianceActivePlayerCount(0), m_HordeActivePlayerCount(0),
+m_ShiftTimer(0), m_ShiftPhase(0), m_ShiftMaxPhase(0), m_OldPhase(0),
+m_State(0), m_OldState(0), m_CapturePoint(0), m_NeutralValue(0), m_ShiftMaxCaptureSpeed(0), m_CapturePointCreature(0)
+{
+}
+
+bool OutdoorPvPObjective::HandlePlayerEnter(Player * plr)
+{
+    // only called if really entered, so no use in the return value anymore
+    // player distance and activity state was checked already in the AI
+    std::set<uint64>::iterator pitr = m_ActivePlayerGuids.find(plr->GetGUID());
+    // if not already counted as active, add player
+    if(pitr == m_ActivePlayerGuids.end())
+    {
+        if(plr->GetTeam() == ALLIANCE)
+            ++m_AllianceActivePlayerCount;
+        else
+            ++m_HordeActivePlayerCount;
+        m_ActivePlayerGuids.insert(plr->GetGUID());
+        sLog.outDebug("player %u entered an outdoorpvpobjective", plr->GetGUIDLow());
+        return true;
+    }
+    return true;
+}
+
+void OutdoorPvPObjective::HandlePlayerLeave(Player * plr)
+{
+    // only decrease the count if the player is in the active list
+    if(m_ActivePlayerGuids.find(plr->GetGUID())!=m_ActivePlayerGuids.end())
+    {
+        if(plr->GetTeam() == ALLIANCE)
+            --m_AllianceActivePlayerCount;
+        else
+            --m_HordeActivePlayerCount;
+        m_ActivePlayerGuids.erase(plr->GetGUID());
+    }
+}
+
+void OutdoorPvPObjective::HandlePlayerActivityChanged(Player * plr)
+{
+    if(m_CapturePointCreature)
+        if(Creature * c = HashMapHolder<Creature>::Find(m_CapturePointCreature))
+            if(c->AI())
+                c->AI()->MoveInLineOfSight(plr);
+}
+
+bool OutdoorPvPObjective::AddObject(uint32 type, uint32 entry, uint32 map, float x, float y, float z, float o, float rotation0, float rotation1, float rotation2, float rotation3)
+{
+    GameObjectInfo const* goinfo = objmgr.GetGameObjectInfo(entry);
+    if (!goinfo)
+        return false;
+
+    uint32 guid = objmgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT);
+
+    GameObjectData& data = objmgr.NewGOData(guid);
+
+    data.id             = entry;
+    data.mapid          = map;
+    data.posX           = x;
+    data.posY           = y;
+    data.posZ           = z;
+    data.orientation    = o;
+    data.rotation0      = rotation0;
+    data.rotation1      = rotation1;
+    data.rotation2      = rotation2;
+    data.rotation3      = rotation3;
+    data.spawntimesecs  = 0;
+    data.animprogress   = 100;
+    data.spawnMask      = 1;
+    data.go_state       = 1;
+
+    objmgr.AddGameobjectToGrid(guid, &data);
+
+    // 2 way registering
+    m_Objects[type] = MAKE_NEW_GUID(guid, entry, HIGHGUID_GAMEOBJECT);
+    m_ObjectTypes[m_Objects[type]]=type;
+
+    Map * pMap = MapManager::Instance().FindMap(map);
+    if(!pMap)
+        return true;
+    GameObject * go = new GameObject;
+    if(!go->Create(guid,entry, pMap,x,y,z,o,rotation0,rotation1,rotation2,rotation3,100,1))
+    {
+        sLog.outError("Gameobject template %u not found in database.", entry);
+        delete go;
+        return true;
+    }
+
+    go->SetRespawnTime(0);
+    objmgr.SaveGORespawnTime(go->GetDBTableGUIDLow(),0,0);
+    pMap->Add(go);
+
+    return true;
+}
+
+bool OutdoorPvPObjective::AddCreature(uint32 type, uint32 entry, uint32 teamval, uint32 map, float x, float y, float z, float o, uint32 spawntimedelay)
+{
+    CreatureInfo const *cinfo = objmgr.GetCreatureTemplate(entry);
+    if(!cinfo)
+    {
+        return false;
+    }
+
+    uint32 displayId = objmgr.ChooseDisplayId(teamval, cinfo, NULL);
+    CreatureModelInfo const *minfo = objmgr.GetCreatureModelRandomGender(displayId);
+    if (!minfo)
+    {
+        return false;
+    }
+    else
+        displayId = minfo->modelid;                        // it can be different (for another gender)
+
+    uint32 guid = objmgr.GenerateLowGuid(HIGHGUID_UNIT);
+
+    CreatureData& data = objmgr.NewOrExistCreatureData(guid);
+
+    data.id = entry;
+    data.mapid = map;
+    data.displayid = displayId;
+    data.equipmentId = cinfo->equipmentId;
+    data.posX = x;
+    data.posY = y;
+    data.posZ = z;
+    data.orientation = o;
+    data.spawntimesecs = spawntimedelay;
+    data.spawndist = 0;
+    data.currentwaypoint = 0;
+    data.curhealth = cinfo->maxhealth;
+    data.curmana = cinfo->maxmana;
+    data.is_dead = false;
+    data.movementType = cinfo->MovementType;
+    data.spawnMask = 1;
+
+    objmgr.AddCreatureToGrid(guid, &data);
+
+    m_Creatures[type] = MAKE_NEW_GUID(guid, entry, HIGHGUID_UNIT);
+    m_CreatureTypes[m_Creatures[type]] = type;
+
+    Map * pMap = MapManager::Instance().FindMap(map);
+    if(!pMap)
+        return true;
+    Creature* pCreature = new Creature;
+    if (!pCreature->Create(guid, pMap, entry, teamval))
+    {
+        sLog.outError("Can't create creature entry: %u",entry);
+        delete pCreature;
+        return true;
+    }
+
+    pCreature->AIM_Initialize();
+
+    pCreature->Relocate(x, y, z, o);
+
+    if(!pCreature->IsPositionValid())
+    {
+        sLog.outError("ERROR: Creature (guidlow %d, entry %d) not added to opvp. Suggested coordinates isn't valid (X: %f Y: %f)",pCreature->GetGUIDLow(),pCreature->GetEntry(),pCreature->GetPositionX(),pCreature->GetPositionY());
+        return false;
+    }
+
+    if(spawntimedelay)
+        pCreature->SetRespawnDelay(spawntimedelay);
+
+    pMap->Add(pCreature);
+
+    return true;
+}
+
+bool OutdoorPvPObjective::AddCapturePoint(uint32 entry, uint32 map, float x, float y, float z, float o, float rotation0, float rotation1, float rotation2, float rotation3)
+{
+    sLog.outDebug("creating capture point %u and capture point creature",entry);
+
+    // check info existence
+    GameObjectInfo const* goinfo = objmgr.GetGameObjectInfo(entry);
+    if (!goinfo)
+        return false;
+
+    CreatureInfo const *cinfo = objmgr.GetCreatureTemplate(OPVP_TRIGGER_CREATURE_ENTRY);
+    if(!cinfo)
+        return false;
+
+    // create capture point creature
+    uint32 displayId = objmgr.ChooseDisplayId(0, cinfo, NULL);
+
+    uint32 creature_guid = objmgr.GenerateLowGuid(HIGHGUID_UNIT);
+
+    CreatureData& cdata = objmgr.NewOrExistCreatureData(creature_guid);
+
+    cdata.id = OPVP_TRIGGER_CREATURE_ENTRY;
+    cdata.mapid = map;
+    cdata.displayid = displayId;
+    cdata.equipmentId = cinfo->equipmentId;
+    cdata.posX = x;
+    cdata.posY = y;
+    cdata.posZ = z;
+    cdata.orientation = o;
+    cdata.spawntimesecs = 1;
+    cdata.spawndist = 0;
+    cdata.currentwaypoint = 0;
+    cdata.curhealth = cinfo->maxhealth;
+    cdata.curmana = cinfo->maxmana;
+    cdata.is_dead = false;
+    cdata.movementType = cinfo->MovementType;
+    cdata.spawnMask = 1;
+
+    objmgr.AddCreatureToGrid(creature_guid, &cdata);
+    m_CapturePointCreature = MAKE_NEW_GUID(creature_guid, OPVP_TRIGGER_CREATURE_ENTRY, HIGHGUID_UNIT);
+
+    // create capture point go
+    uint32 guid = objmgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT);
+
+    GameObjectData& data = objmgr.NewGOData(guid);
+
+    data.id             = entry;
+    data.mapid          = map;
+    data.posX           = x;
+    data.posY           = y;
+    data.posZ           = z;
+    data.orientation    = o;
+    data.rotation0      = rotation0;
+    data.rotation1      = rotation1;
+    data.rotation2      = rotation2;
+    data.rotation3      = rotation3;
+    data.spawntimesecs  = 1;
+    data.animprogress   = 100;
+    data.spawnMask      = 1;
+    data.go_state       = 1;
+
+    objmgr.AddGameobjectToGrid(guid, &data);
+
+    m_CapturePoint = MAKE_NEW_GUID(guid, entry, HIGHGUID_GAMEOBJECT);
+
+    // get the needed values from goinfo
+    m_ShiftMaxPhase = goinfo->raw.data[17];
+    m_ShiftMaxCaptureSpeed = m_ShiftMaxPhase / float(goinfo->raw.data[16]);
+    m_NeutralValue = goinfo->raw.data[12];
+
+    // add to map if map is already loaded
+    Map * pMap = MapManager::Instance().FindMap(map);
+    if(!pMap)
+        return true;
+    // add GO...
+    GameObject * go = new GameObject;
+    if(!go->Create(guid,entry, pMap,x,y,z,o,rotation0,rotation1,rotation2,rotation3,100,1))
+    {
+        sLog.outError("Gameobject template %u not found in database.", entry);
+        delete go;
+    }
+    else
+    {
+        go->SetRespawnTime(0);
+        objmgr.SaveGORespawnTime(go->GetDBTableGUIDLow(), 0, 0);
+        pMap->Add(go);
+    }
+    // add creature...
+    Creature* pCreature = new Creature;
+    if (!pCreature->Create(creature_guid, pMap, OPVP_TRIGGER_CREATURE_ENTRY, 0))
+    {
+        sLog.outError("Can't create creature entry: %u",entry);
+        delete pCreature;
+    }
+    else
+    {
+        pCreature->AIM_Initialize();
+
+        pCreature->Relocate(x, y, z, o);
+
+        if(!pCreature->IsPositionValid())
+        {
+            sLog.outError("ERROR: Creature (guidlow %d, entry %d) not added to opvp. Suggested coordinates isn't valid (X: %f Y: %f)",pCreature->GetGUIDLow(),pCreature->GetEntry(),pCreature->GetPositionX(),pCreature->GetPositionY());
+            return false;
+        }
+
+        pMap->Add(pCreature);
+    }
+    return true;
+}
+
+bool OutdoorPvPObjective::DelCreature(uint32 type)
+{
+    if(!m_Creatures[type])
+    {
+        sLog.outDebug("opvp creature type %u was already deleted",type);
+        return false;
+    }
+
+    Creature *cr = HashMapHolder<Creature>::Find(m_Creatures[type]);
+    if(!cr)
+    {
+        sLog.outError("Can't find creature guid: %u",m_Creatures[type]);
+        return false;
+    }
+    sLog.outDebug("deleting opvp creature type %u",type);
+    uint32 guid = cr->GetDBTableGUIDLow();
+    // dont save respawn time
+    cr->SetRespawnTime(0);
+    cr->RemoveCorpse();
+    cr->CleanupsBeforeDelete();
+    // explicit removal from map
+    // beats me why this is needed, but with the recent removal "cleanup" some creatures stay in the map if "properly" deleted
+    // so this is a big fat workaround, if AddObjectToRemoveList and DoDelayedMovesAndRemoves worked correctly, this wouldn't be needed
+    if(Map * map = MapManager::Instance().FindMap(cr->GetMapId()))
+        map->Remove(cr,false);
+    // delete respawn time for this creature
+    WorldDatabase.PExecute("DELETE FROM creature_respawn WHERE guid = '%u'", guid);
+    cr->AddObjectToRemoveList();
+    objmgr.DeleteCreatureData(guid);
+    m_CreatureTypes[m_Creatures[type]] = 0;
+    m_Creatures[type] = 0;
+    return true;
+}
+
+bool OutdoorPvPObjective::DelObject(uint32 type)
+{
+    if(!m_Objects[type])
+        return false;
+
+    GameObject *obj = HashMapHolder<GameObject>::Find(m_Objects[type]);
+    if(!obj)
+    {
+        sLog.outError("Can't find gobject guid: %u",m_Objects[type]);
+        return false;
+    }
+    uint32 guid = obj->GetDBTableGUIDLow();
+    obj->SetRespawnTime(0);                                 // not save respawn time
+    obj->Delete();
+    objmgr.DeleteGOData(guid);
+    m_ObjectTypes[m_Objects[type]] = 0;
+    m_Objects[type] = 0;
+    return true;
+}
+
+bool OutdoorPvPObjective::DelCapturePoint()
+{
+    if(!m_CapturePoint)
+        return false;
+
+    GameObject *obj = HashMapHolder<GameObject>::Find(m_CapturePoint);
+    if(!obj)
+    {
+        sLog.outError("Can't find gobject guid: %u",m_CapturePoint);
+        return false;
+    }
+    uint32 guid = obj->GetDBTableGUIDLow();
+    obj->SetRespawnTime(0);                                 // not save respawn time
+    obj->Delete();
+    objmgr.DeleteGOData(guid);
+    m_CapturePoint = 0;
+    return true;
+}
+
+void OutdoorPvPObjective::DeleteSpawns()
+{
+    for(std::map<uint32,uint64>::iterator i = m_Objects.begin(); i != m_Objects.end(); ++i)
+        DelObject(i->first);
+    for(std::map<uint32,uint64>::iterator i = m_Creatures.begin(); i != m_Creatures.end(); ++i)
+        DelCreature(i->first);
+    DelCapturePoint();
+}
+
+void OutdoorPvP::DeleteSpawns()
+{
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+        (*itr)->DeleteSpawns();
+}
+
+OutdoorPvP::OutdoorPvP()
+{
+}
+
+OutdoorPvP::~OutdoorPvP()
+{
+    DeleteSpawns();
+}
+
+void OutdoorPvP::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    if(plr->GetTeam()==ALLIANCE)
+        m_PlayerGuids[0].insert(plr->GetGUID());
+    else
+        m_PlayerGuids[1].insert(plr->GetGUID());
+}
+
+void OutdoorPvP::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // inform the objectives of the leaving
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+        (*itr)->HandlePlayerLeave(plr);
+    // remove the world state information from the player (we can't keep everyone up to date, so leave out those who are not in the concerning zones)
+    if(zone != plr->GetZoneId())
+        SendRemoveWorldStates(plr);
+    if(plr->GetTeam()==ALLIANCE)
+        m_PlayerGuids[0].erase(plr->GetGUID());
+    else
+        m_PlayerGuids[1].erase(plr->GetGUID());
+    sLog.outDebug("player left an outdoorpvp zone");
+}
+
+bool OutdoorPvP::Update(uint32 diff)
+{
+    bool objective_changed = false;
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+        objective_changed |= (*itr)->Update(diff);
+    return objective_changed;
+}
+
+bool OutdoorPvPObjective::Update(uint32 diff)
+{
+    uint32 Challenger = 0;
+    if(m_ShiftTimer<diff)
+    {
+        m_ShiftTimer = OUTDOORPVP_OBJECTIVE_UPDATE_INTERVAL;
+
+        // get the difference of numbers
+        float fact_diff = (m_AllianceActivePlayerCount - m_HordeActivePlayerCount);
+
+        if(fact_diff<0)
+        {
+            if(fact_diff < - m_ShiftMaxCaptureSpeed)
+                fact_diff = - m_ShiftMaxCaptureSpeed;
+            Challenger = HORDE;
+            // horde is in majority, but it's already horde-controlled -> no change
+            if(m_State == OBJECTIVESTATE_HORDE && m_ShiftPhase == - m_ShiftMaxPhase)
+                return false;
+        }
+        else if(fact_diff>0)
+        {
+            if(fact_diff > m_ShiftMaxCaptureSpeed)
+                fact_diff = m_ShiftMaxCaptureSpeed;
+            Challenger = ALLIANCE;
+            // ally is in majority, but it's already ally-controlled -> no change
+            if(m_State == OBJECTIVESTATE_ALLIANCE && m_ShiftPhase == m_ShiftMaxPhase)
+                return false;
+        }
+        else /*if(fact_diff==0)*/ // no change
+            return false;
+
+        m_OldPhase = m_ShiftPhase;
+
+        m_OldState = m_State;
+
+        m_ShiftPhase += fact_diff;
+
+        // check limits, these are over the grey part
+        if(m_ShiftPhase <= - m_ShiftMaxPhase * (float)(m_NeutralValue) / 100.0f)
+        {
+            if(m_ShiftPhase <= - m_ShiftMaxPhase)
+                m_ShiftPhase = - m_ShiftMaxPhase;
+            m_State = OBJECTIVESTATE_HORDE;
+            return true;
+        }
+        else if(m_ShiftPhase >= m_ShiftMaxPhase * (float)(m_NeutralValue) / 100.0f)
+        {
+            if(m_ShiftPhase >= m_ShiftMaxPhase)
+                m_ShiftPhase = m_ShiftMaxPhase;
+            m_State = OBJECTIVESTATE_ALLIANCE;
+            return true;
+        }
+
+        if(m_OldPhase*m_ShiftPhase <=0)
+        {
+            // gone through neutral
+            // if challenger is ally, then n->a challenge
+            if(Challenger == ALLIANCE)
+                m_State = OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE;
+            // if challenger is horde, then n->h challenge
+            else if(Challenger == HORDE)
+                m_State = OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE;
+        }
+        else
+        {
+            // old phase and current are on the same side, so one team challenges the other
+            if(Challenger == ALLIANCE && (m_OldState == OBJECTIVESTATE_HORDE || m_OldState == OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE))
+                m_State = OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE;
+            else if(Challenger == HORDE && (m_OldState == OBJECTIVESTATE_ALLIANCE || m_OldState == OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE))
+                m_State = OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE;
+        }
+
+        return true;
+    } else m_ShiftTimer-=diff;
+
+    return false;
+}
+
+bool OutdoorPvPObjective::HandleCaptureCreaturePlayerMoveInLos(Player * p, Creature * c)
+{
+    // check if guid matches
+    if(c->GetGUID() != m_CapturePointCreature)
+        return false;
+
+    // check if capture point go is spawned
+    GameObject * cp = HashMapHolder<GameObject>::Find(m_CapturePoint);
+    if(!cp)
+        return false;
+
+    // check range and activity
+    if(cp->IsWithinDistInMap(p,cp->GetGOInfo()->raw.data[0]) && p->IsOutdoorPvPActive())
+    {
+        // data[8] will be used for player enter
+        return HandleCapturePointEvent(p, cp->GetGOInfo()->raw.data[8]); //i_objective->HandlePlayerEnter((Player*)u);
+    }
+    else
+    {
+        // data[9] will be used for player leave
+        return HandleCapturePointEvent(p, cp->GetGOInfo()->raw.data[9]); //i_objective->HandlePlayerLeave((Player*)u);
+    }
+}
+
+void OutdoorPvP::SendUpdateWorldState(uint32 field, uint32 value)
+{
+    // send to both factions
+    for(int i = 0; i < 2; ++i)
+    {
+        // send to all players present in the area
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[i].begin(); itr != m_PlayerGuids[i].end(); ++itr)
+        {
+            Player * plr = objmgr.GetPlayer(*itr);
+            if(plr)
+            {
+                plr->SendUpdateWorldState(field,value);
+            }
+        }
+    }
+}
+
+void OutdoorPvPObjective::SendUpdateWorldState(uint32 field, uint32 value)
+{
+    // send to all players present in the area
+    for(std::set<uint64>::iterator itr = m_ActivePlayerGuids.begin(); itr != m_ActivePlayerGuids.end(); ++itr)
+    {
+        Player * plr = objmgr.GetPlayer(*itr);
+        if(plr)
+        {
+            plr->SendUpdateWorldState(field,value);
+        }
+    }
+}
+
+void OutdoorPvPObjective::SendObjectiveComplete(uint32 id,uint64 guid)
+{
+    uint32 controlling_faction;
+    switch(m_State)
+    {
+    case OBJECTIVESTATE_ALLIANCE:
+        controlling_faction = ALLIANCE;
+        break;
+    case OBJECTIVESTATE_HORDE:
+        controlling_faction = HORDE;
+        break;
+    default:
+        return;
+        break;
+    }
+
+    // send to all players present in the area
+    for(std::set<uint64>::iterator itr = m_ActivePlayerGuids.begin(); itr != m_ActivePlayerGuids.end(); ++itr)
+    {
+        Player * plr = objmgr.GetPlayer(*itr);
+        if(plr && plr->GetTeam() == controlling_faction)
+        {
+            plr->KilledMonster(id,guid);
+        }
+    }
+}
+
+void OutdoorPvP::HandlePlayerActivityChanged(Player * plr)
+{
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+        (*itr)->HandlePlayerActivityChanged(plr);
+}
+
+void OutdoorPvP::HandleKill(Player *killer, Unit * killed)
+{
+    if(Group * pGroup = killer->GetGroup())
+    {
+        for(GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player *pGroupGuy = itr->getSource();
+
+            if(!pGroupGuy)
+                continue;
+
+            // skip if too far away
+            if(!pGroupGuy->IsAtGroupRewardDistance(killed))
+                continue;
+
+            // creature kills must be notified, even if not inside objective / not outdoor pvp active
+            // player kills only count if active and inside objective
+            if(( pGroupGuy->IsOutdoorPvPActive() && IsInsideObjective(pGroupGuy) ) || killed->GetTypeId() == TYPEID_UNIT)
+            {
+                HandleKillImpl(pGroupGuy, killed);
+            }
+        }
+    }
+    else
+    {
+        // creature kills must be notified, even if not inside objective / not outdoor pvp active
+        if(killer && (( killer->IsOutdoorPvPActive() && IsInsideObjective(killer) ) || killed->GetTypeId() == TYPEID_UNIT))
+        {
+            HandleKillImpl(killer, killed);
+        }
+    }
+}
+
+bool OutdoorPvP::IsInsideObjective(Player *plr)
+{
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        if((*itr)->IsInsideObjective(plr))
+            return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPObjective::IsInsideObjective(Player *plr)
+{
+    std::set<uint64>::iterator itr = m_ActivePlayerGuids.find(plr->GetGUID());
+    return itr != m_ActivePlayerGuids.end();
+}
+
+bool OutdoorPvP::HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go)
+{
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        if((*itr)->HandleCustomSpell(plr,spellId,go))
+            return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPObjective::HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go)
+{
+    if(!plr->IsOutdoorPvPActive())
+        return false;
+    return false;
+}
+
+bool OutdoorPvP::HandleOpenGo(Player *plr, uint64 guid)
+{
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        if((*itr)->HandleOpenGo(plr,guid) >= 0)
+            return true;
+    }
+    return false;
+}
+
+bool OutdoorPvP::HandleCaptureCreaturePlayerMoveInLos(Player * p, Creature * c)
+{
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        if((*itr)->HandleCaptureCreaturePlayerMoveInLos(p, c))
+            return true;
+    }
+    return false;
+}
+
+bool OutdoorPvP::HandleGossipOption(Player * plr, uint64 guid, uint32 id)
+{
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        if((*itr)->HandleGossipOption(plr, guid, id))
+            return true;
+    }
+    return false;
+}
+
+bool OutdoorPvP::CanTalkTo(Player * plr, Creature * c, GossipOption &gso)
+{
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        if((*itr)->CanTalkTo(plr, c, gso))
+            return true;
+    }
+    return false;
+}
+
+bool OutdoorPvP::HandleDropFlag(Player * plr, uint32 id)
+{
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        if((*itr)->HandleDropFlag(plr, id))
+            return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPObjective::HandleGossipOption(Player * plr, uint64 guid, uint32 id)
+{
+    return false;
+}
+
+bool OutdoorPvPObjective::CanTalkTo(Player * plr, Creature * c, GossipOption &gso)
+{
+    return false;
+}
+
+bool OutdoorPvPObjective::HandleDropFlag(Player * plr, uint32 id)
+{
+    return false;
+}
+
+int32 OutdoorPvPObjective::HandleOpenGo(Player *plr, uint64 guid)
+{
+    std::map<uint64,uint32>::iterator itr = m_ObjectTypes.find(guid);
+    if(itr != m_ObjectTypes.end())
+    {
+        return itr->second;   
+    }
+    return -1;
+}
+
+bool OutdoorPvP::HandleAreaTrigger(Player *plr, uint32 trigger)
+{
+    return false;
+}
diff --git a/src/game/OutdoorPvP.h b/src/game/OutdoorPvP.h
new file mode 100644
index 0000000..c5dbeb8
--- /dev/null
+++ b/src/game/OutdoorPvP.h
@@ -0,0 +1,211 @@
+#ifndef OUTDOOR_PVP_H_
+#define OUTDOOR_PVP_H_
+
+#include "Util.h"
+
+#include <map>
+#include <set>
+
+#define OUTDOORPVP_OBJECTIVE_UPDATE_INTERVAL 1000
+
+#define OPVP_TRIGGER_CREATURE_ENTRY 12999
+
+enum ObjectiveStates{
+    OBJECTIVESTATE_NEUTRAL = 0,
+    OBJECTIVESTATE_ALLIANCE = 1,
+    OBJECTIVESTATE_HORDE = 2,
+    OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE = 3,
+    OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE = 4,
+    OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE = 5,
+    OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE = 6
+};
+
+enum OutdoorPvPTypes{
+    OUTDOOR_PVP_HP = 1,
+    OUTDOOR_PVP_NA = 2,
+    OUTDOOR_PVP_TF = 3,
+    OUTDOOR_PVP_ZM = 4,
+    OUTDOOR_PVP_SI = 5,
+    OUTDOOR_PVP_EP = 6
+};
+
+// struct for go spawning
+struct go_type{
+    uint32 entry;
+    uint32 map;
+    float x;
+    float y;
+    float z;
+    float o;
+    float rot0;
+    float rot1;
+    float rot2;
+    float rot3;
+};
+
+// struct for creature spawning
+struct creature_type{
+    uint32 entry;
+    uint32 teamval;
+    uint32 map;
+    float x;
+    float y;
+    float z;
+    float o;
+};
+
+// some class predefs
+class Player;
+class GameObject;
+class WorldPacket;
+class Creature;
+class Unit;
+struct GossipOption;
+
+class OutdoorPvP;
+class OutdoorPvPObjective
+{
+public:
+    OutdoorPvPObjective(OutdoorPvP * pvp);
+
+    virtual void FillInitialWorldStates(WorldPacket & data) {}
+
+    // send world state update to all players present
+    virtual void SendUpdateWorldState(uint32 field, uint32 value);
+    // send kill notify to players in the controlling faction
+    virtual void SendObjectiveComplete(uint32 id, uint64 guid);
+
+    // used when player is activated/inactivated in the area
+    virtual bool HandlePlayerEnter(Player * plr);
+    virtual void HandlePlayerLeave(Player * plr);
+    virtual void HandlePlayerActivityChanged(Player * plr);
+
+    // checks if player is in range of a capture credit marker
+    virtual bool IsInsideObjective(Player * plr);
+
+    virtual bool HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go);
+    virtual int32 HandleOpenGo(Player *plr, uint64 guid);
+
+    // returns true if the state of the objective has changed, in this case, the OutdoorPvP must send a world state ui update.
+    virtual bool Update(uint32 diff);
+
+    virtual bool HandleCapturePointEvent(Player * plr, uint32 eventId) { return false; }
+
+    virtual bool HandleCaptureCreaturePlayerMoveInLos(Player * p, Creature * c);
+
+    virtual bool HandleGossipOption(Player *plr, uint64 guid, uint32 gossipid);
+
+    virtual bool CanTalkTo(Player * plr, Creature * c, GossipOption &gso);
+
+    virtual bool HandleDropFlag(Player * plr, uint32 spellId);
+
+    virtual void DeleteSpawns();
+protected:
+
+    virtual bool AddCapturePoint(uint32 entry, uint32 map, float x, float y, float z, float o, float rotation0, float rotation1, float rotation2, float rotation3);
+    virtual bool AddObject(uint32 type, uint32 entry, uint32 map, float x, float y, float z, float o, float rotation0, float rotation1, float rotation2, float rotation3);
+    virtual bool AddCreature(uint32 type, uint32 entry, uint32 teamval, uint32 map, float x, float y, float z, float o, uint32 spawntimedelay = 0);
+
+    virtual bool DelCreature(uint32 type);
+    virtual bool DelObject(uint32 type);
+    virtual bool DelCapturePoint();
+
+protected:
+    // active players in the area of the objective
+    std::set<uint64> m_ActivePlayerGuids;
+    int32 m_AllianceActivePlayerCount;
+    int32 m_HordeActivePlayerCount;
+    // time left to capture the objective
+    uint32 m_ShiftTimer;
+    // total shift needed to capture the objective
+    float m_ShiftMaxPhase;
+    // maximum speed of capture
+    float m_ShiftMaxCaptureSpeed;
+    // the status of the objective
+    float m_ShiftPhase;
+    // phase before update, used to check which faction is in conquer / control
+    float m_OldPhase;
+    // objective states
+    uint32 m_OldState;
+    uint32 m_State;
+    // neutral value on capture bar
+    uint32 m_NeutralValue;
+
+    // pointer to the OutdoorPvP this objective belongs to
+    OutdoorPvP* m_PvP;
+
+    // map to store the various gameobjects and creatures spawned by the objective
+    //        type , guid
+    std::map<uint32,uint64> m_Objects;
+    std::map<uint32,uint64> m_Creatures;
+    std::map<uint64,uint32> m_ObjectTypes;
+    std::map<uint64,uint32> m_CreatureTypes;
+    uint64 m_CapturePoint;
+    uint64 m_CapturePointCreature;
+};
+
+// base class for specific outdoor pvp handlers
+class OutdoorPvP
+{
+public:
+    // ctor
+    OutdoorPvP();
+    // dtor
+    ~OutdoorPvP();
+    // deletes all gos/creatures spawned by the pvp
+    void DeleteSpawns();
+
+    typedef std::set<OutdoorPvPObjective *> OutdoorPvPObjectiveSet;
+
+    // called from Player::UpdateZone to add / remove buffs given by outdoor pvp events
+    virtual void HandlePlayerEnterZone(Player * plr, uint32 zone);
+    virtual void HandlePlayerLeaveZone(Player * plr, uint32 zone);
+    virtual void HandlePlayerActivityChanged(Player * plr);
+    // called when a player triggers an areatrigger
+    virtual bool HandleAreaTrigger(Player * plr, uint32 trigger);
+    // called on custom spell
+    virtual bool HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go);
+    // called on go use
+    virtual bool HandleOpenGo(Player *plr, uint64 guid);
+    // called from moveinlineofsight
+    virtual bool HandleCaptureCreaturePlayerMoveInLos(Player * p, Creature * c);
+
+    // setup stuff
+    virtual bool SetupOutdoorPvP() {return true;}
+
+    // world state stuff
+    virtual void SendRemoveWorldStates(Player * plr) {}
+    virtual void FillInitialWorldStates(WorldPacket & data) {}
+
+    // send world state update to all players present
+    virtual void SendUpdateWorldState(uint32 field, uint32 value);
+
+    // called by OutdoorPvPMgr, updates the objectives and if needed, sends new worldstateui information
+    virtual bool Update(uint32 diff);
+
+    // handle npc/player kill
+    virtual void HandleKill(Player * killer, Unit * killed);
+    virtual void HandleKillImpl(Player * killer, Unit * killed) {}
+
+    // checks if player is in range of a capture credit marker
+    virtual bool IsInsideObjective(Player * plr);
+
+    // awards rewards for player kill
+    virtual void AwardKillBonus(Player * plr) {}
+
+    uint32 GetTypeId() {return m_TypeId;}
+
+    virtual bool HandleDropFlag(Player * plr, uint32 spellId);
+
+    virtual bool HandleGossipOption(Player *plr, uint64 guid, uint32 gossipid);
+
+    virtual bool CanTalkTo(Player * plr, Creature * c, GossipOption &gso);
+protected:
+    // the map of the objectives belonging to this outdoorpvp
+    OutdoorPvPObjectiveSet m_OutdoorPvPObjectives;
+    // players in the zones of this outdoorpvp, 0 - alliance, 1 - horde
+    std::set<uint64> m_PlayerGuids[2];
+    uint32 m_TypeId;
+};
+
+#endif /*OUTDOOR_PVP_H_*/
diff --git a/src/game/OutdoorPvPEP.cpp b/src/game/OutdoorPvPEP.cpp
new file mode 100644
index 0000000..3d6ab9a
--- /dev/null
+++ b/src/game/OutdoorPvPEP.cpp
@@ -0,0 +1,878 @@
+#include "OutdoorPvPEP.h"
+#include "WorldPacket.h"
+#include "Player.h"
+#include "GameObject.h"
+#include "ObjectMgr.h"
+#include "ObjectAccessor.h"
+#include "OutdoorPvPMgr.h"
+#include "Creature.h"
+#include "Language.h"
+#include "World.h"
+
+OutdoorPvPObjectiveEP_EWT::OutdoorPvPObjectiveEP_EWT(OutdoorPvP *pvp)
+: OutdoorPvPObjective(pvp), m_TowerState(EP_TS_N)
+{
+    AddCapturePoint(EPCapturePoints[EP_EWT].entry,EPCapturePoints[EP_EWT].map,EPCapturePoints[EP_EWT].x,EPCapturePoints[EP_EWT].y,EPCapturePoints[EP_EWT].z,EPCapturePoints[EP_EWT].o,EPCapturePoints[EP_EWT].rot0,EPCapturePoints[EP_EWT].rot1,EPCapturePoints[EP_EWT].rot2,EPCapturePoints[EP_EWT].rot3);
+    AddObject(EP_EWT_FLAGS,EPTowerFlags[EP_EWT].entry,EPTowerFlags[EP_EWT].map,EPTowerFlags[EP_EWT].x,EPTowerFlags[EP_EWT].y,EPTowerFlags[EP_EWT].z,EPTowerFlags[EP_EWT].o,EPTowerFlags[EP_EWT].rot0,EPTowerFlags[EP_EWT].rot1,EPTowerFlags[EP_EWT].rot2,EPTowerFlags[EP_EWT].rot3);
+}
+
+bool OutdoorPvPObjectiveEP_EWT::Update(uint32 diff)
+{
+    if(OutdoorPvPObjective::Update(diff))
+    {
+        if(m_OldState != m_State || fabs(m_ShiftPhase) == m_ShiftMaxPhase)  // state won't change, only phase when maxed out!
+        {
+            // if changing from controlling alliance to horde or vice versa
+            if( m_OldState == OBJECTIVESTATE_ALLIANCE )
+            {
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString((LANG_OPVP_EP_LOOSE_EWT_A),-1));
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_EWT] = 0;
+            }
+            else if ( m_OldState == OBJECTIVESTATE_HORDE )
+            {
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString((LANG_OPVP_EP_LOOSE_EWT_H),-1));
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_EWT] = 0;
+            }
+
+            uint32 artkit = 21;
+
+            switch(m_State)
+            {
+            case OBJECTIVESTATE_ALLIANCE:
+                if(m_ShiftPhase == m_ShiftMaxPhase)
+                {
+                    m_TowerState = EP_TS_A;
+                    SummonSupportUnitAtNorthpassTower(ALLIANCE);
+                }
+                else
+                    m_TowerState = EP_TS_A_P;
+                artkit = 2;
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_EWT] = ALLIANCE;
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_CAPTURE_EWT_A,-1));
+                break;
+            case OBJECTIVESTATE_HORDE:
+                if(m_ShiftPhase == -m_ShiftMaxPhase)
+                {
+                    m_TowerState = EP_TS_H;
+                    SummonSupportUnitAtNorthpassTower(HORDE);
+                }
+                else
+                    m_TowerState = EP_TS_H_P;
+                artkit = 1;
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_EWT] = HORDE;
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_CAPTURE_EWT_H,-1));
+                break;
+            case OBJECTIVESTATE_NEUTRAL:
+                m_TowerState = EP_TS_N;
+                break;
+            case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+            case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+                m_TowerState = EP_TS_N_A;
+                break;
+            case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+            case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+                m_TowerState = EP_TS_N_H;
+                break;
+            }
+
+            GameObject* flag = HashMapHolder<GameObject>::Find(m_CapturePoint);
+            GameObject* flag2 = HashMapHolder<GameObject>::Find(m_Objects[EP_EWT_FLAGS]);
+            if(flag)
+            {
+                flag->SetGoArtKit(artkit);
+                flag->SendUpdateObjectToAllExcept(NULL);
+            }
+            if(flag2)
+            {
+                flag2->SetGoArtKit(artkit);
+                flag2->SendUpdateObjectToAllExcept(NULL);
+            }
+
+
+            UpdateTowerState();
+
+            // complete quest objective
+            if(m_TowerState == EP_TS_A || m_TowerState == EP_TS_H)
+                SendObjectiveComplete(EP_EWT_CM, 0);
+        }
+
+        if(m_ShiftPhase != m_OldPhase)
+        {
+            // send this too, sometimes the slider disappears, dunno why :(
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+            // send these updates to only the ones in this objective
+            uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+            // send this too, sometimes it resets :S
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_NeutralValue);
+        }
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_EWT::FillInitialWorldStates(WorldPacket &data)
+{
+    data << EP_EWT_A << uint32(bool(m_TowerState & EP_TS_A));
+    data << EP_EWT_H << uint32(bool(m_TowerState & EP_TS_H));
+    data << EP_EWT_A_P << uint32(bool(m_TowerState & EP_TS_A_P));
+    data << EP_EWT_H_P << uint32(bool(m_TowerState & EP_TS_H_P));
+    data << EP_EWT_N_A << uint32(bool(m_TowerState & EP_TS_N_A));
+    data << EP_EWT_N_H << uint32(bool(m_TowerState & EP_TS_N_H));
+    data << EP_EWT_N << uint32(bool(m_TowerState & EP_TS_N));
+}
+
+void OutdoorPvPObjectiveEP_EWT::UpdateTowerState()
+{
+    m_PvP->SendUpdateWorldState(EP_EWT_A , bool(m_TowerState & EP_TS_A));
+    m_PvP->SendUpdateWorldState(EP_EWT_H , bool(m_TowerState & EP_TS_H));
+    m_PvP->SendUpdateWorldState(EP_EWT_A_P , bool(m_TowerState & EP_TS_A_P));
+    m_PvP->SendUpdateWorldState(EP_EWT_H_P , bool(m_TowerState & EP_TS_H_P));
+    m_PvP->SendUpdateWorldState(EP_EWT_N_A , bool(m_TowerState & EP_TS_N_A));
+    m_PvP->SendUpdateWorldState(EP_EWT_N_H , bool(m_TowerState & EP_TS_N_H));
+    m_PvP->SendUpdateWorldState(EP_EWT_N , bool(m_TowerState & EP_TS_N));
+}
+
+bool OutdoorPvPObjectiveEP_EWT::HandlePlayerEnter(Player *plr)
+{
+    if(OutdoorPvPObjective::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_NeutralValue);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_EWT::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 0);
+    OutdoorPvPObjective::HandlePlayerLeave(plr);
+}
+
+bool OutdoorPvPObjectiveEP_EWT::HandleCapturePointEvent(Player *plr, uint32 eventId)
+{
+    if(eventId == EPTowerPlayerEnterEvents[EP_EWT])
+    {
+        this->HandlePlayerEnter(plr);
+        return true;
+    }
+    else if (eventId == EPTowerPlayerLeaveEvents[EP_EWT])
+    {
+        this->HandlePlayerLeave(plr);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_EWT::SummonSupportUnitAtNorthpassTower(uint32 team)
+{
+    const creature_type * ct = NULL;
+    if(team == ALLIANCE)
+        ct=EP_EWT_Summons_A;
+    else
+        ct=EP_EWT_Summons_H;
+
+    for(int i = 0; i < EP_EWT_NUM_CREATURES; ++i)
+    {
+        DelCreature(i);
+        AddCreature(i,ct[i].entry,ct[i].teamval,ct[i].map,ct[i].x,ct[i].y,ct[i].z,ct[i].o,1000000);
+    }
+}
+
+// NPT
+OutdoorPvPObjectiveEP_NPT::OutdoorPvPObjectiveEP_NPT(OutdoorPvP *pvp)
+: OutdoorPvPObjective(pvp), m_TowerState(EP_TS_N)
+{
+    AddCapturePoint(EPCapturePoints[EP_NPT].entry,EPCapturePoints[EP_NPT].map,EPCapturePoints[EP_NPT].x,EPCapturePoints[EP_NPT].y,EPCapturePoints[EP_NPT].z,EPCapturePoints[EP_NPT].o,EPCapturePoints[EP_NPT].rot0,EPCapturePoints[EP_NPT].rot1,EPCapturePoints[EP_NPT].rot2,EPCapturePoints[EP_NPT].rot3);
+    AddObject(EP_NPT_FLAGS,EPTowerFlags[EP_NPT].entry,EPTowerFlags[EP_NPT].map,EPTowerFlags[EP_NPT].x,EPTowerFlags[EP_NPT].y,EPTowerFlags[EP_NPT].z,EPTowerFlags[EP_NPT].o,EPTowerFlags[EP_NPT].rot0,EPTowerFlags[EP_NPT].rot1,EPTowerFlags[EP_NPT].rot2,EPTowerFlags[EP_NPT].rot3);
+}
+
+bool OutdoorPvPObjectiveEP_NPT::Update(uint32 diff)
+{
+    if(OutdoorPvPObjective::Update(diff))
+    {
+        if(m_OldState != m_State || fabs(m_ShiftPhase) == m_ShiftMaxPhase)  // state won't change, only phase when maxed out!
+        {
+            // if changing from controlling alliance to horde or vice versa
+            if( m_OldState == OBJECTIVESTATE_ALLIANCE )
+            {
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_LOOSE_NPT_A,-1));
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_NPT] = 0;
+            }
+            else if ( m_OldState == OBJECTIVESTATE_HORDE )
+            {
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_LOOSE_NPT_H,-1));
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_NPT] = 0;
+            }
+
+            uint32 artkit = 21;
+
+            switch(m_State)
+            {
+            case OBJECTIVESTATE_ALLIANCE:
+                if(m_ShiftPhase == m_ShiftMaxPhase)
+                {
+                    m_TowerState = EP_TS_A;
+                    SummonGO(ALLIANCE);
+                }
+                else
+                    m_TowerState = EP_TS_A_P;
+                artkit = 2;
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_NPT] = ALLIANCE;
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_CAPTURE_NPT_A,-1));
+                break;
+            case OBJECTIVESTATE_HORDE:
+                if(m_ShiftPhase == -m_ShiftMaxPhase)
+                {
+                    m_TowerState = EP_TS_H;
+                    SummonGO(HORDE);
+                }
+                else
+                    m_TowerState = EP_TS_H_P;
+                artkit = 1;
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_NPT] = HORDE;
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_CAPTURE_NPT_H,-1));
+                break;
+            case OBJECTIVESTATE_NEUTRAL:
+                m_TowerState = EP_TS_N;
+                DelObject(EP_NPT_BUFF);
+                break;
+            case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+            case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+                m_TowerState = EP_TS_N_A;
+                break;
+            case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+            case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+                m_TowerState = EP_TS_N_H;
+                break;
+            }
+
+            GameObject* flag = HashMapHolder<GameObject>::Find(m_CapturePoint);
+            GameObject* flag2 = HashMapHolder<GameObject>::Find(m_Objects[EP_NPT_FLAGS]);
+            if(flag)
+            {
+                flag->SetGoArtKit(artkit);
+                flag->SendUpdateObjectToAllExcept(NULL);
+            }
+            if(flag2)
+            {
+                flag2->SetGoArtKit(artkit);
+                flag2->SendUpdateObjectToAllExcept(NULL);
+            }
+
+            UpdateTowerState();
+
+            // complete quest objective
+            if(m_TowerState == EP_TS_A || m_TowerState == EP_TS_H)
+                SendObjectiveComplete(EP_NPT_CM, 0);
+        }
+
+        if(m_ShiftPhase != m_OldPhase)
+        {
+            // send this too, sometimes the slider disappears, dunno why :(
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+            // send these updates to only the ones in this objective
+            uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+            // send this too, sometimes it resets :S
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_NeutralValue);
+        }
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_NPT::FillInitialWorldStates(WorldPacket &data)
+{
+    data << EP_NPT_A << uint32(bool(m_TowerState & EP_TS_A));
+    data << EP_NPT_H << uint32(bool(m_TowerState & EP_TS_H));
+    data << EP_NPT_A_P << uint32(bool(m_TowerState & EP_TS_A_P));
+    data << EP_NPT_H_P << uint32(bool(m_TowerState & EP_TS_H_P));
+    data << EP_NPT_N_A << uint32(bool(m_TowerState & EP_TS_N_A));
+    data << EP_NPT_N_H << uint32(bool(m_TowerState & EP_TS_N_H));
+    data << EP_NPT_N << uint32(bool(m_TowerState & EP_TS_N));
+}
+
+void OutdoorPvPObjectiveEP_NPT::UpdateTowerState()
+{
+    m_PvP->SendUpdateWorldState(EP_NPT_A , bool(m_TowerState & EP_TS_A));
+    m_PvP->SendUpdateWorldState(EP_NPT_H , bool(m_TowerState & EP_TS_H));
+    m_PvP->SendUpdateWorldState(EP_NPT_A_P , bool(m_TowerState & EP_TS_A_P));
+    m_PvP->SendUpdateWorldState(EP_NPT_H_P , bool(m_TowerState & EP_TS_H_P));
+    m_PvP->SendUpdateWorldState(EP_NPT_N_A , bool(m_TowerState & EP_TS_N_A));
+    m_PvP->SendUpdateWorldState(EP_NPT_N_H , bool(m_TowerState & EP_TS_N_H));
+    m_PvP->SendUpdateWorldState(EP_NPT_N , bool(m_TowerState & EP_TS_N));
+}
+
+bool OutdoorPvPObjectiveEP_NPT::HandlePlayerEnter(Player *plr)
+{
+    if(OutdoorPvPObjective::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_NeutralValue);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_NPT::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 0);
+    OutdoorPvPObjective::HandlePlayerLeave(plr);
+}
+
+bool OutdoorPvPObjectiveEP_NPT::HandleCapturePointEvent(Player *plr, uint32 eventId)
+{
+    if(eventId == EPTowerPlayerEnterEvents[EP_NPT])
+    {
+        this->HandlePlayerEnter(plr);
+        return true;
+    }
+    else if (eventId == EPTowerPlayerLeaveEvents[EP_NPT])
+    {
+        this->HandlePlayerLeave(plr);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_NPT::SummonGO(uint32 team)
+{
+    DelObject(EP_NPT_BUFF);
+    AddObject(EP_NPT_BUFF,EP_NPT_LordaeronShrine.entry,EP_NPT_LordaeronShrine.map,EP_NPT_LordaeronShrine.x,EP_NPT_LordaeronShrine.y,EP_NPT_LordaeronShrine.z,EP_NPT_LordaeronShrine.o,EP_NPT_LordaeronShrine.rot0,EP_NPT_LordaeronShrine.rot1,EP_NPT_LordaeronShrine.rot2,EP_NPT_LordaeronShrine.rot3);
+    GameObject * go = HashMapHolder<GameObject>::Find(m_Objects[EP_NPT_BUFF]);
+    if(go)
+    {
+        go->SetUInt32Value(GAMEOBJECT_FACTION,(team == ALLIANCE ? 84 : 83));
+    }
+}
+
+// CGT
+OutdoorPvPObjectiveEP_CGT::OutdoorPvPObjectiveEP_CGT(OutdoorPvP *pvp)
+: OutdoorPvPObjective(pvp), m_TowerState(EP_TS_N)
+{
+    AddCapturePoint(EPCapturePoints[EP_CGT].entry,EPCapturePoints[EP_CGT].map,EPCapturePoints[EP_CGT].x,EPCapturePoints[EP_CGT].y,EPCapturePoints[EP_CGT].z,EPCapturePoints[EP_CGT].o,EPCapturePoints[EP_CGT].rot0,EPCapturePoints[EP_CGT].rot1,EPCapturePoints[EP_CGT].rot2,EPCapturePoints[EP_CGT].rot3);
+    AddObject(EP_CGT_FLAGS,EPTowerFlags[EP_CGT].entry,EPTowerFlags[EP_CGT].map,EPTowerFlags[EP_CGT].x,EPTowerFlags[EP_CGT].y,EPTowerFlags[EP_CGT].z,EPTowerFlags[EP_CGT].o,EPTowerFlags[EP_CGT].rot0,EPTowerFlags[EP_CGT].rot1,EPTowerFlags[EP_CGT].rot2,EPTowerFlags[EP_CGT].rot3);
+}
+
+bool OutdoorPvPObjectiveEP_CGT::Update(uint32 diff)
+{
+    if(OutdoorPvPObjective::Update(diff))
+    {
+        if(m_OldState != m_State || fabs(m_ShiftPhase) == m_ShiftMaxPhase)  // state won't change, only phase when maxed out!
+        {
+            // if changing from controlling alliance to horde or vice versa
+            if( m_OldState == OBJECTIVESTATE_ALLIANCE )
+            {
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_LOOSE_CGT_A,-1));
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_CGT] = 0;
+            }
+            else if ( m_OldState == OBJECTIVESTATE_HORDE )
+            {
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_LOOSE_CGT_H,-1));
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_CGT] = 0;
+            }
+
+            uint32 artkit = 21;
+
+            switch(m_State)
+            {
+            case OBJECTIVESTATE_ALLIANCE:
+                if(m_ShiftPhase == m_ShiftMaxPhase)
+                {
+                    m_TowerState = EP_TS_A;
+                    LinkGraveYard(ALLIANCE);
+                }
+                else
+                    m_TowerState = EP_TS_A_P;
+                artkit = 2;
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_CGT] = ALLIANCE;
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_CAPTURE_CGT_A,-1));
+                break;
+            case OBJECTIVESTATE_HORDE:
+                if(m_ShiftPhase == -m_ShiftMaxPhase)
+                {
+                    m_TowerState = EP_TS_H;
+                    LinkGraveYard(HORDE);
+                }
+                else
+                    m_TowerState = EP_TS_H_P;
+                artkit = 1;
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_CGT] = HORDE;
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_CAPTURE_CGT_H,-1));
+                break;
+            case OBJECTIVESTATE_NEUTRAL:
+                m_TowerState = EP_TS_N;
+                break;
+            case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+            case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+                m_TowerState = EP_TS_N_A;
+                break;
+            case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+            case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+                m_TowerState = EP_TS_N_H;
+                break;
+            }
+
+            GameObject* flag = HashMapHolder<GameObject>::Find(m_CapturePoint);
+            GameObject* flag2 = HashMapHolder<GameObject>::Find(m_Objects[EP_CGT_FLAGS]);
+            if(flag)
+            {
+                flag->SetGoArtKit(artkit);
+                flag->SendUpdateObjectToAllExcept(NULL);
+            }
+            if(flag2)
+            {
+                flag2->SetGoArtKit(artkit);
+                flag2->SendUpdateObjectToAllExcept(NULL);
+            }
+
+            UpdateTowerState();
+
+            // complete quest objective
+            if(m_TowerState == EP_TS_A || m_TowerState == EP_TS_H)
+                SendObjectiveComplete(EP_CGT_CM, 0);
+        }
+
+        if(m_ShiftPhase != m_OldPhase)
+        {
+            // send this too, sometimes the slider disappears, dunno why :(
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+            // send these updates to only the ones in this objective
+            uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+            // send this too, sometimes it resets :S
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_NeutralValue);
+        }
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_CGT::FillInitialWorldStates(WorldPacket &data)
+{
+    data << EP_CGT_A << uint32(bool(m_TowerState & EP_TS_A));
+    data << EP_CGT_H << uint32(bool(m_TowerState & EP_TS_H));
+    data << EP_CGT_A_P << uint32(bool(m_TowerState & EP_TS_A_P));
+    data << EP_CGT_H_P << uint32(bool(m_TowerState & EP_TS_H_P));
+    data << EP_CGT_N_A << uint32(bool(m_TowerState & EP_TS_N_A));
+    data << EP_CGT_N_H << uint32(bool(m_TowerState & EP_TS_N_H));
+    data << EP_CGT_N << uint32(bool(m_TowerState & EP_TS_N));
+}
+
+void OutdoorPvPObjectiveEP_CGT::UpdateTowerState()
+{
+    m_PvP->SendUpdateWorldState(EP_CGT_A , bool(m_TowerState & EP_TS_A));
+    m_PvP->SendUpdateWorldState(EP_CGT_H , bool(m_TowerState & EP_TS_H));
+    m_PvP->SendUpdateWorldState(EP_CGT_A_P , bool(m_TowerState & EP_TS_A_P));
+    m_PvP->SendUpdateWorldState(EP_CGT_H_P , bool(m_TowerState & EP_TS_H_P));
+    m_PvP->SendUpdateWorldState(EP_CGT_N_A , bool(m_TowerState & EP_TS_N_A));
+    m_PvP->SendUpdateWorldState(EP_CGT_N_H , bool(m_TowerState & EP_TS_N_H));
+    m_PvP->SendUpdateWorldState(EP_CGT_N , bool(m_TowerState & EP_TS_N));
+}
+
+bool OutdoorPvPObjectiveEP_CGT::HandlePlayerEnter(Player *plr)
+{
+    if(OutdoorPvPObjective::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_NeutralValue);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_CGT::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 0);
+    OutdoorPvPObjective::HandlePlayerLeave(plr);
+}
+
+bool OutdoorPvPObjectiveEP_CGT::HandleCapturePointEvent(Player *plr, uint32 eventId)
+{
+    if(eventId == EPTowerPlayerEnterEvents[EP_CGT])
+    {
+        this->HandlePlayerEnter(plr);
+        return true;
+    }
+    else if (eventId == EPTowerPlayerLeaveEvents[EP_CGT])
+    {
+        this->HandlePlayerLeave(plr);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_CGT::LinkGraveYard(uint32 team)
+{
+    objmgr.RemoveGraveYardLink(EP_GraveYardId,EP_GraveYardZone,team,false);
+    objmgr.AddGraveYardLink(EP_GraveYardId,EP_GraveYardZone,team,false);
+}
+
+// PWT
+OutdoorPvPObjectiveEP_PWT::OutdoorPvPObjectiveEP_PWT(OutdoorPvP *pvp)
+: OutdoorPvPObjective(pvp), m_TowerState(EP_TS_N)
+{
+    AddCapturePoint(EPCapturePoints[EP_PWT].entry,EPCapturePoints[EP_PWT].map,EPCapturePoints[EP_PWT].x,EPCapturePoints[EP_PWT].y,EPCapturePoints[EP_PWT].z,EPCapturePoints[EP_PWT].o,EPCapturePoints[EP_PWT].rot0,EPCapturePoints[EP_PWT].rot1,EPCapturePoints[EP_PWT].rot2,EPCapturePoints[EP_PWT].rot3);
+    AddObject(EP_PWT_FLAGS,EPTowerFlags[EP_PWT].entry,EPTowerFlags[EP_PWT].map,EPTowerFlags[EP_PWT].x,EPTowerFlags[EP_PWT].y,EPTowerFlags[EP_PWT].z,EPTowerFlags[EP_PWT].o,EPTowerFlags[EP_PWT].rot0,EPTowerFlags[EP_PWT].rot1,EPTowerFlags[EP_PWT].rot2,EPTowerFlags[EP_PWT].rot3);
+    memset(m_taximask, 0, sizeof(m_taximask));
+    SetTaximaskNode(EP_PWT_Taxi);
+    SetTaximaskNode(EP_CGT_Taxi);
+    SetTaximaskNode(EP_EWT_Taxi);
+    SetTaximaskNode(EP_NPT_Taxi);
+}
+
+bool OutdoorPvPObjectiveEP_PWT::Update(uint32 diff)
+{
+    if(OutdoorPvPObjective::Update(diff))
+    {
+        if(m_OldState != m_State || fabs(m_ShiftPhase) == m_ShiftMaxPhase)  // state won't change, only phase when maxed out!
+        {
+            // if changing from controlling alliance to horde or vice versa
+            if( m_OldState == OBJECTIVESTATE_ALLIANCE )
+            {
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_LOOSE_PWT_A,-1));
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_PWT] = 0;
+            }
+            else if ( m_OldState == OBJECTIVESTATE_HORDE )
+            {
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_LOOSE_PWT_H,-1));
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_PWT] = 0;
+            }
+
+            uint32 artkit = 21;
+
+            switch(m_State)
+            {
+            case OBJECTIVESTATE_ALLIANCE:
+                if(m_ShiftPhase == m_ShiftMaxPhase)
+                {
+                    m_TowerState = EP_TS_A;
+                    SummonFlightMaster(ALLIANCE);
+                }
+                else
+                    m_TowerState = EP_TS_A_P;
+                artkit = 2;
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_PWT] = ALLIANCE;
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_CAPTURE_PWT_A,-1));
+                break;
+            case OBJECTIVESTATE_HORDE:
+                if(m_ShiftPhase == -m_ShiftMaxPhase)
+                {
+                    m_TowerState = EP_TS_H;
+                    SummonFlightMaster(HORDE);
+                }
+                else
+                    m_TowerState = EP_TS_H_P;
+                artkit = 1;
+                ((OutdoorPvPEP*)m_PvP)->EP_Controls[EP_PWT] = HORDE;
+                sWorld.SendZoneText(EP_GraveYardZone,objmgr.GetMangosString(LANG_OPVP_EP_CAPTURE_PWT_H,-1));
+                break;
+            case OBJECTIVESTATE_NEUTRAL:
+                m_TowerState = EP_TS_N;
+                DelCreature(EP_PWT_FLIGHTMASTER);
+                break;
+            case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+            case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+                m_TowerState = EP_TS_N_A;
+                break;
+            case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+            case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+                m_TowerState = EP_TS_N_H;
+                break;
+            }
+
+            GameObject* flag = HashMapHolder<GameObject>::Find(m_CapturePoint);
+            GameObject* flag2 = HashMapHolder<GameObject>::Find(m_Objects[EP_PWT_FLAGS]);
+            if(flag)
+            {
+                flag->SetGoArtKit(artkit);
+                flag->SendUpdateObjectToAllExcept(NULL);
+            }
+            if(flag2)
+            {
+                flag2->SetGoArtKit(artkit);
+                flag2->SendUpdateObjectToAllExcept(NULL);
+            }
+
+            UpdateTowerState();
+
+            // complete quest objective
+            if(m_TowerState == EP_TS_A || m_TowerState == EP_TS_H)
+                SendObjectiveComplete(EP_PWT_CM, 0);
+        }
+
+        if(m_ShiftPhase != m_OldPhase)
+        {
+            // send this too, sometimes the slider disappears, dunno why :(
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+            // send these updates to only the ones in this objective
+            uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+            // send this too, sometimes it resets :S
+            SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_NeutralValue);
+        }
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_PWT::FillInitialWorldStates(WorldPacket &data)
+{
+    data << EP_PWT_A << uint32(bool(m_TowerState & EP_TS_A));
+    data << EP_PWT_H << uint32(bool(m_TowerState & EP_TS_H));
+    data << EP_PWT_A_P << uint32(bool(m_TowerState & EP_TS_A_P));
+    data << EP_PWT_H_P << uint32(bool(m_TowerState & EP_TS_H_P));
+    data << EP_PWT_N_A << uint32(bool(m_TowerState & EP_TS_N_A));
+    data << EP_PWT_N_H << uint32(bool(m_TowerState & EP_TS_N_H));
+    data << EP_PWT_N << uint32(bool(m_TowerState & EP_TS_N));
+}
+
+void OutdoorPvPObjectiveEP_PWT::UpdateTowerState()
+{
+    m_PvP->SendUpdateWorldState(EP_PWT_A , bool(m_TowerState & EP_TS_A));
+    m_PvP->SendUpdateWorldState(EP_PWT_H , bool(m_TowerState & EP_TS_H));
+    m_PvP->SendUpdateWorldState(EP_PWT_A_P , bool(m_TowerState & EP_TS_A_P));
+    m_PvP->SendUpdateWorldState(EP_PWT_H_P , bool(m_TowerState & EP_TS_H_P));
+    m_PvP->SendUpdateWorldState(EP_PWT_N_A , bool(m_TowerState & EP_TS_N_A));
+    m_PvP->SendUpdateWorldState(EP_PWT_N_H , bool(m_TowerState & EP_TS_N_H));
+    m_PvP->SendUpdateWorldState(EP_PWT_N , bool(m_TowerState & EP_TS_N));
+}
+
+bool OutdoorPvPObjectiveEP_PWT::HandlePlayerEnter(Player *plr)
+{
+    if(OutdoorPvPObjective::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+        plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_NeutralValue);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_PWT::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 0);
+    OutdoorPvPObjective::HandlePlayerLeave(plr);
+}
+
+bool OutdoorPvPObjectiveEP_PWT::HandleCapturePointEvent(Player *plr, uint32 eventId)
+{
+    if(eventId == EPTowerPlayerEnterEvents[EP_PWT])
+    {
+        this->HandlePlayerEnter(plr);
+        return true;
+    }
+    else if (eventId == EPTowerPlayerLeaveEvents[EP_PWT])
+    {
+        this->HandlePlayerLeave(plr);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveEP_PWT::SummonFlightMaster(uint32 team)
+{
+    DelCreature(EP_PWT_FLIGHTMASTER);
+    AddCreature(EP_PWT_FLIGHTMASTER,EP_PWT_FlightMaster.entry,team,EP_PWT_FlightMaster.map,EP_PWT_FlightMaster.x,EP_PWT_FlightMaster.y,EP_PWT_FlightMaster.z,EP_PWT_FlightMaster.o);
+    Creature * c = HashMapHolder<Creature>::Find(m_Creatures[EP_PWT_FLIGHTMASTER]);
+    if(c)
+    {
+        GossipOption * gso = new GossipOption;
+        gso->Action = GOSSIP_OPTION_OUTDOORPVP;
+        gso->GossipId = 0;
+        gso->OptionText.assign("As the breeze whips straight as an arrow, let her go over Kill Devil Hill!");
+        gso->Id = 50;
+        gso->Icon = 1;
+        gso->NpcFlag = 0;
+        c->addGossipOption(*gso);
+    }
+}
+
+bool OutdoorPvPObjectiveEP_PWT::HandleGossipOption(Player *plr, uint64 guid, uint32 gossipid)
+{
+    std::map<uint64,uint32>::iterator itr = m_CreatureTypes.find(guid);
+    if(itr != m_CreatureTypes.end())
+    {
+        Creature * cr = HashMapHolder<Creature>::Find(guid);
+        if(!cr)
+            return true;
+        if(itr->second == EP_PWT_FLIGHTMASTER)
+        {
+            uint32 curloc = EP_PWT_Taxi;
+
+            WorldPacket data( SMSG_SHOWTAXINODES, (4+8+4+8*4) );
+            data << uint32( 1 );
+            data << uint64( cr->GetGUID() );
+            data << uint32( curloc );
+
+            for (uint8 i=0; i<TaxiMaskSize; i++)
+                data << uint32(m_taximask[i]);                  // known nodes
+
+            plr->GetSession()->SendPacket( &data );
+        }
+        return true;
+    }
+    return false;
+}
+
+// ep
+OutdoorPvPEP::OutdoorPvPEP()
+{
+    m_TypeId = OUTDOOR_PVP_EP;
+    memset(EP_Controls,0,sizeof(EP_Controls));
+    m_AllianceTowersControlled = 0;
+    m_HordeTowersControlled = 0;
+}
+
+bool OutdoorPvPEP::SetupOutdoorPvP()
+{
+    for(int i = 0; i < EPBuffZonesNum; ++i)
+        sOutdoorPvPMgr.AddZone(EPBuffZones[i],this);
+
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveEP_EWT(this));
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveEP_PWT(this));
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveEP_CGT(this));
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveEP_NPT(this));
+    return true;
+}
+
+bool OutdoorPvPEP::Update(uint32 diff)
+{
+    if(OutdoorPvP::Update(diff))
+    {
+        m_AllianceTowersControlled = 0;
+        m_HordeTowersControlled = 0;
+        for(int i = 0; i < EP_TOWER_NUM; ++i)
+        {
+            if(EP_Controls[i] == ALLIANCE)
+                ++m_AllianceTowersControlled;
+            else if(EP_Controls[i] == HORDE)
+                ++m_HordeTowersControlled;
+            SendUpdateWorldState(EP_UI_TOWER_COUNT_A,m_AllianceTowersControlled);
+            SendUpdateWorldState(EP_UI_TOWER_COUNT_H,m_HordeTowersControlled);
+            BuffTeams();
+        }
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPEP::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    // add buffs
+    if(plr->GetTeam() == ALLIANCE)
+    {
+        if(m_AllianceTowersControlled && m_AllianceTowersControlled < 5)
+            plr->CastSpell(plr,EP_AllianceBuffs[m_AllianceTowersControlled-1],true);
+    }
+    else
+    {
+        if(m_HordeTowersControlled && m_HordeTowersControlled < 5)
+            plr->CastSpell(plr,EP_HordeBuffs[m_HordeTowersControlled-1],true);
+    }
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPEP::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    if(plr->GetTeam() == ALLIANCE)
+    {
+        for(int i = 0; i < 4; ++i)
+            plr->RemoveAurasDueToSpell(EP_AllianceBuffs[i]);
+    }
+    else
+    {
+        for(int i = 0; i < 4; ++i)
+            plr->RemoveAurasDueToSpell(EP_HordeBuffs[i]);
+    }
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+void OutdoorPvPEP::BuffTeams()
+{
+    for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+    {
+        if(Player * plr = objmgr.GetPlayer(*itr))
+        {
+            for(int i = 0; i < 4; ++i)
+                plr->RemoveAurasDueToSpell(EP_AllianceBuffs[i]);
+            if(m_AllianceTowersControlled && m_AllianceTowersControlled < 5)
+                plr->CastSpell(plr,EP_AllianceBuffs[m_AllianceTowersControlled-1],true);
+        }
+    }
+    for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+    {
+        if(Player * plr = objmgr.GetPlayer(*itr))
+        {
+            for(int i = 0; i < 4; ++i)
+                plr->RemoveAurasDueToSpell(EP_HordeBuffs[i]);
+            if(m_HordeTowersControlled && m_HordeTowersControlled < 5)
+                plr->CastSpell(plr,EP_HordeBuffs[m_HordeTowersControlled-1],true);
+        }
+    }
+}
+
+void OutdoorPvPEP::FillInitialWorldStates(WorldPacket & data)
+{
+    data << EP_UI_TOWER_COUNT_A << m_AllianceTowersControlled;
+    data << EP_UI_TOWER_COUNT_H << m_HordeTowersControlled;
+    data << EP_UI_TOWER_SLIDER_DISPLAY << uint32(0);
+    data << EP_UI_TOWER_SLIDER_POS << uint32(50);
+    data << EP_UI_TOWER_SLIDER_N << uint32(100);
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        (*itr)->FillInitialWorldStates(data);
+    }
+}
+
+void OutdoorPvPEP::SendRemoveWorldStates(Player *plr)
+{
+    plr->SendUpdateWorldState(EP_UI_TOWER_COUNT_A,0);
+    plr->SendUpdateWorldState(EP_UI_TOWER_COUNT_H,0);
+    plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY,0);
+    plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS,0);
+    plr->SendUpdateWorldState(EP_UI_TOWER_SLIDER_N,0);
+
+    plr->SendUpdateWorldState(EP_EWT_A,0);
+    plr->SendUpdateWorldState(EP_EWT_H,0);
+    plr->SendUpdateWorldState(EP_EWT_N,0);
+    plr->SendUpdateWorldState(EP_EWT_A_P,0);
+    plr->SendUpdateWorldState(EP_EWT_H_P,0);
+    plr->SendUpdateWorldState(EP_EWT_N_A,0);
+    plr->SendUpdateWorldState(EP_EWT_N_H,0);
+
+    plr->SendUpdateWorldState(EP_PWT_A,0);
+    plr->SendUpdateWorldState(EP_PWT_H,0);
+    plr->SendUpdateWorldState(EP_PWT_N,0);
+    plr->SendUpdateWorldState(EP_PWT_A_P,0);
+    plr->SendUpdateWorldState(EP_PWT_H_P,0);
+    plr->SendUpdateWorldState(EP_PWT_N_A,0);
+    plr->SendUpdateWorldState(EP_PWT_N_H,0);
+
+    plr->SendUpdateWorldState(EP_NPT_A,0);
+    plr->SendUpdateWorldState(EP_NPT_H,0);
+    plr->SendUpdateWorldState(EP_NPT_N,0);
+    plr->SendUpdateWorldState(EP_NPT_A_P,0);
+    plr->SendUpdateWorldState(EP_NPT_H_P,0);
+    plr->SendUpdateWorldState(EP_NPT_N_A,0);
+    plr->SendUpdateWorldState(EP_NPT_N_H,0);
+
+    plr->SendUpdateWorldState(EP_CGT_A,0);
+    plr->SendUpdateWorldState(EP_CGT_H,0);
+    plr->SendUpdateWorldState(EP_CGT_N,0);
+    plr->SendUpdateWorldState(EP_CGT_A_P,0);
+    plr->SendUpdateWorldState(EP_CGT_H_P,0);
+    plr->SendUpdateWorldState(EP_CGT_N_A,0);
+    plr->SendUpdateWorldState(EP_CGT_N_H,0);
+}
diff --git a/src/game/OutdoorPvPEP.h b/src/game/OutdoorPvPEP.h
new file mode 100644
index 0000000..762e1d2
--- /dev/null
+++ b/src/game/OutdoorPvPEP.h
@@ -0,0 +1,272 @@
+#ifndef OUTDOOR_PVP_EP_
+#define OUTDOOR_PVP_EP_
+
+#include "OutdoorPvP.h"
+
+#include "Database/DBCStructure.h"
+
+const uint32 EP_AllianceBuffs[4] = {11413, 11414, 11415, 1386};
+
+const uint32 EP_HordeBuffs[4] = {30880, 30683, 30682, 29520};
+
+const uint32 EP_GraveYardZone = 139;
+
+const uint32 EP_GraveYardId = 927;
+
+const uint32 EPBuffZonesNum = 3;
+
+const uint32 EP_EWT_CM = 17690;
+const uint32 EP_CGT_CM = 17689;
+const uint32 EP_NPT_CM = 17696;
+const uint32 EP_PWT_CM = 17698;
+
+const uint32 EPBuffZones[EPBuffZonesNum] = {139, 2017, 2057};
+
+enum EP_TaxiNodes {
+    EP_CGT_Taxi = 87,
+    EP_EWT_Taxi = 86,
+    EP_NPT_Taxi = 85,
+    EP_PWT_Taxi = 84
+};
+
+enum EP_EastwallTowerWorldStates {
+    EP_EWT_A = 2354,
+    EP_EWT_H = 2356,
+    EP_EWT_A_P = 2357, // ally progressing
+    EP_EWT_H_P = 2358,
+    EP_EWT_N_A = 2359, // ally conquested
+    EP_EWT_N_H = 2360,
+    EP_EWT_N = 2361
+};
+
+enum EP_NorthpassTowerWorldStates {
+    EP_NPT_N = 2352,
+    EP_NPT_N_A = 2362,
+    EP_NPT_N_H = 2363,
+    EP_NPT_A_P = 2364,
+    EP_NPT_H_P = 2365,
+    EP_NPT_A = 2372,
+    EP_NPT_H = 2373
+};
+
+enum EP_PlagewoodTowerWorldStates {
+    EP_PWT_N_A = 2366,
+    EP_PWT_N_H = 2353, //2367 not present! use neutral!
+    EP_PWT_A_P = 2368,
+    EP_PWT_H_P = 2369,
+    EP_PWT_A = 2370,
+    EP_PWT_H = 2371,
+    EP_PWT_N = 2353
+};
+
+enum EP_CrownGuardTowerWorldStates {
+    EP_CGT_N_A = 2374,
+    EP_CGT_N_H = 2375,
+    EP_CGT_A_P = 2376,
+    EP_CGT_H_P = 2377,
+    EP_CGT_A = 2378,
+    EP_CGT_H = 2379,
+    EP_CGT_N = 2355
+};
+
+enum EP_WorldStates {
+    EP_UI_TOWER_SLIDER_DISPLAY = 2426,
+    EP_UI_TOWER_SLIDER_POS = 2427,
+    EP_UI_TOWER_SLIDER_N = 2428,
+
+    EP_UI_TOWER_COUNT_A = 2327,
+    EP_UI_TOWER_COUNT_H = 2328
+};
+
+enum EP_Summons {
+    EP_EWT_COMMANDER = 0,
+    EP_EWT_SOLDIER1,
+    EP_EWT_SOLDIER2,
+    EP_EWT_SOLDIER3,
+    EP_EWT_SOLDIER4,
+    EP_PWT_FLIGHTMASTER,
+};
+
+enum EP_GoSummons {
+    EP_NPT_BUFF = 0,
+    EP_NPT_FLAGS,
+    EP_EWT_FLAGS,
+    EP_CGT_FLAGS,
+    EP_PWT_FLAGS
+};
+
+enum EP_Towers {
+    EP_EWT = 0, // plaguelands 03
+    EP_NPT,// plaguelands 01
+    EP_PWT,// plaguelands 04
+    EP_CGT,// plaguelands 02
+    EP_TOWER_NUM
+};
+
+const go_type EPCapturePoints[EP_TOWER_NUM] = {
+    {182097,0,2574.51,-4794.89,144.704,-1.45003,-0.097056,0.095578,-0.656229,0.742165},
+    {181899,0,3181.08,-4379.36,174.123,-2.03472,-0.065392,0.119494,-0.842275,0.521553},
+    {182098,0,2962.71,-3042.31,154.789,2.08426,-0.074807,-0.113837,0.855928,0.49883},
+    {182096,0,1860.85,-3731.23,196.716,-2.53214,0.033967,-0.131914,0.944741,-0.298177}
+};
+
+const go_type EPTowerFlags[EP_TOWER_NUM] = {
+    {182106,0,2569.60,-4772.93,115.399,2.72271,0,0,0.978148,0.207912},
+    {182106,0,3148.17,-4365.51,145.029,1.53589,0,0,0.694658,0.71934},
+    {182106,0,2992.63,-3022.95,125.593,3.03687,0,0,0.99863,0.052336},
+    {182106,0,1838.42,-3703.56,167.713,0.890118,0,0,0.430511,0.902585}
+};
+
+const uint32 EPTowerPlayerEnterEvents[EP_TOWER_NUM] = {10691,10699,10701,10705};
+
+const uint32 EPTowerPlayerLeaveEvents[EP_TOWER_NUM] = {10692,10698,10700,10704};
+
+const uint32 EP_NUM_CREATURES = 6;
+const uint32 EP_EWT_NUM_CREATURES = 5;
+
+// one lordaeron commander, 4 soldiers
+// should be spawned at EWT and follow a path, but trans-grid pathing isn't safe, so summon them directly at NPT
+const creature_type EP_EWT_Summons_A[EP_EWT_NUM_CREATURES] = {
+    {17635,469,0, 3167.61,-4352.09,138.20,4.5811},
+    {17647,469,0, 3172.74,-4352.99,139.14,4.9873},
+    {17647,469,0, 3165.89,-4354.46,138.67,3.7244},
+    {17647,469,0, 3164.65,-4350.26,138.22,2.4794},
+    {17647,469,0, 3169.91,-4349.68,138.37,0.7444}
+};
+
+const creature_type EP_EWT_Summons_H[EP_EWT_NUM_CREATURES] = {
+    {17995,67,0, 3167.61,-4352.09,138.20,4.5811},
+    {17996,67,0, 3172.74,-4352.99,139.14,4.9873},
+    {17996,67,0, 3165.89,-4354.46,138.67,3.7244},
+    {17996,67,0, 3164.65,-4350.26,138.22,2.4794},
+    {17996,67,0, 3169.91,-4349.68,138.37,0.7444}
+};
+
+enum EP_TowerStates {
+    EP_TS_N = 1,
+    EP_TS_N_A = 2,
+    EP_TS_N_H = 4,
+    EP_TS_A_P = 8,
+    EP_TS_H_P = 16,
+    EP_TS_A = 32,
+    EP_TS_H = 64
+};
+
+// when spawning, pay attention at setting the faction manually!
+const creature_type EP_PWT_FlightMaster = {17209,0,0,2987.5,-3049.11,120.126,5.75959};
+
+// after spawning, modify the faction so that only the controller will be able to use it with SetUInt32Value(GAMEOBJECT_FACTION, faction_id);
+const go_type EP_NPT_LordaeronShrine = {181682,0,3167.72,-4355.91,138.785,1.69297,0,0,0.748956,0.66262};
+
+class OutdoorPvPEP;
+
+class OutdoorPvPObjectiveEP_EWT : public OutdoorPvPObjective
+{
+friend class OutdoorPvPEP;
+public:
+    OutdoorPvPObjectiveEP_EWT(OutdoorPvP * pvp);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+protected:
+    bool HandleCapturePointEvent(Player * plr, uint32 eventId);
+    void SummonSupportUnitAtNorthpassTower(uint32 team);
+    void UpdateTowerState();
+protected:
+    uint32 m_TowerState;
+};
+
+class OutdoorPvPObjectiveEP_NPT : public OutdoorPvPObjective
+{
+friend class OutdoorPvPEP;
+public:
+    OutdoorPvPObjectiveEP_NPT(OutdoorPvP * pvp);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+protected:
+    bool HandleCapturePointEvent(Player * plr, uint32 eventId);
+    void SummonGO(uint32 team);
+    void UpdateTowerState();
+protected:
+    uint32 m_TowerState;
+};
+
+class OutdoorPvPObjectiveEP_CGT : public OutdoorPvPObjective
+{
+friend class OutdoorPvPEP;
+public:
+    OutdoorPvPObjectiveEP_CGT(OutdoorPvP * pvp);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+protected:
+    bool HandleCapturePointEvent(Player * plr, uint32 eventId);
+    void LinkGraveYard(uint32 team);
+    void UpdateTowerState();
+protected:
+    uint32 m_TowerState;
+};
+
+class OutdoorPvPObjectiveEP_PWT : public OutdoorPvPObjective
+{
+friend class OutdoorPvPEP;
+public:
+    OutdoorPvPObjectiveEP_PWT(OutdoorPvP * pvp);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+    bool HandleGossipOption(Player *plr, uint64 guid, uint32 gossipid);
+protected:
+    bool HandleCapturePointEvent(Player * plr, uint32 eventId);
+    void SummonFlightMaster(uint32 team);
+    void UpdateTowerState();
+    // copy from player.h
+    bool SetTaximaskNode(uint32 nodeidx)
+    {
+        uint8  field   = uint8((nodeidx - 1) / 32);
+        uint32 submask = 1<<((nodeidx-1)%32);
+        if ((m_taximask[field] & submask) != submask )
+        {
+            m_taximask[field] |= submask;
+            return true;
+        }
+        else
+            return false;
+    }
+protected:
+    uint32 m_TowerState;
+    TaxiMask m_taximask;
+};
+
+class OutdoorPvPEP : public OutdoorPvP
+{
+friend class OutdoorPvPObjectiveEP_EWT;
+friend class OutdoorPvPObjectiveEP_NPT;
+friend class OutdoorPvPObjectiveEP_PWT;
+friend class OutdoorPvPObjectiveEP_CGT;
+public:
+    OutdoorPvPEP();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket &data);
+    void SendRemoveWorldStates(Player * plr);
+    void BuffTeams();
+private:
+    // how many towers are controlled
+    uint32 EP_Controls[EP_TOWER_NUM];
+    uint32 m_AllianceTowersControlled;
+    uint32 m_HordeTowersControlled;
+};
+
+#endif
diff --git a/src/game/OutdoorPvPHP.cpp b/src/game/OutdoorPvPHP.cpp
new file mode 100644
index 0000000..54fec5b
--- /dev/null
+++ b/src/game/OutdoorPvPHP.cpp
@@ -0,0 +1,380 @@
+#include "OutdoorPvPHP.h"
+#include "OutdoorPvP.h"
+#include "OutdoorPvPMgr.h"
+#include "Player.h"
+#include "WorldPacket.h"
+#include "World.h"
+#include "ObjectMgr.h"
+#include "Language.h"
+
+const uint32 HP_LANG_LOOSE_A[HP_TOWER_NUM] = {LANG_OPVP_HP_LOOSE_BROKENHILL_A,LANG_OPVP_HP_LOOSE_OVERLOOK_A,LANG_OPVP_HP_LOOSE_STADIUM_A};
+
+const uint32 HP_LANG_LOOSE_H[HP_TOWER_NUM] = {LANG_OPVP_HP_LOOSE_BROKENHILL_H,LANG_OPVP_HP_LOOSE_OVERLOOK_H,LANG_OPVP_HP_LOOSE_STADIUM_H};
+
+const uint32 HP_LANG_CAPTURE_A[HP_TOWER_NUM] = {LANG_OPVP_HP_CAPTURE_BROKENHILL_A,LANG_OPVP_HP_CAPTURE_OVERLOOK_A,LANG_OPVP_HP_CAPTURE_STADIUM_A};
+
+const uint32 HP_LANG_CAPTURE_H[HP_TOWER_NUM] = {LANG_OPVP_HP_CAPTURE_BROKENHILL_H,LANG_OPVP_HP_CAPTURE_OVERLOOK_H,LANG_OPVP_HP_CAPTURE_STADIUM_H};
+
+OutdoorPvPObjectiveHP::OutdoorPvPObjectiveHP(OutdoorPvP *pvp,OutdoorPvPHPTowerType type)
+: OutdoorPvPObjective(pvp), m_TowerType(type)
+{
+    AddCapturePoint(HPCapturePoints[type].entry,
+        HPCapturePoints[type].map,
+        HPCapturePoints[type].x,
+        HPCapturePoints[type].y,
+        HPCapturePoints[type].z,
+        HPCapturePoints[type].o,
+        HPCapturePoints[type].rot0,
+        HPCapturePoints[type].rot1,
+        HPCapturePoints[type].rot2,
+        HPCapturePoints[type].rot3);
+    AddObject(type,
+        HPTowerFlags[type].entry,
+        HPTowerFlags[type].map,
+        HPTowerFlags[type].x,
+        HPTowerFlags[type].y,
+        HPTowerFlags[type].z,
+        HPTowerFlags[type].o,
+        HPTowerFlags[type].rot0,
+        HPTowerFlags[type].rot1,
+        HPTowerFlags[type].rot2,
+        HPTowerFlags[type].rot3);
+}
+
+OutdoorPvPHP::OutdoorPvPHP()
+{
+    m_TypeId = OUTDOOR_PVP_HP;
+}
+
+bool OutdoorPvPHP::SetupOutdoorPvP()
+{
+    m_AllianceTowersControlled = 0;
+    m_HordeTowersControlled = 0;
+    // add the zones affected by the pvp buff
+    for(int i = 0; i < OutdoorPvPHPBuffZonesNum; ++i)
+        sOutdoorPvPMgr.AddZone(OutdoorPvPHPBuffZones[i],this);
+
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveHP(this,HP_TOWER_BROKEN_HILL));
+
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveHP(this,HP_TOWER_OVERLOOK));
+
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveHP(this,HP_TOWER_STADIUM));
+
+    return true;
+}
+
+void OutdoorPvPHP::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    // add buffs
+    if(plr->GetTeam() == ALLIANCE)
+    {
+        if(m_AllianceTowersControlled >=3)
+            plr->CastSpell(plr,AllianceBuff,true);
+    }
+    else
+    {
+        if(m_HordeTowersControlled >=3)
+            plr->CastSpell(plr,HordeBuff,true);
+    }
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPHP::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    if(plr->GetTeam() == ALLIANCE)
+    {
+        plr->RemoveAurasDueToSpell(AllianceBuff);
+    }
+    else
+    {
+        plr->RemoveAurasDueToSpell(HordeBuff);
+    }
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+bool OutdoorPvPHP::Update(uint32 diff)
+{
+    bool changed = false;
+    if(changed = OutdoorPvP::Update(diff))
+    {
+        if(m_AllianceTowersControlled == 3)
+            BuffTeam(ALLIANCE);
+        else if(m_HordeTowersControlled == 3)
+            BuffTeam(HORDE);
+        else
+            BuffTeam(NULL);
+        SendUpdateWorldState(HP_UI_TOWER_COUNT_A, m_AllianceTowersControlled);
+        SendUpdateWorldState(HP_UI_TOWER_COUNT_H, m_HordeTowersControlled);
+    }
+    return changed;
+}
+
+void OutdoorPvPHP::SendRemoveWorldStates(Player *plr)
+{
+    plr->SendUpdateWorldState(HP_UI_TOWER_DISPLAY_A,0);
+    plr->SendUpdateWorldState(HP_UI_TOWER_DISPLAY_H,0);
+    plr->SendUpdateWorldState(HP_UI_TOWER_COUNT_H,0);
+    plr->SendUpdateWorldState(HP_UI_TOWER_COUNT_A,0);
+    plr->SendUpdateWorldState(HP_UI_TOWER_SLIDER_N,0);
+    plr->SendUpdateWorldState(HP_UI_TOWER_SLIDER_POS,0);
+    plr->SendUpdateWorldState(HP_UI_TOWER_SLIDER_DISPLAY,0);
+    for(int i = 0; i < HP_TOWER_NUM; ++i)
+    {
+        plr->SendUpdateWorldState(HP_MAP_N[i],0);
+        plr->SendUpdateWorldState(HP_MAP_A[i],0);
+        plr->SendUpdateWorldState(HP_MAP_H[i],0);
+    }
+}
+
+void OutdoorPvPHP::FillInitialWorldStates(WorldPacket &data)
+{
+    data << uint32(HP_UI_TOWER_DISPLAY_A) << uint32(1);
+    data << uint32(HP_UI_TOWER_DISPLAY_H) << uint32(1);
+    data << uint32(HP_UI_TOWER_COUNT_A) << uint32(m_AllianceTowersControlled);
+    data << uint32(HP_UI_TOWER_COUNT_H) << uint32(m_HordeTowersControlled);
+    data << uint32(HP_UI_TOWER_SLIDER_DISPLAY) << uint32(0);
+    data << uint32(HP_UI_TOWER_SLIDER_POS) << uint32(50);
+    data << uint32(HP_UI_TOWER_SLIDER_N) << uint32(100);
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        (*itr)->FillInitialWorldStates(data);
+    }
+}
+
+bool OutdoorPvPObjectiveHP::Update(uint32 diff)
+{
+    // if status changed:
+    if(OutdoorPvPObjective::Update(diff))
+    {
+        if(m_OldState != m_State)
+        {
+            uint32 field = 0;
+            switch(m_OldState)
+            {
+            case OBJECTIVESTATE_NEUTRAL:
+                field = HP_MAP_N[m_TowerType];
+                break;
+            case OBJECTIVESTATE_ALLIANCE:
+                field = HP_MAP_A[m_TowerType];
+                if(((OutdoorPvPHP*)m_PvP)->m_AllianceTowersControlled)
+                    ((OutdoorPvPHP*)m_PvP)->m_AllianceTowersControlled--;
+                sWorld.SendZoneText(OutdoorPvPHPBuffZones[0],objmgr.GetMangosString(HP_LANG_LOOSE_A[m_TowerType],-1));
+                break;
+            case OBJECTIVESTATE_HORDE:
+                field = HP_MAP_H[m_TowerType];
+                if(((OutdoorPvPHP*)m_PvP)->m_HordeTowersControlled)
+                    ((OutdoorPvPHP*)m_PvP)->m_HordeTowersControlled--;
+                sWorld.SendZoneText(OutdoorPvPHPBuffZones[0],objmgr.GetMangosString(HP_LANG_LOOSE_H[m_TowerType],-1));
+                break;
+            case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+                field = HP_MAP_N[m_TowerType];
+                break;
+            case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+                field = HP_MAP_N[m_TowerType];
+                break;
+            case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+                field = HP_MAP_A[m_TowerType];
+                break;
+            case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+                field = HP_MAP_H[m_TowerType];
+                break;
+            }
+
+            // send world state update
+            if(field)
+            {
+                m_PvP->SendUpdateWorldState(field, 0);
+                field = 0;
+            }
+            uint32 artkit = 21;
+            uint32 artkit2 = HP_TowerArtKit_N[m_TowerType];
+            switch(m_State)
+            {
+            case OBJECTIVESTATE_NEUTRAL:
+                field = HP_MAP_N[m_TowerType];
+                break;
+            case OBJECTIVESTATE_ALLIANCE:
+                field = HP_MAP_A[m_TowerType];
+                artkit = 2;
+                artkit2 = HP_TowerArtKit_A[m_TowerType];
+                if(((OutdoorPvPHP*)m_PvP)->m_AllianceTowersControlled<3)
+                    ((OutdoorPvPHP*)m_PvP)->m_AllianceTowersControlled++;
+                sWorld.SendZoneText(OutdoorPvPHPBuffZones[0],objmgr.GetMangosString(HP_LANG_CAPTURE_A[m_TowerType],-1));
+                break;
+            case OBJECTIVESTATE_HORDE:
+                field = HP_MAP_H[m_TowerType];
+                artkit = 1;
+                artkit2 = HP_TowerArtKit_H[m_TowerType];
+                if(((OutdoorPvPHP*)m_PvP)->m_HordeTowersControlled<3)
+                    ((OutdoorPvPHP*)m_PvP)->m_HordeTowersControlled++;
+                sWorld.SendZoneText(OutdoorPvPHPBuffZones[0],objmgr.GetMangosString(HP_LANG_CAPTURE_H[m_TowerType],-1));
+                break;
+            case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+                field = HP_MAP_N[m_TowerType];
+                break;
+            case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+                field = HP_MAP_N[m_TowerType];
+                break;
+            case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+                field = HP_MAP_A[m_TowerType];
+                artkit = 2;
+                artkit2 = HP_TowerArtKit_A[m_TowerType];
+                break;
+            case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+                field = HP_MAP_H[m_TowerType];
+                artkit = 1;
+                artkit2 = HP_TowerArtKit_H[m_TowerType];
+                break;
+            }
+
+            GameObject* flag = HashMapHolder<GameObject>::Find(m_CapturePoint);
+            GameObject* flag2 = HashMapHolder<GameObject>::Find(m_Objects[m_TowerType]);
+            if(flag)
+            {
+                flag->SetGoArtKit(artkit);
+                flag->SendUpdateObjectToAllExcept(NULL);
+            }
+            if(flag2)
+            {
+                flag2->SetGoArtKit(artkit2);
+                flag2->SendUpdateObjectToAllExcept(NULL);
+            }
+
+            // send world state update
+            if(field)
+                m_PvP->SendUpdateWorldState(field, 1);
+
+            // complete quest objective
+            if(m_State == OBJECTIVESTATE_ALLIANCE || m_State == OBJECTIVESTATE_HORDE)
+                SendObjectiveComplete(HP_CREDITMARKER[m_TowerType], 0);
+        }
+
+        if(m_ShiftPhase != m_OldPhase)
+        {
+            SendUpdateWorldState(HP_UI_TOWER_SLIDER_N, m_NeutralValue);
+            // send these updates to only the ones in this objective
+            uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+            SendUpdateWorldState(HP_UI_TOWER_SLIDER_POS, phase);
+            // send this too, sometimes the slider disappears, dunno why :(
+            SendUpdateWorldState(HP_UI_TOWER_SLIDER_DISPLAY, 1);
+        }
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveHP::FillInitialWorldStates(WorldPacket &data)
+{
+    switch(m_State)
+    {
+        case OBJECTIVESTATE_ALLIANCE:
+        case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+            data << uint32(HP_MAP_N[m_TowerType]) << uint32(0);
+            data << uint32(HP_MAP_A[m_TowerType]) << uint32(1);
+            data << uint32(HP_MAP_H[m_TowerType]) << uint32(0);
+            break;
+        case OBJECTIVESTATE_HORDE:
+        case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+            data << uint32(HP_MAP_N[m_TowerType]) << uint32(0);
+            data << uint32(HP_MAP_A[m_TowerType]) << uint32(0);
+            data << uint32(HP_MAP_H[m_TowerType]) << uint32(1);
+            break;
+        case OBJECTIVESTATE_NEUTRAL:
+        case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+        case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+        default:
+            data << uint32(HP_MAP_N[m_TowerType]) << uint32(1);
+            data << uint32(HP_MAP_A[m_TowerType]) << uint32(0);
+            data << uint32(HP_MAP_H[m_TowerType]) << uint32(0);
+            break;
+    }
+}
+
+bool OutdoorPvPObjectiveHP::HandlePlayerEnter(Player *plr)
+{
+    if(OutdoorPvPObjective::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(HP_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+        plr->SendUpdateWorldState(HP_UI_TOWER_SLIDER_POS, phase);
+        plr->SendUpdateWorldState(HP_UI_TOWER_SLIDER_N, m_NeutralValue);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveHP::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(HP_UI_TOWER_SLIDER_DISPLAY, 0);
+    OutdoorPvPObjective::HandlePlayerLeave(plr);
+}
+
+void OutdoorPvPHP::BuffTeam(uint32 team)
+{
+    if(team == ALLIANCE)
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->CastSpell(plr,AllianceBuff,true);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(HordeBuff);
+        }
+    }
+    else if(team == HORDE)
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->CastSpell(plr,HordeBuff,true);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(AllianceBuff);
+        }
+    }
+    else
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(AllianceBuff);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(HordeBuff);
+        }
+    }
+}
+
+void OutdoorPvPHP::HandleKillImpl(Player *plr, Unit * killed)
+{
+    if(killed->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    if(plr->GetTeam() == ALLIANCE && ((Player*)killed)->GetTeam() != ALLIANCE)
+        plr->CastSpell(plr,AlliancePlayerKillReward,true);
+    else if(plr->GetTeam() == HORDE && ((Player*)killed)->GetTeam() != HORDE)
+        plr->CastSpell(plr,HordePlayerKillReward,true);
+}
+
+bool OutdoorPvPObjectiveHP::HandleCapturePointEvent(Player *plr, uint32 eventId)
+{
+    if(eventId == HP_CapturePointEvent_Enter[m_TowerType])
+    {
+        this->HandlePlayerEnter(plr);
+        return true;
+    }
+    else if(eventId == HP_CapturePointEvent_Leave[m_TowerType])
+    {
+        this->HandlePlayerLeave(plr);
+        return true;
+    }
+    return false;
+}
diff --git a/src/game/OutdoorPvPHP.h b/src/game/OutdoorPvPHP.h
new file mode 100644
index 0000000..33a5bbf
--- /dev/null
+++ b/src/game/OutdoorPvPHP.h
@@ -0,0 +1,100 @@
+#ifndef OUTDOOR_PVP_HP_
+#define OUTDOOR_PVP_HP_
+
+#include "OutdoorPvP.h"
+
+#define OutdoorPvPHPBuffZonesNum 6
+                                                         //  HP, citadel, ramparts, blood furnace, shattered halls, mag's lair
+const uint32 OutdoorPvPHPBuffZones[OutdoorPvPHPBuffZonesNum] = { 3483, 3563, 3562, 3713, 3714, 3836 };
+
+const uint32 AllianceBuff = 32071;
+
+const uint32 HordeBuff = 32049;
+
+const uint32 AlliancePlayerKillReward = 32155;
+
+const uint32 HordePlayerKillReward = 32158;
+
+enum OutdoorPvPHPTowerType{
+    HP_TOWER_BROKEN_HILL = 0,
+    HP_TOWER_OVERLOOK = 1,
+    HP_TOWER_STADIUM = 2,
+    HP_TOWER_NUM = 3
+};
+
+const uint32 HP_CREDITMARKER[HP_TOWER_NUM] = {19032,19028,19029};
+
+const uint32 HP_CapturePointEvent_Enter[HP_TOWER_NUM] = {11404,11396,11388};
+
+const uint32 HP_CapturePointEvent_Leave[HP_TOWER_NUM] = {11403,11395,11387};
+
+enum OutdoorPvPHPWorldStates{
+    HP_UI_TOWER_DISPLAY_A = 0x9ba,
+    HP_UI_TOWER_DISPLAY_H = 0x9b9,
+
+    HP_UI_TOWER_COUNT_H = 0x9ae,
+    HP_UI_TOWER_COUNT_A = 0x9ac,
+
+    HP_UI_TOWER_SLIDER_N = 2475,
+    HP_UI_TOWER_SLIDER_POS = 2474,
+    HP_UI_TOWER_SLIDER_DISPLAY = 2473
+};
+
+const uint32 HP_MAP_N[HP_TOWER_NUM] = {0x9b5,0x9b2,0x9a8};
+
+const uint32 HP_MAP_A[HP_TOWER_NUM] = {0x9b3,0x9b0,0x9a7};
+
+const uint32 HP_MAP_H[HP_TOWER_NUM] = {0x9b4,0x9b1,0x9a6};
+
+const uint32 HP_TowerArtKit_A[HP_TOWER_NUM] = {65,62,67};
+
+const uint32 HP_TowerArtKit_H[HP_TOWER_NUM] = {64,61,68};
+
+const uint32 HP_TowerArtKit_N[HP_TOWER_NUM] = {66,63,69};
+
+const go_type HPCapturePoints[HP_TOWER_NUM] = {
+    {182175,530,-471.462,3451.09,34.6432,0.174533,0,0,0.087156,0.996195},      // 0 - Broken Hill
+    {182174,530,-184.889,3476.93,38.205,-0.017453,0,0,0.008727,-0.999962},     // 1 - Overlook
+    {182173,530,-290.016,3702.42,56.6729,0.034907,0,0,0.017452,0.999848}     // 2 - Stadium
+};
+
+const go_type HPTowerFlags[HP_TOWER_NUM] = {
+    {183514,530,-467.078,3528.17,64.7121,3.14159,0,0,1,0},  // 0 broken hill
+    {182525,530,-187.887,3459.38,60.0403,-3.12414,0,0,0.999962,-0.008727}, // 1 overlook
+    {183515,530,-289.610,3696.83,75.9447,3.12414,0,0,0.999962,0.008727} // 2 stadium
+};
+
+class OutdoorPvPObjectiveHP : public OutdoorPvPObjective
+{
+public:
+    OutdoorPvPObjectiveHP(OutdoorPvP * pvp, OutdoorPvPHPTowerType type);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+    bool HandleCapturePointEvent(Player * plr, uint32 eventId);
+private:
+    OutdoorPvPHPTowerType m_TowerType;
+};
+
+class OutdoorPvPHP : public OutdoorPvP
+{
+friend class OutdoorPvPObjectiveHP;
+public:
+    OutdoorPvPHP();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket &data);
+    void SendRemoveWorldStates(Player * plr);
+    void HandleKillImpl(Player * plr, Unit * killed);
+    void BuffTeam(uint32 team);
+private:
+    // how many towers are controlled
+    uint32 m_AllianceTowersControlled;
+    uint32 m_HordeTowersControlled;
+};
+
+#endif
diff --git a/src/game/OutdoorPvPMgr.cpp b/src/game/OutdoorPvPMgr.cpp
new file mode 100644
index 0000000..3121b60
--- /dev/null
+++ b/src/game/OutdoorPvPMgr.cpp
@@ -0,0 +1,219 @@
+#include "OutdoorPvPMgr.h"
+#include "OutdoorPvPHP.h"
+#include "OutdoorPvPNA.h"
+#include "OutdoorPvPTF.h"
+#include "OutdoorPvPZM.h"
+#include "OutdoorPvPSI.h"
+#include "OutdoorPvPEP.h"
+#include "Player.h"
+#include "Policies/SingletonImp.h"
+
+INSTANTIATE_SINGLETON_1( OutdoorPvPMgr );
+
+OutdoorPvPMgr::OutdoorPvPMgr()
+{
+    sLog.outDebug("Instantiating OutdoorPvPMgr");
+}
+
+OutdoorPvPMgr::~OutdoorPvPMgr()
+{
+    sLog.outDebug("Deleting OutdoorPvPMgr");
+    for(OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        (*itr)->DeleteSpawns();
+    }
+}
+
+void OutdoorPvPMgr::InitOutdoorPvP()
+{
+    // create new opvp
+    OutdoorPvP * pOP = new OutdoorPvPHP;
+    // respawn, init variables
+    if(!pOP->SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : HP init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.insert(pOP);
+        sLog.outDebug("OutdoorPvP : HP successfully initiated.");
+    }
+
+
+    pOP = new OutdoorPvPNA;
+    // respawn, init variables
+    if(!pOP->SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : NA init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.insert(pOP);
+        sLog.outDebug("OutdoorPvP : NA successfully initiated.");
+    }
+
+
+    pOP = new OutdoorPvPTF;
+    // respawn, init variables
+    if(!pOP->SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : TF init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.insert(pOP);
+        sLog.outDebug("OutdoorPvP : TF successfully initiated.");
+    }
+
+    pOP = new OutdoorPvPZM;
+    // respawn, init variables
+    if(!pOP->SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : ZM init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.insert(pOP);
+        sLog.outDebug("OutdoorPvP : ZM successfully initiated.");
+    }
+
+    pOP = new OutdoorPvPSI;
+    // respawn, init variables
+    if(!pOP->SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : SI init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.insert(pOP);
+        sLog.outDebug("OutdoorPvP : SI successfully initiated.");
+    }
+
+    pOP = new OutdoorPvPEP;
+    // respawn, init variables
+    if(!pOP->SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : EP init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.insert(pOP);
+        sLog.outDebug("OutdoorPvP : EP successfully initiated.");
+    }
+}
+
+void OutdoorPvPMgr::AddZone(uint32 zoneid, OutdoorPvP *handle)
+{
+    m_OutdoorPvPMap[zoneid] = handle;
+}
+
+
+void OutdoorPvPMgr::HandlePlayerEnterZone(Player *plr, uint32 zoneid)
+{
+    OutdoorPvPMap::iterator itr = m_OutdoorPvPMap.find(zoneid);
+    if(itr == m_OutdoorPvPMap.end())
+    {
+        // no handle for this zone, return
+        return;
+    }
+    // add possibly beneficial buffs to plr for zone
+    itr->second->HandlePlayerEnterZone(plr, zoneid);
+    plr->SendInitWorldStates();
+    sLog.outDebug("Player %u entered outdoorpvp id %u",plr->GetGUIDLow(), itr->second->GetTypeId());
+}
+
+void OutdoorPvPMgr::HandlePlayerLeaveZone(Player *plr, uint32 zoneid)
+{
+    OutdoorPvPMap::iterator itr = m_OutdoorPvPMap.find(zoneid);
+    if(itr == m_OutdoorPvPMap.end())
+    {
+        // no handle for this zone, return
+        return;
+    }
+    // inform the OutdoorPvP class of the leaving, it should remove the player from all objectives
+    itr->second->HandlePlayerLeaveZone(plr, zoneid);
+    sLog.outDebug("Player %u left outdoorpvp id %u",plr->GetGUIDLow(), itr->second->GetTypeId());
+}
+
+OutdoorPvP * OutdoorPvPMgr::GetOutdoorPvPToZoneId(uint32 zoneid)
+{
+    OutdoorPvPMap::iterator itr = m_OutdoorPvPMap.find(zoneid);
+    if(itr == m_OutdoorPvPMap.end())
+    {
+        // no handle for this zone, return
+        return NULL;
+    }
+    return itr->second;
+}
+
+void OutdoorPvPMgr::Update(uint32 diff)
+{
+    for(OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        (*itr)->Update(diff);
+    }
+}
+
+bool OutdoorPvPMgr::HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go)
+{
+    for(OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)->HandleCustomSpell(plr,spellId,go))
+            return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPMgr::HandleOpenGo(Player *plr, uint64 guid)
+{
+    for(OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)->HandleOpenGo(plr,guid))
+            return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPMgr::HandleCaptureCreaturePlayerMoveInLos(Player * plr, Creature * c)
+{
+    for(OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)->HandleCaptureCreaturePlayerMoveInLos(plr,c))
+            return true;
+    }
+    return false;
+}
+
+void OutdoorPvPMgr::HandleGossipOption(Player *plr, uint64 guid, uint32 gossipid)
+{
+    for(OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)->HandleGossipOption(plr,guid,gossipid))
+            return;
+    }
+}
+
+bool OutdoorPvPMgr::CanTalkTo(Player * plr, Creature * c, GossipOption & gso)
+{
+    for(OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)->CanTalkTo(plr,c,gso))
+            return true;
+    }
+    return false;
+}
+
+void OutdoorPvPMgr::HandleDropFlag(Player *plr, uint32 spellId)
+{
+    for(OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)->HandleDropFlag(plr,spellId))
+            return;
+    }
+}
diff --git a/src/game/OutdoorPvPMgr.h b/src/game/OutdoorPvPMgr.h
new file mode 100644
index 0000000..2fbefa9
--- /dev/null
+++ b/src/game/OutdoorPvPMgr.h
@@ -0,0 +1,59 @@
+#ifndef OUTDOOR_PVP_MGR_H_
+#define OUTDOOR_PVP_MGR_H_
+
+#include "OutdoorPvP.h"
+#include "Policies/Singleton.h"
+
+class Player;
+class GameObject;
+class Creature;
+struct GossipOption;
+
+// class to handle player enter / leave / areatrigger / GO use events
+class OutdoorPvPMgr
+{
+public:
+    // ctor
+    OutdoorPvPMgr();
+    // dtor
+    ~OutdoorPvPMgr();
+
+    // create outdoor pvp events
+    void InitOutdoorPvP();
+    // called when a player enters an outdoor pvp area
+    void HandlePlayerEnterZone(Player * plr, uint32 areaflag);
+    // called when player leaves an outdoor pvp area
+    void HandlePlayerLeaveZone(Player * plr, uint32 areaflag);
+    // return assigned outdoor pvp
+    OutdoorPvP * GetOutdoorPvPToZoneId(uint32 zoneid);
+    // handle custom (non-exist in dbc) spell if registered
+    bool HandleCustomSpell(Player * plr, uint32 spellId, GameObject* go);
+    // handle custom go if registered
+    bool HandleOpenGo(Player * plr, uint64 guid);
+
+    void AddZone(uint32 zoneid, OutdoorPvP * handle);
+
+    void Update(uint32 diff);
+
+    bool HandleCaptureCreaturePlayerMoveInLos(Player * plr, Creature * c);
+
+    void HandleGossipOption(Player * player, uint64 guid, uint32 gossipid);
+
+    bool CanTalkTo(Player * player, Creature * creature, GossipOption & gso);
+
+    void HandleDropFlag(Player * plr, uint32 spellId);
+
+    typedef std::set<OutdoorPvP*> OutdoorPvPSet;
+    typedef std::map<uint32 /* zoneid */, OutdoorPvP*> OutdoorPvPMap;
+private:
+    // contains all initiated outdoor pvp events
+    // used when initing / cleaning up
+    OutdoorPvPSet  m_OutdoorPvPSet;
+    // maps the zone ids to an outdoor pvp event
+    // used in player event handling
+    OutdoorPvPMap   m_OutdoorPvPMap;
+};
+
+#define sOutdoorPvPMgr MaNGOS::Singleton<OutdoorPvPMgr>::Instance()
+
+#endif /*OUTDOOR_PVP_MGR_H_*/
diff --git a/src/game/OutdoorPvPNA.cpp b/src/game/OutdoorPvPNA.cpp
new file mode 100644
index 0000000..d9621f5
--- /dev/null
+++ b/src/game/OutdoorPvPNA.cpp
@@ -0,0 +1,706 @@
+#include "OutdoorPvPNA.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "OutdoorPvPMgr.h"
+#include "WorldPacket.h"
+#include "Language.h"
+#include "World.h"
+
+OutdoorPvPNA::OutdoorPvPNA()
+{
+    m_TypeId = OUTDOOR_PVP_NA;
+}
+
+void OutdoorPvPNA::HandleKillImpl(Player *plr, Unit * killed)
+{
+    if(killed->GetTypeId() == TYPEID_PLAYER && plr->GetTeam() != ((Player*)killed)->GetTeam())
+    {
+        plr->KilledMonster(NA_CREDIT_MARKER,0); // 0 guid, btw it isn't even used in killedmonster function :S
+        if(plr->GetTeam() == ALLIANCE)
+            plr->CastSpell(plr,NA_KILL_TOKEN_ALLIANCE,true);
+        else
+            plr->CastSpell(plr,NA_KILL_TOKEN_HORDE,true);
+    }
+}
+
+uint32 OutdoorPvPObjectiveNA::GetAliveGuardsCount()
+{
+    uint32 cnt = 0;
+    for(std::map<uint32, uint64>::iterator itr = m_Creatures.begin(); itr != m_Creatures.end(); ++itr)
+    {
+        switch(itr->first)
+        {
+        case NA_NPC_GUARD_01:
+        case NA_NPC_GUARD_02:
+        case NA_NPC_GUARD_03:
+        case NA_NPC_GUARD_04:
+        case NA_NPC_GUARD_05:
+        case NA_NPC_GUARD_06:
+        case NA_NPC_GUARD_07:
+        case NA_NPC_GUARD_08:
+        case NA_NPC_GUARD_09:
+        case NA_NPC_GUARD_10:
+        case NA_NPC_GUARD_11:
+        case NA_NPC_GUARD_12:
+        case NA_NPC_GUARD_13:
+        case NA_NPC_GUARD_14:
+        case NA_NPC_GUARD_15:
+            {
+                if(Creature * cr = HashMapHolder<Creature>::Find(itr->second))
+                {
+                    if(cr->isAlive())
+                        ++cnt;
+                }
+                else if (CreatureData const * cd = objmgr.GetCreatureData(GUID_LOPART(itr->second)))
+                {
+                    if(!cd->is_dead)
+                        ++cnt;
+                }
+            }
+            break;
+        default:
+            break;
+        }
+    }
+    return cnt;
+}
+
+void OutdoorPvPNA::BuffTeam(uint32 team)
+{
+    if(team == ALLIANCE)
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->CastSpell(plr,NA_CAPTURE_BUFF,true);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(NA_CAPTURE_BUFF);
+        }
+    }
+    else if(team == HORDE)
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->CastSpell(plr,NA_CAPTURE_BUFF,true);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(NA_CAPTURE_BUFF);
+        }
+    }
+    else
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(NA_CAPTURE_BUFF);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(NA_CAPTURE_BUFF);
+        }
+    }
+}
+
+void OutdoorPvPObjectiveNA::SpawnNPCsForTeam(uint32 team)
+{
+    const creature_type * creatures = NULL;
+    if(team == ALLIANCE)
+        creatures=AllianceControlNPCs;
+    else if(team == HORDE)
+        creatures=HordeControlNPCs;
+    else
+        return;
+    for(int i = 0; i < NA_CONTROL_NPC_NUM; ++i)
+        AddCreature(i,creatures[i].entry,creatures[i].teamval,creatures[i].map,creatures[i].x,creatures[i].y,creatures[i].z,creatures[i].o,1000000);
+}
+
+void OutdoorPvPObjectiveNA::DeSpawnNPCs()
+{
+    for(int i = 0; i < NA_CONTROL_NPC_NUM; ++i)
+        DelCreature(i);
+}
+
+void OutdoorPvPObjectiveNA::SpawnGOsForTeam(uint32 team)
+{
+    const go_type * gos = NULL;
+    if(team == ALLIANCE)
+        gos=AllianceControlGOs;
+    else if(team == HORDE)
+        gos=HordeControlGOs;
+    else
+        return;
+    for(int i = 0; i < NA_CONTROL_GO_NUM; ++i)
+    {
+        if( i == NA_ROOST_S ||
+            i == NA_ROOST_W ||
+            i == NA_ROOST_N ||
+            i == NA_ROOST_E ||
+            i == NA_BOMB_WAGON_S || 
+            i == NA_BOMB_WAGON_W || 
+            i == NA_BOMB_WAGON_N || 
+            i == NA_BOMB_WAGON_E )
+            continue;   // roosts and bomb wagons are spawned when someone uses the matching destroyed roost
+        AddObject(i,gos[i].entry,gos[i].map,gos[i].x,gos[i].y,gos[i].z,gos[i].o,gos[i].rot0,gos[i].rot1,gos[i].rot2,gos[i].rot3);
+    }
+}
+
+void OutdoorPvPObjectiveNA::DeSpawnGOs()
+{
+    for(int i = 0; i < NA_CONTROL_GO_NUM; ++i)
+    {
+        DelObject(i);
+    }
+}
+
+void OutdoorPvPObjectiveNA::FactionTakeOver(uint32 team)
+{
+    if(m_ControllingFaction)
+        objmgr.RemoveGraveYardLink(NA_HALAA_GRAVEYARD,NA_HALAA_GRAVEYARD_ZONE,m_ControllingFaction,false);
+    if(m_ControllingFaction == ALLIANCE)
+        sWorld.SendZoneText(NA_HALAA_GRAVEYARD_ZONE,objmgr.GetMangosString(LANG_OPVP_NA_LOOSE_A,-1));
+    else if(m_ControllingFaction == HORDE)
+        sWorld.SendZoneText(NA_HALAA_GRAVEYARD_ZONE,objmgr.GetMangosString(LANG_OPVP_NA_LOOSE_H,-1));
+
+    m_ControllingFaction = team;
+    if(m_ControllingFaction)
+        objmgr.AddGraveYardLink(NA_HALAA_GRAVEYARD,NA_HALAA_GRAVEYARD_ZONE,m_ControllingFaction,false);
+    DeSpawnGOs();
+    DeSpawnNPCs();
+    SpawnGOsForTeam(team);
+    SpawnNPCsForTeam(team);
+    m_GuardsAlive = NA_GUARDS_MAX;
+    m_capturable = false;
+    this->UpdateHalaaWorldState();
+    if(team == ALLIANCE)
+    {
+        m_WyvernStateSouth = WYVERN_NEU_HORDE;
+        m_WyvernStateNorth = WYVERN_NEU_HORDE;
+        m_WyvernStateEast = WYVERN_NEU_HORDE;
+        m_WyvernStateWest = WYVERN_NEU_HORDE;
+        m_PvP->SendUpdateWorldState(NA_UI_HORDE_GUARDS_SHOW, 0);
+        m_PvP->SendUpdateWorldState(NA_UI_ALLIANCE_GUARDS_SHOW, 1);
+        m_PvP->SendUpdateWorldState(NA_UI_GUARDS_LEFT, m_GuardsAlive);
+        sWorld.SendZoneText(NA_HALAA_GRAVEYARD_ZONE,objmgr.GetMangosString(LANG_OPVP_NA_CAPTURE_A,-1));
+    }
+    else
+    {
+        m_WyvernStateSouth = WYVERN_NEU_ALLIANCE;
+        m_WyvernStateNorth = WYVERN_NEU_ALLIANCE;
+        m_WyvernStateEast = WYVERN_NEU_ALLIANCE;
+        m_WyvernStateWest = WYVERN_NEU_ALLIANCE;
+        m_PvP->SendUpdateWorldState(NA_UI_HORDE_GUARDS_SHOW, 1);
+        m_PvP->SendUpdateWorldState(NA_UI_ALLIANCE_GUARDS_SHOW, 0);
+        m_PvP->SendUpdateWorldState(NA_UI_GUARDS_LEFT, m_GuardsAlive);
+        sWorld.SendZoneText(NA_HALAA_GRAVEYARD_ZONE,objmgr.GetMangosString(LANG_OPVP_NA_CAPTURE_H,-1));
+    }
+    this->UpdateWyvernRoostWorldState(NA_ROOST_S);
+    this->UpdateWyvernRoostWorldState(NA_ROOST_N);
+    this->UpdateWyvernRoostWorldState(NA_ROOST_W);
+    this->UpdateWyvernRoostWorldState(NA_ROOST_E);
+    ((OutdoorPvPNA*)m_PvP)->BuffTeam(team);
+}
+
+bool OutdoorPvPObjectiveNA::HandlePlayerEnter(Player *plr)
+{
+    if(OutdoorPvPObjective::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(NA_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+        plr->SendUpdateWorldState(NA_UI_TOWER_SLIDER_POS, phase);
+        plr->SendUpdateWorldState(NA_UI_TOWER_SLIDER_N, m_NeutralValue);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveNA::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(NA_UI_TOWER_SLIDER_DISPLAY, 0);
+    OutdoorPvPObjective::HandlePlayerLeave(plr);
+}
+
+OutdoorPvPObjectiveNA::OutdoorPvPObjectiveNA(OutdoorPvP *pvp) : 
+OutdoorPvPObjective(pvp), m_capturable(true), m_GuardsAlive(0), m_ControllingFaction(0),
+m_HalaaState(HALAA_N), m_WyvernStateSouth(0), m_WyvernStateNorth(0), m_WyvernStateWest(0),
+m_WyvernStateEast(0), m_RespawnTimer(NA_RESPAWN_TIME), m_GuardCheckTimer(NA_GUARD_CHECK_TIME)
+{
+    AddCapturePoint(182210,530,-1572.57,7945.3,-22.475,2.05949,0,0,0.857167,0.515038);
+}
+
+bool OutdoorPvPNA::SetupOutdoorPvP()
+{
+//    m_TypeId = OUTDOOR_PVP_NA; _MUST_ be set in ctor, because of spawns cleanup
+    // add the zones affected by the pvp buff
+    sOutdoorPvPMgr.AddZone(NA_BUFF_ZONE,this);
+
+    // halaa
+    m_obj = new OutdoorPvPObjectiveNA(this);
+    if(!m_obj)
+        return false;
+    m_OutdoorPvPObjectives.insert(m_obj);
+
+    return true;
+}
+
+void OutdoorPvPNA::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    // add buffs
+    if(plr->GetTeam() == m_obj->m_ControllingFaction)
+        plr->CastSpell(plr,NA_CAPTURE_BUFF,true);
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPNA::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    plr->RemoveAurasDueToSpell(NA_CAPTURE_BUFF);
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+void OutdoorPvPNA::FillInitialWorldStates(WorldPacket &data)
+{
+    m_obj->FillInitialWorldStates(data);
+}
+
+void OutdoorPvPObjectiveNA::FillInitialWorldStates(WorldPacket &data)
+{
+    if(m_ControllingFaction == ALLIANCE)
+    {
+        data << NA_UI_HORDE_GUARDS_SHOW << uint32(0);
+        data << NA_UI_ALLIANCE_GUARDS_SHOW << uint32(1);
+    }
+    else if(m_ControllingFaction == HORDE)
+    {
+        data << NA_UI_HORDE_GUARDS_SHOW << uint32(1);
+        data << NA_UI_ALLIANCE_GUARDS_SHOW << uint32(0);
+    }
+    else
+    {
+        data << NA_UI_HORDE_GUARDS_SHOW << uint32(0);
+        data << NA_UI_ALLIANCE_GUARDS_SHOW << uint32(0);
+    }
+
+    data << NA_UI_GUARDS_MAX << NA_GUARDS_MAX;
+    data << NA_UI_GUARDS_LEFT << uint32(m_GuardsAlive);
+
+    data << NA_UI_TOWER_SLIDER_DISPLAY << uint32(0);
+    data << NA_UI_TOWER_SLIDER_POS << uint32(50);
+    data << NA_UI_TOWER_SLIDER_N << uint32(100);
+
+    data << NA_MAP_WYVERN_NORTH_NEU_H << uint32(bool(m_WyvernStateNorth & WYVERN_NEU_HORDE));
+    data << NA_MAP_WYVERN_NORTH_NEU_A << uint32(bool(m_WyvernStateNorth & WYVERN_NEU_ALLIANCE));
+    data << NA_MAP_WYVERN_NORTH_H << uint32(bool(m_WyvernStateNorth & WYVERN_HORDE));
+    data << NA_MAP_WYVERN_NORTH_A << uint32(bool(m_WyvernStateNorth & WYVERN_ALLIANCE));
+
+    data << NA_MAP_WYVERN_SOUTH_NEU_H << uint32(bool(m_WyvernStateSouth & WYVERN_NEU_HORDE));
+    data << NA_MAP_WYVERN_SOUTH_NEU_A << uint32(bool(m_WyvernStateSouth & WYVERN_NEU_ALLIANCE));
+    data << NA_MAP_WYVERN_SOUTH_H << uint32(bool(m_WyvernStateSouth & WYVERN_HORDE));
+    data << NA_MAP_WYVERN_SOUTH_A << uint32(bool(m_WyvernStateSouth & WYVERN_ALLIANCE));
+
+    data << NA_MAP_WYVERN_WEST_NEU_H << uint32(bool(m_WyvernStateWest & WYVERN_NEU_HORDE));
+    data << NA_MAP_WYVERN_WEST_NEU_A << uint32(bool(m_WyvernStateWest & WYVERN_NEU_ALLIANCE));
+    data << NA_MAP_WYVERN_WEST_H << uint32(bool(m_WyvernStateWest & WYVERN_HORDE));
+    data << NA_MAP_WYVERN_WEST_A << uint32(bool(m_WyvernStateWest & WYVERN_ALLIANCE));
+
+    data << NA_MAP_WYVERN_EAST_NEU_H << uint32(bool(m_WyvernStateEast & WYVERN_NEU_HORDE));
+    data << NA_MAP_WYVERN_EAST_NEU_A << uint32(bool(m_WyvernStateEast & WYVERN_NEU_ALLIANCE));
+    data << NA_MAP_WYVERN_EAST_H << uint32(bool(m_WyvernStateEast & WYVERN_HORDE));
+    data << NA_MAP_WYVERN_EAST_A << uint32(bool(m_WyvernStateEast & WYVERN_ALLIANCE));
+
+    data << NA_MAP_HALAA_NEUTRAL << uint32(bool(m_HalaaState & HALAA_N));
+    data << NA_MAP_HALAA_NEU_A << uint32(bool(m_HalaaState & HALAA_N_A));
+    data << NA_MAP_HALAA_NEU_H << uint32(bool(m_HalaaState & HALAA_N_H));
+    data << NA_MAP_HALAA_HORDE << uint32(bool(m_HalaaState & HALAA_H));
+    data << NA_MAP_HALAA_ALLIANCE << uint32(bool(m_HalaaState & HALAA_A)); 
+}
+
+void OutdoorPvPNA::SendRemoveWorldStates(Player *plr)
+{
+    plr->SendUpdateWorldState(NA_UI_HORDE_GUARDS_SHOW,0);
+    plr->SendUpdateWorldState(NA_UI_ALLIANCE_GUARDS_SHOW,0);
+    plr->SendUpdateWorldState(NA_UI_GUARDS_MAX,0);
+    plr->SendUpdateWorldState(NA_UI_GUARDS_LEFT,0);
+    plr->SendUpdateWorldState(NA_UI_TOWER_SLIDER_DISPLAY,0);
+    plr->SendUpdateWorldState(NA_UI_TOWER_SLIDER_POS,0);
+    plr->SendUpdateWorldState(NA_UI_TOWER_SLIDER_N,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_NEU_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_NEU_A,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_A,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_NEU_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_NEU_A,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_A,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_WEST_NEU_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_WEST_NEU_A,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_WEST_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_WEST_A,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_EAST_NEU_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_EAST_NEU_A,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_EAST_H,0);
+    plr->SendUpdateWorldState(NA_MAP_WYVERN_EAST_A,0);
+    plr->SendUpdateWorldState(NA_MAP_HALAA_NEUTRAL,0);
+    plr->SendUpdateWorldState(NA_MAP_HALAA_NEU_A,0);
+    plr->SendUpdateWorldState(NA_MAP_HALAA_NEU_H,0);
+    plr->SendUpdateWorldState(NA_MAP_HALAA_HORDE,0);
+    plr->SendUpdateWorldState(NA_MAP_HALAA_ALLIANCE,0); 
+}
+
+bool OutdoorPvPNA::Update(uint32 diff)
+{
+    return m_obj->Update(diff);
+}
+
+bool OutdoorPvPObjectiveNA::HandleCustomSpell(Player * plr, uint32 spellId, GameObject * go)
+{
+    std::vector<uint32> nodes;
+    nodes.resize(2);
+    bool retval = false;
+    switch(spellId)
+    {
+    case NA_SPELL_FLY_NORTH:
+        nodes[0] = FlightPathStartNodes[NA_ROOST_N];
+        nodes[1] = FlightPathEndNodes[NA_ROOST_N];
+        plr->ActivateTaxiPathTo(nodes);
+        plr->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);
+        plr->UpdatePvP(true,true);
+        retval = true;
+        break;
+    case NA_SPELL_FLY_SOUTH:
+        nodes[0] = FlightPathStartNodes[NA_ROOST_S];
+        nodes[1] = FlightPathEndNodes[NA_ROOST_S];
+        plr->ActivateTaxiPathTo(nodes);
+        plr->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);
+        plr->UpdatePvP(true,true);
+        retval = true;
+        break;
+    case NA_SPELL_FLY_WEST:
+        nodes[0] = FlightPathStartNodes[NA_ROOST_W];
+        nodes[1] = FlightPathEndNodes[NA_ROOST_W];
+        plr->ActivateTaxiPathTo(nodes);
+        plr->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);
+        plr->UpdatePvP(true,true);
+        retval = true;
+        break;
+    case NA_SPELL_FLY_EAST:
+        nodes[0] = FlightPathStartNodes[NA_ROOST_E];
+        nodes[1] = FlightPathEndNodes[NA_ROOST_E];
+        plr->ActivateTaxiPathTo(nodes);
+        plr->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);
+        plr->UpdatePvP(true,true);
+        retval = true;
+        break;
+    default:
+        break;
+    }
+
+    if(retval)
+    {
+        //Adding items
+        uint32 noSpaceForCount = 0;
+
+        // check space and find places
+        ItemPosCountVec dest;                           
+
+        int32 count = 10;
+        uint32 itemid = 24538;
+                                                                // bomb id count
+        uint8 msg = plr->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, itemid, count, &noSpaceForCount );
+        if( msg != EQUIP_ERR_OK )                               // convert to possible store amount
+            count -= noSpaceForCount;
+
+        if( count == 0 || dest.empty())                         // can't add any
+        {
+            return true;
+        }
+
+        Item* item = plr->StoreNewItem( dest, itemid, true);
+
+        if(count > 0 && item)
+        {
+            plr->SendNewItem(item,count,true,false);
+        }
+
+        return true;
+    }
+    return false;
+}
+
+int32 OutdoorPvPObjectiveNA::HandleOpenGo(Player *plr, uint64 guid)
+{
+    uint32 retval = OutdoorPvPObjective::HandleOpenGo(plr, guid);
+    if(retval>=0)
+    {
+        const go_type * gos = NULL;
+        if(m_ControllingFaction == ALLIANCE)
+            gos=AllianceControlGOs;
+        else if(m_ControllingFaction == HORDE)
+            gos=HordeControlGOs;
+        else
+            return -1;
+
+        int32 del = -1;
+        int32 del2 = -1;
+        int32 add = -1;
+        int32 add2 = -1;
+
+        switch(retval)
+        {
+        case NA_DESTROYED_ROOST_S:
+            del = NA_DESTROYED_ROOST_S;
+            add = NA_ROOST_S;
+            add2 = NA_BOMB_WAGON_S;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateSouth = WYVERN_ALLIANCE;
+            else
+                m_WyvernStateSouth = WYVERN_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_S);
+            break;
+        case NA_DESTROYED_ROOST_N:
+            del = NA_DESTROYED_ROOST_N;
+            add = NA_ROOST_N;
+            add2 = NA_BOMB_WAGON_N;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateNorth = WYVERN_ALLIANCE;
+            else
+                m_WyvernStateNorth = WYVERN_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_N);
+            break;
+        case NA_DESTROYED_ROOST_W:
+            del = NA_DESTROYED_ROOST_W;
+            add = NA_ROOST_W;
+            add2 = NA_BOMB_WAGON_W;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateWest = WYVERN_ALLIANCE;
+            else
+                m_WyvernStateWest = WYVERN_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_W);
+            break;
+        case NA_DESTROYED_ROOST_E:
+            del = NA_DESTROYED_ROOST_E;
+            add = NA_ROOST_E;
+            add2 = NA_BOMB_WAGON_E;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateEast = WYVERN_ALLIANCE;
+            else
+                m_WyvernStateEast = WYVERN_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_E);
+            break;
+        case NA_BOMB_WAGON_S:
+            del = NA_BOMB_WAGON_S;
+            del2 = NA_ROOST_S;
+            add = NA_DESTROYED_ROOST_S;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateSouth = WYVERN_NEU_ALLIANCE;
+            else
+                m_WyvernStateSouth = WYVERN_NEU_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_S);
+            break;
+        case NA_BOMB_WAGON_N:
+            del = NA_BOMB_WAGON_N;
+            del2 = NA_ROOST_N;
+            add = NA_DESTROYED_ROOST_N;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateNorth = WYVERN_NEU_ALLIANCE;
+            else
+                m_WyvernStateNorth = WYVERN_NEU_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_N);
+            break;
+        case NA_BOMB_WAGON_W:
+            del = NA_BOMB_WAGON_W;
+            del2 = NA_ROOST_W;
+            add = NA_DESTROYED_ROOST_W;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateWest = WYVERN_NEU_ALLIANCE;
+            else
+                m_WyvernStateWest = WYVERN_NEU_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_W);
+            break;
+        case NA_BOMB_WAGON_E:
+            del = NA_BOMB_WAGON_E;
+            del2 = NA_ROOST_E;
+            add = NA_DESTROYED_ROOST_E;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateEast = WYVERN_NEU_ALLIANCE;
+            else
+                m_WyvernStateEast = WYVERN_NEU_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_E);
+            break;
+        default:
+            return -1;
+            break;
+        }
+
+        if(del>-1)
+            DelObject(del);
+
+        if(del2>-1)
+            DelObject(del2);
+
+        if(add>-1)
+            AddObject(add,gos[add].entry,gos[add].map,gos[add].x,gos[add].y,gos[add].z,gos[add].o,gos[add].rot0,gos[add].rot1,gos[add].rot2,gos[add].rot3);
+
+        if(add2>-1)
+            AddObject(add2,gos[add2].entry,gos[add2].map,gos[add2].x,gos[add2].y,gos[add2].z,gos[add2].o,gos[add2].rot0,gos[add2].rot1,gos[add2].rot2,gos[add2].rot3);
+
+        return retval;
+    }
+    return -1;
+}
+
+bool OutdoorPvPObjectiveNA::Update(uint32 diff)
+{
+    // let the controlling faction advance in phase
+    bool capturable = false;
+    if(m_ControllingFaction == ALLIANCE && m_AllianceActivePlayerCount > m_HordeActivePlayerCount)
+        capturable = true;
+    else if(m_ControllingFaction == HORDE && m_AllianceActivePlayerCount < m_HordeActivePlayerCount)
+        capturable = true;
+
+    if(m_GuardCheckTimer < diff)
+    {
+        m_GuardCheckTimer = NA_GUARD_CHECK_TIME;
+        uint32 cnt = GetAliveGuardsCount();
+        if(cnt != m_GuardsAlive)
+        {
+            m_GuardsAlive = cnt;
+            if(m_GuardsAlive == 0)
+                m_capturable = true;
+            // update the guard count for the players in zone
+            m_PvP->SendUpdateWorldState(NA_UI_GUARDS_LEFT,m_GuardsAlive);
+        }
+    } else m_GuardCheckTimer -= diff;
+
+    if((m_capturable || capturable) && OutdoorPvPObjective::Update(diff))
+    {
+        if(m_RespawnTimer < diff)
+        {
+            // if the guards have been killed, then the challenger has one hour to take over halaa.
+            // in case they fail to do it, the guards are respawned, and they have to start again.
+            if(m_ControllingFaction)
+                FactionTakeOver(m_ControllingFaction);
+            m_RespawnTimer = NA_RESPAWN_TIME;
+        } else m_RespawnTimer -= diff;
+
+        if(m_OldState != m_State)
+        {
+            uint32 artkit = 21;
+            switch(m_State)
+            {
+            case OBJECTIVESTATE_NEUTRAL:
+                m_HalaaState = HALAA_N;
+                break;
+            case OBJECTIVESTATE_ALLIANCE:
+                m_HalaaState = HALAA_A;
+                FactionTakeOver(ALLIANCE);
+                artkit = 2;
+                break;
+            case OBJECTIVESTATE_HORDE:
+                m_HalaaState = HALAA_H;
+                FactionTakeOver(HORDE);
+                artkit = 1;
+                break;
+            case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+                m_HalaaState = HALAA_N_A;
+                break;
+            case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+                m_HalaaState = HALAA_N_H;
+                break;
+            case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+                m_HalaaState = HALAA_N_A;
+                artkit = 2;
+                break;
+            case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+                m_HalaaState = HALAA_N_H;
+                artkit = 1;
+                break;
+            }
+
+            GameObject* flag = HashMapHolder<GameObject>::Find(m_CapturePoint);
+            if(flag)
+            {
+                flag->SetGoArtKit(artkit);
+                flag->SendUpdateObjectToAllExcept(NULL);
+            }
+
+            UpdateHalaaWorldState();
+        }
+
+        if(m_ShiftPhase != m_OldPhase)
+        {
+            // send this too, sometimes the slider disappears, dunno why :(
+            SendUpdateWorldState(NA_UI_TOWER_SLIDER_DISPLAY, 1);
+            // send these updates to only the ones in this objective
+            uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+            SendUpdateWorldState(NA_UI_TOWER_SLIDER_POS, phase);
+            SendUpdateWorldState(NA_UI_TOWER_SLIDER_N, m_NeutralValue);
+        }
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveNA::UpdateHalaaWorldState()
+{
+    m_PvP->SendUpdateWorldState( NA_MAP_HALAA_NEUTRAL ,uint32(bool(m_HalaaState & HALAA_N)));
+    m_PvP->SendUpdateWorldState( NA_MAP_HALAA_NEU_A ,uint32(bool(m_HalaaState & HALAA_N_A)));
+    m_PvP->SendUpdateWorldState( NA_MAP_HALAA_NEU_H ,uint32(bool(m_HalaaState & HALAA_N_H)));
+    m_PvP->SendUpdateWorldState( NA_MAP_HALAA_HORDE ,uint32(bool(m_HalaaState & HALAA_H)));
+    m_PvP->SendUpdateWorldState( NA_MAP_HALAA_ALLIANCE ,uint32(bool(m_HalaaState & HALAA_A)));
+}
+
+void OutdoorPvPObjectiveNA::UpdateWyvernRoostWorldState(uint32 roost)
+{
+    switch(roost)
+    {
+    case NA_ROOST_S:
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_NEU_H,uint32(bool(m_WyvernStateSouth & WYVERN_NEU_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_NEU_A,uint32(bool(m_WyvernStateSouth & WYVERN_NEU_ALLIANCE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_H,uint32(bool(m_WyvernStateSouth & WYVERN_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_A,uint32(bool(m_WyvernStateSouth & WYVERN_ALLIANCE)));
+        break;
+    case NA_ROOST_N:
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_NEU_H,uint32(bool(m_WyvernStateNorth & WYVERN_NEU_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_NEU_A,uint32(bool(m_WyvernStateNorth & WYVERN_NEU_ALLIANCE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_H,uint32(bool(m_WyvernStateNorth & WYVERN_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_NORTH_A,uint32(bool(m_WyvernStateNorth & WYVERN_ALLIANCE)));
+        break;
+    case NA_ROOST_W:
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_WEST_NEU_H,uint32(bool(m_WyvernStateWest & WYVERN_NEU_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_WEST_NEU_A,uint32(bool(m_WyvernStateWest & WYVERN_NEU_ALLIANCE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_WEST_H,uint32(bool(m_WyvernStateWest & WYVERN_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_WEST_A,uint32(bool(m_WyvernStateWest & WYVERN_ALLIANCE)));
+        break;
+    case NA_ROOST_E:
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_EAST_NEU_H,uint32(bool(m_WyvernStateEast & WYVERN_NEU_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_EAST_NEU_A,uint32(bool(m_WyvernStateEast & WYVERN_NEU_ALLIANCE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_EAST_H,uint32(bool(m_WyvernStateEast & WYVERN_HORDE)));
+        m_PvP->SendUpdateWorldState(NA_MAP_WYVERN_EAST_A,uint32(bool(m_WyvernStateEast & WYVERN_ALLIANCE)));
+        break;
+    }
+}
+
+bool OutdoorPvPObjectiveNA::HandleCapturePointEvent(Player *plr, uint32 eventId)
+{
+    switch(eventId)
+    {
+    case 11821:
+        this->HandlePlayerEnter(plr);
+        return true;
+        break;
+    case 11822:
+        this->HandlePlayerLeave(plr);
+        return true;
+        break;
+    default:
+        break;
+    }
+    return false;
+}
diff --git a/src/game/OutdoorPvPNA.h b/src/game/OutdoorPvPNA.h
new file mode 100644
index 0000000..65a70bb
--- /dev/null
+++ b/src/game/OutdoorPvPNA.h
@@ -0,0 +1,279 @@
+#ifndef OUTDOOR_PVP_NA_
+#define OUTDOOR_PVP_NA_
+
+// TODO: "sometimes" set to neutral
+
+#include "OutdoorPvP.h"
+
+// kill credit for pks
+const uint32 NA_CREDIT_MARKER = 24867;
+
+const uint32 NA_KILL_TOKEN_ALLIANCE = 33005;
+const uint32 NA_KILL_TOKEN_HORDE = 33004;
+
+const uint32 NA_CAPTURE_BUFF = 33795;  // strength of the halaani
+
+const uint32 NA_GUARDS_MAX = 15;
+
+const uint32 NA_BUFF_ZONE = 3518;
+
+const uint32 NA_HALAA_GRAVEYARD = 993;
+
+const uint32 NA_HALAA_GRAVEYARD_ZONE = 3518; // need to add zone id, not area id
+
+const uint32 NA_RESPAWN_TIME = 3600000; // one hour to capture after defeating all guards
+
+const uint32 NA_GUARD_CHECK_TIME = 500; // every half second
+
+enum OutdoorPvPNAWorldStates{
+    NA_UI_HORDE_GUARDS_SHOW = 2503,
+    NA_UI_ALLIANCE_GUARDS_SHOW = 2502,
+    NA_UI_GUARDS_MAX = 2493,
+    NA_UI_GUARDS_LEFT = 2491,
+
+    NA_UI_TOWER_SLIDER_DISPLAY = 2495,
+    NA_UI_TOWER_SLIDER_POS = 2494,
+    NA_UI_TOWER_SLIDER_N = 2497,
+
+    NA_MAP_WYVERN_NORTH_NEU_H = 2762,
+    NA_MAP_WYVERN_NORTH_NEU_A = 2662,
+    NA_MAP_WYVERN_NORTH_H = 2663,
+    NA_MAP_WYVERN_NORTH_A = 2664,
+
+    NA_MAP_WYVERN_SOUTH_NEU_H = 2760,
+    NA_MAP_WYVERN_SOUTH_NEU_A = 2670,
+    NA_MAP_WYVERN_SOUTH_H = 2668,
+    NA_MAP_WYVERN_SOUTH_A = 2669,
+
+    NA_MAP_WYVERN_WEST_NEU_H = 2761,
+    NA_MAP_WYVERN_WEST_NEU_A = 2667,
+    NA_MAP_WYVERN_WEST_H = 2665,
+    NA_MAP_WYVERN_WEST_A = 2666,
+
+    NA_MAP_WYVERN_EAST_NEU_H = 2763,
+    NA_MAP_WYVERN_EAST_NEU_A = 2659,
+    NA_MAP_WYVERN_EAST_H = 2660,
+    NA_MAP_WYVERN_EAST_A = 2661,
+
+    NA_MAP_HALAA_NEUTRAL = 2671,
+    NA_MAP_HALAA_NEU_A = 2676,
+    NA_MAP_HALAA_NEU_H = 2677,
+    NA_MAP_HALAA_HORDE = 2672,
+    NA_MAP_HALAA_ALLIANCE = 2673 
+};
+
+const uint32 FLIGHT_NODES_NUM = 4;
+
+// used to access the elements of Horde/AllyControlGOs
+enum ControlGOTypes{
+    NA_ROOST_S = 0,
+    NA_ROOST_W = 1,
+    NA_ROOST_N = 2,
+    NA_ROOST_E = 3,
+
+    NA_BOMB_WAGON_S = 4,
+    NA_BOMB_WAGON_W = 5,
+    NA_BOMB_WAGON_N = 6,
+    NA_BOMB_WAGON_E = 7,
+
+    NA_DESTROYED_ROOST_S = 8, 
+    NA_DESTROYED_ROOST_W = 9, 
+    NA_DESTROYED_ROOST_N = 10,
+    NA_DESTROYED_ROOST_E = 11,
+
+    NA_CONTROL_GO_NUM = 12
+};
+
+const uint32 FlightPathStartNodes[FLIGHT_NODES_NUM] = {103,105,107,109};
+const uint32 FlightPathEndNodes[FLIGHT_NODES_NUM] = {104,106,108,110};
+
+enum FlightSpellsNA{
+    NA_SPELL_FLY_SOUTH = 32059,
+    NA_SPELL_FLY_WEST = 32068,
+    NA_SPELL_FLY_NORTH = 32075,
+    NA_SPELL_FLY_EAST = 32081
+};
+
+// spawned when the alliance is attacking, horde is in control
+const go_type HordeControlGOs[NA_CONTROL_GO_NUM] = {
+    {182267,530,-1815.8,8036.51,-26.2354,-2.89725,0,0,0.992546,-0.121869}, //ALLY_ROOST_SOUTH
+    {182280,530,-1507.95,8132.1,-19.5585,-1.3439,0,0,0.622515,-0.782608}, //ALLY_ROOST_WEST
+    {182281,530,-1384.52,7779.33,-11.1663,-0.575959,0,0,0.284015,-0.95882}, //ALLY_ROOST_NORTH
+    {182282,530,-1650.11,7732.56,-15.4505,-2.80998,0,0,0.986286,-0.165048}, //ALLY_ROOST_EAST
+
+    {182222,530,-1825.4022,8039.2602,-26.08,-2.89725,0,0,0.992546,-0.121869}, //HORDE_BOMB_WAGON_SOUTH
+    {182272,530,-1515.37,8136.91,-20.42,-1.3439,0,0,0.622515,-0.782608}, //HORDE_BOMB_WAGON_WEST
+    {182273,530,-1377.95,7773.44,-10.31,-0.575959,0,0,0.284015,-0.95882}, //HORDE_BOMB_WAGON_NORTH
+    {182274,530,-1659.87,7733.15,-15.75,-2.80998,0,0,0.986286,-0.165048}, //HORDE_BOMB_WAGON_EAST
+
+    {182266,530,-1815.8,8036.51,-26.2354,-2.89725,0,0,0.992546,-0.121869}, //DESTROYED_ALLY_ROOST_SOUTH
+    {182275,530,-1507.95,8132.1,-19.5585,-1.3439,0,0,0.622515,-0.782608}, //DESTROYED_ALLY_ROOST_WEST
+    {182276,530,-1384.52,7779.33,-11.1663,-0.575959,0,0,0.284015,-0.95882}, //DESTROYED_ALLY_ROOST_NORTH
+    {182277,530,-1650.11,7732.56,-15.4505,-2.80998,0,0,0.986286,-0.165048}  //DESTROYED_ALLY_ROOST_EAST
+};
+
+// spawned when the horde is attacking, alliance is in control
+const go_type AllianceControlGOs[NA_CONTROL_GO_NUM] = {
+    {182301,530,-1815.8,8036.51,-26.2354,-2.89725,0,0,0.992546,-0.121869}, //HORDE_ROOST_SOUTH
+    {182302,530,-1507.95,8132.1,-19.5585,-1.3439,0,0,0.622515,-0.782608}, //HORDE_ROOST_WEST
+    {182303,530,-1384.52,7779.33,-11.1663,-0.575959,0,0,0.284015,-0.95882}, //HORDE_ROOST_NORTH
+    {182304,530,-1650.11,7732.56,-15.4505,-2.80998,0,0,0.986286,-0.165048}, //HORDE_ROOST_EAST
+
+    {182305,530,-1825.4022,8039.2602,-26.08,-2.89725,0,0,0.992546,-0.121869}, //ALLY_BOMB_WAGON_SOUTH
+    {182306,530,-1515.37,8136.91,-20.42,-1.3439,0,0,0.622515,-0.782608}, //ALLY_BOMB_WAGON_WEST
+    {182307,530,-1377.95,7773.44,-10.31,-0.575959,0,0,0.284015,-0.95882}, //ALLY_BOMB_WAGON_NORTH
+    {182308,530,-1659.87,7733.15,-15.75,-2.80998,0,0,0.986286,-0.165048}, //ALLY_BOMB_WAGON_EAST
+
+    {182297,530,-1815.8,8036.51,-26.2354,-2.89725,0,0,0.992546,-0.121869}, //DESTROYED_HORDE_ROOST_SOUTH
+    {182298,530,-1507.95,8132.1,-19.5585,-1.3439,0,0,0.622515,-0.782608}, //DESTROYED_HORDE_ROOST_WEST
+    {182299,530,-1384.52,7779.33,-11.1663,-0.575959,0,0,0.284015,-0.95882}, //DESTROYED_HORDE_ROOST_NORTH
+    {182300,530,-1650.11,7732.56,-15.4505,-2.80998,0,0,0.986286,-0.165048}  //DESTROYED_HORDE_ROOST_EAST
+};
+
+enum ControlNPCTypes{
+    NA_NPC_RESEARCHER = 0,
+    NA_NPC_QUARTERMASTER,
+    NA_NPC_BLADE_MERCHANT,
+    NA_NPC_FOOD_MERCHANT,
+    NA_NPC_AMMO,
+
+    NA_NPC_GUARD_01,
+    NA_NPC_GUARD_02,
+    NA_NPC_GUARD_03,
+    NA_NPC_GUARD_04,
+    NA_NPC_GUARD_05,
+    NA_NPC_GUARD_06,
+    NA_NPC_GUARD_07,
+    NA_NPC_GUARD_08,
+    NA_NPC_GUARD_09,
+    NA_NPC_GUARD_10,
+    NA_NPC_GUARD_11,
+    NA_NPC_GUARD_12,
+    NA_NPC_GUARD_13,
+    NA_NPC_GUARD_14,
+    NA_NPC_GUARD_15,
+
+    NA_CONTROL_NPC_NUM
+};
+
+const creature_type HordeControlNPCs[NA_CONTROL_NPC_NUM] = {
+    {18816,67,530,-1523.92,7951.76,-17.6942,3.51172},
+    {18821,67,530,-1527.75,7952.46,-17.6948,3.99317},
+    {21474,67,530,-1520.14,7927.11,-20.2527,3.39389},
+    {21484,67,530,-1524.84,7930.34,-20.182,3.6405},
+    {21483,67,530,-1570.01,7993.8,-22.4505,5.02655},
+    {18192,67,530,-1654.06,8000.46,-26.59,3.37},
+    {18192,67,530,-1487.18,7899.1,-19.53,0.954},
+    {18192,67,530,-1480.88,7908.79,-19.19,4.485},
+    {18192,67,530,-1540.56,7995.44,-20.45,0.947},
+    {18192,67,530,-1546.95,8000.85,-20.72,6.035},
+    {18192,67,530,-1595.31,7860.53,-21.51,3.747},
+    {18192,67,530,-1642.31,7995.59,-25.8,3.317},
+    {18192,67,530,-1545.46,7995.35,-20.63,1.094},
+    {18192,67,530,-1487.58,7907.99,-19.27,5.567},
+    {18192,67,530,-1651.54,7988.56,-26.5289,2.98451},
+    {18192,67,530,-1602.46,7866.43,-22.1177,4.74729},
+    {18192,67,530,-1591.22,7875.29,-22.3536,4.34587},
+    {18192,67,530,-1550.6,7944.45,-21.63,3.559},
+    {18192,67,530,-1545.57,7935.83,-21.13,3.448},
+    {18192,67,530,-1550.86,7937.56,-21.7,3.801}
+};
+
+const creature_type AllianceControlNPCs[NA_CONTROL_NPC_NUM] = {
+    {18817,469,530,-1591.18,8020.39,-22.2042,4.59022},
+    {18822,469,530,-1588.0,8019.0,-22.2042,4.06662},
+    {21485,469,530,-1521.93,7927.37,-20.2299,3.24631},
+    {21487,469,530,-1540.33,7971.95,-20.7186,3.07178},
+    {21488,469,530,-1570.01,7993.8,-22.4505,5.02655},
+    {18256,469,530,-1654.06,8000.46,-26.59,3.37},
+    {18256,469,530,-1487.18,7899.1,-19.53,0.954},
+    {18256,469,530,-1480.88,7908.79,-19.19,4.485},
+    {18256,469,530,-1540.56,7995.44,-20.45,0.947},
+    {18256,469,530,-1546.95,8000.85,-20.72,6.035},
+    {18256,469,530,-1595.31,7860.53,-21.51,3.747},
+    {18256,469,530,-1642.31,7995.59,-25.8,3.317},
+    {18256,469,530,-1545.46,7995.35,-20.63,1.094},
+    {18256,469,530,-1487.58,7907.99,-19.27,5.567},
+    {18256,469,530,-1651.54,7988.56,-26.5289,2.98451},
+    {18256,469,530,-1602.46,7866.43,-22.1177,4.74729},
+    {18256,469,530,-1591.22,7875.29,-22.3536,4.34587},
+    {18256,469,530,-1603.75,8000.36,-24.18,4.516},
+    {18256,469,530,-1585.73,7994.68,-23.29,4.439},
+    {18256,469,530,-1595.5,7991.27,-23.53,4.738}
+};
+
+enum WyvernStates{
+    WYVERN_NEU_HORDE = 1,
+    WYVERN_NEU_ALLIANCE = 2,
+    WYVERN_HORDE = 4,
+    WYVERN_ALLIANCE = 8
+};
+
+enum HalaaStates{
+    HALAA_N = 1,
+    HALAA_N_A = 2,
+    HALAA_A = 4,
+    HALAA_N_H = 8,
+    HALAA_H = 16
+};
+
+class Unit;
+class Creature;
+class OutdoorPvPNA;
+class OutdoorPvPObjectiveNA : public OutdoorPvPObjective
+{
+friend class OutdoorPvPNA;
+public:
+    OutdoorPvPObjectiveNA(OutdoorPvP * pvp);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+    bool HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go);
+    int32 HandleOpenGo(Player *plr, uint64 guid);
+    uint32 GetAliveGuardsCount();
+protected:
+    // called when a faction takes control
+    void FactionTakeOver(uint32 team);
+
+    void DeSpawnNPCs();
+    void DeSpawnGOs();
+    void SpawnNPCsForTeam(uint32 team);
+    void SpawnGOsForTeam(uint32 team);
+
+    void UpdateWyvernRoostWorldState(uint32 roost);
+    void UpdateHalaaWorldState();
+
+    bool HandleCapturePointEvent(Player * plr, uint32 eventId);
+private:
+    bool m_capturable;
+    uint32 m_GuardsAlive;
+    uint32 m_ControllingFaction;
+    uint32 m_WyvernStateNorth;
+    uint32 m_WyvernStateSouth;
+    uint32 m_WyvernStateEast;
+    uint32 m_WyvernStateWest;
+    uint32 m_HalaaState;
+    uint32 m_RespawnTimer;
+    uint32 m_GuardCheckTimer;
+};
+
+class OutdoorPvPNA : public OutdoorPvP
+{
+friend class OutdoorPvPObjectiveNA;
+public:
+    OutdoorPvPNA();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket &data);
+    void SendRemoveWorldStates(Player * plr);
+    void HandleKillImpl(Player * plr, Unit * killed);
+    void BuffTeam(uint32 team);
+private:
+    OutdoorPvPObjectiveNA * m_obj;
+};
+
+#endif
diff --git a/src/game/OutdoorPvPObjectiveAI.cpp b/src/game/OutdoorPvPObjectiveAI.cpp
new file mode 100644
index 0000000..1e28d42
--- /dev/null
+++ b/src/game/OutdoorPvPObjectiveAI.cpp
@@ -0,0 +1,65 @@
+/* 
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "OutdoorPvPObjectiveAI.h"
+#include "Creature.h"
+#include "Player.h"
+#include "Unit.h"
+#include "OutdoorPvPMgr.h"
+#include "World.h"
+
+#define MAX_OUTDOOR_PVP_DISTANCE 200 // the max value in capture point type go data0 is 100 currently, so use twice that much to handle leaving as well
+
+OutdoorPvPObjectiveAI::OutdoorPvPObjectiveAI(Creature &c) : i_creature(c)
+{
+    sLog.outDebug("OutdoorPvP objective AI assigned to creature guid %u", c.GetGUIDLow());
+}
+
+void OutdoorPvPObjectiveAI::MoveInLineOfSight(Unit *u)
+{
+    // IsVisible only passes for players in range, so no need to check again
+    // leaving/entering distance will be checked based on go range data
+    sOutdoorPvPMgr.HandleCaptureCreaturePlayerMoveInLos(((Player*)u),&i_creature);
+}
+
+int OutdoorPvPObjectiveAI::Permissible(const Creature * c)
+{
+    // this AI can only be assigned if the AIName is OutdoorPvPObjectiveAI. It shouldn't be returned by permissible check.
+    return PERMIT_BASE_NO;
+}
+
+bool OutdoorPvPObjectiveAI::IsVisible(Unit *pl) const
+{
+    return (pl->GetTypeId() == TYPEID_PLAYER) && (i_creature.GetDistance(pl) < MAX_OUTDOOR_PVP_DISTANCE * MAX_OUTDOOR_PVP_DISTANCE);
+}
+
+void OutdoorPvPObjectiveAI::AttackStart(Unit *)
+{
+    EnterEvadeMode();
+}
+
+void OutdoorPvPObjectiveAI::EnterEvadeMode()
+{
+    i_creature.DeleteThreatList();
+    i_creature.CombatStop();
+}
+
+void OutdoorPvPObjectiveAI::UpdateAI(const uint32 diff)
+{
+}
+
diff --git a/src/game/OutdoorPvPObjectiveAI.h b/src/game/OutdoorPvPObjectiveAI.h
new file mode 100644
index 0000000..aa93740
--- /dev/null
+++ b/src/game/OutdoorPvPObjectiveAI.h
@@ -0,0 +1,43 @@
+/* 
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef MANGOS_OUTDOORPVPOBJECTIVEAI_H
+#define MANGOS_OUTDOORPVPOBJECTIVEAI_H
+
+#include "CreatureAI.h"
+
+class Creature;
+
+class MANGOS_DLL_DECL OutdoorPvPObjectiveAI : public CreatureAI
+{
+    public:
+
+        OutdoorPvPObjectiveAI(Creature &c);
+
+        void MoveInLineOfSight(Unit *);
+        bool IsVisible(Unit *) const;
+        void AttackStart(Unit *);
+        void EnterEvadeMode();
+        void UpdateAI(const uint32 diff);
+
+        static int Permissible(const Creature *);
+
+    private:
+        Creature &i_creature;
+};
+#endif
diff --git a/src/game/OutdoorPvPSI.cpp b/src/game/OutdoorPvPSI.cpp
new file mode 100644
index 0000000..7fd726f
--- /dev/null
+++ b/src/game/OutdoorPvPSI.cpp
@@ -0,0 +1,244 @@
+#include "OutdoorPvPSI.h"
+#include "WorldPacket.h"
+#include "Player.h"
+#include "GameObject.h"
+#include "MapManager.h"
+#include "ObjectMgr.h"
+#include "OutdoorPvPMgr.h"
+#include "Language.h"
+#include "World.h"
+
+OutdoorPvPSI::OutdoorPvPSI()
+{
+    m_TypeId = OUTDOOR_PVP_SI;
+    m_Gathered_A = 0;
+    m_Gathered_H = 0;
+    m_LastController = 0;
+}
+
+void OutdoorPvPSI::FillInitialWorldStates(WorldPacket &data)
+{
+    data << SI_GATHERED_A << m_Gathered_A;
+    data << SI_GATHERED_H << m_Gathered_H;
+    data << SI_SILITHYST_MAX << SI_MAX_RESOURCES;
+}
+
+void OutdoorPvPSI::SendRemoveWorldStates(Player *plr)
+{
+    plr->SendUpdateWorldState(SI_GATHERED_A,0);
+    plr->SendUpdateWorldState(SI_GATHERED_H,0);
+    plr->SendUpdateWorldState(SI_SILITHYST_MAX,0);
+}
+
+void OutdoorPvPSI::UpdateWorldState()
+{
+    SendUpdateWorldState(SI_GATHERED_A,m_Gathered_A);
+    SendUpdateWorldState(SI_GATHERED_H,m_Gathered_H);
+    SendUpdateWorldState(SI_SILITHYST_MAX,SI_MAX_RESOURCES);
+}
+
+bool OutdoorPvPSI::SetupOutdoorPvP()
+{
+    for(int i = 0; i < OutdoorPvPSIBuffZonesNum; ++i)
+        sOutdoorPvPMgr.AddZone(OutdoorPvPSIBuffZones[i],this);
+    return true;
+}
+
+bool OutdoorPvPSI::Update(uint32 diff)
+{
+    return false;
+}
+
+void OutdoorPvPSI::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    if(plr->GetTeam() == m_LastController)
+        plr->CastSpell(plr,SI_CENARION_FAVOR,true);
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPSI::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    plr->RemoveAurasDueToSpell(SI_CENARION_FAVOR);
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+void OutdoorPvPSI::BuffTeam(uint32 team)
+{
+    if(team == ALLIANCE)
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->CastSpell(plr,SI_CENARION_FAVOR,true);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(SI_CENARION_FAVOR);
+        }
+    }
+    else if(team == HORDE)
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->CastSpell(plr,SI_CENARION_FAVOR,true);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(SI_CENARION_FAVOR);
+        }
+    }
+    else
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(SI_CENARION_FAVOR);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(SI_CENARION_FAVOR);
+        }
+    }
+}
+
+bool OutdoorPvPSI::HandleAreaTrigger(Player *plr, uint32 trigger)
+{
+    switch(trigger)
+    {
+    case SI_AREATRIGGER_A:
+        if(plr->GetTeam() == ALLIANCE && plr->HasAura(SI_SILITHYST_FLAG,0))
+        {
+            // remove aura
+            plr->RemoveAurasDueToSpell(SI_SILITHYST_FLAG);
+            ++ m_Gathered_A;
+            if(m_Gathered_A >= SI_MAX_RESOURCES)
+            {
+                BuffTeam(ALLIANCE);
+                sWorld.SendZoneText(OutdoorPvPSIBuffZones[0],objmgr.GetMangosString(LANG_OPVP_SI_CAPTURE_A,-1));
+                m_LastController = ALLIANCE;
+                m_Gathered_A = 0;
+                m_Gathered_H = 0;
+            }
+            UpdateWorldState();
+            // reward player
+            plr->CastSpell(plr,SI_TRACES_OF_SILITHYST,true);
+            // add 19 honor
+            plr->RewardHonor(NULL,1,19);
+            // add 20 cenarion circle repu
+            plr->ModifyFactionReputation(609,20);
+            // complete quest
+            plr->KilledMonster(SI_TURNIN_QUEST_CM_A,0);
+        }
+        return true;
+    case SI_AREATRIGGER_H:
+        if(plr->GetTeam() == HORDE && plr->HasAura(SI_SILITHYST_FLAG,0))
+        {
+            // remove aura
+            plr->RemoveAurasDueToSpell(SI_SILITHYST_FLAG);
+            ++ m_Gathered_H;
+            if(m_Gathered_H >= SI_MAX_RESOURCES)
+            {
+                BuffTeam(HORDE);
+                sWorld.SendZoneText(OutdoorPvPSIBuffZones[0],objmgr.GetMangosString(LANG_OPVP_SI_CAPTURE_H,-1));
+                m_LastController = HORDE;
+                m_Gathered_A = 0;
+                m_Gathered_H = 0;
+            }
+            UpdateWorldState();
+            // reward player
+            plr->CastSpell(plr,SI_TRACES_OF_SILITHYST,true);
+            // add 19 honor
+            plr->RewardHonor(NULL,1,19);
+            // add 20 cenarion circle repu
+            plr->ModifyFactionReputation(609,20);
+            // complete quest
+            plr->KilledMonster(SI_TURNIN_QUEST_CM_H,0);
+        }
+        return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPSI::HandleDropFlag(Player *plr, uint32 spellId)
+{
+    if(spellId == SI_SILITHYST_FLAG)
+    {
+        // if it was dropped away from the player's turn-in point, then create a silithyst mound, if it was dropped near the areatrigger, then it was dispelled by the outdoorpvp, so do nothing
+        switch(plr->GetTeam())
+        {
+        case ALLIANCE:
+            {
+                AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(SI_AREATRIGGER_A);
+                if(atEntry)
+                {
+                    // 5.0f is safe-distance
+                    if(plr->GetDistance(atEntry->x,atEntry->y,atEntry->z) > 5.0f + atEntry->radius)
+                    {
+                        // he dropped it further, summon mound
+                        GameObject * go = new GameObject;
+                        Map * map = MapManager::Instance().GetMap(plr->GetMapId(), plr);
+                        if(!map)
+                            return true;
+                        if(!go->Create(objmgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT),SI_SILITHYST_MOUND, map,plr->GetPositionX(),plr->GetPositionY(),plr->GetPositionZ(),plr->GetOrientation(),0,0,0,0,100,1))
+                        {
+                            delete go;                
+                        }
+                        else
+                        {
+                            go->SetRespawnTime(0);
+                            map->Add(go);
+                        }
+                    }
+                }
+            }
+            break;
+        case HORDE:
+            {
+                AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(SI_AREATRIGGER_H);
+                if(atEntry)
+                {
+                    // 5.0f is safe-distance
+                    if(plr->GetDistance(atEntry->x,atEntry->y,atEntry->z) > 5.0f + atEntry->radius)
+                    {
+                        // he dropped it further, summon mound
+                        GameObject * go = new GameObject;
+                        Map * map = MapManager::Instance().GetMap(plr->GetMapId(), plr);
+                        if(!map)
+                            return true;
+                        if(!go->Create(objmgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT),SI_SILITHYST_MOUND, map ,plr->GetPositionX(),plr->GetPositionY(),plr->GetPositionZ(),plr->GetOrientation(),0,0,0,0,100,1))
+                        {
+                            delete go;                
+                        }
+                        else
+                        {
+                            go->SetRespawnTime(0);
+                            map->Add(go);
+                        }
+                    }
+                }
+            }
+            break;
+        }
+        return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPSI::HandleCustomSpell(Player *plr, uint32 spellId, GameObject *go)
+{
+    if(!go || spellId != SI_SILITHYST_FLAG_GO_SPELL)
+        return false;
+    plr->CastSpell(plr,SI_SILITHYST_FLAG,true);
+    if(go->GetGOInfo()->id == SI_SILITHYST_MOUND)
+    {
+        // despawn go
+        go->SetRespawnTime(0);
+        go->Delete();
+    }
+    return true;
+}
diff --git a/src/game/OutdoorPvPSI.h b/src/game/OutdoorPvPSI.h
new file mode 100644
index 0000000..9ee8c8a
--- /dev/null
+++ b/src/game/OutdoorPvPSI.h
@@ -0,0 +1,57 @@
+#ifndef OUTDOOR_PVP_SI_
+#define OUTDOOR_PVP_SI_
+
+#include "OutdoorPvP.h"
+
+const uint32 SI_SILITHYST_FLAG_GO_SPELL = 29518;
+
+const uint32 SI_SILITHYST_FLAG = 29519;
+
+const uint32 SI_TRACES_OF_SILITHYST = 29534;
+
+const uint32 SI_CENARION_FAVOR = 30754;
+
+const uint32 SI_MAX_RESOURCES = 200;
+
+const uint32 OutdoorPvPSIBuffZonesNum = 3;
+
+const uint32 OutdoorPvPSIBuffZones[OutdoorPvPSIBuffZonesNum] = { 1377, 3428, 3429 };
+
+const uint32 SI_AREATRIGGER_H = 4168;
+
+const uint32 SI_AREATRIGGER_A = 4162;
+
+const uint32 SI_TURNIN_QUEST_CM_A = 17090;
+
+const uint32 SI_TURNIN_QUEST_CM_H = 18199;
+
+const uint32 SI_SILITHYST_MOUND = 181597;
+
+enum SI_WorldStates{
+    SI_GATHERED_A = 2313,
+    SI_GATHERED_H = 2314,
+    SI_SILITHYST_MAX = 2317
+};
+
+class OutdoorPvPSI : public OutdoorPvP
+{
+public:
+    OutdoorPvPSI();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket &data);
+    void SendRemoveWorldStates(Player * plr);
+    bool HandleAreaTrigger(Player * plr, uint32 trigger);
+    bool HandleDropFlag(Player * plr, uint32 spellId);
+    bool HandleCustomSpell(Player * plr, uint32 spellId, GameObject *go);
+    void BuffTeam(uint32 team);
+    void UpdateWorldState();
+private:
+    uint32 m_Gathered_A;
+    uint32 m_Gathered_H;
+    uint32 m_LastController;
+};
+
+#endif
diff --git a/src/game/OutdoorPvPTF.cpp b/src/game/OutdoorPvPTF.cpp
new file mode 100644
index 0000000..bfbe343
--- /dev/null
+++ b/src/game/OutdoorPvPTF.cpp
@@ -0,0 +1,348 @@
+#include "OutdoorPvPTF.h"
+#include "OutdoorPvPMgr.h"
+#include "WorldPacket.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "Language.h"
+#include "World.h"
+
+OutdoorPvPTF::OutdoorPvPTF()
+{
+    m_TypeId = OUTDOOR_PVP_TF;
+}
+
+OutdoorPvPObjectiveTF::OutdoorPvPObjectiveTF(OutdoorPvP *pvp, OutdoorPvPTF_TowerType type)
+: OutdoorPvPObjective(pvp), m_TowerType(type), m_TowerState(TF_TOWERSTATE_N)
+{
+    AddCapturePoint(TFCapturePoints[type].entry,TFCapturePoints[type].map,TFCapturePoints[type].x,TFCapturePoints[type].y,TFCapturePoints[type].z,TFCapturePoints[type].o,TFCapturePoints[type].rot0,TFCapturePoints[type].rot1,TFCapturePoints[type].rot2,TFCapturePoints[type].rot3);
+}
+
+void OutdoorPvPObjectiveTF::FillInitialWorldStates(WorldPacket &data)
+{
+    data << uint32(TFTowerWorldStates[m_TowerType].n) << uint32(bool(m_TowerState & TF_TOWERSTATE_N));
+    data << uint32(TFTowerWorldStates[m_TowerType].h) << uint32(bool(m_TowerState & TF_TOWERSTATE_H));
+    data << uint32(TFTowerWorldStates[m_TowerType].a) << uint32(bool(m_TowerState & TF_TOWERSTATE_A));
+}
+
+void OutdoorPvPTF::FillInitialWorldStates(WorldPacket &data)
+{
+    data << TF_UI_TOWER_SLIDER_POS << uint32(50);
+    data << TF_UI_TOWER_SLIDER_N << uint32(100);
+    data << TF_UI_TOWER_SLIDER_DISPLAY << uint32(0);
+
+    data << TF_UI_TOWER_COUNT_H << m_HordeTowersControlled;
+    data << TF_UI_TOWER_COUNT_A << m_AllianceTowersControlled;
+    data << TF_UI_TOWERS_CONTROLLED_DISPLAY << uint32(!m_IsLocked);
+
+    data << TF_UI_LOCKED_TIME_MINUTES_FIRST_DIGIT << first_digit;
+    data << TF_UI_LOCKED_TIME_MINUTES_SECOND_DIGIT << second_digit;
+    data << TF_UI_LOCKED_TIME_HOURS << hours_left;
+
+    data << TF_UI_LOCKED_DISPLAY_NEUTRAL << uint32(m_IsLocked && !m_HordeTowersControlled && !m_AllianceTowersControlled);
+    data << TF_UI_LOCKED_DISPLAY_HORDE << uint32(m_IsLocked && (m_HordeTowersControlled > m_AllianceTowersControlled));
+    data << TF_UI_LOCKED_DISPLAY_ALLIANCE << uint32(m_IsLocked && (m_HordeTowersControlled < m_AllianceTowersControlled));
+
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        (*itr)->FillInitialWorldStates(data);
+    }
+}
+
+void OutdoorPvPTF::SendRemoveWorldStates(Player * plr)
+{
+    plr->SendUpdateWorldState(TF_UI_TOWER_SLIDER_POS,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_TOWER_SLIDER_N,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_TOWER_SLIDER_DISPLAY,uint32(0));
+
+    plr->SendUpdateWorldState(TF_UI_TOWER_COUNT_H,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_TOWER_COUNT_A,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_TOWERS_CONTROLLED_DISPLAY,uint32(0));
+
+    plr->SendUpdateWorldState(TF_UI_LOCKED_TIME_MINUTES_FIRST_DIGIT,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_LOCKED_TIME_MINUTES_SECOND_DIGIT,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_LOCKED_TIME_HOURS,uint32(0));
+
+    plr->SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_NEUTRAL,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_HORDE,uint32(0));
+    plr->SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_ALLIANCE,uint32(0));
+
+    for(int i = 0; i < TF_TOWER_NUM; ++i)
+    {
+        plr->SendUpdateWorldState(uint32(TFTowerWorldStates[i].n),uint32(0));
+        plr->SendUpdateWorldState(uint32(TFTowerWorldStates[i].h),uint32(0));
+        plr->SendUpdateWorldState(uint32(TFTowerWorldStates[i].a),uint32(0));
+    }
+}
+
+void OutdoorPvPObjectiveTF::UpdateTowerState()
+{
+    m_PvP->SendUpdateWorldState(uint32(TFTowerWorldStates[m_TowerType].n),uint32(bool(m_TowerState & TF_TOWERSTATE_N)));
+    m_PvP->SendUpdateWorldState(uint32(TFTowerWorldStates[m_TowerType].h),uint32(bool(m_TowerState & TF_TOWERSTATE_H)));
+    m_PvP->SendUpdateWorldState(uint32(TFTowerWorldStates[m_TowerType].a),uint32(bool(m_TowerState & TF_TOWERSTATE_A)));
+}
+
+bool OutdoorPvPObjectiveTF::HandlePlayerEnter(Player *plr)
+{
+    if(OutdoorPvPObjective::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(TF_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+        plr->SendUpdateWorldState(TF_UI_TOWER_SLIDER_POS, phase);
+        plr->SendUpdateWorldState(TF_UI_TOWER_SLIDER_N, m_NeutralValue);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveTF::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(TF_UI_TOWER_SLIDER_DISPLAY, 0);
+    OutdoorPvPObjective::HandlePlayerLeave(plr);
+}
+
+bool OutdoorPvPObjectiveTF::HandleCapturePointEvent(Player *plr, uint32 eventId)
+{
+    if(eventId == TFTowerPlayerEnterEvents[m_TowerType])
+    {
+        this->HandlePlayerEnter(plr);
+        return true;
+    }
+    else if (eventId == TFTowerPlayerLeaveEvents[m_TowerType])
+    {
+        this->HandlePlayerLeave(plr);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPTF::BuffTeam(uint32 team)
+{
+    if(team == ALLIANCE)
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->CastSpell(plr,TF_CAPTURE_BUFF,true);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(TF_CAPTURE_BUFF);
+        }
+    }
+    else if(team == HORDE)
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->CastSpell(plr,TF_CAPTURE_BUFF,true);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(TF_CAPTURE_BUFF);
+        }
+    }
+    else
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(TF_CAPTURE_BUFF);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(TF_CAPTURE_BUFF);
+        }
+    }
+}
+
+bool OutdoorPvPTF::Update(uint32 diff)
+{
+    bool changed = false;
+
+    if(changed = OutdoorPvP::Update(diff))
+    {
+        if(m_AllianceTowersControlled == TF_TOWER_NUM)
+        {
+            BuffTeam(ALLIANCE);
+            m_IsLocked = true;
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_NEUTRAL,uint32(0));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_HORDE,uint32(0));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_ALLIANCE,uint32(1));
+            SendUpdateWorldState(TF_UI_TOWERS_CONTROLLED_DISPLAY, uint32(0));
+        }
+        else if(m_HordeTowersControlled == TF_TOWER_NUM)
+        {
+            BuffTeam(HORDE);
+            m_IsLocked = true;
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_NEUTRAL,uint32(0));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_HORDE,uint32(1));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_ALLIANCE,uint32(0));
+            SendUpdateWorldState(TF_UI_TOWERS_CONTROLLED_DISPLAY, uint32(0));
+        }
+        else
+            BuffTeam(NULL);
+        SendUpdateWorldState(TF_UI_TOWER_COUNT_A, m_AllianceTowersControlled);
+        SendUpdateWorldState(TF_UI_TOWER_COUNT_H, m_HordeTowersControlled);
+    }
+    if(m_IsLocked)
+    {
+        // lock timer is down, release lock
+        if(m_LockTimer < diff)
+        {
+            m_LockTimer = TF_LOCK_TIME;
+            m_LockTimerUpdate = 0;
+            m_IsLocked = false;
+            SendUpdateWorldState(TF_UI_TOWERS_CONTROLLED_DISPLAY, uint32(1));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_NEUTRAL,uint32(0));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_HORDE,uint32(0));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_ALLIANCE,uint32(0));
+        }
+        else
+        {
+            // worldstateui update timer is down, update ui with new time data
+            if(m_LockTimerUpdate < diff)
+            {
+                m_LockTimerUpdate = TF_LOCK_TIME_UPDATE;
+                uint32 minutes_left = m_LockTimer / 60000;
+                hours_left = minutes_left / 60;
+                minutes_left -= hours_left * 60;
+                second_digit = minutes_left % 10;
+                first_digit = minutes_left / 10;
+
+                SendUpdateWorldState(TF_UI_LOCKED_TIME_MINUTES_FIRST_DIGIT,first_digit);
+                SendUpdateWorldState(TF_UI_LOCKED_TIME_MINUTES_SECOND_DIGIT,second_digit);
+                SendUpdateWorldState(TF_UI_LOCKED_TIME_HOURS,hours_left);
+            } else m_LockTimerUpdate -= diff;
+            m_LockTimer -= diff;
+        }
+    }
+    return changed;
+}
+
+void OutdoorPvPTF::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    if(plr->GetTeam() == ALLIANCE)
+    {
+        if(m_AllianceTowersControlled >= TF_TOWER_NUM)
+            plr->CastSpell(plr,TF_CAPTURE_BUFF,true);
+    }
+    else
+    {
+        if(m_HordeTowersControlled >= TF_TOWER_NUM)
+            plr->CastSpell(plr,TF_CAPTURE_BUFF,true);
+    }
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPTF::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    plr->RemoveAurasDueToSpell(TF_CAPTURE_BUFF);
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+bool OutdoorPvPTF::SetupOutdoorPvP()
+{
+    m_AllianceTowersControlled = 0;
+    m_HordeTowersControlled = 0;
+
+    m_IsLocked = false;
+    m_LockTimer = TF_LOCK_TIME;
+    m_LockTimerUpdate = 0; 
+    hours_left = 6;
+    second_digit = 0;
+    first_digit = 0;
+
+    // add the zones affected by the pvp buff
+    for(int i = 0; i < OutdoorPvPTFBuffZonesNum; ++i)
+        sOutdoorPvPMgr.AddZone(OutdoorPvPTFBuffZones[i],this);
+
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveTF(this,TF_TOWER_NW));
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveTF(this,TF_TOWER_N));
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveTF(this,TF_TOWER_NE));
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveTF(this,TF_TOWER_SE));
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveTF(this,TF_TOWER_S));
+
+    return true;
+}
+
+bool OutdoorPvPObjectiveTF::Update(uint32 diff)
+{
+    // can update even in locked state if gathers the controlling faction
+    bool canupdate = ((((OutdoorPvPTF*)m_PvP)->m_AllianceTowersControlled > 0) && this->m_AllianceActivePlayerCount > this->m_HordeActivePlayerCount) ||
+            ((((OutdoorPvPTF*)m_PvP)->m_HordeTowersControlled > 0) && this->m_AllianceActivePlayerCount < this->m_HordeActivePlayerCount);
+    // if gathers the other faction, then only update if the pvp is unlocked
+    canupdate = canupdate || !((OutdoorPvPTF*)m_PvP)->m_IsLocked;
+    if(canupdate && OutdoorPvPObjective::Update(diff))
+    {
+        if(m_OldState != m_State)
+        {
+            // if changing from controlling alliance to horde
+            if( m_OldState == OBJECTIVESTATE_ALLIANCE )
+            {
+                if(((OutdoorPvPTF*)m_PvP)->m_AllianceTowersControlled)
+                    ((OutdoorPvPTF*)m_PvP)->m_AllianceTowersControlled--;
+                sWorld.SendZoneText(OutdoorPvPTFBuffZones[0],objmgr.GetMangosString(LANG_OPVP_TF_LOOSE_A, -1));
+            }
+            // if changing from controlling horde to alliance
+            else if ( m_OldState == OBJECTIVESTATE_HORDE )
+            {
+                if(((OutdoorPvPTF*)m_PvP)->m_HordeTowersControlled)
+                    ((OutdoorPvPTF*)m_PvP)->m_HordeTowersControlled--;
+                sWorld.SendZoneText(OutdoorPvPTFBuffZones[0],objmgr.GetMangosString(LANG_OPVP_TF_LOOSE_H,-1));
+            }
+
+            uint32 artkit = 21;
+
+            switch(m_State)
+            {
+            case OBJECTIVESTATE_ALLIANCE:
+                m_TowerState = TF_TOWERSTATE_A;
+                artkit = 2;
+                if(((OutdoorPvPTF*)m_PvP)->m_AllianceTowersControlled<TF_TOWER_NUM)
+                    ((OutdoorPvPTF*)m_PvP)->m_AllianceTowersControlled++;
+                sWorld.SendZoneText(OutdoorPvPTFBuffZones[0],objmgr.GetMangosString(LANG_OPVP_TF_CAPTURE_A,-1));
+                break;
+            case OBJECTIVESTATE_HORDE:
+                m_TowerState = TF_TOWERSTATE_H;
+                artkit = 1;
+                if(((OutdoorPvPTF*)m_PvP)->m_HordeTowersControlled<TF_TOWER_NUM)
+                    ((OutdoorPvPTF*)m_PvP)->m_HordeTowersControlled++;
+                sWorld.SendZoneText(OutdoorPvPTFBuffZones[0],objmgr.GetMangosString(LANG_OPVP_TF_CAPTURE_H,-1));
+                break;
+            case OBJECTIVESTATE_NEUTRAL:
+            case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+            case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+            case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+            case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+                m_TowerState = TF_TOWERSTATE_N;
+                break;
+            }
+
+            GameObject* flag = HashMapHolder<GameObject>::Find(m_CapturePoint);
+            if(flag)
+            {
+                flag->SetGoArtKit(artkit);
+                flag->SendUpdateObjectToAllExcept(NULL);
+            }
+
+            UpdateTowerState();
+        }
+
+        if(m_ShiftPhase != m_OldPhase)
+        {
+            // send this too, sometimes the slider disappears, dunno why :(
+            SendUpdateWorldState(TF_UI_TOWER_SLIDER_DISPLAY, 1);
+            // send these updates to only the ones in this objective
+            uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+            SendUpdateWorldState(TF_UI_TOWER_SLIDER_POS, phase);
+            // send this too, sometimes it resets :S
+            SendUpdateWorldState(TF_UI_TOWER_SLIDER_N, m_NeutralValue);
+        }
+        return true;
+    }
+    return false;
+}
diff --git a/src/game/OutdoorPvPTF.h b/src/game/OutdoorPvPTF.h
new file mode 100644
index 0000000..802f163
--- /dev/null
+++ b/src/game/OutdoorPvPTF.h
@@ -0,0 +1,117 @@
+#ifndef OUTDOOR_PVP_TF_
+#define OUTDOOR_PVP_TF_
+
+#include "OutdoorPvP.h"
+
+const uint32 OutdoorPvPTFBuffZonesNum = 5;
+
+const uint32 OutdoorPvPTFBuffZones[OutdoorPvPTFBuffZonesNum] = { 3519 /*Terokkar Forest*/, 3791 /*Sethekk Halls*/, 3789 /*Shadow Labyrinth*/, 3792 /*Mana-Tombs*/, 3790 /*Auchenai Crypts*/ };
+
+// locked for 6 hours after capture
+const uint32 TF_LOCK_TIME = 3600 * 6 * 1000;
+// update lock timer every 1/4 minute (overkill, but this way it's sure the timer won't "jump" 2 minutes at once.)
+const uint32 TF_LOCK_TIME_UPDATE = 15000;
+
+// blessing of auchindoun
+const uint32 TF_CAPTURE_BUFF = 33377;
+
+const uint32 TF_ALLY_QUEST = 11505;
+const uint32 TF_HORDE_QUEST = 11506;
+
+enum OutdoorPvPTF_TowerType{
+    TF_TOWER_NW = 0,
+    TF_TOWER_N,
+    TF_TOWER_NE,
+    TF_TOWER_SE,
+    TF_TOWER_S,
+    TF_TOWER_NUM
+};
+
+const go_type TFCapturePoints[TF_TOWER_NUM] = {
+    {183104,530,-3081.65,5335.03,17.1853,-2.14675,0,0,0.878817,-0.477159},
+    {183411,530,-2939.9,4788.73,18.987,2.77507,0,0,0.983255,0.182236},
+    {183412,530,-3174.94,4440.97,16.2281,1.86750,0,0.803857,0.594823},
+    {183413,530,-3603.31,4529.15,20.9077,0.994838,0,0,0.477159,0.878817},
+    {183414,530,-3812.37,4899.3,17.7249,0.087266,0,0,0.043619,0.999048}
+};
+
+struct tf_tower_world_state{
+    uint32 n;
+    uint32 h;
+    uint32 a;
+};
+
+const tf_tower_world_state TFTowerWorldStates[TF_TOWER_NUM] = {
+    {0xa79,0xa7a,0xa7b},
+    {0xa7e,0xa7d,0xa7c},
+    {0xa82,0xa81,0xa80},
+    {0xa88,0xa87,0xa86},
+    {0xa85,0xa84,0xa83}
+};
+
+const uint32 TFTowerPlayerEnterEvents[TF_TOWER_NUM] = {12226, 12497, 12486, 12499, 12501};
+
+const uint32 TFTowerPlayerLeaveEvents[TF_TOWER_NUM] = {12225, 12496, 12487, 12498, 12500};
+
+enum TFWorldStates{
+    TF_UI_TOWER_SLIDER_POS = 0xa41,
+    TF_UI_TOWER_SLIDER_N = 0xa40,
+    TF_UI_TOWER_SLIDER_DISPLAY = 0xa3f,
+
+    TF_UI_TOWER_COUNT_H = 0xa3e,
+    TF_UI_TOWER_COUNT_A = 0xa3d,
+    TF_UI_TOWERS_CONTROLLED_DISPLAY = 0xa3c,
+
+    TF_UI_LOCKED_TIME_MINUTES_FIRST_DIGIT = 0x9d0,
+    TF_UI_LOCKED_TIME_MINUTES_SECOND_DIGIT = 0x9ce,
+    TF_UI_LOCKED_TIME_HOURS = 0x9cd,
+    TF_UI_LOCKED_DISPLAY_NEUTRAL = 0x9cc,
+    TF_UI_LOCKED_DISPLAY_HORDE = 0xad0,
+    TF_UI_LOCKED_DISPLAY_ALLIANCE = 0xacf
+};
+
+enum TFTowerStates {
+    TF_TOWERSTATE_N = 1,
+    TF_TOWERSTATE_H = 2,
+    TF_TOWERSTATE_A = 4
+};
+
+class OutdoorPvPObjectiveTF : public OutdoorPvPObjective
+{
+public:
+    OutdoorPvPObjectiveTF(OutdoorPvP * pvp, OutdoorPvPTF_TowerType type);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+    void UpdateTowerState();
+protected:
+    virtual bool HandleCapturePointEvent(Player * plr, uint32 eventId);
+protected:
+    OutdoorPvPTF_TowerType m_TowerType;
+    uint32 m_TowerState;
+};
+
+class OutdoorPvPTF : public OutdoorPvP
+{
+friend class OutdoorPvPObjectiveTF;
+public:
+    OutdoorPvPTF();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket &data);
+    void SendRemoveWorldStates(Player * plr);
+    void BuffTeam(uint32 team);
+private:
+    bool m_IsLocked;
+    uint32 m_LockTimer;
+    uint32 m_LockTimerUpdate;
+    uint32 m_AllianceTowersControlled;
+    uint32 m_HordeTowersControlled;
+    uint32 hours_left, second_digit, first_digit;
+};
+
+#endif
diff --git a/src/game/OutdoorPvPZM.cpp b/src/game/OutdoorPvPZM.cpp
new file mode 100644
index 0000000..76dabfd
--- /dev/null
+++ b/src/game/OutdoorPvPZM.cpp
@@ -0,0 +1,476 @@
+#include "OutdoorPvPZM.h"
+#include "ObjectMgr.h"
+#include "OutdoorPvPMgr.h"
+#include "Player.h"
+#include "Creature.h"
+#include "ObjectAccessor.h"
+#include "WorldPacket.h"
+#include "GossipDef.h"
+#include "World.h"
+
+OutdoorPvPObjectiveZM_Beacon::OutdoorPvPObjectiveZM_Beacon(OutdoorPvP *pvp, ZM_BeaconType type)
+: OutdoorPvPObjective(pvp), m_TowerType(type), m_TowerState(ZM_TOWERSTATE_N)
+{
+    AddCapturePoint(ZMCapturePoints[type].entry,ZMCapturePoints[type].map,ZMCapturePoints[type].x,ZMCapturePoints[type].y,ZMCapturePoints[type].z,ZMCapturePoints[type].o,ZMCapturePoints[type].rot0,ZMCapturePoints[type].rot1,ZMCapturePoints[type].rot2,ZMCapturePoints[type].rot3);
+}
+
+void OutdoorPvPObjectiveZM_Beacon::FillInitialWorldStates(WorldPacket &data)
+{
+    data << uint32(ZMBeaconInfo[m_TowerType].ui_tower_n) << uint32(bool(m_TowerState & ZM_TOWERSTATE_N));
+    data << uint32(ZMBeaconInfo[m_TowerType].map_tower_n) << uint32(bool(m_TowerState & ZM_TOWERSTATE_N));
+    data << uint32(ZMBeaconInfo[m_TowerType].ui_tower_a) << uint32(bool(m_TowerState & ZM_TOWERSTATE_A));
+    data << uint32(ZMBeaconInfo[m_TowerType].map_tower_a) << uint32(bool(m_TowerState & ZM_TOWERSTATE_A));
+    data << uint32(ZMBeaconInfo[m_TowerType].ui_tower_h) << uint32(bool(m_TowerState & ZM_TOWERSTATE_H));
+    data << uint32(ZMBeaconInfo[m_TowerType].map_tower_h) << uint32(bool(m_TowerState & ZM_TOWERSTATE_H));
+}
+
+void OutdoorPvPObjectiveZM_Beacon::UpdateTowerState()
+{
+    m_PvP->SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].ui_tower_n),uint32(bool(m_TowerState & ZM_TOWERSTATE_N)));
+    m_PvP->SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].map_tower_n),uint32(bool(m_TowerState & ZM_TOWERSTATE_N)));
+    m_PvP->SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].ui_tower_a),uint32(bool(m_TowerState & ZM_TOWERSTATE_A)));
+    m_PvP->SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].map_tower_a),uint32(bool(m_TowerState & ZM_TOWERSTATE_A)));
+    m_PvP->SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].ui_tower_h),uint32(bool(m_TowerState & ZM_TOWERSTATE_H)));
+    m_PvP->SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].map_tower_h),uint32(bool(m_TowerState & ZM_TOWERSTATE_H)));
+}
+
+bool OutdoorPvPObjectiveZM_Beacon::HandlePlayerEnter(Player *plr)
+{
+    if(OutdoorPvPObjective::HandlePlayerEnter(plr))
+    {
+        plr->SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_disp, 1);
+        uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+        plr->SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_pos, phase);
+        plr->SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_n, m_NeutralValue);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPObjectiveZM_Beacon::HandlePlayerLeave(Player *plr)
+{
+    plr->SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_disp, 0);
+    OutdoorPvPObjective::HandlePlayerLeave(plr);
+}
+
+bool OutdoorPvPObjectiveZM_Beacon::HandleCapturePointEvent(Player *plr, uint32 eventId)
+{
+    if(eventId == ZMBeaconInfo[m_TowerType].event_enter)
+    {
+        this->HandlePlayerEnter(plr);
+        return true;
+    }
+    else if (eventId == ZMBeaconInfo[m_TowerType].event_leave)
+    {
+        this->HandlePlayerLeave(plr);
+        return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPObjectiveZM_Beacon::Update(uint32 diff)
+{
+    if(OutdoorPvPObjective::Update(diff))
+    {
+        if(m_OldState != m_State)
+        {
+            // if changing from controlling alliance to horde
+            if( m_OldState == OBJECTIVESTATE_ALLIANCE )
+            {
+                if(((OutdoorPvPZM*)m_PvP)->m_AllianceTowersControlled)
+                    ((OutdoorPvPZM*)m_PvP)->m_AllianceTowersControlled--;
+                sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,objmgr.GetMangosString(ZMBeaconLooseA[m_TowerType], -1));
+            }
+            // if changing from controlling horde to alliance
+            else if ( m_OldState == OBJECTIVESTATE_HORDE )
+            {
+                if(((OutdoorPvPZM*)m_PvP)->m_HordeTowersControlled)
+                    ((OutdoorPvPZM*)m_PvP)->m_HordeTowersControlled--;
+                sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,objmgr.GetMangosString(ZMBeaconLooseH[m_TowerType],-1));
+            }
+
+            switch(m_State)
+            {
+            case OBJECTIVESTATE_ALLIANCE:
+                m_TowerState = ZM_TOWERSTATE_A;
+                if(((OutdoorPvPZM*)m_PvP)->m_AllianceTowersControlled<ZM_NUM_BEACONS)
+                    ((OutdoorPvPZM*)m_PvP)->m_AllianceTowersControlled++;
+                sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,objmgr.GetMangosString(ZMBeaconCaptureA[m_TowerType],-1));
+                break;
+            case OBJECTIVESTATE_HORDE:
+                m_TowerState = ZM_TOWERSTATE_H;
+                if(((OutdoorPvPZM*)m_PvP)->m_HordeTowersControlled<ZM_NUM_BEACONS)
+                    ((OutdoorPvPZM*)m_PvP)->m_HordeTowersControlled++;
+                sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,objmgr.GetMangosString(ZMBeaconCaptureH[m_TowerType],-1));
+                break;
+            case OBJECTIVESTATE_NEUTRAL:
+            case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+            case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+            case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+            case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+                m_TowerState = ZM_TOWERSTATE_N;
+                break;
+            }
+
+            UpdateTowerState();
+        }
+
+        if(m_ShiftPhase != m_OldPhase)
+        {
+            // send this too, sometimes the slider disappears, dunno why :(
+            SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_disp, 1);
+            // send these updates to only the ones in this objective
+            uint32 phase = (uint32)ceil(( m_ShiftPhase + m_ShiftMaxPhase) / ( 2 * m_ShiftMaxPhase ) * 100.0f);
+            SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_pos, phase);
+            SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_n, m_NeutralValue);
+        }
+        return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPZM::Update(uint32 diff)
+{
+    bool changed = false;
+    if(changed = OutdoorPvP::Update(diff))
+    {
+        if(m_AllianceTowersControlled == ZM_NUM_BEACONS)
+            m_GraveYard->SetBeaconState(ALLIANCE);
+        else if(m_HordeTowersControlled == ZM_NUM_BEACONS)
+            m_GraveYard->SetBeaconState(HORDE);
+        else
+            m_GraveYard->SetBeaconState(0);
+    }
+    return changed;
+}
+
+void OutdoorPvPZM::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    if(plr->GetTeam() == ALLIANCE)
+    {
+        if(m_GraveYard->m_GraveYardState & ZM_GRAVEYARD_A)
+            plr->CastSpell(plr,ZM_CAPTURE_BUFF,true);
+    }
+    else
+    {
+        if(m_GraveYard->m_GraveYardState & ZM_GRAVEYARD_H)
+            plr->CastSpell(plr,ZM_CAPTURE_BUFF,true);
+    }
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPZM::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    plr->RemoveAurasDueToSpell(ZM_CAPTURE_BUFF);
+    // remove flag
+    plr->RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_A);
+    plr->RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_H);
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+OutdoorPvPZM::OutdoorPvPZM()
+{
+    m_TypeId = OUTDOOR_PVP_ZM;
+    m_GraveYard = NULL;
+    m_AllianceTowersControlled = 0;
+    m_HordeTowersControlled = 0;
+
+}
+
+bool OutdoorPvPZM::SetupOutdoorPvP()
+{
+    m_AllianceTowersControlled = 0;
+    m_HordeTowersControlled = 0;
+
+    // add the zones affected by the pvp buff
+    for(int i = 0; i < OutdoorPvPZMBuffZonesNum; ++i)
+        sOutdoorPvPMgr.AddZone(OutdoorPvPZMBuffZones[i],this);
+
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveZM_Beacon(this,ZM_BEACON_WEST));
+    m_OutdoorPvPObjectives.insert(new OutdoorPvPObjectiveZM_Beacon(this,ZM_BEACON_EAST));
+    m_GraveYard = new OutdoorPvPObjectiveZM_GraveYard(this);
+    m_OutdoorPvPObjectives.insert(m_GraveYard); // though the update function isn't used, the handleusego is!
+
+    return true;
+}
+
+void OutdoorPvPZM::HandleKillImpl(Player *plr, Unit * killed)
+{
+    if(killed->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    if(plr->GetTeam() == ALLIANCE && ((Player*)killed)->GetTeam() != ALLIANCE)
+        plr->CastSpell(plr,ZM_AlliancePlayerKillReward,true);
+    else if(plr->GetTeam() == HORDE && ((Player*)killed)->GetTeam() != HORDE)
+        plr->CastSpell(plr,ZM_HordePlayerKillReward,true);
+}
+
+void OutdoorPvPZM::BuffTeam(uint32 team)
+{
+    if(team == ALLIANCE)
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->CastSpell(plr,ZM_CAPTURE_BUFF,true);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(ZM_CAPTURE_BUFF);
+        }
+    }
+    else if(team == HORDE)
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->CastSpell(plr,ZM_CAPTURE_BUFF,true);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(ZM_CAPTURE_BUFF);
+        }
+    }
+    else
+    {
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[0].begin(); itr != m_PlayerGuids[0].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(ZM_CAPTURE_BUFF);
+        }
+        for(std::set<uint64>::iterator itr = m_PlayerGuids[1].begin(); itr != m_PlayerGuids[1].end(); ++itr)
+        {
+            if(Player * plr = objmgr.GetPlayer(*itr))
+                plr->RemoveAurasDueToSpell(ZM_CAPTURE_BUFF);
+        }
+    }
+}
+
+bool OutdoorPvPObjectiveZM_GraveYard::Update(uint32 diff)
+{
+    bool retval = m_State != m_OldState;
+    m_State = m_OldState;
+    return retval;
+}
+
+int32 OutdoorPvPObjectiveZM_GraveYard::HandleOpenGo(Player *plr, uint64 guid)
+{
+    uint32 retval = OutdoorPvPObjective::HandleOpenGo(plr, guid);
+    if(retval>=0)
+    {
+        if(plr->HasAura(ZM_BATTLE_STANDARD_A,0) && m_GraveYardState != ZM_GRAVEYARD_A)
+        {
+            if(m_GraveYardState == ZM_GRAVEYARD_H)
+                sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,objmgr.GetMangosString(LANG_OPVP_ZM_LOOSE_GY_H,-1));
+            m_GraveYardState = ZM_GRAVEYARD_A;
+            DelObject(0);   // only one gotype is used in the whole outdoor pvp, no need to call it a constant
+            AddObject(0,ZM_Banner_A.entry,ZM_Banner_A.map,ZM_Banner_A.x,ZM_Banner_A.y,ZM_Banner_A.z,ZM_Banner_A.o,ZM_Banner_A.rot0,ZM_Banner_A.rot1,ZM_Banner_A.rot2,ZM_Banner_A.rot3);
+            objmgr.RemoveGraveYardLink(ZM_GRAVEYARD_ID, ZM_GRAVEYARD_ZONE, HORDE);          // rem gy
+            objmgr.AddGraveYardLink(ZM_GRAVEYARD_ID, ZM_GRAVEYARD_ZONE, ALLIANCE, false);   // add gy
+            ((OutdoorPvPZM*)m_PvP)->BuffTeam(ALLIANCE);
+            plr->RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_A);
+            sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,objmgr.GetMangosString(LANG_OPVP_ZM_CAPTURE_GY_A, -1));
+        }
+        else if(plr->HasAura(ZM_BATTLE_STANDARD_H,0) && m_GraveYardState != ZM_GRAVEYARD_H)
+        {
+            if(m_GraveYardState == ZM_GRAVEYARD_A)
+                sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,objmgr.GetMangosString(LANG_OPVP_ZM_LOOSE_GY_A,-1));
+            m_GraveYardState = ZM_GRAVEYARD_H;
+            DelObject(0);   // only one gotype is used in the whole outdoor pvp, no need to call it a constant
+            AddObject(0,ZM_Banner_H.entry,ZM_Banner_H.map,ZM_Banner_H.x,ZM_Banner_H.y,ZM_Banner_H.z,ZM_Banner_H.o,ZM_Banner_H.rot0,ZM_Banner_H.rot1,ZM_Banner_H.rot2,ZM_Banner_H.rot3);
+            objmgr.RemoveGraveYardLink(ZM_GRAVEYARD_ID, ZM_GRAVEYARD_ZONE, ALLIANCE);          // rem gy
+            objmgr.AddGraveYardLink(ZM_GRAVEYARD_ID, ZM_GRAVEYARD_ZONE, HORDE, false);   // add gy
+            ((OutdoorPvPZM*)m_PvP)->BuffTeam(HORDE);
+            plr->RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_H);
+            sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,objmgr.GetMangosString(LANG_OPVP_ZM_CAPTURE_GY_H,-1));
+        }
+        UpdateTowerState();
+    }
+    return retval;
+}
+
+OutdoorPvPObjectiveZM_GraveYard::OutdoorPvPObjectiveZM_GraveYard(OutdoorPvP *pvp)
+: OutdoorPvPObjective(pvp)
+{
+    m_BothControllingFaction = 0;
+    m_GraveYardState = ZM_GRAVEYARD_N;
+    m_FlagCarrierGUID = 0;
+    // add field scouts here
+    AddCreature(ZM_ALLIANCE_FIELD_SCOUT,ZM_AllianceFieldScout.entry,ZM_AllianceFieldScout.teamval,ZM_AllianceFieldScout.map,ZM_AllianceFieldScout.x,ZM_AllianceFieldScout.y,ZM_AllianceFieldScout.z,ZM_AllianceFieldScout.o);
+    AddCreature(ZM_HORDE_FIELD_SCOUT,ZM_HordeFieldScout.entry,ZM_HordeFieldScout.teamval,ZM_HordeFieldScout.map,ZM_HordeFieldScout.x,ZM_HordeFieldScout.y,ZM_HordeFieldScout.z,ZM_HordeFieldScout.o);
+    // add neutral banner
+    AddObject(0,ZM_Banner_N.entry,ZM_Banner_N.map,ZM_Banner_N.x,ZM_Banner_N.y,ZM_Banner_N.z,ZM_Banner_N.o,ZM_Banner_N.rot0,ZM_Banner_N.rot1,ZM_Banner_N.rot2,ZM_Banner_N.rot3);
+}
+
+void OutdoorPvPObjectiveZM_GraveYard::UpdateTowerState()
+{
+    m_PvP->SendUpdateWorldState(ZM_MAP_GRAVEYARD_N,uint32(bool(m_GraveYardState & ZM_GRAVEYARD_N)));
+    m_PvP->SendUpdateWorldState(ZM_MAP_GRAVEYARD_H,uint32(bool(m_GraveYardState & ZM_GRAVEYARD_H)));
+    m_PvP->SendUpdateWorldState(ZM_MAP_GRAVEYARD_A,uint32(bool(m_GraveYardState & ZM_GRAVEYARD_A)));
+
+    m_PvP->SendUpdateWorldState(ZM_MAP_ALLIANCE_FLAG_READY,uint32(m_BothControllingFaction == ALLIANCE));
+    m_PvP->SendUpdateWorldState(ZM_MAP_ALLIANCE_FLAG_NOT_READY,uint32(m_BothControllingFaction != ALLIANCE));
+    m_PvP->SendUpdateWorldState(ZM_MAP_HORDE_FLAG_READY,uint32(m_BothControllingFaction == HORDE));
+    m_PvP->SendUpdateWorldState(ZM_MAP_HORDE_FLAG_NOT_READY,uint32(m_BothControllingFaction != HORDE));
+}
+
+void OutdoorPvPObjectiveZM_GraveYard::FillInitialWorldStates(WorldPacket &data)
+{
+    data << ZM_MAP_GRAVEYARD_N  << uint32(bool(m_GraveYardState & ZM_GRAVEYARD_N));
+    data << ZM_MAP_GRAVEYARD_H  << uint32(bool(m_GraveYardState & ZM_GRAVEYARD_H));
+    data << ZM_MAP_GRAVEYARD_A  << uint32(bool(m_GraveYardState & ZM_GRAVEYARD_A));
+
+    data << ZM_MAP_ALLIANCE_FLAG_READY  << uint32(m_BothControllingFaction == ALLIANCE);
+    data << ZM_MAP_ALLIANCE_FLAG_NOT_READY  << uint32(m_BothControllingFaction != ALLIANCE);
+    data << ZM_MAP_HORDE_FLAG_READY  << uint32(m_BothControllingFaction == HORDE);
+    data << ZM_MAP_HORDE_FLAG_NOT_READY  << uint32(m_BothControllingFaction != HORDE);
+}
+
+void OutdoorPvPObjectiveZM_GraveYard::SetBeaconState(uint32 controlling_faction)
+{
+    // nothing to do here
+    if(m_BothControllingFaction == controlling_faction)
+        return;
+    m_BothControllingFaction = controlling_faction;
+
+    switch(controlling_faction)
+    {
+    case ALLIANCE:
+        // if ally already controls the gy and taken back both beacons, return, nothing to do for us
+        if(m_GraveYardState & ZM_GRAVEYARD_A)
+            return;
+        // ally doesn't control the gy, but controls the side beacons -> add gossip option, add neutral banner
+        break;
+    case HORDE:
+        // if horde already controls the gy and taken back both beacons, return, nothing to do for us
+        if(m_GraveYardState & ZM_GRAVEYARD_H)
+            return;
+        // horde doesn't control the gy, but controls the side beacons -> add gossip option, add neutral banner
+        break;
+    default:
+        // if the graveyard is not neutral, then leave it that way
+        // if the graveyard is neutral, then we have to dispel the buff from the flag carrier
+        if(m_GraveYardState & ZM_GRAVEYARD_N)
+        {
+            // gy was neutral, thus neutral banner was spawned, it is possible that someone was taking the flag to the gy
+            if(m_FlagCarrierGUID)
+            {
+                // remove flag from carrier, reset flag carrier guid
+                Player * p = objmgr.GetPlayer(m_FlagCarrierGUID);
+                if(p)
+                {
+                   p->RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_A);
+                   p->RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_H);
+                }
+                m_FlagCarrierGUID = 0;
+            }
+        }
+        break;
+    }
+    // send worldstateupdate
+    UpdateTowerState();
+}
+
+bool OutdoorPvPObjectiveZM_GraveYard::CanTalkTo(Player * plr, Creature * c, GossipOption & gso)
+{
+    uint64 guid = c->GetGUID();
+    std::map<uint64,uint32>::iterator itr = m_CreatureTypes.find(guid);
+    if(itr != m_CreatureTypes.end())
+    {
+        if(itr->second == ZM_ALLIANCE_FIELD_SCOUT && plr->GetTeam() == ALLIANCE && m_BothControllingFaction == ALLIANCE && !m_FlagCarrierGUID && m_GraveYardState != ZM_GRAVEYARD_A)
+        {
+            gso.OptionText.assign("Give me the flag, I'll take it to the Central Tower for the glory of the Alliance!");
+            return true;
+        }
+        else if(itr->second == ZM_HORDE_FIELD_SCOUT && plr->GetTeam() == HORDE && m_BothControllingFaction == HORDE && !m_FlagCarrierGUID && m_GraveYardState != ZM_GRAVEYARD_H)
+        {
+            gso.OptionText.assign("Give me the flag, I'll take it to the Central Tower for the glory of the Horde!");
+            return true;
+        }
+    }
+    return false;
+}
+
+bool OutdoorPvPObjectiveZM_GraveYard::HandleGossipOption(Player *plr, uint64 guid, uint32 gossipid)
+{
+    std::map<uint64,uint32>::iterator itr = m_CreatureTypes.find(guid);
+    if(itr != m_CreatureTypes.end())
+    {
+        Creature * cr = HashMapHolder<Creature>::Find(guid);
+        if(!cr)
+            return true;
+        // if the flag is already taken, then return
+        if(m_FlagCarrierGUID)
+            return true;
+        if(itr->second == ZM_ALLIANCE_FIELD_SCOUT)
+        {
+            cr->CastSpell(plr,ZM_BATTLE_STANDARD_A,true);
+            m_FlagCarrierGUID = plr->GetGUID();
+        }
+        else if(itr->second == ZM_HORDE_FIELD_SCOUT)
+        {
+            cr->CastSpell(plr,ZM_BATTLE_STANDARD_H,true);
+            m_FlagCarrierGUID = plr->GetGUID();
+        }
+        UpdateTowerState();
+        plr->PlayerTalkClass->CloseGossip();
+        return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPObjectiveZM_GraveYard::HandleDropFlag(Player * plr, uint32 spellId)
+{
+    switch(spellId)
+    {
+    case ZM_BATTLE_STANDARD_A:
+        m_FlagCarrierGUID = 0;
+        return true;
+    case ZM_BATTLE_STANDARD_H:
+        m_FlagCarrierGUID = 0;
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPZM::FillInitialWorldStates(WorldPacket &data)
+{
+    data << ZM_WORLDSTATE_UNK_1 << uint32(1);
+    for(OutdoorPvPObjectiveSet::iterator itr = m_OutdoorPvPObjectives.begin(); itr != m_OutdoorPvPObjectives.end(); ++itr)
+    {
+        (*itr)->FillInitialWorldStates(data);
+    }
+}
+
+void OutdoorPvPZM::SendRemoveWorldStates(Player *plr)
+{
+    plr->SendUpdateWorldState(ZM_UI_TOWER_SLIDER_N_W,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_SLIDER_POS_W,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_SLIDER_DISPLAY_W,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_SLIDER_N_E,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_SLIDER_POS_E,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_SLIDER_DISPLAY_E,0);
+    plr->SendUpdateWorldState(ZM_WORLDSTATE_UNK_1,1);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_EAST_N,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_EAST_H,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_EAST_A,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_WEST_N,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_WEST_H,0);
+    plr->SendUpdateWorldState(ZM_UI_TOWER_WEST_A,0);
+    plr->SendUpdateWorldState(ZM_MAP_TOWER_EAST_N,0);
+    plr->SendUpdateWorldState(ZM_MAP_TOWER_EAST_H,0);
+    plr->SendUpdateWorldState(ZM_MAP_TOWER_EAST_A,0);
+    plr->SendUpdateWorldState(ZM_MAP_GRAVEYARD_H,0);
+    plr->SendUpdateWorldState(ZM_MAP_GRAVEYARD_A,0);
+    plr->SendUpdateWorldState(ZM_MAP_GRAVEYARD_N,0);
+    plr->SendUpdateWorldState(ZM_MAP_TOWER_WEST_N,0);
+    plr->SendUpdateWorldState(ZM_MAP_TOWER_WEST_H,0);
+    plr->SendUpdateWorldState(ZM_MAP_TOWER_WEST_A,0);
+    plr->SendUpdateWorldState(ZM_MAP_HORDE_FLAG_READY,0);
+    plr->SendUpdateWorldState(ZM_MAP_HORDE_FLAG_NOT_READY,0);
+    plr->SendUpdateWorldState(ZM_MAP_ALLIANCE_FLAG_NOT_READY,0);
+    plr->SendUpdateWorldState(ZM_MAP_ALLIANCE_FLAG_READY,0);
+}
diff --git a/src/game/OutdoorPvPZM.h b/src/game/OutdoorPvPZM.h
new file mode 100644
index 0000000..ae94f59
--- /dev/null
+++ b/src/game/OutdoorPvPZM.h
@@ -0,0 +1,197 @@
+#ifndef OUTDOOR_PVP_ZM_
+#define OUTDOOR_PVP_ZM_
+
+#include "OutdoorPvP.h"
+#include "Language.h"
+
+const uint32 OutdoorPvPZMBuffZonesNum = 5;
+// the buff is cast in these zones
+const uint32 OutdoorPvPZMBuffZones[OutdoorPvPZMBuffZonesNum] = {3521,3607,3717,3715,3716};
+// cast on the players of the controlling faction
+const uint32 ZM_CAPTURE_BUFF = 33779;  // twin spire blessing
+// spell that the field scout casts on the player to carry the flag
+const uint32 ZM_BATTLE_STANDARD_A = 32430;
+// spell that the field scout casts on the player to carry the flag
+const uint32 ZM_BATTLE_STANDARD_H = 32431;
+// linked when the central tower is controlled
+const uint32 ZM_GRAVEYARD_ZONE = 3521;
+// linked when the central tower is controlled
+const uint32 ZM_GRAVEYARD_ID = 969;
+// token create spell
+const uint32 ZM_AlliancePlayerKillReward = 32155;
+// token create spell
+const uint32 ZM_HordePlayerKillReward = 32158;
+
+// banners 182527, 182528, 182529, gotta check them ingame
+const go_type ZM_Banner_A = { 182527,530,253.54,7083.81,36.7728,-0.017453,0,0,0.008727,-0.999962 };
+const go_type ZM_Banner_H = { 182528,530,253.54,7083.81,36.7728,-0.017453,0,0,0.008727,-0.999962 };
+const go_type ZM_Banner_N = { 182529,530,253.54,7083.81,36.7728,-0.017453,0,0,0.008727,-0.999962 };
+
+// horde field scout spawn data
+const creature_type ZM_HordeFieldScout = {18564,67,530,296.625,7818.4,42.6294,5.18363};
+// alliance field scout spawn data
+const creature_type ZM_AllianceFieldScout = {18581,469,530,374.395,6230.08,22.8351,0.593412};
+
+enum ZMCreatureTypes{
+    ZM_ALLIANCE_FIELD_SCOUT = 0,
+    ZM_HORDE_FIELD_SCOUT,
+    ZM_CREATURE_NUM
+};
+
+struct zm_beacon {
+    uint32 slider_disp;
+    uint32 slider_n;
+    uint32 slider_pos;
+    uint32 ui_tower_n;
+    uint32 ui_tower_h;
+    uint32 ui_tower_a;
+    uint32 map_tower_n;
+    uint32 map_tower_h;
+    uint32 map_tower_a;
+    uint32 event_enter;
+    uint32 event_leave;
+};
+
+enum ZM_BeaconType{
+    ZM_BEACON_EAST = 0,
+    ZM_BEACON_WEST,
+    ZM_NUM_BEACONS
+};
+
+const zm_beacon ZMBeaconInfo[ZM_NUM_BEACONS] = {
+    {2533,2535,2534,2560,2559,2558,2652,2651,2650,11807,11806},
+    {2527,2529,2528,2557,2556,2555,2646,2645,2644,11805,11804}
+};
+
+const uint32 ZMBeaconCaptureA[ZM_NUM_BEACONS] = {
+    LANG_OPVP_ZM_CAPTURE_EAST_A,
+    LANG_OPVP_ZM_CAPTURE_WEST_A
+};
+
+const uint32 ZMBeaconCaptureH[ZM_NUM_BEACONS] = {
+    LANG_OPVP_ZM_CAPTURE_EAST_H,
+    LANG_OPVP_ZM_CAPTURE_WEST_H
+};
+
+const uint32 ZMBeaconLooseA[ZM_NUM_BEACONS] = {
+    LANG_OPVP_ZM_LOOSE_EAST_A,
+    LANG_OPVP_ZM_LOOSE_WEST_A
+};
+
+const uint32 ZMBeaconLooseH[ZM_NUM_BEACONS] = {
+    LANG_OPVP_ZM_LOOSE_EAST_H,
+    LANG_OPVP_ZM_LOOSE_WEST_H
+};
+
+const go_type ZMCapturePoints[ZM_NUM_BEACONS] = {
+    {182523,530,303.243,6841.36,40.1245,-1.58825,0,0,0.71325,-0.700909},
+    {182522,530,336.466,7340.26,41.4984,-1.58825,0,0,0.71325,-0.700909}
+};
+
+enum OutdoorPvPZMWorldStates
+{
+    ZM_UI_TOWER_SLIDER_N_W = 2529,
+    ZM_UI_TOWER_SLIDER_POS_W = 2528,
+    ZM_UI_TOWER_SLIDER_DISPLAY_W = 2527,
+
+    ZM_UI_TOWER_SLIDER_N_E = 2535,
+    ZM_UI_TOWER_SLIDER_POS_E = 2534,
+    ZM_UI_TOWER_SLIDER_DISPLAY_E = 2533,
+
+    ZM_WORLDSTATE_UNK_1 = 2653,
+
+    ZM_UI_TOWER_EAST_N = 2560,
+    ZM_UI_TOWER_EAST_H = 2559,
+    ZM_UI_TOWER_EAST_A = 2558,
+    ZM_UI_TOWER_WEST_N = 2557,
+    ZM_UI_TOWER_WEST_H = 2556,
+    ZM_UI_TOWER_WEST_A = 2555,
+
+    ZM_MAP_TOWER_EAST_N = 2652,
+    ZM_MAP_TOWER_EAST_H = 2651,
+    ZM_MAP_TOWER_EAST_A = 2650,
+    ZM_MAP_GRAVEYARD_H = 2649,
+    ZM_MAP_GRAVEYARD_A = 2648,
+    ZM_MAP_GRAVEYARD_N = 2647,
+    ZM_MAP_TOWER_WEST_N = 2646,
+    ZM_MAP_TOWER_WEST_H = 2645,
+    ZM_MAP_TOWER_WEST_A = 2644,
+
+    ZM_MAP_HORDE_FLAG_READY = 2658,
+    ZM_MAP_HORDE_FLAG_NOT_READY = 2657,
+    ZM_MAP_ALLIANCE_FLAG_NOT_READY = 2656,
+    ZM_MAP_ALLIANCE_FLAG_READY = 2655
+};
+
+enum ZM_TowerStateMask{
+    ZM_TOWERSTATE_N = 1,
+    ZM_TOWERSTATE_A = 2,
+    ZM_TOWERSTATE_H = 4
+};
+
+class OutdoorPvPZM;
+class OutdoorPvPObjectiveZM_Beacon : public OutdoorPvPObjective
+{
+friend class OutdoorPvPZM;
+public:
+    OutdoorPvPObjectiveZM_Beacon(OutdoorPvP * pvp, ZM_BeaconType type);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket & data);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+    void UpdateTowerState();
+protected:
+    bool HandleCapturePointEvent(Player * plr, uint32 eventId);
+protected:
+    ZM_BeaconType m_TowerType;
+    uint32 m_TowerState;
+};
+
+enum ZM_GraveYardState{
+    ZM_GRAVEYARD_N = 1,
+    ZM_GRAVEYARD_A = 2,
+    ZM_GRAVEYARD_H = 4
+};
+
+class OutdoorPvPObjectiveZM_GraveYard : public OutdoorPvPObjective
+{
+friend class OutdoorPvPZM;
+public:
+    OutdoorPvPObjectiveZM_GraveYard(OutdoorPvP * pvp);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket & data);
+    void UpdateTowerState();
+    int32 HandleOpenGo(Player *plr, uint64 guid);
+    void SetBeaconState(uint32 controlling_team); // not good atm
+    bool HandleGossipOption(Player * plr, uint64 guid, uint32 gossipid);
+    bool HandleDropFlag(Player * plr, uint32 spellId);
+    bool CanTalkTo(Player * plr, Creature * c, GossipOption &gso);
+private:
+    uint32 m_GraveYardState;
+protected:
+    uint32 m_BothControllingFaction;
+    uint64 m_FlagCarrierGUID;
+};
+
+class OutdoorPvPZM : public OutdoorPvP
+{
+friend class OutdoorPvPObjectiveZM_Beacon;
+public:
+    OutdoorPvPZM();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket &data);
+    void SendRemoveWorldStates(Player * plr);
+    void HandleKillImpl(Player * plr, Unit * killed);
+    void BuffTeam(uint32 team);
+private:
+    OutdoorPvPObjectiveZM_GraveYard * m_GraveYard;
+    uint32 m_AllianceTowersControlled;
+    uint32 m_HordeTowersControlled;
+};
+
+// todo: flag carrier death/leave/mount/activitychange should give back the gossip options
+#endif
diff --git a/src/game/Player.cpp b/src/game/Player.cpp
index df3d925..46a5ae5 100644
--- a/src/game/Player.cpp
+++ b/src/game/Player.cpp
@@ -53,6 +53,8 @@
 #include "Weather.h"
 #include "BattleGround.h"
 #include "BattleGroundMgr.h"
+#include "OutdoorPvP.h"
+#include "OutdoorPvPMgr.h"
 #include "ArenaTeam.h"
 #include "Chat.h"
 #include "Database/DatabaseImpl.h"
@@ -6102,6 +6104,7 @@ void Player::UpdateArea(uint32 newArea)
 
 void Player::UpdateZone(uint32 newZone)
 {
+    uint32 oldZoneId  = m_zoneUpdateId;
     m_zoneUpdateId    = newZone;
     m_zoneUpdateTimer = ZONE_UPDATE_INTERVAL;
 
@@ -6112,6 +6115,13 @@ void Player::UpdateZone(uint32 newZone)
     if(!zone)
         return;
 
+    // inform outdoor pvp
+    if(oldZoneId != m_zoneUpdateId)
+    {
+        sOutdoorPvPMgr.HandlePlayerLeaveZone(this, oldZoneId);
+        sOutdoorPvPMgr.HandlePlayerEnterZone(this, m_zoneUpdateId);
+    }
+
     if (sWorld.getConfig(CONFIG_WEATHER))
     {
         Weather *wth = sWorld.FindWeather(zone->ID);
@@ -6245,6 +6255,11 @@ void Player::CheckDuelDistance(time_t currTime)
     }
 }
 
+bool Player::IsOutdoorPvPActive()
+{
+    return (isAlive() && !HasInvisibilityAura() && !HasStealthAura() && (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP) || sWorld.IsPvPRealm())  && !HasUnitMovementFlag(MOVEMENTFLAG_FLYING2) && !isInFlight());
+}
+
 void Player::DuelComplete(DuelCompleteType type)
 {
     // duel not requested
@@ -7339,13 +7354,17 @@ void Player::SendUpdateWorldState(uint32 Field, uint32 Value)
     GetSession()->SendPacket(&data);
 }
 
-void Player::SendInitWorldStates()
+void Player::SendInitWorldStates(bool forceZone, uint32 forceZoneId)
 {
     // data depends on zoneid/mapid...
     BattleGround* bg = GetBattleGround();
     uint16 NumberOfFields = 0;
     uint32 mapid = GetMapId();
-    uint32 zoneid = GetZoneId();
+    uint32 zoneid;
+    if(forceZone)
+        zoneid = forceZoneId;
+    else
+        zoneid = GetZoneId();
     uint32 areaid = GetAreaId();
     sLog.outDebug("Sending SMSG_INIT_WORLD_STATES to Map:%u, Zone: %u", mapid, zoneid);
     // may be exist better way to do this...
@@ -7370,6 +7389,12 @@ void Player::SendInitWorldStates()
         case 2918:
             NumberOfFields = 6;
             break;
+        case 139:
+            NumberOfFields = 39;
+            break;
+        case 1377:
+            NumberOfFields = 13;
+            break;
         case 2597:
             NumberOfFields = 81;
             break;
@@ -7381,7 +7406,10 @@ void Player::SendInitWorldStates()
             NumberOfFields = 38;
             break;
         case 3483:
-            NumberOfFields = 22;
+            NumberOfFields = 25;
+            break;
+        case 3518:
+            NumberOfFields = 37;
             break;
         case 3519:
             NumberOfFields = 36;
@@ -7431,6 +7459,68 @@ void Player::SendInitWorldStates()
         case 1537:
         case 2257:
             break;
+        case 139: // EPL
+            {
+                OutdoorPvP * pvp = this->GetOutdoorPvP();
+                if(pvp && pvp->GetTypeId() == OUTDOOR_PVP_EP)
+                    pvp->FillInitialWorldStates(data);
+                else
+                {
+                    data << uint32(0x97a) << uint32(0x0); // 10 2426 
+                    data << uint32(0x917) << uint32(0x0); // 11 2327 
+                    data << uint32(0x918) << uint32(0x0); // 12 2328 
+                    data << uint32(0x97b) << uint32(0x32); // 13 2427
+                    data << uint32(0x97c) << uint32(0x32); // 14 2428
+                    data << uint32(0x933) << uint32(0x1); // 15 2355 
+                    data << uint32(0x946) << uint32(0x0); // 16 2374 
+                    data << uint32(0x947) << uint32(0x0); // 17 2375 
+                    data << uint32(0x948) << uint32(0x0); // 18 2376 
+                    data << uint32(0x949) << uint32(0x0); // 19 2377 
+                    data << uint32(0x94a) << uint32(0x0); // 20 2378 
+                    data << uint32(0x94b) << uint32(0x0); // 21 2379 
+                    data << uint32(0x932) << uint32(0x0); // 22 2354 
+                    data << uint32(0x934) << uint32(0x0); // 23 2356 
+                    data << uint32(0x935) << uint32(0x0); // 24 2357 
+                    data << uint32(0x936) << uint32(0x0); // 25 2358 
+                    data << uint32(0x937) << uint32(0x0); // 26 2359 
+                    data << uint32(0x938) << uint32(0x0); // 27 2360 
+                    data << uint32(0x939) << uint32(0x1); // 28 2361 
+                    data << uint32(0x930) << uint32(0x1); // 29 2352 
+                    data << uint32(0x93a) << uint32(0x0); // 30 2362 
+                    data << uint32(0x93b) << uint32(0x0); // 31 2363 
+                    data << uint32(0x93c) << uint32(0x0); // 32 2364 
+                    data << uint32(0x93d) << uint32(0x0); // 33 2365 
+                    data << uint32(0x944) << uint32(0x0); // 34 2372 
+                    data << uint32(0x945) << uint32(0x0); // 35 2373 
+                    data << uint32(0x931) << uint32(0x1); // 36 2353 
+                    data << uint32(0x93e) << uint32(0x0); // 37 2366 
+                    data << uint32(0x931) << uint32(0x1); // 38 2367 ??  grey horde not in dbc! send for consistency's sake, and to match field count
+                    data << uint32(0x940) << uint32(0x0); // 39 2368 
+                    data << uint32(0x941) << uint32(0x0); // 7 2369 
+                    data << uint32(0x942) << uint32(0x0); // 8 2370 
+                    data << uint32(0x943) << uint32(0x0); // 9 2371 
+                }
+            }
+            break;
+        case 1377: // Silithus			
+            {
+                OutdoorPvP * pvp = this->GetOutdoorPvP();
+                if(pvp && pvp->GetTypeId() == OUTDOOR_PVP_SI)
+                    pvp->FillInitialWorldStates(data);
+                else
+                {
+                    // states are always shown
+                    data << uint32(2313) << uint32(0x0); // 7 ally silityst gathered
+                    data << uint32(2314) << uint32(0x0); // 8 horde silityst gathered
+                    data << uint32(2317) << uint32(0x0); // 9 max silithyst
+                }
+                // dunno about these... aq opening event maybe?
+                data << uint32(2322) << uint32(0x0); // 10 sandworm N
+                data << uint32(2323) << uint32(0x0); // 11 sandworm S
+                data << uint32(2324) << uint32(0x0); // 12 sandworm SW
+                data << uint32(2325) << uint32(0x0); // 13 sandworm E	
+            }
+            break;
         case 2597:                                          // AV
             data << uint32(0x7ae) << uint32(0x1);           // 7
             data << uint32(0x532) << uint32(0x1);           // 8
@@ -7602,77 +7692,150 @@ void Player::SendInitWorldStates()
                 // and some more ... unknown
             }
             break;
+        // any of these needs change! the client remembers the prev setting!
+        // ON EVERY ZONE LEAVE, RESET THE OLD ZONE'S WORLD STATE, BUT AT LEAST THE UI STUFF!
         case 3483:                                          // Hellfire Peninsula
-            data << uint32(0x9ba) << uint32(0x1);           // 10
-            data << uint32(0x9b9) << uint32(0x1);           // 11
-            data << uint32(0x9b5) << uint32(0x0);           // 12
-            data << uint32(0x9b4) << uint32(0x1);           // 13
-            data << uint32(0x9b3) << uint32(0x0);           // 14
-            data << uint32(0x9b2) << uint32(0x0);           // 15
-            data << uint32(0x9b1) << uint32(0x1);           // 16
-            data << uint32(0x9b0) << uint32(0x0);           // 17
-            data << uint32(0x9ae) << uint32(0x0);           // 18 horde pvp objectives captured
-            data << uint32(0x9ac) << uint32(0x0);           // 19
-            data << uint32(0x9a8) << uint32(0x0);           // 20
-            data << uint32(0x9a7) << uint32(0x0);           // 21
-            data << uint32(0x9a6) << uint32(0x1);           // 22
+            {
+                OutdoorPvP * pvp = this->GetOutdoorPvP();
+                if(pvp && pvp->GetTypeId() == OUTDOOR_PVP_HP)
+                    pvp->FillInitialWorldStates(data);
+                else
+                {
+                    data << uint32(0x9ba) << uint32(0x1);           // 10 // add ally tower main gui icon       // maybe should be sent only on login?
+                    data << uint32(0x9b9) << uint32(0x1);           // 11 // add horde tower main gui icon      // maybe should be sent only on login?
+                    data << uint32(0x9b5) << uint32(0x0);           // 12 // show neutral broken hill icon      // 2485
+                    data << uint32(0x9b4) << uint32(0x1);           // 13 // show icon above broken hill        // 2484
+                    data << uint32(0x9b3) << uint32(0x0);           // 14 // show ally broken hill icon         // 2483
+                    data << uint32(0x9b2) << uint32(0x0);           // 15 // show neutral overlook icon         // 2482
+                    data << uint32(0x9b1) << uint32(0x1);           // 16 // show the overlook arrow            // 2481
+                    data << uint32(0x9b0) << uint32(0x0);           // 17 // show ally overlook icon            // 2480
+                    data << uint32(0x9ae) << uint32(0x0);           // 18 // horde pvp objectives captured      // 2478
+                    data << uint32(0x9ac) << uint32(0x0);           // 19 // ally pvp objectives captured       // 2476
+                    data << uint32(2475)  << uint32(100); //: ally / horde slider grey area                              // show only in direct vicinity!
+                    data << uint32(2474)  << uint32(50);  //: ally / horde slider percentage, 100 for ally, 0 for horde  // show only in direct vicinity!
+                    data << uint32(2473)  << uint32(0);   //: ally / horde slider display                                // show only in direct vicinity!
+                    data << uint32(0x9a8) << uint32(0x0);           // 20 // show the neutral stadium icon      // 2472
+                    data << uint32(0x9a7) << uint32(0x0);           // 21 // show the ally stadium icon         // 2471 
+                    data << uint32(0x9a6) << uint32(0x1);           // 22 // show the horde stadium icon        // 2470
+                }
+            }
+            break;
+        case 3518:
+            {
+                OutdoorPvP * pvp = this->GetOutdoorPvP();
+                if(pvp && pvp->GetTypeId() == OUTDOOR_PVP_NA)
+                    pvp->FillInitialWorldStates(data);
+                else
+                {
+                    data << uint32(2503) << uint32(0x0);    // 10
+                    data << uint32(2502) << uint32(0x0);    // 11
+                    data << uint32(2493) << uint32(0x0);    // 12
+                    data << uint32(2491) << uint32(0x0);    // 13
+
+                    data << uint32(2495) << uint32(0x0);    // 14
+                    data << uint32(2494) << uint32(0x0);    // 15
+                    data << uint32(2497) << uint32(0x0);    // 16
+
+                    data << uint32(2762) << uint32(0x0);    // 17
+                    data << uint32(2662) << uint32(0x0);    // 18
+                    data << uint32(2663) << uint32(0x0);    // 19
+                    data << uint32(2664) << uint32(0x0);    // 20
+
+                    data << uint32(2760) << uint32(0x0);    // 21
+                    data << uint32(2670) << uint32(0x0);    // 22
+                    data << uint32(2668) << uint32(0x0);    // 23
+                    data << uint32(2669) << uint32(0x0);    // 24
+
+                    data << uint32(2761) << uint32(0x0);    // 25
+                    data << uint32(2667) << uint32(0x0);    // 26
+                    data << uint32(2665) << uint32(0x0);    // 27
+                    data << uint32(2666) << uint32(0x0);    // 28
+
+                    data << uint32(2763) << uint32(0x0);    // 29
+                    data << uint32(2659) << uint32(0x0);    // 30
+                    data << uint32(2660) << uint32(0x0);    // 31
+                    data << uint32(2661) << uint32(0x0);    // 32
+
+                    data << uint32(2671) << uint32(0x0);    // 33
+                    data << uint32(2676) << uint32(0x0);    // 34
+                    data << uint32(2677) << uint32(0x0);    // 35
+                    data << uint32(2672) << uint32(0x0);    // 36
+                    data << uint32(2673) << uint32(0x0);    // 37
+                }
+            }
             break;
         case 3519:                                          // Terokkar Forest
-            data << uint32(0xa41) << uint32(0x0);           // 10
-            data << uint32(0xa40) << uint32(0x14);          // 11
-            data << uint32(0xa3f) << uint32(0x0);           // 12
-            data << uint32(0xa3e) << uint32(0x0);           // 13
-            data << uint32(0xa3d) << uint32(0x5);           // 14
-            data << uint32(0xa3c) << uint32(0x0);           // 15
-            data << uint32(0xa87) << uint32(0x0);           // 16
-            data << uint32(0xa86) << uint32(0x0);           // 17
-            data << uint32(0xa85) << uint32(0x0);           // 18
-            data << uint32(0xa84) << uint32(0x0);           // 19
-            data << uint32(0xa83) << uint32(0x0);           // 20
-            data << uint32(0xa82) << uint32(0x0);           // 21
-            data << uint32(0xa81) << uint32(0x0);           // 22
-            data << uint32(0xa80) << uint32(0x0);           // 23
-            data << uint32(0xa7e) << uint32(0x0);           // 24
-            data << uint32(0xa7d) << uint32(0x0);           // 25
-            data << uint32(0xa7c) << uint32(0x0);           // 26
-            data << uint32(0xa7b) << uint32(0x0);           // 27
-            data << uint32(0xa7a) << uint32(0x0);           // 28
-            data << uint32(0xa79) << uint32(0x0);           // 29
-            data << uint32(0x9d0) << uint32(0x5);           // 30
-            data << uint32(0x9ce) << uint32(0x0);           // 31
-            data << uint32(0x9cd) << uint32(0x0);           // 32
-            data << uint32(0x9cc) << uint32(0x0);           // 33
-            data << uint32(0xa88) << uint32(0x0);           // 34
-            data << uint32(0xad0) << uint32(0x0);           // 35
-            data << uint32(0xacf) << uint32(0x1);           // 36
+            {
+                OutdoorPvP * pvp = this->GetOutdoorPvP();
+                if(pvp && pvp->GetTypeId() == OUTDOOR_PVP_TF)
+                    pvp->FillInitialWorldStates(data);
+                else
+                {
+                    data << uint32(0xa41) << uint32(0x0);           // 10 // 2625 capture bar pos
+                    data << uint32(0xa40) << uint32(0x14);          // 11 // 2624 capture bar neutral
+                    data << uint32(0xa3f) << uint32(0x0);           // 12 // 2623 show capture bar
+                    data << uint32(0xa3e) << uint32(0x0);           // 13 // 2622 horde towers controlled
+                    data << uint32(0xa3d) << uint32(0x5);           // 14 // 2621 ally towers controlled
+                    data << uint32(0xa3c) << uint32(0x0);           // 15 // 2620 show towers controlled
+                    data << uint32(0xa88) << uint32(0x0);           // 16 // 2696 SE Neu
+                    data << uint32(0xa87) << uint32(0x0);           // 17 // SE Horde
+                    data << uint32(0xa86) << uint32(0x0);           // 18 // SE Ally
+                    data << uint32(0xa85) << uint32(0x0);           // 19 //S Neu
+                    data << uint32(0xa84) << uint32(0x0);           // 20 S Horde
+                    data << uint32(0xa83) << uint32(0x0);           // 21 S Ally
+                    data << uint32(0xa82) << uint32(0x0);           // 22 NE Neu
+                    data << uint32(0xa81) << uint32(0x0);           // 23 NE Horde
+                    data << uint32(0xa80) << uint32(0x0);           // 24 NE Ally
+                    data << uint32(0xa7e) << uint32(0x0);           // 25 // 2686 N Neu
+                    data << uint32(0xa7d) << uint32(0x0);           // 26 N Horde
+                    data << uint32(0xa7c) << uint32(0x0);           // 27 N Ally
+                    data << uint32(0xa7b) << uint32(0x0);           // 28 NW Ally
+                    data << uint32(0xa7a) << uint32(0x0);           // 29 NW Horde
+                    data << uint32(0xa79) << uint32(0x0);           // 30 NW Neutral
+                    data << uint32(0x9d0) << uint32(0x5);           // 31 // 2512 locked time remaining seconds first digit
+                    data << uint32(0x9ce) << uint32(0x0);           // 32 // 2510 locked time remaining seconds second digit
+                    data << uint32(0x9cd) << uint32(0x0);           // 33 // 2509 locked time remaining minutes
+                    data << uint32(0x9cc) << uint32(0x0);           // 34 // 2508 neutral locked time show
+                    data << uint32(0xad0) << uint32(0x0);           // 35 // 2768 horde locked time show
+                    data << uint32(0xacf) << uint32(0x1);           // 36 // 2767 ally locked time show
+                }
+            }
             break;
         case 3521:                                          // Zangarmarsh
-            data << uint32(0x9e1) << uint32(0x0);           // 10
-            data << uint32(0x9e0) << uint32(0x0);           // 11
-            data << uint32(0x9df) << uint32(0x0);           // 12
-            data << uint32(0xa5d) << uint32(0x1);           // 13
-            data << uint32(0xa5c) << uint32(0x0);           // 14
-            data << uint32(0xa5b) << uint32(0x1);           // 15
-            data << uint32(0xa5a) << uint32(0x0);           // 16
-            data << uint32(0xa59) << uint32(0x1);           // 17
-            data << uint32(0xa58) << uint32(0x0);           // 18
-            data << uint32(0xa57) << uint32(0x0);           // 19
-            data << uint32(0xa56) << uint32(0x0);           // 20
-            data << uint32(0xa55) << uint32(0x1);           // 21
-            data << uint32(0xa54) << uint32(0x0);           // 22
-            data << uint32(0x9e7) << uint32(0x0);           // 23
-            data << uint32(0x9e6) << uint32(0x0);           // 24
-            data << uint32(0x9e5) << uint32(0x0);           // 25
-            data << uint32(0xa00) << uint32(0x0);           // 26
-            data << uint32(0x9ff) << uint32(0x1);           // 27
-            data << uint32(0x9fe) << uint32(0x0);           // 28
-            data << uint32(0x9fd) << uint32(0x0);           // 29
-            data << uint32(0x9fc) << uint32(0x1);           // 30
-            data << uint32(0x9fb) << uint32(0x0);           // 31
-            data << uint32(0xa62) << uint32(0x0);           // 32
-            data << uint32(0xa61) << uint32(0x1);           // 33
-            data << uint32(0xa60) << uint32(0x1);           // 34
-            data << uint32(0xa5f) << uint32(0x0);           // 35
+            {
+                OutdoorPvP * pvp = this->GetOutdoorPvP();
+                if(pvp && pvp->GetTypeId() == OUTDOOR_PVP_ZM)
+                    pvp->FillInitialWorldStates(data);
+                else
+                {
+                    data << uint32(0x9e1) << uint32(0x0);           // 10 //2529
+                    data << uint32(0x9e0) << uint32(0x0);           // 11
+                    data << uint32(0x9df) << uint32(0x0);           // 12
+                    data << uint32(0xa5d) << uint32(0x1);           // 13 //2653 
+                    data << uint32(0xa5c) << uint32(0x0);           // 14 //2652 east beacon neutral
+                    data << uint32(0xa5b) << uint32(0x1);           // 15 horde
+                    data << uint32(0xa5a) << uint32(0x0);           // 16 ally
+                    data << uint32(0xa59) << uint32(0x1);           // 17 // 2649 Twin spire graveyard horde  12???
+                    data << uint32(0xa58) << uint32(0x0);           // 18 ally     14 ???
+                    data << uint32(0xa57) << uint32(0x0);           // 19 neutral  7???
+                    data << uint32(0xa56) << uint32(0x0);           // 20 // 2646 west beacon neutral
+                    data << uint32(0xa55) << uint32(0x1);           // 21 horde
+                    data << uint32(0xa54) << uint32(0x0);           // 22 ally
+                    data << uint32(0x9e7) << uint32(0x0);           // 23 // 2535
+                    data << uint32(0x9e6) << uint32(0x0);           // 24
+                    data << uint32(0x9e5) << uint32(0x0);           // 25
+                    data << uint32(0xa00) << uint32(0x0);           // 26 // 2560
+                    data << uint32(0x9ff) << uint32(0x1);           // 27
+                    data << uint32(0x9fe) << uint32(0x0);           // 28
+                    data << uint32(0x9fd) << uint32(0x0);           // 29 
+                    data << uint32(0x9fc) << uint32(0x1);           // 30
+                    data << uint32(0x9fb) << uint32(0x0);           // 31
+                    data << uint32(0xa62) << uint32(0x0);           // 32 // 2658
+                    data << uint32(0xa61) << uint32(0x1);           // 33
+                    data << uint32(0xa60) << uint32(0x1);           // 34
+                    data << uint32(0xa5f) << uint32(0x0);           // 35
+                }
+            }
             break;
         case 3698:                                          // Nagrand Arena
             data << uint32(0xa0f) << uint32(0x0);           // 7
@@ -17677,6 +17840,11 @@ void Player::AutoUnequipOffhandIfNeed()
     }
 }
 
+OutdoorPvP * Player::GetOutdoorPvP() const
+{
+    return sOutdoorPvPMgr.GetOutdoorPvPToZoneId(GetZoneId());
+}
+
 bool Player::HasItemFitToSpellReqirements(SpellEntry const* spellInfo, Item const* ignoreItem)
 {
     if(spellInfo->EquippedItemClass < 0)
diff --git a/src/game/Player.h b/src/game/Player.h
index ca6e50b..9c8c4f3 100644
--- a/src/game/Player.h
+++ b/src/game/Player.h
@@ -45,6 +45,7 @@ class PlayerMenu;
 class Transport;
 class UpdateMask;
 class PlayerSocial;
+class OutdoorPvP;
 
 typedef std::deque<Mail*> PlayerMails;
 
@@ -1780,7 +1781,7 @@ class MANGOS_DLL_SPEC Player : public Unit
         void UpdateEquipSpellsAtFormChange();
         void CastItemCombatSpell(Item *item,Unit* Target, WeaponAttackType attType);
 
-        void SendInitWorldStates();
+        void SendInitWorldStates(bool force = false, uint32 forceZoneId = 0);
         void SendUpdateWorldState(uint32 Field, uint32 Value);
         void SendDirectMessage(WorldPacket *data);
 
@@ -1887,6 +1888,14 @@ class MANGOS_DLL_SPEC Player : public Unit
         bool isAllowUseBattleGroundObject();
 
         /*********************************************************/
+        /***               OUTDOOR PVP SYSTEM                  ***/
+        /*********************************************************/
+
+        OutdoorPvP * GetOutdoorPvP() const;
+        // returns true if the player is in active state for outdoor pvp objective capturing, false otherwise
+        bool IsOutdoorPvPActive();
+
+        /*********************************************************/
         /***                    REST SYSTEM                    ***/
         /*********************************************************/
 
diff --git a/src/game/Spell.cpp b/src/game/Spell.cpp
index a18a8cd..76598ab 100644
--- a/src/game/Spell.cpp
+++ b/src/game/Spell.cpp
@@ -3841,6 +3841,26 @@ uint8 Spell::CanCast(bool strict)
 
                 break;
             }
+            case SPELL_EFFECT_SUMMON_WILD:
+            {
+                // fire bomb trigger, can only be used in halaa opvp when flying on a path from a wyvern roost
+                // yeah, hacky, I know, but neither item flags, nor spell attributes contained any useable data (or I was unable to find it)
+                if(m_spellInfo->EffectMiscValue[i] == 18225 && m_caster->GetTypeId() == TYPEID_PLAYER)
+                {
+                    // if not in halaa or not in flight, cannot be used
+                    if(m_caster->GetAreaId() != 3628 || !m_caster->isInFlight())
+                        return SPELL_FAILED_NOT_HERE;
+
+                    // if not on one of the specific taxi paths, then cannot be used
+                    uint32 src_node = ((Player*)m_caster)->m_taxi.GetTaxiSource();
+                    if( src_node != 103 &&
+                        src_node != 105 &&
+                        src_node != 107 &&
+                        src_node != 109 )
+                        return SPELL_FAILED_NOT_HERE;
+                }
+                break;
+            }
             case SPELL_EFFECT_SUMMON_PET:
             {
                 if(m_caster->GetPetGUID())                  //let warlock do a replacement summon
diff --git a/src/game/SpellAuras.cpp b/src/game/SpellAuras.cpp
index 0beaf61..9b91146 100644
--- a/src/game/SpellAuras.cpp
+++ b/src/game/SpellAuras.cpp
@@ -40,6 +40,8 @@
 #include "Creature.h"
 #include "Formulas.h"
 #include "BattleGround.h"
+#include "OutdoorPvP.h"
+#include "OutdoorPvPMgr.h"
 #include "CreatureAI.h"
 #include "Util.h"
 #include "GridNotifiers.h"
@@ -3254,10 +3256,18 @@ void Aura::HandleModStealth(bool apply, bool Real)
 {
     if(apply)
     {
-        // drop flag at stealth in bg
-        if(Real && m_target->GetTypeId()==TYPEID_PLAYER && ((Player*)m_target)->InBattleGround())
-            if(BattleGround *bg = ((Player*)m_target)->GetBattleGround())
-                bg->EventPlayerDroppedFlag((Player*)m_target);
+        if(Real && m_target->GetTypeId()==TYPEID_PLAYER)
+        {
+            // drop flag at stealth in bg
+            if(((Player*)m_target)->InBattleGround())
+            {
+                if(BattleGround *bg = ((Player*)m_target)->GetBattleGround())
+                    bg->EventPlayerDroppedFlag((Player*)m_target);
+            }
+            // remove player from the objective's active player count at stealth
+            if(OutdoorPvP * pvp = ((Player*)m_target)->GetOutdoorPvP())
+                pvp->HandlePlayerActivityChanged((Player*)m_target);
+        }
 
         // only at real aura add
         if(Real)
@@ -3302,6 +3312,12 @@ void Aura::HandleModStealth(bool apply, bool Real)
                 }
                 else
                     m_target->SetVisibility(VISIBILITY_ON);
+                if(m_target->GetTypeId() == TYPEID_PLAYER)
+                {
+                    if(OutdoorPvP * pvp = ((Player*)m_target)->GetOutdoorPvP())
+                        pvp->HandlePlayerActivityChanged((Player*)m_target);
+                    m_target->SendUpdateToPlayer((Player*)m_target);
+                }
             }
         }
     }
@@ -3334,6 +3350,9 @@ void Aura::HandleInvisibility(bool apply, bool Real)
         {
             // apply glow vision
             m_target->SetFlag(PLAYER_FIELD_BYTES2,PLAYER_FIELD_BYTE2_INVISIBILITY_GLOW);
+            // remove player from the objective's active player count at invisibility
+            if(OutdoorPvP * pvp = ((Player*)m_target)->GetOutdoorPvP())
+                pvp->HandlePlayerActivityChanged((Player*)m_target);
 
             // drop flag at invisible in bg
             if(((Player*)m_target)->InBattleGround())
@@ -3370,6 +3389,13 @@ void Aura::HandleInvisibility(bool apply, bool Real)
                 // if have stealth aura then already have stealth visibility
                 if(!m_target->HasAuraType(SPELL_AURA_MOD_STEALTH))
                     m_target->SetVisibility(VISIBILITY_ON);
+                if(m_target->GetTypeId() == TYPEID_PLAYER)
+                {
+                    if(OutdoorPvP * pvp = ((Player*)m_target)->GetOutdoorPvP())
+                        pvp->HandlePlayerActivityChanged((Player*)m_target);
+
+                    m_target->SendUpdateToPlayer((Player*)m_target);
+                }
             }
         }
     }
@@ -3809,6 +3835,8 @@ void Aura::HandleAuraModEffectImmunity(bool apply, bool Real)
                     }
                 }
             }
+            else
+                sOutdoorPvPMgr.HandleDropFlag((Player*)m_target,GetSpellProto()->Id);
         }
     }
 
diff --git a/src/game/SpellEffects.cpp b/src/game/SpellEffects.cpp
index 0e08b9c..1740c79 100644
--- a/src/game/SpellEffects.cpp
+++ b/src/game/SpellEffects.cpp
@@ -48,6 +48,7 @@
 #include "BattleGround.h"
 #include "BattleGroundEY.h"
 #include "BattleGroundWS.h"
+#include "OutdoorPvPMgr.h"
 #include "VMapFactory.h"
 #include "Language.h"
 #include "SocialMgr.h"
@@ -2861,6 +2862,10 @@ void Spell::EffectOpenLock(uint32 /*i*/)
                 return;
             }
         }
+        // handle outdoor pvp object opening, return true if go was registered for handling
+        // these objects must have been spawned by outdoorpvp!
+        else if(gameObjTarget->GetGOInfo()->type == GAMEOBJECT_TYPE_GOOBER && sOutdoorPvPMgr.HandleOpenGo(player, gameObjTarget->GetGUID()))
+            return;
         lockId = gameObjTarget->GetLockId();
         guid = gameObjTarget->GetGUID();
     }
diff --git a/src/game/Unit.cpp b/src/game/Unit.cpp
index 46f5a15..9e745a1 100644
--- a/src/game/Unit.cpp
+++ b/src/game/Unit.cpp
@@ -41,6 +41,7 @@
 #include "BattleGround.h"
 #include "InstanceSaveMgr.h"
 #include "GridNotifiersImpl.h"
+#include "OutdoorPvP.h"
 #include "CellImpl.h"
 #include "Path.h"
 
@@ -660,6 +661,24 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
         if(!spiritOfRedemtionTalentReady)
             pVictim->setDeathState(JUST_DIED);
 
+        // outdoor pvp things, do these after setting the death state, else the player activity notify won't work... doh...
+        // handle player kill only if not suicide (spirit of redemption for example)
+        if(GetTypeId() == TYPEID_PLAYER && this != pVictim)
+        {
+            if(OutdoorPvP * pvp = ((Player*)this)->GetOutdoorPvP())
+            {
+                pvp->HandleKill((Player*)this,pVictim);
+            }
+        }
+
+        if(pVictim->GetTypeId() == TYPEID_PLAYER)
+        {
+            if(OutdoorPvP * pvp = ((Player*)pVictim)->GetOutdoorPvP())
+            {
+                pvp->HandlePlayerActivityChanged((Player*)pVictim);
+            }
+        }
+
         DEBUG_LOG("DealDamageHealth1");
 
         if(spiritOfRedemtionTalentReady)
diff --git a/src/game/Unit.h b/src/game/Unit.h
index ee5b94b..a0eb97a 100644
--- a/src/game/Unit.h
+++ b/src/game/Unit.h
@@ -512,6 +512,7 @@ enum NPCFlags
     UNIT_NPC_FLAG_GUILD_BANKER          = 0x00800000,       // cause client to send 997 opcode
     UNIT_NPC_FLAG_SPELLCLICK            = 0x01000000,       // cause client to send 1015 opcode (spell click)
     UNIT_NPC_FLAG_GUARD                 = 0x10000000,       // custom flag for guards
+    UNIT_NPC_FLAG_OUTDOORPVP            = 0x20000000,       // custom flag for outdoor pvp creatures
 };
 
 enum MovementFlags
diff --git a/src/game/World.cpp b/src/game/World.cpp
index 4f9dcb0..a592e58 100644
--- a/src/game/World.cpp
+++ b/src/game/World.cpp
@@ -57,6 +57,7 @@
 #include "InstanceSaveMgr.h"
 #include "WaypointManager.h"
 #include "Util.h"
+#include "OutdoorPvPMgr.h"
 
 INSTANTIATE_SINGLETON_1( World );
 
@@ -1186,6 +1187,9 @@ void World::SetInitialWorldSettings()
     sLog.outString( "Starting BattleGround System" );
     sBattleGroundMgr.CreateInitialBattleGrounds();
 
+    sLog.outString( "Starting Outdoor PvP System" );
+    sOutdoorPvPMgr.InitOutdoorPvP();
+
     //Not sure if this can be moved up in the sequence (with static data loading) as it uses MapManager
     sLog.outString( "Loading Transports..." );
     MapManager::Instance().LoadTransports();
@@ -1379,6 +1383,8 @@ void World::Update(time_t diff)
             ScriptsProcess();
 
         sBattleGroundMgr.Update(diff);
+
+        sOutdoorPvPMgr.Update(diff);
     }
 
     // execute callbacks from sql queries that were queued recently
diff --git a/src/game/WorldSession.cpp b/src/game/WorldSession.cpp
index 59e236c..a3e48b9 100644
--- a/src/game/WorldSession.cpp
+++ b/src/game/WorldSession.cpp
@@ -36,7 +36,8 @@
 #include "MapManager.h"
 #include "ObjectAccessor.h"
 #include "BattleGroundMgr.h"
-#include "Language.h"                                       // for CMSG_CANCEL_MOUNT_AURA handler
+#include "OutdoorPvPMgr.h"
+#include "Language.h"                                       // for CMSG_DISMOUNT handler
 #include "Chat.h"
 #include "SocialMgr.h"
 
@@ -302,6 +303,8 @@ void WorldSession::LogoutPlayer(bool Save)
         if(_player->InBattleGround())
             _player->LeaveBattleground();
 
+        sOutdoorPvPMgr.HandlePlayerLeaveZone(_player,_player->GetZoneId());
+
         for (int i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
         {
             if(int32 bgTypeId = _player->GetBattleGroundQueueId(i))
diff --git a/win/VC71/game.vcproj b/win/VC71/game.vcproj
index 17ce916..2b8d087 100644
--- a/win/VC71/game.vcproj
+++ b/win/VC71/game.vcproj
@@ -352,6 +352,70 @@
 				RelativePath="..\..\src\game\ObjectGridLoader.h">
 			</File>
 			<File
+				RelativePath="..\..\src\game\OutdoorPvP.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvP.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPEP.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPEP.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPHP.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPHP.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPMgr.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPMgr.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPNA.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPNA.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPSI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPSI.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPTF.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPTF.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPZM.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPZM.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\Path.h">
 			</File>
 			<File
@@ -643,6 +707,14 @@
 				RelativePath="..\..\src\game\ObjectPosSelector.h">
 			</File>
 			<File
+				RelativePath="..\..\src\game\OutdoorPvPObjectiveAI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPObjectiveAI.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\Pet.cpp">
 			</File>
 			<File
diff --git a/win/VC80/game.vcproj b/win/VC80/game.vcproj
index b05cb19..86e90cc 100644
--- a/win/VC80/game.vcproj
+++ b/win/VC80/game.vcproj
@@ -643,6 +643,70 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\game\OutdoorPvP.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvP.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPEP.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPEP.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPHP.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPHP.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPMgr.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPMgr.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPNA.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPNA.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPSI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPSI.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPTF.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPTF.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPZM.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPZM.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\Path.h"
 				>
 			</File>
@@ -1031,6 +1095,14 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\game\OutdoorPvPObjectiveAI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPObjectiveAI.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\Pet.cpp"
 				>
 			</File>
diff --git a/win/VC90/game.vcproj b/win/VC90/game.vcproj
index 8d914b3..56d3e9d 100644
--- a/win/VC90/game.vcproj
+++ b/win/VC90/game.vcproj
@@ -644,6 +644,70 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\game\OutdoorPvP.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvP.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPEP.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPEP.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPHP.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPHP.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPMgr.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPMgr.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPNA.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPNA.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPSI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPSI.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPTF.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPTF.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPZM.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPZM.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\Path.h"
 				>
 			</File>
@@ -1032,6 +1096,14 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\game\OutdoorPvPObjectiveAI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\OutdoorPvPObjectiveAI.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\Pet.cpp"
 				>
 			</File>
